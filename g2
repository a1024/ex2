#ifdef _DEBUG
#pragma warning(push)
#pragma warning(disable:4996)
#endif
#include	<boost/random/mersenne_twister.hpp>
#include	<boost/random/uniform_real.hpp>
#include	<boost/math/special_functions.hpp>
#include	<boost/math/quaternion.hpp>
#include	<boost/math/octonion.hpp>
#include	<fftw3.h>
#include	<cmath>
#include	<ctime>
#include	<Windows.h>
#include	<ppl.h>
#include	<concurrent_unordered_set.h>
#include	<list>
#include	<stack>
#include	<vector>
#include	<set>
#include	<unordered_set>
#include	<map>
#include	<unordered_map>
#include	<string>
#include	<algorithm>
#include	<boost/range/adaptor/reversed.hpp>
#include	<emmintrin.h>//SSE2
#ifdef _DEBUG
#pragma warning(pop)
#endif
#pragma		comment(lib, "libfftw3-3.lib")
double inv_sqrt(double x)//http://stackoverflow.com/questions/11513344/how-to-implement-the-fast-inverse-square-root-in-java
{
	double t0;
	(long long&)t0=0x5FE6EC85E7DE30DA-((long long&)x>>1);
	return t0*(1.5-.5*x*t0*t0);
//	auto t1=0x5FE6EC85E7DE30DA-((long long&)x>>1);
//	auto t2=(double&)t1;
//	return t2*(1.5-.5*x*t2*t2);
}
namespace	G2
{
	enum Map
	{
		M_IGNORED,
		
		M_N,
		
		M_LPR, M_RPR,																//(		)
		M_COMMA,																	//,
		M_QUESTION_MARK, M_COLON,													//?		:

			M_PROCEDURAL_START,
		M_IF, M_ELSE, M_FOR, M_DO, M_WHILE,											//if else for do while
		M_CONTINUE, M_BREAK, M_RETURN,												//continue break return
		M_LBRACE, M_RBRACE,															//{		}
		M_SEMICOLON,																//;

			M_PROCEDURAL_ASSIGN_START,
		M_ASSIGN, M_ASSIGN_MULTIPLY, M_ASSIGN_DIVIDE, M_ASSIGN_MOD,					//= *= /= %=
		M_ASSIGN_PLUS, M_ASSIGN_MINUS, M_ASSIGN_LEFT, M_ASSIGN_RIGHT,				//+= -= <<= >>=
		M_ASSIGN_AND, M_ASSIGN_XOR, M_ASSIGN_OR,									//&= #= |=
			M_PROCEDURAL_ASSIGN_END,

			M_PROCEDURAL_END,

		M_INCREMENT, M_DECREMENT,													//++ --
		M_FACTORIAL_LOGIC_NOT,														//!
		M_MODULO_PERCENT,															//%
		M_BITWISE_NOT,																//~
		M_PENTATE,																	//^^^
		M_TETRATE,																	//^^
		M_POWER,																	//^
		M_MULTIPLY, M_DIVIDE, M_LOGIC_DIVIDES,										//*		/		@
		M_PLUS, M_MINUS,															//+		-
		M_BITWISE_SHIFT_LEFT, M_BITWISE_SHIFT_RIGHT,								//<<	>>
		M_LOGIC_LESS, M_LOGIC_LESS_EQUAL, M_LOGIC_GREATER, M_LOGIC_GREATER_EQUAL,	//<		<=		>		>=
		M_LOGIC_EQUAL, M_LOGIC_NOT_EQUAL,											//==	!=
		M_BITWISE_AND, M_BITWISE_NAND,												//&		~& |~
		M_BITWISE_XOR, M_BITWISE_XNOR,												//#		~# #~
		M_VERTICAL_BAR, M_BITWISE_NOR,												//|		~| &~
		M_LOGIC_AND,																//&&
		M_LOGIC_XOR,																//##
		M_LOGIC_OR,																	//||
		M_LOGIC_CONDITION_ZERO,														//??

		M_S_EQUAL_ASSIGN, M_S_NOT_EQUAL,											//= _!=				not supported
		M_S_LESS, M_S_LESS_EQUAL, M_S_GREATER, M_S_GREATER_EQUAL,					//= _< =< _> =>		not supported

			M_FSTART,

		M_COS, M_ACOS, M_COSH, M_ACOSH, M_COSC,
		M_SEC, M_ASEC, M_SECH, M_ASECH,
		M_SIN, M_ASIN, M_SINH, M_ASINH, M_SINC, M_SINHC,
		M_CSC, M_ACSC, M_CSCH, M_ACSCH,
		M_TAN,         M_TANH, M_ATANH, M_TANC,
		M_COT, M_ACOT, M_COTH, M_ACOTH,
		M_EXP, M_LN, M_SQRT, M_CBRT, M_INVSQRT,
		M_GAUSS, M_ERF, M_FIB, M_ZETA, M_LNGAMMA,
		M_STEP, M_SGN, M_RECT, M_TENT,
		M_CEIL, M_FLOOR, M_ROUND,
		M_ABS, M_ARG, M_REAL, M_IMAG, M_CONJUGATE, M_POLAR, M_CARTESIAN,
		
			M_BFSTART,

		M_RAND,
		M_ATAN,
		M_LOG,
		M_BETA, M_GAMMA, M_PERMUTATION, M_COMBINATION,
		M_BESSEL, M_NEUMANN, M_HANKEL1,
		M_SQWV, M_TRWV, M_SAW, M_MIN, M_MAX,

		M_USER_FUNCTION
	};
/*	enum
	{
		M_IGNORED,
		
		M_N,
		
		M_LPR, M_RPR,																//(		)
		M_COMMA,																	//,
		M_QUESTION_MARK, M_COLON,													//?		:

			M_PROCEDURAL_START,
		M_IF, M_ELSE, M_FOR, M_DO, M_WHILE,											//if else for do while
		M_LBRACE, M_RBRACE,															//{		}

			M_PROCEDURAL_ASSIGN_START,
		M_ASSIGN, M_ASSIGN_MULTIPLY, M_ASSIGN_DIVIDE, M_ASSIGN_MOD,					//= *= /= %=
		M_ASSIGN_PLUS, M_ASSIGN_MINUS, M_ASSIGN_LEFT, M_ASSIGN_RIGHT,				//+= -= <<= >>=
		M_ASSIGN_AND, M_ASSIGN_XOR, M_ASSIGN_OR,									//&= #= |=
			M_PROCEDURAL_ASSIGN_END,

		M_SEMICOLON,																//;
		M_CONTINUE, M_BREAK, M_RETURN,												//continue break return
			M_PROCEDURAL_END,

		M_FACTORIAL_LOGIC_NOT,														//!
		M_MODULO_PERCENT,															//%
		M_BITWISE_NOT,																//~
		M_PENTATE,																	//^^^
		M_TETRATE,																	//^^
		M_POWER,																	//^
		M_MULTIPLY, M_DIVIDE, M_LOGIC_DIVIDES,										//*		/		@
		M_PLUS, M_MINUS,															//+		-
		M_BITWISE_SHIFT_LEFT, M_BITWISE_SHIFT_RIGHT,								//<<	>>
		M_LOGIC_LESS, M_LOGIC_LESS_EQUAL, M_LOGIC_GREATER, M_LOGIC_GREATER_EQUAL,	//<		<=		>		>=
		M_LOGIC_EQUAL, M_LOGIC_NOT_EQUAL,											//==	!=
		M_BITWISE_AND, M_BITWISE_NAND,												//&		~& |~
		M_BITWISE_XOR, M_BITWISE_XNOR,												//#		~# #~
		M_VERTICAL_BAR, M_BITWISE_NOR,												//|		~| &~
		M_LOGIC_AND,																//&&
		M_LOGIC_XOR,																//##
		M_LOGIC_OR,																	//||
		M_LOGIC_CONDITION_ZERO,														//??

		M_S_EQUAL_ASSIGN, M_S_NOT_EQUAL,											//= _!=				not supported
		M_S_LESS, M_S_LESS_EQUAL, M_S_GREATER, M_S_GREATER_EQUAL,					//= _< =< _> =>		not supported

			M_FUNCTION_START,
		//	M_FSTART,

		M_COS, M_ACOS, M_COSH, M_ACOSH, M_COSC,
		M_SEC, M_ASEC, M_SECH, M_ASECH,
		M_SIN, M_ASIN, M_SINH, M_ASINH, M_SINC, M_SINHC,
		M_CSC, M_ACSC, M_CSCH, M_ACSCH,
		M_TAN,         M_TANH, M_ATANH, M_TANC,
		M_COT, M_ACOT, M_COTH, M_ACOTH,
		M_EXP, M_LN, M_SQRT, M_CBRT, M_INVSQRT,
		M_GAUSS, M_ERF, M_FIB, M_ZETA,
		M_STEP, M_SGN, M_RECT, M_TENT,
		M_CEIL, M_FLOOR, M_ROUND,
		M_ABS, M_ARG, M_REAL, M_IMAG, M_CONJUGATE, M_POLAR, M_CARTESIAN,
		
			M_BINARY_FUNCTION_START,
		//	M_BFSTART,

		M_RAND,
		M_ATAN,
		M_LOG,
		M_BETA, M_GAMMA, M_PERMUTATION, M_COMBINATION,
		M_BESSEL, M_NEUMANN, M_HANKEL1,
		M_SQWV, M_TRWV, M_SAW, M_MIN, M_MAX,
		
			M_USER_FUNCTION_START,
	};//*/
/*	enum Map
	{
		M_IGNORED,

		M_N, M_V, M_V2,			//number/variable,		number/variable first in arg list,		number/variable first in arg list: 2

		M_LPR, M_RPR,																//(		)
		M_COMMA,																	//,
		M_QUESTION_MARK, M_COLON,													//?		:

			M_PROCEDURAL_START,
		M_IF, M_ELSE, M_FOR, M_DO, M_WHILE,											//if else for do while
		M_LBRACE, M_RBRACE,															//{		}
		M_ASSIGN, M_ASSIGN_MULTIPLY, M_ASSIGN_DIVIDE, M_ASSIGN_MOD,					//= *= /= %=
		M_ASSIGN_PLUS, M_ASSIGN_MINUS, M_ASSIGN_LEFT, M_ASSIGN_RIGHT,				//+= -= <<= >>=
		M_ASSIGN_AND, M_ASSIGN_XOR, M_ASSIGN_OR,									//&= #= |=
		M_SEMICOLON,																//;
		M_CONTINUE, M_BREAK, M_RETURN,												//continue break return
			M_PROCEDURAL_END,

		M_FACTORIAL_LOGIC_NOT,														//!
		M_MODULO_PERCENT,															//%
		M_BITWISE_NOT,																//~
		M_PENTATE,																	//^^^
		M_TETRATE,																	//^^
		M_POWER,																	//^
		M_MULTIPLY, M_DIVIDE, M_LOGIC_DIVIDES,										//*		/		@
		M_PLUS, M_MINUS,															//+		-
		M_BITWISE_SHIFT_LEFT, M_BITWISE_SHIFT_RIGHT,								//<<	>>
		M_LOGIC_LESS, M_LOGIC_LESS_EQUAL, M_LOGIC_GREATER, M_LOGIC_GREATER_EQUAL,	//<		<=		>		>=
		M_LOGIC_EQUAL, M_LOGIC_NOT_EQUAL,											//==	!=
		M_BITWISE_AND, M_BITWISE_NAND,												//&		~& |~
		M_BITWISE_XOR, M_BITWISE_XNOR,												//#		~# #~
		M_VERTICAL_BAR, M_BITWISE_NOR,												//|		~| &~
		M_LOGIC_AND,																//&&
		M_LOGIC_XOR,																//##
		M_LOGIC_OR,																	//||
		M_LOGIC_CONDITION_ZERO,														//??

		M_S_EQUAL_ASSIGN, M_S_NOT_EQUAL,											//_= _!=			not supported
		M_S_LESS, M_S_LESS_EQUAL, M_S_GREATER, M_S_GREATER_EQUAL,					//_< =< _> =>		not supported

			M_FSTART,
		M_COS, M_ACOS, M_COSH, M_ACOSH, M_COSC,
		M_SEC, M_ASEC, M_SECH, M_ASECH,
		M_SIN, M_ASIN, M_SINH, M_ASINH, M_SINC, M_SINHC,
		M_CSC, M_ACSC, M_CSCH, M_ACSCH,
		M_TAN,         M_TANH, M_ATANH, M_TANC,
		M_COT, M_ACOT, M_COTH, M_ACOTH,
		M_EXP, M_LN, M_SQRT, M_CBRT, M_INVSQRT,
		M_GAUSS, M_ERF, M_FIB, M_ZETA,
		M_STEP, M_SGN, M_RECT, M_TENT,
		M_CEIL, M_FLOOR, M_ROUND,
		M_MAG, M_MAG_2, M_ARG, M_REAL, M_IMAG, M_CONJUGATE, M_POLAR, M_CARTESIAN,
		
			M_BFSTART,

		M_RAND,
		M_ATAN,
		M_LOG,
		M_BETA, M_GAMMA, M_PERMUTATION, M_COMBINATION,
		M_BESSEL, M_NEUMANN, M_HANKEL1,
		M_SQWV, M_TRWV, M_SAW, M_MIN, M_MAX,
			M_FEND,
	};//*/
	const double	_atm	=101325,			_bbr	=5.670373e-8,
					_c		=299792458,			_ele	=8.854187817620e-12,
					_e		=::exp(1.),			_g		=9.80665,
					_G		=6.67384e-11,		_h		=6.62606957e-34,
					_mag	=1.2566370614e-6,	_me		=9.10938291e-31,
					_mn		=1.674927351e-27,	_mp		=1.672621777e-27,
					_Me		=5.9736e24,			_Ms		=1.9891e30,
					_Na		=6.02214129e23,		_phi	=1.6180339887498948482045868343656381177203091798057628621354486227052604628189,
					_pi		=::acos(-1.),		_q		=1.602176565e-19,
					_R		=8.3144621,			_qnan	=std::numeric_limits<double>::quiet_NaN();
}
void		render();
bool		_2d_drag_graph_not_window=false, _dangerous_code=false, _3d_stretch_move_cam=true, _3d_shift_move_cam=false, _3d_zoom_move_cam=false;
bool		commasInNumbers=false, commentIncompleteScope=true, nestedComments=false, colorComments=false;
bool		fullscreen=false, showBenchmark=false, showLastModeOnIdle=true, function_timeout=true;
int			w, h, oldMouse, cursorB, cursorEx, prevCursorEx=0;
RECT		oldWindowSize;
char		kb[256]={0}, caps_lock, num_lock;
tagPOINT	centerP, mouseP0;
tagRECT		R;
HWND__		*ghWnd;
HDC__		*ghDC, *ghMemDC;
int			*rgb, *modeRGB=nullptr;
HBITMAP__	*ghBitmap;
void		user_trigered_seed()
{
	LARGE_INTEGER li;
	QueryPerformanceCounter(&li);
	srand(li.LowPart);
}
class		Font
{
	static const int	NFONTS;
	static HFONT		_hFont_[];
	static int			_charW_[][128], _fontH_[];
	char				font;
	void				assign(){hFont=_hFont_[font], W=_charW_[font], H=_fontH_[font];}
public:
	HFONT__				*hFont;
	int					*W, H;
	void				createFonts();
	double				change(int);
	double				larger();
	double				smaller();
	double				assign(int newFont)
	{
		hFont=_hFont_[newFont], W=_charW_[newFont], H=_fontH_[newFont];
		double A=double(H)/_fontH_[font];
		font=newFont;
		return A;
	}
	int					getTextW(const char *a, int i, int f){return short(GetTabbedTextExtentA(ghMemDC, &a[i], f-i, 0, 0));}
	~					Font();
} font;
HFONT Font::_hFont_[]=
{
	CreateFontA(-  7, 0, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH|FF_ROMAN, "Small Fonts"),
	CreateFontA(-  8, 0, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH|FF_ROMAN, "Small Fonts"),
	CreateFontA(- 10, 0, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH|FF_ROMAN, "Small Fonts"),
	CreateFontA(   1, 0, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH|FF_ROMAN, "System"),
	CreateFontA(  29, 0, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH|FF_ROMAN, "System"),
	CreateFontA(  47, 0, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH|FF_ROMAN, "System"),
	CreateFontA(  64, 0, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH|FF_ROMAN, "System"),
	CreateFontA(  94, 0, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH|FF_ROMAN, "System"),
	CreateFontA( 112, 0, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH|FF_ROMAN, "System"),
	CreateFontA( 128, 0, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH|FF_ROMAN, "System")
};
const int Font::NFONTS=sizeof(_hFont_)/sizeof(HFONT);
int Font::_charW_[NFONTS][128], Font::_fontH_[NFONTS];
void			Font::createFonts()
{
	for(int k=0;k<NFONTS;++k)
	{
		_hFont_[k]=(HFONT__*)SelectObject(ghMemDC, _hFont_[k]);
		for(int k2=0;k2<128;++k2)
		{
			auto LOL=(char*)&k2;
			_charW_[k][k2]=(short)GetTabbedTextExtentA(ghMemDC, (char*)&k2, 1, 0, 0);//
		}
		_fontH_[k]=GetTabbedTextExtentA(ghMemDC, "text", 4, 0, 0)>>16;
		_hFont_[k]=(HFONT__*)SelectObject(ghMemDC, _hFont_[k]);
	}
	font=3;
	assign();
}
double			Font::larger	(){return font<NFONTS-1	?assign(font+1):1;}
double			Font::smaller	(){return font>0		?assign(font-1):1;}
double			Font::change(int wParam)
{
	if(((short*)&wParam)[1]<0)
	{
		if(font>0)
			return assign(font-1);
	}
	else
	{
		if(font<NFONTS-1)
			return assign(font+1);
	}
	return 1;
}
				Font::~Font()
{
	for(int k=0;k<NFONTS;++k)
		DeleteObject(_hFont_[k]);
}
struct		Map
{
	G2::Map _0;
	int _1;
	int pos, len;
	Map(int pos=0, int len=0, G2::Map _0=G2::M_IGNORED, int _1=0):_0(_0), _1(_1), pos(pos), len(len){}
};

const int	g_buf_size=1024;
char		g_buf[g_buf_size];
void		GUIPrint(HDC hDC, int x, int y, const char* format, ...)
{
	int linelen=vsprintf_s(g_buf, format, (char*)(&format+1));
	if(linelen>0)
		TextOutA(hDC, x, y, g_buf, linelen);
}
void		GUIPrint(HDC hDC, int x, int y, int value)
{
	int linelen=sprintf_s(g_buf, 1024, "%d", value);
	if(linelen>0)
		TextOutA(hDC, x, y, g_buf, linelen);
}
template<int buffer_size>bool printValue_real		(				char (&buffer)[buffer_size], int &offset, double const &value)
{
	if(value)
	{
		offset+=sprintf_s(buffer+offset, buffer_size-offset,

			value!=value?//NAN
				(long long&)value==0x7FF8000000000010?	"+-inf"
				:										"0/0"
			:value==_HUGE?	"inf"
			:value==-_HUGE?	"-inf"
			:				"%.15g"

			, value);//
		return true;
	}
	return false;
}
template<int buffer_size>bool printValue_real		(				char (&buffer)[buffer_size], int &offset, double const &value, int const base)
{
	if(value)
	{
		if(value!=value)
			offset+=sprintf_s(buffer+offset, buffer_size-offset, (long long&)value==0x7FF8000000000010?"+-inf":"0/0");
		else if(value==_HUGE)
			offset+=sprintf_s(buffer+offset, buffer_size-offset, "inf");
		else if(value==-_HUGE)
			offset+=sprintf_s(buffer+offset, buffer_size-offset, "-inf");
		else if(base==10)
			offset+=sprintf_s(buffer+offset, buffer_size-offset, "%.15g", value);
		else
		{
			const int l2int[]={0xFF, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4};
			int l2base=l2int[base];
			if(value<0)
				offset+=sprintf_s(buffer+offset, buffer_size-offset, "-");
			const char *prefix[]={"", "B", "", "0", "0x"};
			offset+=sprintf_s(buffer+offset, buffer_size-offset, prefix[l2base]);
			int exponent=(((int*)&value)[1]>>20&0x000007FF)-1023;
			auto mantissa=(long long&)value&0x000FFFFFFFFFFFFF|0x0010000000000000;//1.<52bits>*2^<11bits>		1.m<<e
			long long digit;
			if(exponent>=-13&&exponent<=50)
			{
				if(exponent<0)
				{
					int nzeros=-(exponent+1)/l2base;
					if(nzeros)
						offset+=sprintf_s(buffer+offset, buffer_size-offset, "0.%0*d", nzeros, 0);
					else
						offset+=sprintf_s(buffer+offset, buffer_size-offset, "0.");
					for(int k=52-(l2base+exponent%l2base)%l2base;k>=0&&mantissa;k-=l2base)
					{
						digit=mantissa>>k, mantissa-=digit<<k;
						offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X", digit);
					}
				}
				else for(int k=52-exponent%l2base;k>=0;k-=l2base)//>=0 <=50
				{
					digit=mantissa>>k, mantissa-=digit<<k;
					offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X", digit);
					if(k==52-exponent)
					{
						if(mantissa)
						{
							offset+=sprintf_s(buffer+offset, buffer_size-offset, ".");
							for(k-=l2base;k>=0&&mantissa;k-=l2base)
							{
								digit=mantissa>>k, mantissa-=digit<<k;
								offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X", digit);
							}
							if(mantissa)
							{
								digit=mantissa<<((l2base-(52-exponent)%l2base)%l2base), mantissa-=digit<<k;
								offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X", digit);
							}
						}
						break;
					}
				}
			}
			else
			{
				int k=52;//p=2
			//	int k=52-exponent%l2base;//p=16
			//	int k=52-(l2base+exponent%l2base)%l2base;
				digit=mantissa>>k, mantissa-=digit<<k;
				offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X.", digit);
				for(k-=l2base;k>=0&&mantissa;k-=l2base)
				{
					digit=mantissa>>k, mantissa-=digit<<k;
					offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X", digit);
				}
				if(exponent<0)
					offset+=sprintf_s(buffer+offset, buffer_size-offset, "p-");
				else
					offset+=sprintf_s(buffer+offset, buffer_size-offset, "p+");
			//	exponent/=l2base;
				for(int k=10-10%l2base, digit;k>=0&&exponent;k-=l2base)
				{
					if(digit=exponent>>k)
					{
						exponent-=digit<<k;
						offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X", digit);
						for(k-=l2base;k>=0&&exponent;k-=l2base)
						{
							digit=exponent>>k, exponent-=digit<<k;
							offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X", digit);
						}
						break;
					}
				}
			}
		}
		return true;
	}
	return false;
}
template<int buffer_size>void printValue_unreal		(bool &written, char (&buffer)[buffer_size], int &offset, double const &value, char const *component)
{
	if(value)
	{
		offset+=sprintf_s(buffer+offset, buffer_size-offset,
			
			value!=value?//NAN
				(long long&)value==0x7FF8000000000010?	"+-inf"
				:										written?"+0/0":"0/0"
			:value==_HUGE?			written?"+inf":"inf"
			:value==-_HUGE?			"-inf"
			:value==-1?				"-"
			:value==1?				written?"+":""
			:						written&&value>0?"+%.15g":"%.15g"

			, value);//
		offset+=sprintf_s(buffer+offset, buffer_size-offset, component);
		written=true;
	}
}
template<int buffer_size>void printValue_unreal		(bool &written, char (&buffer)[buffer_size], int &offset, double const &value, char const *component, int const base)
{
	if(value)
	{
		if(value!=value)
			offset+=sprintf_s(buffer+offset, buffer_size-offset, (long long&)value==0x7FF8000000000010?"+-inf":written?"+0/0":"0/0");
		else if(value==_HUGE)
			offset+=sprintf_s(buffer+offset, buffer_size-offset, written?"+inf":"inf");
		else if(value==-_HUGE)
			offset+=sprintf_s(buffer+offset, buffer_size-offset, "-inf");
		else if(value==1)
			offset+=sprintf_s(buffer+offset, buffer_size-offset, written?"+":"");
		else if(value==-1)
			offset+=sprintf_s(buffer+offset, buffer_size-offset, "-");
		else if(base==10)
			offset+=sprintf_s(buffer+offset, buffer_size-offset, written&&value>0?"+%.15g":"%.15g", value);
		else
		{
			const int l2int[]={0x80000000, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4};
			int l2base=l2int[base];
			if(written&&value>0)
				offset+=sprintf_s(buffer+offset, buffer_size-offset, "+");
			if(value<0)
				offset+=sprintf_s(buffer+offset, buffer_size-offset, "-");
			const char *prefix[]={"", "B", "", "0", "0x"};
			offset+=sprintf_s(buffer+offset, buffer_size-offset, prefix[l2base]);
			int exponent=(((int*)&value)[1]>>20&0x000007FF)-1023;
			auto mantissa=(long long&)value&0x000FFFFFFFFFFFFF|0x0010000000000000;//1.<52bits>*2^<11bits>		1.m<<e
			long long digit;
			if(exponent>=-13&&exponent<=50)
			{
				if(exponent<0)
				{
					int nzeros=-(exponent+1)/l2base;
					if(nzeros)
						offset+=sprintf_s(buffer+offset, buffer_size-offset, "0.%0*d", nzeros, 0);
					else
						offset+=sprintf_s(buffer+offset, buffer_size-offset, "0.");
					for(int k=52-exponent%l2base;k>=0&&mantissa;k-=l2base)
					{
						digit=mantissa>>k, mantissa-=digit<<k;
						offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X", digit);
					}
				}
				else for(int k=52-exponent%l2base;k>=0;k-=l2base)//>=0 <=50
				{
					digit=mantissa>>k, mantissa-=digit<<k;
					offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X", digit);
					if(k==52-exponent)
					{
						if(mantissa)
						{
							offset+=sprintf_s(buffer+offset, buffer_size-offset, ".");
							for(k-=l2base;k>=0&&mantissa;k-=l2base)
							{
								digit=mantissa>>k, mantissa-=digit<<k;
								offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X", digit);
							}
							if(mantissa)
							{
								digit=mantissa<<((l2base-(52-exponent)%l2base)%l2base), mantissa-=digit<<k;
								offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X", digit);
							}
						}
						break;
					}
				}
			}
			else
			{
				int k=52;
			//	int k=52-(l2base+exponent%l2base)%l2base;
				digit=mantissa>>k, mantissa-=digit<<k;
				offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X.", digit);
				for(k-=l2base;k>=0&&mantissa;k-=l2base)
				{
					digit=mantissa>>k, mantissa-=digit<<k;
					offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X", digit);
				}
				if(exponent<0)
					offset+=sprintf_s(buffer+offset, buffer_size-offset, "p-");
				else
					offset+=sprintf_s(buffer+offset, buffer_size-offset, "p+");
			//	exponent/=l2base;
				for(int k=10-10%l2base, digit;k>=0&&exponent;k-=l2base)
				{
					if(digit=exponent>>k)
					{
						exponent-=digit<<k;
						offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X", digit);
						for(k-=l2base;k>=0&&exponent;k-=l2base)
						{
							digit=exponent>>k, exponent-=digit<<k;
							offset+=sprintf_s(buffer+offset, buffer_size-offset, "%X", digit);
						}
						break;
					}
				}
			}
		}
		offset+=sprintf_s(buffer+offset, buffer_size-offset, component);
		written=true;
	}
}
struct		Value
{
	double r, i, j, k;//in order
	Value(double r=0, double i=0, double j=0, double k=0):r(r), i(i), j(j), k(k){}
	Value(std::complex<double> const &x):r(x.real()), i(x.imag()), j(0), k(0){}
	Value(boost::math::quaternion<double> const &x):r(x.R_component_1()), i(x.R_component_2()), j(x.R_component_3()), k(x.R_component_4()){}
	operator double&						(){return r;}
	operator double							()const{return r;}
	operator std::complex<double>			()const{return std::complex<double>(r, i);}
	operator boost::math::quaternion<double>()const{return boost::math::quaternion<double>(r, i, j, k);}
	Value& operator=	(double							const &x){r=x, i=j=k=0;																				return *this;}
	Value& operator=	(std::complex<double>			const &x){r=x.real(), i=x.imag(), j=k=0;															return *this;}
	Value& operator=	(boost::math::quaternion<double>const &x){r=x.R_component_1(), i=x.R_component_2(), j=x.R_component_3(), k=x.R_component_4();		return *this;}
	Value& operator+=	(double							const &x){r+=x;																						return *this;}
	Value& operator+=	(std::complex<double>			const &x){r+=x.real(), i+=x.imag();																	return *this;}
	Value& operator+=	(boost::math::quaternion<double>const &x){r+=x.R_component_1(), i+=x.R_component_2(), j+=x.R_component_3(), k+=x.R_component_4();	return *this;}
	Value& operator-=	(double							const &x){r-=x;																						return *this;}
	Value& operator-=	(std::complex<double>			const &x){r-=x.real(), i-=x.imag();																	return *this;}
	Value& operator-=	(boost::math::quaternion<double>const &x){r-=x.R_component_1(), i-=x.R_component_2(), j-=x.R_component_3(), k-=x.R_component_4();	return *this;}
	bool r_isTrue()const{return r!=0;}
	bool c_isTrue()const{return r!=0||i!=0;}
	bool q_isTrue()const{return r!=0||i!=0||j!=0||k!=0;}
	template<int buffer_size>void printReal(char (&buffer)[buffer_size], int &offset)const
	{
		if(!printValue_real(buffer, offset, r))
			offset+=sprintf_s(buffer+offset, buffer_size-offset, "0");
	}
	template<int buffer_size>void printReal(char (&buffer)[buffer_size], int &offset, int base)const
	{
		if(!printValue_real(buffer, offset, r, base))
			offset+=sprintf_s(buffer+offset, buffer_size-offset, "0");
	}
	template<int _size>void printComplex(char(&)[_size], int&)const;
	template<int _size>void printComplex(char(&)[_size], int&, int)const;
	template<int _size>void printQuaternion(char(&)[_size], int&)const;
	template<int _size>void printQuaternion(char(&)[_size], int&, int)const;
	template<int _size>void print(char (&a)[_size], int &o, char mathSet)const
	{
		switch(mathSet)
		{
		case 'r':
	//	case 'R':
			printReal(a, o);
			break;
		case 'c':
	//	case 'C':
			printComplex(a, o);
			break;
		case 'H':
			printQuaternion(a, o);
			break;
		}
	}
	template<int _size>void print(char (&a)[_size], int &o, char mathSet, int base)const
	{
		switch(mathSet)
		{
		case 'r':
	//	case 'R':
			printReal(a, o, base);
			break;
		case 'c':
	//	case 'C':
			printComplex(a, o, base);
			break;
		case 'H':
			printQuaternion(a, o, base);
			break;
		}
	}
};
template<int buffer_size>void Value::printComplex	(				char (&buffer)[buffer_size], int &offset			)const
{
	bool written=printValue_real(buffer, offset, r);
	printValue_unreal(written, buffer, offset, i, "i");
	if(!written)
		offset+=sprintf_s(buffer+offset, buffer_size-offset, "0");
}
template<int buffer_size>void Value::printComplex	(				char (&buffer)[buffer_size], int &offset, int base	)const
{
	bool written=printValue_real(buffer, offset, r, base);
	printValue_unreal(written, buffer, offset, i, "i", base);
	if(!written)
		offset+=sprintf_s(buffer+offset, buffer_size-offset, "0");
}
template<int buffer_size>void Value::printQuaternion(				char (&buffer)[buffer_size], int &offset			)const
{
	bool written=printValue_real(buffer, offset, r);
	printValue_unreal(written, buffer, offset, i, "i");
	printValue_unreal(written, buffer, offset, j, "j");
	printValue_unreal(written, buffer, offset, k, "k");
	if(!written)
		offset+=sprintf_s(buffer+offset, buffer_size-offset, "0");
}
template<int buffer_size>void Value::printQuaternion(				char (&buffer)[buffer_size], int &offset, int base	)const
{
	bool written=printValue_real(buffer, offset, r, base);
	printValue_unreal(written, buffer, offset, i, "i", base);
	printValue_unreal(written, buffer, offset, j, "j", base);
	printValue_unreal(written, buffer, offset, k, "k", base);
	if(!written)
		offset+=sprintf_s(buffer+offset, buffer_size-offset, "0");
}
struct DiscontinuityFunction
{
	bool disc_in, disc_out;//evaluated before/after the function
	union
	{
		bool
			(*d_o)(Value const&, Value const&),
			(*ud_i)(Value const&, Value const&),
			(*bd_i)(Value const&, Value const&, Value const&, Value const&),
			(*td_i)(Value const&, Value const&, Value const&, Value const&, Value const&, Value const&);
	};

	//continuous function
	DiscontinuityFunction():
		disc_in(false), disc_out(false){}

	//discontinuity takes unary function argument or any function's output
	DiscontinuityFunction(bool (*d)(Value const&, Value const&), bool disc_in):
		disc_in(disc_in), disc_out(!disc_in), ud_i(d){}

	//discontinuity takes binary function arguments
	DiscontinuityFunction(bool (*bd_i)(Value const&, Value const&, Value const&, Value const&)):
		disc_in(true), disc_out(false), bd_i(bd_i){}

	//discontinuity takes triary function arguments
	DiscontinuityFunction(bool (*td_i)(Value const&, Value const&, Value const&, Value const&, Value const&, Value const&)):
		disc_in(true), disc_out(false), td_i(td_i){}

	//continuous function
	void operator()()
	{disc_out=disc_in=false;}

	//discontinuity takes unary function argument or any function's output
	void operator()(bool (*d)(Value const&, Value const&), bool disc_in)
	{disc_out=!(this->disc_in=disc_in), ud_i=d;}

	//discontinuity takes binary function arguments
	void operator()(bool (*bd_i)(Value const&, Value const&, Value const&, Value const&))
	{disc_out=!(disc_in=true), this->bd_i=bd_i;}

	//discontinuity takes triary function arguments
	void operator()(bool (*td_i)(Value const&, Value const&, Value const&, Value const&, Value const&, Value const&))
	{disc_out=!(disc_in=true), this->td_i=td_i;}
};
struct Instruction
{
	// 1		'1' function of 1	n[result].ndr[v]=uf(n[op1].ndr[v])
	// 2		'2' function of 2	n[result].ndr[v]=bf(n[op1].ndr[v], n[op2].ndr[v])
	// 3		'3' function of 3	n[result].ndr[v]=tf(n[op1].ndr[v], n[op2].ndr[v], n[op3].ndr[v])
	//'c' call						n[result].ndr[v]=ufd[op1]
	//'b' branch if					if(data[op1].q_isTrue())i=result
	//'B' branch if not				if(!data[op1].q_isTrue())i=result
	//'j' jump						i=result
	//'r' return					data[result]
	char type;
	
	//function of 1-3 args
	union
	{
		Value
			(*uf)(Value const&),
			(*bf)(Value const&, Value const&),
			(*tf)(Value const&, Value const&, Value const&);
	};
	union
	{
		char
			(*umts)(char),
			(*bmts)(char, char),
			(*tmts)(char, char, char);
	};
	int op1, op2, op3, result;
	DiscontinuityFunction d;
	
	//call
	std::vector<int> args;//arg positions
	Instruction(int function, std::vector<int> const &args, int n_result){type='c', op1=function, this->args=args, result=n_result;}
	
	Instruction(char type, int n_condition){this->type=type, op1=n_condition;}//branch:		'b' branch if		'B' branch if not		op1 condition, result dest
	Instruction(){type='j';}//jump		result dest
	Instruction(int n_result){type='r', result=n_result;}//return		result result

	//unary function
	Instruction(Value (*uf)(Value const&), char (*umts)(char), int op1, int result, DiscontinuityFunction &d):
		type(1), uf(uf), umts(umts), op1(op1), result(result), d(d){}
//	Instruction(Value (*uf)(Value const&), char (*umts)(char), int op1, DiscontinuityFunction &d):
//		type(1), uf(uf), umts(umts), op1(op1), result(op1), d(d){}

	//binary function
	Instruction(Value (*bf)(Value const&, Value const&), char (*bmts)(char, char), int op1, int op2, int result, DiscontinuityFunction &d):
		type(2), bf(bf), bmts(bmts), op1(op1), op2(op2), result(result), d(d){}

	//triary function
	Instruction(Value (*tf)(Value const&, Value const&, Value const&), char (*tmts)(char, char, char), int op1, int op2, int op3, int result, DiscontinuityFunction &d):
		type(3), tf(tf), tmts(tmts), op1(op1), op2(op2), op3(op3), result(result), d(d){}
};
struct Variable
{
	std::string name;
	char mathSet,//R real, C complex, H quaternion
		varTypeR, varTypeI, varTypeJ, varTypeK;//x y z space, t time, c constant
	Value val;

	//real variable
	Variable(char const *a, int len, int varTypeR):
		name(a, len), mathSet('r'), varTypeR(varTypeR){}
	//	name(a, len), mathSet('R'), varTypeR(varTypeR){}

	//complex variable
	Variable(char const *a, int len, int varTypeR, int varTypeI):
		name(a, len), mathSet('c'), varTypeR(varTypeR), varTypeI(varTypeI){}
	//	name(a, len), mathSet('C'), varTypeR(varTypeR), varTypeI(varTypeI){}

	//quaternion variable
	Variable(char const *a, int len, int varTypeR, int varTypeI, int varTypeJ, int varTypeK):
		name(a, len), mathSet('H'), varTypeR(varTypeR), varTypeI(varTypeI), varTypeJ(varTypeJ), varTypeK(varTypeK){}
};
struct UFVariableName
{
	std::string name;
	int scopeLevel, data_idx;
	UFVariableName(char const *a, int len, int scopeLevel, int data_idx):name(a, len), scopeLevel(scopeLevel), data_idx(data_idx){}
};
struct Term
{
	bool constant;
	char mathSet;//'r' real, 'c' complex, 'H' quaternion	smaller value = superset	//'R'==82, 'C'==67, 'H'==72	'c'==99, 'h'==104
	int varNo;

	//constant
	Term(char mathSet='r'):constant(true), mathSet(mathSet){}

	//function variable constant==false//
	Term(char mathSet, bool constant):constant(constant), mathSet(mathSet), varNo(0){}

	//expr variable
	Term(char mathSet, int varNo):constant(false), mathSet(mathSet), varNo(varNo){}

	std::vector<Value> ndr;
};
struct		Expression
{
	std::vector<std::pair<int, int>> syntaxErrors;//highlight text[first, second[
	void insertSyntaxError(int first, int second)
	{
		int k=0, kEnd=syntaxErrors.size();
		for(;k<kEnd&&syntaxErrors[k].first<first;++k);
		if(k==kEnd||syntaxErrors[k].first!=first)
			syntaxErrors.insert(syntaxErrors.begin()+k, std::pair<int, int>(first, second));
	}

	std::vector<bool> discontinuities;

	int lineNo, endLineNo, boundNo,
		color,//argb
		winColor,//abgr
		nx, nZ, nQ,
		nISD;//3 space dimentions max
	bool nITD;//1 time dimention max
	char resultMathSet;//'r' real, 'c' complex, 'H' quaternion	smaller value = superset	//'R'==82, 'C'==67, 'H'==72	'c'==99, 'h'==104

	std::vector<Map> m;
	std::vector<Variable> variables;
	std::vector<Term> n;
	std::vector<Value> data;
	std::vector<Instruction> i;
	int resultLogicType;//0: not bool, 1: && ## || < <= > >= logic/inequality, 2: = equation, 3: != anti-equation
	int lastInstruction;
	std::vector<int> rmode;

	//user function
	bool valid;
	int name_id;//unique name_id > M_USER_FUNCTION_START
	int nArgs;//, lineNo;
	bool functionStuck;//true: user function returns nan without evaluation when markFunctionsStuck=true

	Expression():color(0), winColor(0), nx(0), nZ(0), nQ(0), nISD(0), nITD(false), rmode(1, 0),
		valid(true), nArgs(0){}
	
	void insertMap(int pos, int len, G2::Map _0, int _1=0){m.push_back(Map(pos, len, _0, _1));}
//	void insertMap(G2::Map _0, int _1=0){m.push_back(Map(_0, _1));}
	void insertMapData(int pos, int len, char mathSet, double r=0, double i=0, double j=0, double k=0)
	{
		m.push_back(Map(pos, len, G2::M_N, data.size()));
		n.push_back(Term(mathSet)), data.push_back(Value(r, i, j, k));
	}//*/
/*	void insertMapData(char mathSet, double r=0, double i=0, double j=0, double k=0)
	{
		m.push_back(Map(G2::M_N, data.size()));
		n.push_back(Term(mathSet)), data.push_back(Value(r, i, j, k));
	}//*/
//	void insertData(char mathSet, Value &x){n.push_back(Term(mathSet)), data.push_back(x);}//ambiguous
	void insertData(char mathSet, Value x=Value()){n.push_back(Term(mathSet)), data.push_back(x);}

	void insertRVar(int, int, char const*, int);
	void insertCVar(int, int, char const*);
	void insertHVar(int, int, char const*);
//	void insertRVar(char const*, int, int);
//	void insertCVar(char const*, int);
//	void insertHVar(char const*, int);
	void setColor_random()
	{
		auto c=(unsigned char*)&color, wc=(unsigned char*)&winColor;
		c[0]=wc[2]=rand();
		c[1]=wc[1]=rand();
		c[2]=wc[0]=rand();
		c[3]=wc[3]=0;
	}
	void setColor_black(){color=winColor=0;}
	
	//user function
	void insertFVar(char mathSet){n.push_back(Term(mathSet, false)), data.push_back(Value());}
};
void			Expression::insertRVar(int pos, int len, char const *a, int varType)
{
	std::string str(a, len);
	int k=std::find_if(variables.begin(), variables.end(), [&](Variable &v){return v.name==str;})-variables.begin();
	m.push_back(Map(pos, len, G2::M_N, n.size()));
	n.push_back(Term('r', k)), data.push_back(Value());
//	n.push_back(Term('R', k)), data.push_back(Value());
	if(k==variables.size())
	{
		++nx;
		switch(varType)
		{
		case 's':
			switch(nISD)
			{
			case 0:
			case 1:
			case 2:
				varType='x'+nISD, ++nISD;
				break;
			case 3:
				if(nITD)
					varType='c';
				else
					varType='t', nITD=true;
				break;
			}
			break;
		case 't':
			if(nITD)
				switch(nISD)
				{
				case 0:
				case 1:
				case 2:
					varType='x'+nISD, ++nISD;
					break;
				case 3:
					varType='c';
					break;
				}
			else
				nITD=true;
			break;
		}
		variables.push_back(Variable(a, len, varType));
	}
}
void			Expression::insertCVar(int pos, int len, char const *a)
{
	std::string str(a, len);
	int k=std::find_if(variables.begin(), variables.end(), [&](Variable &v){return v.name==str;})-variables.begin();
	m.push_back(Map(pos, len, G2::M_N, n.size()));
	n.push_back(Term('c', k)), data.push_back(Value());
//	n.push_back(Term('C', k)), data.push_back(Value());
	if(k==variables.size())
	{
		++nZ;
		switch(nISD)
		{
		case 0:
		case 1:
			variables.push_back(Variable(a, len,
				'x'+nISD,
				'x'+nISD+1)), nISD+=2;
			break;
		case 2:
			variables.push_back(Variable(a, len,
				'z',
				nITD?'c':'t')), ++nISD, nITD=true;
			break;
		case 3:
			variables.push_back(Variable(a, len,
				nITD?'c':'t',
				'c')), nITD=true;
			break;
		}
	}
}
void			Expression::insertHVar(int pos, int len, char const *a)
{
	std::string str(a, len);
	int k=std::find_if(variables.begin(), variables.end(), [&](Variable &v){return v.name==str;})-variables.begin();
	m.push_back(Map(pos, len, G2::M_N, n.size()));
	n.push_back(Term('H', k)), data.push_back(Value());
//	n.push_back(Term('C', k)), data.push_back(Value());
	if(k==variables.size())
	{
		++nQ;
		switch(nISD)
		{
		case 0:
			variables.push_back(Variable(a, len,
				nITD?'c':'t',
				'x'+nISD,
				'x'+nISD+1,
				'x'+nISD+2)), nISD+=3, nITD=true;
			break;
		case 1:
			variables.push_back(Variable(a, len,
				'x'+nISD,
				'x'+nISD+1,
				nITD?'c':'t', 'c')), nISD+=2, nITD=true;
			break;
		case 2:
			variables.push_back(Variable(a, len,
				'x'+nISD,
				nITD?'c':'t',
				'c',
				'c')), ++nISD, nITD=true;
			break;
		case 3:
			variables.push_back(Variable(a, len,
				nITD?'c':'t',
				'c',
				'c',
				'c')), nITD=true;
			break;
		}
	}
}
std::vector<Expression> expr(1), userFunctionDefinitions(1);

struct NameTreeNode
{
	bool success;//subsequence support
	int name_id;
	NameTreeNode *nextChar[128];
	std::vector<char> children;
//	NameTreeNode():success(false), nextChar{}{}//warning C4351: new behavior: default initialization	inspect your code
	NameTreeNode():success(false)
	{
		for(int k=0;k<128;++k)
			nextChar[k]=nullptr;
	}
	void allocate_leaky(char c)
	{
		nextChar[c]=new NameTreeNode;
		children.push_back(c);
	}
	void allocate(char c)
	{
		if(!nextChar[c])
		{
			nextChar[c]=new NameTreeNode;
			children.push_back(c);
		}
	}
	void free(char c)
	{
		delete nextChar[c];
		nextChar[c]=nullptr;
		for(int k=0, kEnd=children.size();k<kEnd;++k)
		{
			if(children[k]==c)
			{
				children.erase(children.begin()+k);
				break;
			}
		}
	}
	~NameTreeNode()
	{
		for(auto &c:children)
			delete nextChar[c];
	}
};
class NameTree
{
	NameTreeNode userFunctionNamesRoot;
	int name_id_counter;
public:
	NameTree():name_id_counter(0){}
//	NameTree():name_id_counter(G2::M_USER_FUNCTION_START){}
	NameTreeNode* matchName_free(char *text, int i, int kEnd, int &nameEnd)//free match		inline
	{
		auto node=userFunctionNamesRoot.nextChar[text[i]];
		for(int ch=i+1;node;++ch)
		{
			if(node->success)
			{
				nameEnd=ch;
				return node;
			}
			if(ch==kEnd)
				break;
			node=node->nextChar[text[ch]];
		}
		return nullptr;
	}
	NameTreeNode* matchName		(char *text, int i, int f, int &nameEnd)//bounded match
	{
		auto node=userFunctionNamesRoot.nextChar[text[i]];
		for(int ch=i+1;node;++ch)
		{
			if(ch==f)
			{
				if(node->success)
				{
					nameEnd=ch;
					return node;
				}
				break;
			}
			node=node->nextChar[text[ch]];
		}
		return nullptr;
	}
	NameTreeNode* addName		(char *text, int i, int f)
	{
		if(		text[0]=='b'&&text[1]=='r'&&text[2]=='e'&&text[3]=='a'&&text[4]=='k'
			||	text[0]=='c'&&text[1]=='o'&&text[2]=='n'&&text[3]=='t'&&text[4]=='i'&&text[5]=='n'&&text[6]=='u'&&text[7]=='e'
			||	text[0]=='d'&&text[1]=='o'
			||	text[0]=='e'&&text[1]=='l'&&text[2]=='s'&&text[3]=='e'
			||	text[0]=='f'&&text[1]=='o'&&text[2]=='r'
			||	text[0]=='g'&&text[1]=='o'&&text[2]=='t'&&text[3]=='o'
			||	text[0]=='i'&&text[1]=='f'
			||	text[0]=='r'&&text[1]=='e'&&text[2]=='t'&&text[3]=='u'&&text[4]=='r'&&text[5]=='n'
			||	text[0]=='s'&&text[1]=='w'&&text[2]=='i'&&text[3]=='t'&&text[4]=='c'&&text[5]=='h'
			||	text[0]=='w'&&text[1]=='h'&&text[2]=='i'&&text[3]=='l'&&text[4]=='e')
			return nullptr;
		auto node=&userFunctionNamesRoot;
		for(int k2=i;;++k2)
		{
			if(k2==f)//subsequence
			{
				if(!node->success)
					node->success=true, node->name_id=name_id_counter++;
				return node;
			}
			auto next=node->nextChar[text[k2]];
			if(next)
				node=next;
			else
			{
				for(;k2<f;++k2)
				{
					node->allocate_leaky(text[k2]);
					node=node->nextChar[text[k2]];
				}
				node->success=true, node->name_id=name_id_counter++;
				return node;
			}
		}
		return nullptr;
	}
	void removeName				(char *text, int i, int f)
	{
		auto node=userFunctionNamesRoot.nextChar[text[i]];
		std::stack<std::pair<NameTreeNode*, int>> depth;//parentNode, child char
	//	depth.push(std::pair<NameTreeNode*, int>(node, text[i]));
		for(int ch=i+1;node;++ch)//find
		{
			if(ch==f)//found, remove
			{
				if(node->children.size())//remove subsequence
					node->success=false;
				else//remove pillar sequence
				{
					for(;depth.size()&&depth.top().first->children.size()==1&&!depth.top().first->success;)//seek start of free branch
						depth.pop();
					if(depth.size())//remove child & pillar branch
						depth.top().first->free(depth.top().second);
					else//remove last entry
						userFunctionNamesRoot.free(userFunctionNamesRoot.children[0]);
				}
				break;
			}
			depth.push(std::pair<NameTreeNode*, int>(node, text[ch]));
			node=node->nextChar[text[ch]];
		}
	}
	void cleanTree()
	{
		if(userFunctionNamesRoot.children.size())
		{
			auto ufdBegin=userFunctionDefinitions.begin(), ufdEnd=userFunctionDefinitions.end();
			auto node=userFunctionNamesRoot.nextChar[userFunctionNamesRoot.children[0]];
			std::vector<std::pair<NameTreeNode*, int>> depth(1, std::pair<NameTreeNode*, int>(&userFunctionNamesRoot, 0));//stack: &pauseParentNode, pauseChildNo
			for(int br=0;;)
			{
				if(node->success&&std::find_if(ufdBegin, ufdEnd, [&](Expression const &def){return def.name_id==node->name_id;})==ufdEnd)//unused name, remove
				{
					if(node->children.size())//remove subsequence
						node->success=false;
					else//remove pillar sequence
					{
						for(;depth.size()&&depth.rbegin()->first->children.size()==1&&!depth.rbegin()->first->success;)//seek start of free branch
							depth.pop_back();
						if(depth.size())
						{
							auto parent=depth.rbegin()->first;
							parent->free(depth.rbegin()->second);//remove pillar branch
							if(depth.rbegin()->second==parent->children.size())//no next child, find from parents above
							{
								depth.pop_back();
								for(;depth.size()&&depth.rbegin()->second==depth.rbegin()->first->children.size()-1;)//if parent branches exhausted pop and repeat
									depth.pop_back();
								if(depth.size())
									br=++depth.rbegin()->second, node=parent->nextChar[parent->children[br]];
								else//scan finish
									break;
							}
							else//next child is where goner was
								br=depth.rbegin()->second, node=parent->nextChar[parent->children[br]];
						}
						else//remove last entry
						{
							userFunctionNamesRoot.free(userFunctionNamesRoot.children[0]);
							break;
						}
					}
				}
				if(br==depth.rbegin()->first->children.size())//branches exhausted
				{
					for(;depth.size()&&depth.rbegin()->second==depth.rbegin()->first->children.size()-1;)//if parent branches exhausted pop and repeat
						depth.pop_back();
					if(depth.size())//if parents left goto next child
					{
						auto parent=depth.rbegin()->first;
						br=++depth.rbegin()->second, node=parent->nextChar[parent->children[br]];
					}
					else//root exhausted
						break;
				}
				else
				{
					depth.push_back(std::pair<NameTreeNode*, int>(node, br));
					node=node->nextChar[node->children[br]];
				}
			}
		}
	}
} userFunctionNames;

int lineChangeStart=-1, lineRemoveEnd=-1, lineInsertEnd=-1, nLines=1;
int boundChangeStart=-1, boundRemoveEnd=-1, boundInsertEnd=-1;
int exprChangeStart=-1, exprRemoveEnd=-1, exprInsertEnd=-1;
int functionChangeStart=-1, functionRemoveEnd=-1, functionInsertEnd=-1;
std::vector<std::pair<int, char>> bounds(1, std::pair<int, char>(0, 'c'));//e expression, f function, c clear/empty
//std::vector<std::pair<int, char>> bounds(1, std::pair<int, char>(0, 'e'));
std::vector<std::pair<int, int>> allComments;

struct		Performance
{
	static int nCalls, odd;
	static long long freq, nticks;
	static _LARGE_INTEGER li;
	static double best;
	Performance(){QueryPerformanceCounter(&li);}
	Performance(int x, int y)
	{
		nCalls++;
		QueryPerformanceFrequency(&li);
		freq=li.QuadPart;
		QueryPerformanceCounter(&li);
		double current=1000.*(li.QuadPart-nticks)/freq;
		if(nCalls==200)
			best=current, nCalls=0, odd=!odd;
		else if(current<best)
			best=current;
		int bkMode=GetBkMode(ghMemDC);
		SetBkMode(ghMemDC, OPAQUE);
		GUIPrint(ghMemDC, x, y, odd?"[%.10fms], %.10fms, %d":"%.10fms, %.10fms, %d", best, current, nCalls);
		SetBkMode(ghMemDC, bkMode);
		nticks=li.QuadPart;
	}
};
int				Performance::nCalls=0, Performance::odd=0;
long long		Performance::freq, Performance::nticks;
_LARGE_INTEGER	Performance::li;
double			Performance::best=_HUGE;

class		TextBox
{
protected:
	int bpx, bpy, bw, bh;
	int mouseTextSel, mouseTextScrollX, mouseTextScrollY;
	HRGN__ *hRgn;
	char mapChar(char c)
	{
		return
			 c>='0'&&c<='9'||c=='.'?							'0'
			:c=='\''||c>='A'&&c<='Z'||c>='a'&&c<='z'||c=='_'?	'a'
			:c==' '||c=='\t'?									' '
			:c=='\r'||c=='\n'?									'\r'
			:													c;
	}
	void cursorAtMouse(int x, int y);
	int toTeleportCursor;
	void cursorTeleport();
public:
	char *text;
	int textlen, cursor, selcur;
	bool active;
	int tpx, tpy, tw, th;
	TextBox(bool active);
	void changeFont(double A);
	void setDimensions(int x, int y, int w, int h);
	int private_clickRegion(short x, short y)//
	{
		if(tw>w)
		{
			if(th>h)//horizontal & vertical scrolling
			{
				if(y>=0)
				{
					if(y<17)
					{
						if(x>=bw-17&&x<bw)//	[^]
						{
							tpy=tpy-font.H<0?0:tpy-font.H;
							return 1;
						}
					}
					else if(y<bh-34)
					{
						if(x>=bw-17&&x<bw)//	|
						{
							mouseTextScrollY=1;
							return 0;
						}
					}
					else if(y<bh-17)
					{
						if(x>=bw-17&&x<bw)//	[v]
						{
							tpy=tpy+font.H>th-bh?th-bh:tpy+font.H;
							return 1;
						}
					}
					else if(y<bh)
					{
						if(x>=0)
						{
							if(x<17)//	[<]
							{
								tpx=tpx-font.H<0?0:tpx-font.H;
								return 1;
							}
							else if(x<bw-34)//	__
							{
								mouseTextScrollX=1;
								return 0;
							}
							else if(x<bw-17)//	[>]
							{
								tpx=tpx+font.H>tw-bw?tw-bw:tpx+font.H;
								return 1;
							}
						}
					}
				}
			}
			else//horizontal scrolling only
			{
				if(y>=bh-17&&y<bh)
				{
					if(x>=0)
					{
						if(x<17)//	[<]
						{
							tpx=tpx-font.H<0		?0		:tpx-font.H;
							return 1;
						}
						else if(x<bw-17)//	__
						{
							mouseTextScrollX=1;
							return 0;
						}
						else if(x<bw)//	[>]
						{
							tpx=tpx+font.H>tw-bw	?tw-bw	:tpx+font.H;
							return 1;
						}
					}
				}
			}
		}
		else
		{
			if(th>h)//vertical scrolling only
			{
				if(x>=bw-17&&x<bw)
				{
					if(y>=0)
					{
						if(y<17)//	[^]
						{
							tpy=tpy-font.H<0?0:tpy-font.H;
							return 1;
						}
						else if(y<bh-17)//	|
						{
							mouseTextScrollY=1;
							return 0;
						}
						else if(y<bh)//	[v]
						{
							tpx=tpx+font.H>tw-bw	?tw-bw	:tpx+font.H;
							return 1;
						}
					}
				}
			}
		}
		mouseTextSel=1;
		cursorAtMouse(x, y);
		if(!kb[VK_SHIFT])
			selcur=cursor;
		return 1;
	}
	virtual int switchToWithMouseOn(int lParam);
	virtual int inputLButtonDown(int lParam);
	int inputMouseMove(int lParam);
	void inputLButtonUp();
	int inputMouseWheel(int wParam);
	virtual int inputKeyDown(int wParam, int lParam);
	virtual void draw();
	virtual void draw_corresponding			(std::set<int>const&, TextBox*);
	virtual void draw_corresponding_color	(std::set<int>const&, TextBox*);
	~TextBox();

};
void			TextBox::cursorAtMouse(int x, int y)
{
	cursor=0;
	if(y>=0)
	{
		for(int k=0, l=0;k<textlen-1;++k)
		{
			if(l==(tpy+y)/font.H)
				break;
			else if(text[k]=='\r')
				cursor=++k+1, ++l;
		}
	}
	int lstart=cursor;
	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	for(int x2=0;text[cursor]!='\r'&&cursor<textlen;++cursor)
	{
		int tx2=font.getTextW(text, lstart, cursor+1);
		if(tpx+x<x2+(tx2-x2)/2)
			break;
		x2=tx2;
	}
	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
//	cursorTeleport();
}
void			TextBox::cursorTeleport()
{
//	if(tw>w||th>h)//outdated
	{
		font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
		int currentLineStart=0, cursorY=0, cursorX=0;
		for(int k=0;k<cursor;++k)
		{
			if(text[k]=='\r')
			{
				cursorY+=font.H;
				if(k+1<textlen&&text[k+1]=='\n')
					++k;
				currentLineStart=k+1;
			}
		}
		if(currentLineStart<cursor)
			cursorX=font.getTextW(text, currentLineStart, cursor);
		font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			 if(cursorY<tpy			)tpy=cursorY;
		else if(cursorY>tpy+h-font.H)tpy=cursorY-h+font.H;
			 if(cursorX<tpx			)tpx=cursorX;
		else if(cursorX>tpx+w		)tpx=cursorX-w;
	}
	if(!kb[VK_SHIFT])
		selcur=cursor;//cursorAtMouse
	toTeleportCursor=false;
}
				TextBox::TextBox(bool active=false):active(active), cursor(0), selcur(0), bpx(0), bpy(0), bw(0), bh(0), tpx(0), tpy(0), tw(0), th(0), mouseTextSel(0), mouseTextScrollX(0), mouseTextScrollY(0), toTeleportCursor(0)
{
	text=(char*)malloc(((textlen=0)+1)*sizeof(char)), text[textlen]='\0';
	hRgn=CreateRectRgn(bpx, bpy, bpx+bw, bpy+bh);
}
void			TextBox::setDimensions(int x, int y, int w, int h)
{
	bpx=x, bpy=y, bw=w, bh=h;
	DeleteObject(hRgn);
	hRgn=CreateRectRgn(bpx, bpy, bpx+bw, bpy+bh);
}
void			TextBox::changeFont(double A){tpx=int(A*tpx), tpy=int(A*tpy);}
int				TextBox::switchToWithMouseOn(int lParam){return private_clickRegion(((short*)&lParam)[0]-bpx, ((short*)&lParam)[1]-bpy);}
int				TextBox::inputLButtonDown(int lParam)
{
	short x=((short*)&lParam)[0]-bpx, y=((short*)&lParam)[1]-bpy;
	if(x>=0&&x<bw&&y>=0&&y<bh)//
		return private_clickRegion(((short*)&lParam)[0]-bpx, ((short*)&lParam)[1]-bpy);
	else if(active)
	{
		active=false;
		return 1;
	}
	else
		return 0;
}
int				TextBox::inputMouseMove(int lParam)
{
	if(active)
	{
		int x=((short*)&lParam)[0], y=((short*)&lParam)[1];
			 if(mouseTextSel	){	cursorAtMouse(x-bpx, y-bpy);																					return 1;}
		else if(mouseTextScrollX){	tpx+=int(double(tw)*(x-short(oldMouse		))/(tw>bw&&th>bh?bw-41:bw-34)), tpx=tpx<0?0:tpx>tw-bw?tw-bw:tpx;	return 1;}
		else if(mouseTextScrollY){	tpy+=int(double(th)*(y-short(oldMouse>>16	))/(tw>bw&&th>bh?bh-41:bh-34)), tpy=tpy<0?0:tpy>th-bh?th-bh:tpy;	return 1;}
	}
	return 0;
}
void			TextBox::inputLButtonUp()
{
	if(active)
		mouseTextSel=mouseTextScrollX=mouseTextScrollY=0;
}
int				TextBox::inputMouseWheel(int wParam)
{
	if(active)
	{
		if(th>bh){		 if(((short*)&wParam)[1]<0)	{tpy=tpy+100>th-bh	?th-bh	:tpy+100;return 1;}
					else							{tpy=tpy-100<0		?0		:tpy-100;return 1;}}
	}
	return 0;
}
int				TextBox::inputKeyDown(int wParam, int lParam)
{
	if(kb[VK_CONTROL])
	{
		switch(wParam)
		{
		case VK_CAPITAL:				return 0;
		case VK_NUMLOCK:				return 0;
		case VK_OEM_3:					return 0;
		case '1':						return 0;
		case '2':						return 0;
		case '3':						return 0;
		case '4':						return 0;
		case '5':						return 0;
		case '6':						return 0;
		case '7':						return 0;
		case '8':						return 0;
		case '9':						return 0;
		case '0':						return 0;
		case VK_OEM_MINUS:				return 0;
		case VK_OEM_PLUS:				return 0;
		case VK_TAB:					return 0;
		case 'Q':						return 0;
		case 'W':						return 0;
		case 'E':						return 0;
		case 'R':						return 0;
		case 'T':						return 0;
		case 'Y':						return 0;
		case 'U':						return 0;
		case 'I':						return 0;
		case 'O':						return 0;
		case 'P':						return 0;
		case VK_OEM_4:					return 0;
		case VK_OEM_6:					return 0;
		case 'A':
			cursor=textlen;
			cursorTeleport();
			selcur=0;
			return 1;
		case 'S':						return 0;
		case 'D':						return 0;
		case 'F':						return 0;
		case 'G':						return 0;
		case 'H':						return 0;
		case 'J':						return 0;
		case 'K':						return 0;
		case 'L':						return 0;
		case VK_OEM_1:					return 0;
		case VK_OEM_7:					return 0;
		case VK_OEM_5:case VK_OEM_102:	return 0;
		case 'Z':						return 0;
		case 'X':						return 0;
		case 'C':
			if(cursor!=selcur)
			{
				int k=cursor<selcur?cursor:selcur, k2=cursor>selcur?cursor:selcur;
				char *clipboard=(char*)LocalAlloc(LMEM_FIXED, (k2-k+1)*sizeof(char));
				memcpy(clipboard, &text[k], (k2-k)*sizeof(char));
				clipboard[k2-k]='\0';
				OpenClipboard(ghWnd), EmptyClipboard(), SetClipboardData(CF_OEMTEXT, (void*)clipboard), CloseClipboard();
			}
			return 0;
		case 'V':						return 0;
		case 'B':						return 0;
		case 'N':						return 0;
		case 'M':						return 0;
		case VK_OEM_COMMA:				return 0;
		case VK_OEM_PERIOD:				return 0;
		case VK_OEM_2:					return 0;
		case VK_SPACE:					return 0;
		case VK_NUMPAD0:				return 0;
		case VK_NUMPAD1:				return 0;
		case VK_NUMPAD2:				return 0;
		case VK_NUMPAD3:				return 0;
		case VK_NUMPAD4:				return 0;
		case VK_NUMPAD5:				return 0;
		case VK_NUMPAD6:				return 0;
		case VK_NUMPAD7:				return 0;
		case VK_NUMPAD8:				return 0;
		case VK_NUMPAD9:				return 0;
		case VK_DECIMAL:				return 0;
		case VK_ADD:					return 0;
		case VK_SUBTRACT:				return 0;
		case VK_MULTIPLY:				return 0;
		case VK_DIVIDE:					return 0;
		case VK_DELETE:					return 0;
		case VK_BACK:					return 0;
		case VK_RETURN:					return 0;
		case VK_UP:
			if(th>bh)
			{
				tpy=tpy-font.H<0?0:tpy-font.H;
				return 1;
			}
			return 0;
		case VK_DOWN:
			if(th>bh)
			{
				tpy=tpy+font.H>th-bh?th-bh:tpy+font.H;
				return 1;
			}
			return 0;
		case VK_LEFT:
			if(cursor)
			{
				char initial=mapChar(text[--cursor]);
				for(;cursor;--cursor)
					if(mapChar(text[cursor-1])!=initial)
						break;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_RIGHT:
			if(cursor!=textlen)
			{
				char initial=mapChar(text[cursor++]);
				for(;cursor!=textlen;++cursor)
					if(mapChar(text[cursor])!=initial)
						break;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_HOME:
			if(kb[VK_SHIFT])
			{
				cursor=0;
				cursorTeleport();
				return 1;
			}
			else if(tw>bw)
			{
				tpx=0;
				return 1;
			}
			return 0;
		case VK_END:
			if(kb[VK_SHIFT])
			{
				cursor=textlen;
				cursorTeleport();
				return 1;
			}
			else if(tw>bw)
			{
				tpx=tw-bw;
				return 1;
			}
			return 0;
		case VK_ESCAPE:case VK_F1:case VK_F2:case VK_F3:case VK_F4:case VK_F5:case VK_F6:case VK_F7:case VK_F8:case VK_F9:case VK_F10:case VK_F11:case VK_F12:case VK_INSERT:	return 0;
		case VK_F13:case VK_F14:case VK_F15:case VK_F16:case VK_F17:case VK_F18:case VK_F19:case VK_F20:case VK_F21:case VK_F22:case VK_F23:case VK_F24:						return 0;
		case VK_SHIFT:					return 0;
		case VK_CONTROL:case VK_LWIN:	return 0;
		case VK_PRIOR:case VK_NEXT:		return 0;
		default:						return 0;
		}
	}
	else
	{
		switch(wParam)
		{
		case VK_CAPITAL:				return 0;
		case VK_NUMLOCK:				return 0;
		case VK_OEM_3:					return 0;
		case '0':						return 0;
		case '1':						return 0;
		case '2':						return 0;
		case '3':						return 0;
		case '4':						return 0;
		case '5':						return 0;
		case '6':						return 0;
		case '7':						return 0;
		case '8':						return 0;
		case '9':						return 0;
		case VK_OEM_MINUS:				return 0;
		case VK_OEM_PLUS:				return 0;
		case 'Q':						return 0;
		case 'W':						return 0;
		case 'E':						return 0;
		case 'R':						return 0;
		case 'T':						return 0;
		case 'Y':						return 0;
		case 'U':						return 0;
		case 'I':						return 0;
		case 'O':						return 0;
		case 'P':						return 0;
		case VK_OEM_4:					return 0;
		case VK_OEM_6:					return 0;
		case 'A':						return 0;
		case 'S':						return 0;
		case 'D':						return 0;
		case 'F':						return 0;
		case 'G':						return 0;
		case 'H':						return 0;
		case 'J':						return 0;
		case 'K':						return 0;
		case 'L':						return 0;
		case VK_OEM_1:					return 0;
		case VK_OEM_7:					return 0;
		case VK_OEM_5:case VK_OEM_102:	return 0;
		case 'Z':						return 0;
		case 'X':						return 0;
		case 'C':						return 0;
		case 'V':						return 0;
		case 'B':						return 0;
		case 'N':						return 0;
		case 'M':						return 0;
		case VK_OEM_COMMA:				return 0;
		case VK_OEM_PERIOD:				return 0;
		case VK_OEM_2:					return 0;
		case VK_SPACE:					return 0;
		case VK_NUMPAD0:				return 0;
		case VK_NUMPAD1:				return 0;
		case VK_NUMPAD2:				return 0;
		case VK_NUMPAD3:				return 0;
		case VK_NUMPAD4:				return 0;
		case VK_NUMPAD5:				return 0;
		case VK_NUMPAD6:				return 0;
		case VK_NUMPAD7:				return 0;
		case VK_NUMPAD8:				return 0;
		case VK_NUMPAD9:				return 0;
		case VK_DECIMAL:				return 0;
		case VK_ADD:					return 0;
		case VK_SUBTRACT:				return 0;
		case VK_MULTIPLY:				return 0;
		case VK_DIVIDE:					return 0;
		case VK_DELETE:					return 0;
		case VK_BACK:					return 0;
		case VK_RETURN:					return 0;
		case VK_UP:
			if(kb[VK_SHIFT])
			{
				for(int k=cursor-2;k>=0;--k)
				{
					if(text[k]=='\r')
					{
						font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
						int x=font.getTextW(text, k+2, cursor), x2=0;
						for(;;--k)
							if(!k||text[k-1]=='\n')
								break;
						for(int k2=k;;++k2)
						{
							if(text[k2]=='\r')
							{
								cursor=k2;
								break;
							}
							int tx2;
							if(text[k2]=='\t')
								tx2=font.getTextW(text, k, k2+1);
							else
								tx2=x2+font.W[text[k2]];
							if(tx2>x)
							{
								cursor=tx2-(tx2-x2)/2>x?k2:k2+1;
								break;
							}
							x2=tx2;
						}
						font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
						cursorTeleport();
						return 1;
					}
				}
			}
			else if(th>bh)
			{
				tpy=tpy-font.H<0?0:tpy-font.H;
				return 1;
			}
			return 0;
		case VK_DOWN:
			if(kb[VK_SHIFT])
			{
				for(int k=cursor;k<textlen;++k)
				{
					if(text[k]=='\n')
					{
						font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
						int k2=cursor;
						for(;k2>0;--k2)
							if(text[k2-1]=='\n')
								break;
						int x=font.getTextW(text, k2, cursor), x2=0;
						for(int k2=++k;;++k2)
						{
							if(text[k2]=='\r'||k2==textlen)
							{
								cursor=k2;
								break;
							}
							int tx2;
							if(text[k2]=='\t')
								tx2=font.getTextW(text, k, k2+1);
							else
								tx2=x2+font.W[text[k2]];
							if(tx2>x)
							{
								cursor=tx2-(tx2-x2)/2>x?k2:k2+1;
								break;
							}
							x2=tx2;
						}
						font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
						cursorTeleport();
						return 1;
					}
				}
			}
			else if(th>bh)
			{
				tpy=tpy+font.H>th-bh?th-bh:tpy+font.H;
				return 1;
			}
			return 0;
		case VK_LEFT:
			if(kb[VK_SHIFT])
			{
				if(cursor)
				{
					cursor-=text[cursor-1]=='\n'?2:1;
					cursorTeleport();
					return 1;
				}
			}
			return 0;
		case VK_RIGHT:
			if(kb[VK_SHIFT])
			{
				if(cursor<textlen)
				{
					cursor+=text[cursor]=='\r'?2:1;
					cursorTeleport();
					return 1;
				}
			}
			return 0;
		case VK_HOME:
			if(kb[VK_SHIFT])
			{
				if(cursor&&text[cursor-1]!='\n')
				{
					for(;;--cursor)
						if(!cursor||text[cursor-1]=='\n')
							break;
					cursorTeleport();
					return 1;
				}
			}
			if(tw>bw)
			{
				tpx=0;
				return 1;
			}
			return 0;
		case VK_END:
			if(kb[VK_SHIFT])
			{
				if(text[cursor]!='\r'&&cursor<textlen)
				{
					for(;;++cursor)
						if(text[cursor]=='\r'||cursor==textlen)
							break;
					cursorTeleport();
					return 1;
				}
			}
			if(tw>bw)
			{
				tpx=tw-bw;
				return 1;
			}
			return 0;
		case VK_ESCAPE:case VK_F1:case VK_F2:case VK_F3:case VK_F4:case VK_F5:case VK_F6:case VK_F7:case VK_F8:case VK_F9:case VK_F10:case VK_F11:case VK_F12:case VK_INSERT:	return 0;
		case VK_F13:case VK_F14:case VK_F15:case VK_F16:case VK_F17:case VK_F18:case VK_F19:case VK_F20:case VK_F21:case VK_F22:case VK_F23:case VK_F24:						return 0;
		case VK_TAB:					return 0;
		case VK_SHIFT:					return 0;
		case VK_CONTROL:case VK_LWIN:	return 0;
		case VK_PRIOR:case VK_NEXT:		return 0;
		default:						return 0;
		}
	}
	return 0;
}
void			TextBox::draw()
{
	SelectClipRgn(ghMemDC, hRgn);
	tw=th=0;
	int bkMode=GetBkMode(ghMemDC), bkColor=GetBkColor(ghMemDC);
//	SetBkMode(ghMemDC, TRANSPARENT);
	for(int k=cursor<selcur?cursor:selcur, k2=cursor>selcur?cursor:selcur, k3=0, k4=0, x=0, y=0;k4<=textlen;++k4)
	{
		if(k4==k)
		{
			x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
			k3=k4;
			SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, active?0x00FFFF96:0x00969696);
		}
		if(k4==k2)
		{
			x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
			k3=k4;
			SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
		//	SetBkMode(ghMemDC, TRANSPARENT);
		}
		if(text[k4]=='\r'||k4==textlen)
		{
			x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
			if(x>tw)
				tw=x;
			k3=k4+2, x=0, th+=font.H, y+=font.H;
		}
	}
	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
	if(tw>bw&&th>bh)
	{
		int xi=bpx+17+int(double(bw-51)*tpx/tw), xf=bpx+17+int(double(bw-51)*(tpx+bw)/tw), yi=bpy+17+int(double(bh-51)*tpy/th), yf=bpy+17+int(double(bh-51)*(tpy+bh)/th);
		MoveToEx(ghMemDC, bpx		, bpy+bh-17	, 0), LineTo(ghMemDC, bpx+bw	, bpy+bh-17	);
		MoveToEx(ghMemDC, bpx+17	, bpy+bh-17	, 0), LineTo(ghMemDC, bpx+17	, bpy+bh	);
		MoveToEx(ghMemDC, xi		, bpy+bh-17	, 0), LineTo(ghMemDC, xi		, bpy+bh	);
		MoveToEx(ghMemDC, xf		, bpy+bh-17	, 0), LineTo(ghMemDC, xf		, bpy+bh	);
		MoveToEx(ghMemDC, bpx+bw-34	, bpy+bh-17	, 0), LineTo(ghMemDC, bpx+bw-34	, bpy+bh	);
		MoveToEx(ghMemDC, bpx+bw-17	, bpy		, 0), LineTo(ghMemDC, bpx+bw-17	, bpy+bh	);
		MoveToEx(ghMemDC, bpx+bw-17	, bpy+17	, 0), LineTo(ghMemDC, bpx+bw	, bpy+17	);
		MoveToEx(ghMemDC, bpx+bw-17	, yi		, 0), LineTo(ghMemDC, bpx+bw	, yi		);
		MoveToEx(ghMemDC, bpx+bw-17	, yf		, 0), LineTo(ghMemDC, bpx+bw	, yf		);
		MoveToEx(ghMemDC, bpx+bw-17	, bpy+bh-34	, 0), LineTo(ghMemDC, bpx+bw	, bpy+bh-34	);
	}
	else if(tw>bw)
	{
		tpy=0;
		int xi=bpx+17+int(double(bw-34)*tpx/tw), xf=bpx+17+int(double(bw-34)*(tpx+bw)/tw);
		MoveToEx(ghMemDC, bpx		, bpy+bh-17, 0), LineTo(ghMemDC, bpx+bw		, bpy+bh-17	);
		MoveToEx(ghMemDC, bpx+17	, bpy+bh-17, 0), LineTo(ghMemDC, bpx+17		, bpy+bh	);
		MoveToEx(ghMemDC, xi		, bpy+bh-17, 0), LineTo(ghMemDC, xi			, bpy+bh	);
		MoveToEx(ghMemDC, xf		, bpy+bh-17, 0), LineTo(ghMemDC, xf			, bpy+bh	);
		MoveToEx(ghMemDC, bpx+bw-17	, bpy+bh-17, 0), LineTo(ghMemDC, bpx+bw-17	, bpy+bh	);
	}
	else if(th>bh)
	{	
		tpx=0;
		int yi=bpy+17+int(double(bh-34)*tpy/th), yf=bpy+17+int(double(bh-34)*(tpy+bh)/th);
		MoveToEx(ghMemDC, bpx+bw-17, bpy		, 0), LineTo(ghMemDC, bpx+bw-17	, bpy+bh	);
		MoveToEx(ghMemDC, bpx+bw-17, bpy+17		, 0), LineTo(ghMemDC, bpx+bw	, bpy+17	);
		MoveToEx(ghMemDC, bpx+bw-17, yi			, 0), LineTo(ghMemDC, bpx+bw	, yi		);
		MoveToEx(ghMemDC, bpx+bw-17, yf			, 0), LineTo(ghMemDC, bpx+bw	, yf		);
		MoveToEx(ghMemDC, bpx+bw-17, bpy+bh-17	, 0), LineTo(ghMemDC, bpx+bw	, bpy+bh-17	);
	}
	else
		tpx=tpy=0;
	SelectClipRgn(ghMemDC, 0);
}
void			TextBox::draw_corresponding(std::set<int>const &modes, TextBox *tb)
{
	int xc, yc;
	SelectClipRgn(ghMemDC, hRgn);
	tw=th=0;
	int bkMode=GetBkMode(ghMemDC), bkColor=GetBkColor(ghMemDC), txtColor=GetTextColor(ghMemDC), line=0;
	{
		int x=0, y=0;
		auto exprIT=expr.begin();
		for(;exprIT!=expr.end();++exprIT)
		{
			if(modes.find(exprIT->rmode[0])!=modes.end())
			{
				th=y=font.H*exprIT->endLineNo;
			//	th=y=font.H*((exprIT+1!=expr.end()?exprIT[1].lineNo:nLines)-1);
				break;
			}
		}
		for(int k=cursor<selcur?cursor:selcur, k2=cursor>selcur?cursor:selcur, k3=0, k4=0;k4<=textlen;++k4)
		{
			if(k4==k)
			{
				if(k3<k4)
					x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				k3=k4;
				if(k4==cursor)
					xc=x, yc=y;
				SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, active?0x00FFFF96:0x00969696);
			}
			if(k4==k2)
			{
				if(k3<k4)
					x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				k3=k4;
				if(k4==cursor)
					xc=x, yc=y;
				SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
			}
			if(text[k4]=='\r')
			{
				if(k3<k4)
					x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				if(x>tw)
					tw=x;
				k3=k4+2, x=0;
				if(k4==0||text[k4-1]!='\\')
				{
					++exprIT;
					for(;exprIT!=expr.end();++exprIT)
					{
						if(modes.find(exprIT->rmode[0])!=modes.end())
						{
							th=y=font.H*exprIT->endLineNo;
						//	th=y=font.H*((exprIT+1!=expr.end()?exprIT[1].lineNo:nLines)-1);
							break;
						}
					}
				}
			}
			else if(k4==textlen)
			{
				if(k3<k4)
					x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				if(x>tw)
					tw=x;
				k3=k4+2, x=0, th+=font.H;
			}
		}
	}
	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor), SetTextColor(ghMemDC, txtColor);
	SelectClipRgn(ghMemDC, 0);
}
void			TextBox::draw_corresponding_color(std::set<int>const &modes, TextBox *tb)
{
	int xc, yc;
	SelectClipRgn(ghMemDC, hRgn);
	tw=th=0;
	int bkMode=GetBkMode(ghMemDC), bkColor=GetBkColor(ghMemDC), txtColor=GetTextColor(ghMemDC), line=0;
	{
		int x=0, y=0;
		auto exprIT=expr.begin();
		for(;exprIT!=expr.end();++exprIT)
		{
			if(modes.find(exprIT->rmode[0])!=modes.end())
			{
				th=y=font.H*exprIT->endLineNo;
				SetTextColor(ghMemDC, modes.find(exprIT->rmode[0])!=modes.end()?exprIT->winColor:txtColor);
				break;
			}
		}
		for(int k=cursor<selcur?cursor:selcur, k2=cursor>selcur?cursor:selcur, k3=0, k4=0;k4<=textlen;++k4)
		{
			if(k4==k)
			{
				x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				k3=k4;
				if(k4==cursor)
					xc=x, yc=y;
				SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, active?0x00FFFF96:0x00969696);
			}
			if(k4==k2)
			{
				x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				k3=k4;
				if(k4==cursor)
					xc=x, yc=y;
				SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
			//	SetBkMode(ghMemDC, TRANSPARENT);
			}
			if(text[k4]=='\r')
			{
				x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				if(x>tw)
					tw=x;
				k3=k4+2, x=0;
				if(k4==0||text[k4-1]!='\\')
				{
					++exprIT;
					for(;exprIT!=expr.end();++exprIT)
					{
						if(modes.find(exprIT->rmode[0])!=modes.end())
						{
							th=y=font.H*exprIT->endLineNo;
							SetTextColor(ghMemDC, modes.find(exprIT->rmode[0])!=modes.end()?exprIT->winColor:txtColor);
							break;
						}
					}
				}
			}
			else if(k4==textlen)
			{
				x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				if(x>tw)
					tw=x;
				k3=k4+2, x=0, th+=font.H;
			}
		}
	}
	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor), SetTextColor(ghMemDC, txtColor);
	SelectClipRgn(ghMemDC, 0);
}
				TextBox::~TextBox()
{
	free(text);
	DeleteObject(hRgn);
}
class		InputTextBox:public TextBox
{
	int	*history, histpos, histlen, cont;
public:
	int getLineNo(int, int, int);
private:
	void closeComment(int, int);
	void replaceText_update(int, int, int);
	void replaceText(int, int, char*, int);
	void insertText(int, char*, int);
	void removeText(int, int);
public:
	InputTextBox(bool active):TextBox(active), history(0), histpos(0), histlen(0), cont(1){}
	virtual int switchToWithMouseOn(int lParam);
	int inputLButtonDown(int lParam);
	int inputKeyDown(int wParam, int lParam);
	void draw();
	void draw_color(std::set<int>const&);
	friend int copy_text_with_n0d_results(int);
} itb(1);
int				InputTextBox::getLineNo(int i, int i_lineNo, int f)
{
	int lineNo=i_lineNo;
	for(int k=i;k<f;++k)
		if(text[k]=='\n'||text[k]=='\r'&&text[k+1]!='\n')
			++lineNo;
	return lineNo;
}
void			InputTextBox::closeComment(int cStart, int cEnd)
{
	int min=cStart;
	for(;allComments.size()&&allComments.rbegin()->second>cStart;)
	{
		if(min>allComments.rbegin()->first)
			min=allComments.rbegin()->first;
		allComments.pop_back();
	}
	allComments.push_back(std::pair<int, int>(min, cEnd));
}
void			InputTextBox::replaceText_update(int i, int fr, int fi)
{
	std::vector<std::pair<int, char>> oldbounds=std::move(bounds);
	{
		nLines=1;
		allComments.clear();
		{
			std::stack<int> cStack;//positions of /*
			bool cFound=false, lineComment=false;
			int cFirst, lcFirst;
			for(int k=0;;++k)//A: comments					block 5
			{
				if(k>=textlen)
				{
					if(lineComment)
						closeComment(lcFirst, textlen);
					if(commentIncompleteScope)
					{
						if(nestedComments)
						{
							if(cStack.size())
							{
								for(;cStack.size()>1;)
									cStack.pop();
								closeComment(cStack.top(), textlen);
								cStack.pop();
							}
						}
						else if(cFound)
							closeComment(cFirst, textlen);
					}
					break;
				}
				switch(text[k])
				{
				case '\\':
					if(k+1<textlen&&text[k+1]=='\r')//robust
					{
						k+=1+(k+2<textlen&&text[k+2]=='\n');
						++nLines;
					}
					continue;
				case '\r':
					if(k+1<textlen&&text[k+1]=='\n')//
						++k;
				case '\n':
					if(lineComment)
					{
						closeComment(lcFirst, k-1);
						lineComment=false;
					}
					++nLines;
					continue;
				case '/':
					if(k+1<textlen)
					{
						if(text[k+1]=='*')
						{
							if(nestedComments)
								cStack.push(k);
							else if(!cFound)
								cFirst=k, cFound=true;
							++k;
						}
						else if(text[k+1]=='/')
						{
							if(!lineComment&&(nestedComments&&!cStack.size()||!cFound))
								lcFirst=k, lineComment=true;
							++k;
						}
					}
					continue;
				case '*':
					if(k+1<textlen&&text[k+1]=='/')
					{
						if(nestedComments)
						{
							if(cStack.size())
							{
								closeComment(cStack.top(), k+2);
								cStack.pop();
							}
							++k;
						}
						else if(cFound)
						{
							closeComment(cFirst, k+2);
							cFound=false;
							++k;//c c++
						}
					}
					continue;
				}
			}
		}
		const char *rHeaderTable[]=//C: extend functions
		{
		//allow newlines in header		args with mathset specifier
		//	          tn  r                  s!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
			"`````````ab``b``````````````````a````````e``````cccccccccc```````dddddddddddddddddddddddddd````d`dddddddddddddddddddddddddd`````",//a	[f]	[)]
			"`````````ab``b``````````````````a````````e``````cccccccccc```````dddddddddddddddddddddddddd`a``d`dddddddddddddddddddddddddd`````",//b	\\\r\n
			"````````````````````````````````````````````````cccccccccc```````dddddddddddddddddddddddddd````d`dddddddddddddddddddddddddd`````",//c	number	f{}
			"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^cccccccccc^^^^^^^dddddddddddddddddddddddddd^^^^d^dddddddddddddddddddddddddd^^^^^",//d	letter	f{}
			
			"`````````ef``f``````````````````e```````o```````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//e	(	[arg]
			"`````````ef``f``````````````````e```````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj`e``j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//f	\\\r\n

			"`````````eh``h``````````````````g```````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//g	arg
			"`````````eh``h``````````````````g```````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj`g``j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//h	\\\r\n
			"````````````````````````````````````````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//i	number	arg
			"`````````kl`````````````````````k```````o```g```iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//j	letter	arg

			"`````````kl``l``````````````````k```````o```g``````````````````````m````m````````mm````````````````m````m````````mm`````````````",//k	, [mathset]
			"`````````kl``l``````````````````k```````````g``````````````````````m````m````````mm`````````k``````m````m````````mm`````````````",//l	\\\r\n

			"`````````mn``n``````````````````m```````o```g```````````````````````````````````````````````````````````````````````````````````",//m	,
			"`````````mn``n``````````````````m```````````g```````````````````````````````````````````````m```````````````````````````````````",//n	\\\r\n

			"`````````op``p``````````````````o```````````````qqqqqqqqqq```````rrrrrrrrrrrrrrrrrrrrrrrrrr````r`rrrrrrrrrrrrrrrrrrrrrrrrrr`````",//o	[f]
			"`````````op``p``````````````````o```````````````qqqqqqqqqq```````rrrrrrrrrrrrrrrrrrrrrrrrrr`o``r`rrrrrrrrrrrrrrrrrrrrrrrrrr`````",//p	\\\r\n
			"````````````````````````````````````````````````qqqqqqqqqq```````rrrrrrrrrrrrrrrrrrrrrrrrrr````r`rrrrrrrrrrrrrrrrrrrrrrrrrr`````",//q	number	f
			"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^qqqqqqqqqq^^^^^^^rrrrrrrrrrrrrrrrrrrrrrrrrr^^^^r^rrrrrrrrrrrrrrrrrrrrrrrrrr^^^^^" //r	letter	f
	/*	//allow newlines in header
		//	          tn  r                  s!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
			"`````````ab``b``````````````````a````````e``````cccccccccc```````dddddddddddddddddddddddddd````d`dddddddddddddddddddddddddd`````",//a	[f]	[)]
			"`````````ab``b``````````````````a````````e``````cccccccccc```````dddddddddddddddddddddddddd`a``d`dddddddddddddddddddddddddd`````",//b	\\\r\n
			"````````````````````````````````````````````````cccccccccc```````dddddddddddddddddddddddddd````d`dddddddddddddddddddddddddd`````",//c	number	f{}
			"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^cccccccccc^^^^^^^dddddddddddddddddddddddddd^^^^d^dddddddddddddddddddddddddd^^^^^",//d	letter	f{}
			
			"`````````ef``f``````````````````e```````m```````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//e	(	[arg]
			"`````````ef``f``````````````````e```````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj`e``j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//f	\\\r\n

			"`````````eh``h``````````````````g```````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//g	arg
			"`````````eh``h``````````````````g```````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj`g``j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//h	\\\r\n
			"````````````````````````````````````````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//i	number	arg
			"`````````kl`````````````````````k```````m```g```iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//j	letter	arg

			"`````````kl``l``````````````````k```````m```g```````````````````````````````````````````````````````````````````````````````````",//k	,
			"`````````kl``l``````````````````k```````````g```````````````````````````````````````````````k```````````````````````````````````",//l	\\\r\n

			"`````````mn``n``````````````````m```````````````oooooooooo```````pppppppppppppppppppppppppp````p`pppppppppppppppppppppppppp`````",//m	[f]
			"`````````mn``n``````````````````m```````````````oooooooooo```````pppppppppppppppppppppppppp`m``p`pppppppppppppppppppppppppp`````",//n	\\\r\n
			"````````````````````````````````````````````````oooooooooo```````pppppppppppppppppppppppppp````p`pppppppppppppppppppppppppp`````",//o	number	f
			"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^oooooooooo^^^^^^^pppppppppppppppppppppppppp^^^^p^pppppppppppppppppppppppppp^^^^^" //p	letter	f//*/
		}, *tailTable[]=
		{
		//	          tn  r                  s!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
			"_````````a^``a``````````````````a```````````````````````````````````````````````````````````b```````````````````````````````````",//a	ws
			"_`````````a``b``````````````````````````````````````````````````````````````````````````````````````````````````````````````````" //b	\\\r\n
		};
		//state=table[state-'a'][text[k]]	>'`': continue;		=='`': return;		<'`': i=k+'_'-state;return;
		{
			std::stack<int> fStack;
			auto cIT=allComments.begin();
			for(int k=0, kEnd=cIT!=allComments.end()?cIT->first:textlen;;++k)//B: bounds
			{
				if(k>=kEnd)
				{
					if(cIT!=allComments.end())
					{
						k=cIT->second;
						++cIT;
						kEnd=cIT!=allComments.end()?cIT->first:textlen;
					}
					else
					{
						if(commentIncompleteScope&&fStack.size())
						{
							while(fStack.size()>1)		//find first '{', extend as header, push as comment
								fStack.pop();
							int cStart=fStack.top();//first '{'
							auto acIT=allComments.end();
							for(;acIT!=allComments.begin()&&acIT[-1].first>cStart;--acIT);
							char state='a';
							for(int rk=cStart, rkEnd=acIT!=allComments.begin()?acIT[-1].second:-1, newStart=-1;;--rk)//extend as header
							{
								if(rk<rkEnd)//check counter
								{
									if(acIT!=allComments.begin())
									{
										state=rHeaderTable[state-'a'][' '];
										rk=acIT[-1].first-1;
										--acIT;
										rkEnd=acIT!=allComments.begin()?acIT[-1].second:-1;
									}
									else break;
								}
								else state=rHeaderTable[state-'a'][rk<0?'\0':text[rk]];
								if(state<'a')//check for final state
								{
									if(state<'`'||newStart!=-1)//success final state or optional end reached earlier
									{
										if(state<'`')
											newStart=rk+'_'-state;
										cStart=newStart;
									}
									break;
								}
								if(state=='m'&&newStart==-1)
									newStart=rk;
							}
							closeComment(cStart, textlen);
							for(;bounds.size()>1&&bounds.rbegin()[1].first>cStart;)
								bounds.pop_back();
							if(bounds.size())
								bounds.rbegin()->first=cStart;
							bounds.push_back(std::pair<int, char>(textlen, 'e'));//separate empty expr
						}
						else if(!bounds.size()||bounds.rbegin()->first<textlen||text[textlen-1]=='\n'&&(textlen-3<0||text[textlen-3]!='\\'))
							bounds.push_back(std::pair<int, char>(textlen, 'e'));
						break;
					}
				}
				switch(text[k])
				{
				case '\\':
					if(k+1<textlen&&text[k+1]=='\r')//robust
						k+=1+(k+2<textlen&&text[k+2]=='\n');
					continue;
				case '\r':
					if(k+1<textlen&&text[k+1]=='\n')//
						++k;
				case '\n':
					bounds.push_back(std::pair<int, char>(k+1, 'e'));
					continue;
				case '{':
					fStack.push(k);
					continue;
				case '}':
					if(fStack.size())
					{
						for(;bounds.size()&&fStack.top()<bounds.rbegin()->first;)
							bounds.pop_back();
						int start=bounds.size()?bounds.rbegin()->first:0;
						if(start<fStack.top())
							bounds.push_back(std::pair<int, char>(fStack.top(), 'e'));
						bounds.push_back(std::pair<int, char>(k+1, 'f'));
						fStack.pop();
					}
					continue;
				}
			}
		}
		{
			auto cIT=allComments.begin(), acIT=cIT;
			for(int b=0, bEnd=bounds.size();b<bEnd;++b)
			{
				if(bounds[b].second=='f')
				{
					if(b)
					{
						for(;cIT!=allComments.end()&&cIT->first<bounds[b-1].first;++cIT);//cIT[-1]: last comment before function b start
						acIT=cIT;
						char state='a';
						for(int rk=bounds[b-1].first-1, rkEnd=acIT!=allComments.begin()?acIT[-1].second:-1, newStart=-1;;--rk)//header/whitespace before function
						{
							if(rk<rkEnd)//check counter
							{
								if(acIT!=allComments.begin())
								{
									state=rHeaderTable[state-'a'][' '];
									rk=acIT[-1].first-1;
									--acIT;
									rkEnd=acIT!=allComments.begin()?acIT[-1].second:-1;
								}
								else break;
							}
							else state=rHeaderTable[state-'a'][rk<0?'\0':text[rk]];
							if(state<'a')//check state
							{
								if(state<'`'||newStart!=-1)
								{
									if(state<'`')
										newStart=rk+'_'-state;
									if(newStart==0)
									{
										bounds.erase(bounds.begin(), bounds.begin()+b);
										bEnd-=b, b=0;
									}
									else
									{
										for(int rb2=b-1;rb2>=0;--rb2)
										{
											if(rb2==0||bounds[rb2-1].first<newStart)//prev bound rb2 start
											{
												if(rb2+1<b)
												{
													bounds.erase(bounds.begin()+rb2+1, bounds.begin()+b);
													bEnd-=b-(rb2+1), b=rb2+1;
												}
												break;
											}
										}
										bounds[b-1].first=newStart;
									}
								}
								break;
							}
							if(state=='m'&&newStart==-1)
								newStart=rk;
						}
					}
					if(b+1<bEnd)
					{
						for(;cIT!=allComments.end()&&cIT->first<bounds[b].first;++cIT);//cIT: first comment after function b end
						acIT=cIT;
						char state='a';
						for(int k=bounds[b].first, kEnd=acIT!=allComments.end()?acIT->first:textlen+1;;++k)//whitespace after function
						{
							if(k>=kEnd)
							{
								if(acIT!=allComments.end())
								{
									k=acIT->second;
									state=tailTable[state-'a'][' '];
									++acIT;
									kEnd=acIT!=allComments.end()?acIT->first:textlen+1;
								}
								else break;
							}
							else state=tailTable[state-'a'][text[k]];
							if(state<'a')
							{
								if(state<'`')
								{
									int newEnd=k+'_'-state;
									for(int b2=b+1;;++b2)
									{
										if(b2==bounds.size()||newEnd<=bounds[b2].first)//next bound end b+1
										{
											b2+=newEnd==bounds[b2].first;
											if(b+1<b2)
											{
												bounds.erase(bounds.begin()+b+1, bounds.begin()+b2);
												bEnd-=b2-(b+1);
											}
											bounds[b].first=newEnd;
											break;
										}
									}
								}
								break;
							}
						}
					}
				}
			}
		}
	}
	for(int b=0, bEnd=bounds.size(), e=0, func=0;b<bEnd;++b)//D: find change extent
	{
		if(bounds[b].first>i||bounds[b].first!=oldbounds[b].first)
		{
			boundChangeStart=b;
			exprChangeStart=e, functionChangeStart=func;
			if(b==bounds.size()||b==oldbounds.size()||bounds[b].second=='f')//recompile everything below when changing a function
		//	if(bounds[b].second=='f')
			{
				boundRemoveEnd=oldbounds.size(), boundInsertEnd=bounds.size();
				break;
			}
			int dk=fi-fr;
			bool diff_enc=bounds[b].first!=oldbounds[b].first+dk*(bounds[b].first>i), end_unas=true;
			if(!diff_enc)
				++b;
			for(int ob=b, oldBoundEnd=oldbounds.size();;)
			{
				if(b>=bEnd||ob>=oldBoundEnd)
				{
					if(diff_enc||end_unas)
						boundRemoveEnd=oldbounds.size(), boundInsertEnd=bEnd;
					else if(boundRemoveEnd==oldbounds.size())
						boundInsertEnd=bEnd;
					else if(boundInsertEnd==bEnd)
						boundRemoveEnd=oldbounds.size();
					break;
				}
				if(oldbounds[ob].second=='f'||bounds[b].second=='f')//recompile everything below when changing a function
				{
					boundRemoveEnd=oldbounds.size(), boundInsertEnd=bounds.size();
					break;
				}
				int obf=oldbounds[ob].first+dk*(oldbounds[ob].first>i);
				if(bounds[b].first<obf)
				{
					diff_enc=true;
					++b;
				}
				else if(bounds[b].first>obf)
				{
					diff_enc=true;
					++ob;
				}
				else
				{
					if(bounds[b].second!=oldbounds[ob].second)
					{
						if(b+1<bEnd&&ob+1<oldBoundEnd&&bounds[b+1].first==oldbounds[ob+1].first+dk&&bounds[b+1].second==oldbounds[ob+1].second&&fr<oldbounds[ob+1].first&&fi<bounds[b+1].first)//diff typ~, same>f
							boundRemoveEnd=ob+1, boundInsertEnd=b+1, diff_enc=false, end_unas=false;
						else
							diff_enc=true;//diff typ~
					}
					else if(diff_enc)//diff~, diff start~
						boundRemoveEnd=ob+1, boundInsertEnd=b+1, diff_enc=false, end_unas=false;
					else if(ob>0&&b>0&&oldbounds[ob-1].first>=fr&&bounds[b-1].first>=fi&&(ob==1||b==1||oldbounds[ob-2].first<fr||bounds[b-2].first<fi))
						boundRemoveEnd=ob, boundInsertEnd=b, diff_enc=false, end_unas=false;
					++b, ++ob;
				}
			}
			break;
		}
		if(bounds[b].second=='e')
			++e;
		else
			++func;
	}
	int b=boundChangeStart, e=exprChangeStart, func=functionChangeStart;//E: change in expr and functions
	for(;b<boundRemoveEnd;++b)
		e+=oldbounds[b].second&1, func+=(oldbounds[b].second&2)!=0;
/*	{
		if(oldbounds[b].second=='e')
			++e;
		else
			++func;
	}//*/
	exprRemoveEnd=e, functionRemoveEnd=func;
	b=boundChangeStart, e=exprChangeStart, func=functionChangeStart;
	for(;b<boundInsertEnd;++b)
	{
		if(bounds[b].second=='e')
			++e;
		else
			++func;
	}
	exprInsertEnd=e, functionInsertEnd=func;
}
void			InputTextBox::replaceText(int i, int f, char *a, int len)
{
	lineChangeStart=getLineNo(0, 0, i);
	lineRemoveEnd=getLineNo(i, lineChangeStart, f)+1;

	//remove
	if(i<f)
	{
		histlen=histpos+f-i, history=(int*)realloc(history, histlen*sizeof(int));
		for(int k=0;k<f-i;++k)				history[histpos+k]=(f-1-k)<<10|cont<<9|1<<8|text[f-1-k	], cont=1;
		for(int k=f;k<=textlen;++k)			text[k-f+i]=text[k];
		textlen-=f-i, histpos=histlen, cursor=selcur=i;
	}
	//insert
	text=(char*)realloc(text, (textlen+1+len)*sizeof(char));
	histlen=histpos+len, history=(int*)realloc(history, histlen*sizeof(int));
	for(int k=0;k<len;++k)				history[histpos+k]=(i+k	)<<10|cont<<9|0<<8|a	[k		], cont=1;
	for(int k=textlen;k>=cursor;--k)	text[k+len]=text[k];
	memcpy(&text[cursor], a, len*sizeof(char));
	textlen+=len, histpos=histlen, cursor=selcur=cursor+len;
	replaceText_update(i, f, i+len);

	lineInsertEnd=getLineNo(0, 0, i+len)+1;
}
void			InputTextBox::insertText(int o, char *a, int len)
{
	lineChangeStart=getLineNo(0, 0, o);
	lineRemoveEnd=lineChangeStart+1;

	text=(char*)realloc(text, (textlen+1+len)*sizeof(char));
	histlen=histpos+len, history=(int*)realloc(history, histlen*sizeof(int));
	for(int k=0;k<len;++k)				history[histpos+k]=(o+k	)<<10|cont<<9|0<<8|a	[k		], cont=1;//position, action continuity, insert, character
	for(int k=textlen;k>=cursor;--k)	text[k+len]=text[k];
	memcpy(&text[cursor], a, len*sizeof(char));
	textlen+=len, histpos=histlen, cursor=selcur=cursor+len;
	replaceText_update(o, o, o+len);

	lineInsertEnd=getLineNo(0, 0, o+len)+1;
}
void			InputTextBox::removeText(int i, int f)
{
	lineChangeStart=getLineNo(0, 0, i);
	lineRemoveEnd=getLineNo(i, lineChangeStart, f)+1;

	histlen=histpos+f-i, history=(int*)realloc(history, histlen*sizeof(int));
	for(int k=0;k<f-i;++k)				history[histpos+k]=(f-1-k)<<10|cont<<9|1<<8|text[f-1-k	], cont=1;//position, action continuity, remove, character
	for(int k=f;k<=textlen;++k)			text[k-f+i]=text[k];
	textlen-=f-i, histpos=histlen, cursor=selcur=i;
	text=(char*)realloc(text, (textlen+1)*sizeof(char));
	replaceText_update(i, f, i);

	lineInsertEnd=lineChangeStart+1;

}
int				InputTextBox::switchToWithMouseOn	(int lParam){cont=0;return TextBox::switchToWithMouseOn(lParam);}
int				InputTextBox::inputLButtonDown		(int lParam){cont=0;return TextBox::inputLButtonDown(lParam);}
int				InputTextBox::inputKeyDown(int wParam, int lParam)
{
	if(kb[VK_CONTROL])
	{
		switch(wParam)
		{
		case VK_CAPITAL:				return 0;
		case VK_NUMLOCK:				return 0;
		case VK_OEM_3:					return 0;
		case '1':						return 0;
		case '2':						return 0;
		case '3':						return 0;
		case '4':						return 0;
		case '5':						return 0;
		case '6':						return 0;
		case '7':						return 0;
		case '8':						return 0;
		case '9':						return 0;
		case '0':						return 0;
		case VK_OEM_MINUS:				return 0;
		case VK_OEM_PLUS:				return 0;
		case 'Q':						return 0;
		case 'W':						return 0;
		case 'E':						return 0;
		case 'R':						return 0;
		case 'T':						return 0;
		case 'Y':
			if(histpos<histlen)
			{
				int rStart, rEnd;
				int iStart, iEnd;
				bool remove, insert;
				{
					int ph=histpos;
					bool allowInsert=true;
					if(remove=(history[ph]&0x00000100)!=0)
					{
						rStart=history[ph]>>10&0x003FFFFF, rEnd=rStart+1;
						++ph;
						for(;ph<histlen&&history[ph]&0x00000200&&history[ph]&0x00000100;++ph)
						{
						//	int LOL_1=history[ph]>>10&0x003FFFFF;
							if((history[ph]>>10&0x003FFFFF)<rStart)
								--rStart;//backspace
							else
								++rEnd;//delete
						//	if((history[ph]>>10&0x003FFFFF)==rStart)
						//		++rEnd;//delete
						//	else
						//		--rStart;//backspace
						//	if(rStart<(history[ph]>>10&0x003FFFFF))//what?
						//		--rStart;//backspace
						//	else
						//		++rEnd;//delete
						}
						allowInsert=(history[ph]&0x00000200)!=0;
					}
					if(insert=allowInsert&&!(history[ph]&0x00000100))
					{
						iStart=history[ph]>>10&0x003FFFFF, iEnd=iStart+1;
						++ph;
						for(;ph<histlen&&history[ph]&0x00000200;++ph)
					//	for(;ph<histlen&&history[ph]&0x00000200&&!(history[ph]&0x00000100);++ph)
							++iEnd;
						if(!remove)
							rStart=rEnd=iStart;
					}
					else
						iStart=iEnd=rStart;
				}
				lineChangeStart=getLineNo(0, 0, iStart);
				if(remove)
				{
					lineRemoveEnd=getLineNo(iStart, lineChangeStart, rEnd)+1;
					for(int k=rStart, k2=rEnd;k2<=textlen;++k, ++k2)
						text[k]=text[k2];
					histpos+=rEnd-rStart;
					cursor=selcur=rStart;
				}
				else
					lineRemoveEnd=lineChangeStart+1;
				if(iEnd!=rEnd)
					textlen+=iEnd-rEnd, text=(char*)realloc(text, (textlen+1)*sizeof(char));
				if(insert)
				{
					for(int k=textlen-(iEnd-iStart), k2=textlen;k>=iStart;--k, --k2)
						text[k2]=text[k];
					for(int k=iStart;k<iEnd;++k, ++histpos)
						text[k]=char(history[histpos]);
					lineInsertEnd=getLineNo(0, 0, iEnd)+1;
					cursor=selcur=iEnd;
				}
				else
					lineInsertEnd=lineChangeStart+1;
				replaceText_update(iStart, rEnd, iEnd);
				cursorTeleport();
				cont=0;//
			}
		/*	removedExEnd=insertedExEnd=-1;
			removeText_update(0, textlen);
			for(;histpos<histlen;)
			{
				int k=history[histpos]>>10&0x003FFFFF;
				if(!(history[histpos]&0x00000100))
				{
					++textlen, text=(char*)realloc(text, (textlen+1)*sizeof(char)), cursor=selcur=k+1;
					for(int k2=textlen;k2>k;--k2)text[k2]=text[k2-1];
					text[k]=history[histpos]&0x000000FF;
				}
				else
				{
					for(int k2=k;k2<textlen;++k2)text[k2]=text[k2+1];
					--textlen, text=(char*)realloc(text, (textlen+1)*sizeof(char)), cursor=selcur=k;
				}
				++histpos;
				if(histpos<histlen)if(!(history[histpos]&0x00000200))break;
			}
			insertText_update(0, textlen);//*/
			return 2;
		case 'U':						return 0;
		case 'I':						return 0;
		case 'O':						return 0;
		case 'P':						return 0;
		case VK_OEM_4:					return 0;
		case VK_OEM_6:					return 0;
		case 'A':
			cursor=textlen;
			cursorTeleport();
			cont=0, selcur=0;
			return 1;
		case 'S':						return 0;
		case 'D':
			histpos=0, histlen=0, history=(int*)realloc(history, histlen*sizeof(int));
			return 0;
		case 'F':						return 0;
		case 'G':						return 0;
		case 'H':						return 0;
		case 'J':						return 0;
		case 'K':						return 0;
		case 'L':						return 0;
		case VK_OEM_1:					return 0;
		case VK_OEM_7:					return 0;
		case VK_OEM_5:case VK_OEM_102:	return 0;
		case 'Z':
			if(histpos>0)
			{
				int urStart, urEnd;
				int uiStart, uiEnd;
				bool undoInsert, undoRemove, backspace=true;
				{
					int ph=histpos-1;
					bool allowUndoRemove=true;
					if(undoInsert=!(history[ph]&0x00000100))//undo insert?
					{
						uiStart=history[ph]>>10&0x003FFFFF, uiEnd=uiStart+1;
						if(history[ph]&0x00000200)//continue?
						{
							for(;ph;)
							{
								--ph;
								if(history[ph]&0x00000100)//next undo remove?
									break;
								--uiStart;
								if(!(history[ph]&0x00000200))//stop?
								{
									allowUndoRemove=false;
									break;
								}
							}
						}
						else
							allowUndoRemove=false;
					}
					if(undoRemove=allowUndoRemove&&(history[ph]&0x00000100)!=0)//undo remove?
					{
						urStart=history[ph]>>10&0x003FFFFF, urEnd=urStart+1;
						for(;ph&&history[ph]&0x00000200;)//continue?
						{
							--ph;
							backspace=(history[ph]>>10&0x003FFFFF)>urStart;//undo moves to the right?
							++urEnd;
						}
						if(!undoInsert)
							uiStart=uiEnd=urStart;
					}
					else
						urStart=urEnd=uiStart;
				}
				lineChangeStart=getLineNo(0, 0, urStart);
				if(undoInsert)
				{
					lineRemoveEnd=getLineNo(urStart, lineChangeStart, uiEnd)+1;
					for(int k=uiStart, k2=uiEnd;k2<=textlen;++k, ++k2)
						text[k]=text[k2];
					histpos-=uiEnd-uiStart;
					cursor=selcur=uiStart;
				}
				else
					lineRemoveEnd=lineChangeStart+1;
				if(urEnd!=uiEnd)
					textlen+=urEnd-uiEnd, text=(char*)realloc(text, (textlen+1)*sizeof(char));
				if(undoRemove)
				{
					for(int k=textlen-(urEnd-urStart), k2=textlen;k>=urStart;--k, --k2)
						text[k2]=text[k];
					if(backspace)
					{
						for(int k=urStart;k<urEnd;++k)
						{
							--histpos;
							text[k]=char(history[histpos]);
						}
					}
					else
					{
						for(int k=urEnd-1;k>=urStart;--k)
						{
							--histpos;
							text[k]=char(history[histpos]);
						}
					}
					cursor=selcur=urEnd;
					lineInsertEnd=getLineNo(0, 0, urEnd)+1;
				}
				else
					lineInsertEnd=lineChangeStart+1;
				replaceText_update(urStart, uiEnd, urEnd);
				cursorTeleport();
				cont=0;//
			}
#if 0
			if(histpos>0)
			{
				int urStart, urEnd;
				int uiStart, uiEnd;
				bool undoRemove, undoInsert;
				{
					int ph=histpos-1;
					bool allowUndoRemove=true;
					if(undoInsert=!(history[ph]&0x00000100))//undo insert?
					{
						uiStart=history[ph]>>10&0x003FFFFF, uiEnd=uiStart+1;
						if(history[ph]&0x00000200)//continue?
					//	if(history[ph]&0x00000200&&!(history[ph]&0x00000100))
						{
							for(;ph;)
							{
								--ph;
								if(history[ph]&0x00000100)//next undo remove?
									break;
								--uiStart;
								if(!(history[ph]&0x00000200))//stop?
								{
									allowUndoRemove=false;
									break;
								}
							//	if(!(history[ph]&0x00000200))
							//		break;

							//	--ph;
							//	--uiStart;
							//	if(!(history[ph]&0x00000200)||history[ph]&0x00000100)
							//		break;
							}
						}
						else
							allowUndoRemove=false;
					//	allowUndoRemove=(history[ph]&0x00000200)!=0;
					}
					if(undoRemove=allowUndoRemove&&(history[ph]&0x00000100)!=0)//undo remove?
					{
						urStart=history[ph]>>10&0x003FFFFF, urEnd=urStart+1;
						for(;ph&&history[ph]&0x00000200;)//continue?
						{
							--ph;
							++urEnd;
						//	if((history[ph]>>10&0x003FFFFF)>urStart)//undo moves to the right?
						//		++urEnd;//undo backspace
						//	else//undo stays in place
						//		--urStart;//delete
						}
						if(!undoInsert)
							uiStart=uiEnd=urStart;
					}
					else
						urStart=urEnd=uiStart;//*/
				/*	if(undoRemove=allowUndoRemove&&(history[ph]&0x00000100)!=0)//undo remove?
					{
						urStart=history[ph]>>10&0x003FFFFF, urEnd=urStart+1;
						if(history[ph]&0x00000200&&history[ph]&0x00000100)//continue undo remove?
						{
							for(;ph;)
							{
								--ph;
								if(urStart<(history[ph]>>10&0x003FFFFF))
									++urEnd;//backspace
								else
									--urStart;//delete
								if(!(history[ph]&0x00000200))//continue?
							//	if(!(history[ph]&0x00000200)||!(history[ph]&0x00000100))
									break;
							}
						}
						if(!undoInsert)
							uiStart=uiEnd=urStart;
					}
					else
						urStart=urEnd=uiStart;//*/
				}
				lineChangeStart=getLineNo(0, 0, urStart);
				if(undoInsert)
					lineRemoveEnd=getLineNo(urStart, lineChangeStart, uiEnd)+1;
				else
					lineRemoveEnd=lineChangeStart+1;
				if(undoInsert)
				{
					for(int k=uiStart, k2=uiEnd;k2<=textlen;++k, ++k2)
						text[k]=text[k2];
					histpos-=uiEnd-uiStart;
					cursor=selcur=uiStart;
				}
				if(urEnd!=uiEnd)
					textlen+=urEnd-uiEnd, text=(char*)realloc(text, (textlen+1)*sizeof(char));
				if(undoRemove)
				{
					for(int k=textlen-(urEnd-urStart), k2=textlen;k>=urStart;--k, --k2)
				//	for(int k=oldTextLen, k2=textlen;k>=urStart;--k, --k2)
						text[k2]=text[k];
					for(int k=urStart;k<urEnd;++k)
					{
						--histpos;
						text[k]=char(history[histpos]);
					}
					cursor=selcur=urEnd;
				}
				lineRemoveEnd=getLineNo(0, 0, uiEnd);
				replaceText_update(urStart, uiEnd, urEnd);
				if(undoRemove)
					lineInsertEnd=getLineNo(0, 0, urEnd)+1;
				else
					lineInsertEnd=lineChangeStart+1;
			}
#endif
		/*	removedExEnd=insertedExEnd=-1;
			removeText_update(0, textlen);
			for(;histpos		;)
			{
				--histpos;
				int k=history[histpos]>>10&0x003FFFFF;
				if(history[histpos]&0x00000100)
				{
					++textlen, text=(char*)realloc(text, (textlen+1)*sizeof(char)), cursor=selcur=k+1;
					for(int k2=textlen;k2>k;--k2)text[k2]=text[k2-1];
					text[k]=history[histpos]&0x000000FF;
				}
				else
				{
					for(int k2=k;k2<textlen;++k2)text[k2]=text[k2+1];
					--textlen, text=(char*)realloc(text, (textlen+1)*sizeof(char)), cursor=selcur=k;
				}
				if(!(history[histpos]&0x00000200))break;
			}
			insertText_update(0, textlen);//*/
			return 2;
		case 'X':
		case 'C':
			if(cursor!=selcur)
			{
				int k=cursor<selcur?cursor:selcur, k2=cursor>selcur?cursor:selcur;
				char *clipboard=(char*)LocalAlloc(LMEM_FIXED, (k2-k+1)*sizeof(char));
				memcpy(clipboard, &text[k], (k2-k)*sizeof(char));
				clipboard[k2-k]='\0';
				OpenClipboard(ghWnd), EmptyClipboard(), SetClipboardData(CF_OEMTEXT, (void*)clipboard), CloseClipboard();
				if(wParam=='X')
				{
					removeText(k, k2);
					return 2;
				}
				if(wParam=='X')
					cursorTeleport();
			}
			return 0;
		case 'V':
			{
				OpenClipboard(ghWnd);
				char *clipboard=(char*)GetClipboardData(CF_OEMTEXT);	if(!clipboard				){CloseClipboard();break;}
				int size=strlen(clipboard);								if(size<=0||size>0x003FFFFF	){CloseClipboard();break;}
				char *a=(char*)malloc((size+1)*sizeof(char));
				memcpy(a, clipboard, (size+1)*sizeof(char)), CloseClipboard();
				for(int k=0;k<size;++k)
				{
					if(a[k]=='\r'&&a[k+1]!='\n')
					{
						++k, ++size, a=(char*)realloc(a, (size+1)*sizeof(char));
						for(int k2=size-1;k2>k;++k2)a[k2]=a[k2-1];	a[k]='\n';
					}
					else if(a[k]&0x80)//UNICODE UTF-8
					{
						free(a);
						return 0;
					}
					//	a[k]=' ';
					//	a[k]&=0x7F;
				}
				cont=0;
				replaceText(cursor<selcur?cursor:selcur, cursor>selcur?cursor:selcur, a, size);
				cursorTeleport();
				free(a);
				cont=0;//
			}
			return 2;
		case 'B':						return 0;
		case 'N':						return 0;
		case 'M':						return 0;
		case VK_OEM_COMMA:				return 0;
		case VK_OEM_PERIOD:				return 0;
		case VK_OEM_2:					return 0;
		case VK_SPACE:					return 0;
		case VK_NUMPAD0:				return 0;
		case VK_NUMPAD1:				return 0;
		case VK_NUMPAD2:				return 0;
		case VK_NUMPAD3:				return 0;
		case VK_NUMPAD4:				return 0;
		case VK_NUMPAD5:				return 0;
		case VK_NUMPAD6:				return 0;
		case VK_NUMPAD7:				return 0;
		case VK_NUMPAD8:				return 0;
		case VK_NUMPAD9:				return 0;
		case VK_DECIMAL:				return 0;
		case VK_ADD:					return 0;
		case VK_SUBTRACT:				return 0;
		case VK_MULTIPLY:				return 0;
		case VK_DIVIDE:					return 0;
		case VK_DELETE:					return 0;
		case VK_BACK:					return 0;
		case VK_RETURN:					return 0;
		case VK_UP:
			if(th>bh)
			{
				tpy=tpy-font.H<0?0:tpy-font.H;
				return 1;
			}
			return 0;
		case VK_DOWN:
			if(th>bh)
			{
				tpy=tpy+font.H>th-bh?th-bh:tpy+font.H;
				return 1;
			}
			return 0;
		case VK_LEFT:
			if(cursor)
			{
				char initial=mapChar(text[--cursor]);
				for(;cursor;--cursor)
					if(mapChar(text[cursor-1])!=initial)
						break;
				cont=0;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_RIGHT:
			if(cursor!=textlen)
			{
				char initial=mapChar(text[cursor++]);
				for(;cursor!=textlen;++cursor)
					if(mapChar(text[cursor])!=initial)
						break;
				cont=0;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_HOME:
			if(cursor)
			{
				cursor=0, cont=0;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_END:
			if(cursor!=textlen)
			{
				cursor=textlen, cont=0;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_ESCAPE:case VK_F1:case VK_F2:case VK_F3:case VK_F4:case VK_F5:case VK_F6:case VK_F7:case VK_F8:case VK_F9:case VK_F10:case VK_F11:case VK_F12:case VK_INSERT:	return 0;
		case VK_F13:case VK_F14:case VK_F15:case VK_F16:case VK_F17:case VK_F18:case VK_F19:case VK_F20:case VK_F21:case VK_F22:case VK_F23:case VK_F24:						return 0;
		case VK_TAB:					return 0;
		case VK_SHIFT:					return 0;
		case VK_CONTROL:case VK_LWIN:	return 0;
		case VK_PRIOR:case VK_NEXT:		return 0;
		default:						return 0;
		}
	}
	else
	{
		char character=caps_lock!=kb[VK_SHIFT];
	//	char character=-(caps_lock!=kb[VK_SHIFT]);
	//	char character=caps_lock&&!kb[VK_SHIFT]||!caps_lock&&kb[VK_SHIFT]?-1:0;
		switch(wParam)
		{
		case VK_CAPITAL:				return 0;
		case VK_NUMLOCK:				return 0;
		case VK_OEM_3:					character=kb[VK_SHIFT]	?'~':	'`'	;	break;
		case '0':						character=kb[VK_SHIFT]	?')':	'0'	;	break;
		case '1':						character=kb[VK_SHIFT]	?'!':	'1'	;	break;
		case '2':						character=kb[VK_SHIFT]	?'@':	'2'	;	break;
		case '3':						character=kb[VK_SHIFT]	?'#':	'3'	;	break;
		case '4':						character=kb[VK_SHIFT]	?'$':	'4'	;	break;
		case '5':						character=kb[VK_SHIFT]	?'%':	'5'	;	break;
		case '6':						character=kb[VK_SHIFT]	?'^':	'6'	;	break;
		case '7':						character=kb[VK_SHIFT]	?'&':	'7'	;	break;
		case '8':						character=kb[VK_SHIFT]	?'*':	'8'	;	break;
		case '9':						character=kb[VK_SHIFT]	?'(':	'9'	;	break;
		case VK_OEM_MINUS:				character=kb[VK_SHIFT]	?'_':	'-'	;	break;
		case VK_OEM_PLUS:				character=kb[VK_SHIFT]	?'+':	'='	;	break;
		case VK_TAB:					character=						'\t';	break;
		case 'Q':						character=character		?'Q':	'q'	;	break;
		case 'W':						character=character		?'W':	'w'	;	break;
		case 'E':						character=character		?'E':	'e'	;	break;
		case 'R':						character=character		?'R':	'r'	;	break;
		case 'T':						character=character		?'T':	't'	;	break;
		case 'Y':						character=character		?'Y':	'y'	;	break;
		case 'U':						character=character		?'U':	'u'	;	break;
		case 'I':						character=character		?'I':	'i'	;	break;
		case 'O':						character=character		?'O':	'o'	;	break;
		case 'P':						character=character		?'P':	'p'	;	break;
		case VK_OEM_4:					character=kb[VK_SHIFT]	?'{':	'['	;	break;
		case VK_OEM_6:					character=kb[VK_SHIFT]	?'}':	']'	;	break;
		case 'A':						character=character		?'A':	'a'	;	break;
		case 'S':						character=character		?'S':	's'	;	break;
		case 'D':						character=character		?'D':	'd'	;	break;
		case 'F':						character=character		?'F':	'f'	;	break;
		case 'G':						character=character		?'G':	'g'	;	break;
		case 'H':						character=character		?'H':	'h'	;	break;
		case 'J':						character=character		?'J':	'j'	;	break;
		case 'K':						character=character		?'K':	'k'	;	break;
		case 'L':						character=character		?'L':	'l'	;	break;
		case VK_OEM_1:					character=kb[VK_SHIFT]	?':':	';'	;	break;
		case VK_OEM_7:					character=kb[VK_SHIFT]	?'"':	'\'';	break;
		case VK_OEM_5:case VK_OEM_102:	character=kb[VK_SHIFT]	?'|':	'\\';	break;
		case 'Z':						character=character		?'Z':	'z'	;	break;
		case 'X':						character=character		?'X':	'x'	;	break;
		case 'C':						character=character		?'C':	'c'	;	break;
		case 'V':						character=character		?'V':	'v'	;	break;
		case 'B':						character=character		?'B':	'b'	;	break;
		case 'N':						character=character		?'N':	'n'	;	break;
		case 'M':						character=character		?'M':	'm'	;	break;
		case VK_OEM_COMMA:				character=kb[VK_SHIFT]	?'<':	','	;	break;
		case VK_OEM_PERIOD:				character=kb[VK_SHIFT]	?'>':	'.'	;	break;
		case VK_OEM_2:					character=kb[VK_SHIFT]	?'?':	'/'	;	break;
		case VK_SPACE:					character=						' '	;	break;
		case VK_NUMPAD0:				character=						'0'	;	break;
		case VK_NUMPAD1:				character=						'1'	;	break;
		case VK_NUMPAD2:				character=						'2'	;	break;
		case VK_NUMPAD3:				character=						'3'	;	break;
		case VK_NUMPAD4:				character=						'4'	;	break;
		case VK_NUMPAD5:				character=						'5'	;	break;
		case VK_NUMPAD6:				character=						'6'	;	break;
		case VK_NUMPAD7:				character=						'7'	;	break;
		case VK_NUMPAD8:				character=						'8'	;	break;
		case VK_NUMPAD9:				character=						'9'	;	break;
		case VK_DECIMAL:				character=						'.'	;	break;
		case VK_ADD:					character=						'+'	;	break;
		case VK_SUBTRACT:				character=						'-'	;	break;
		case VK_MULTIPLY:				character=						'*'	;	break;
		case VK_DIVIDE:					character=						'/'	;	break;
		case VK_DELETE:
			if(cursor!=selcur)
			{
				cont=0;
				removeText(cursor<selcur?cursor:selcur, cursor>selcur?cursor:selcur);
				cursorTeleport();
				return 2;
			}
			else if(text[cursor])
			{
				cont=0;
				removeText(cursor, cursor+1+(text[cursor]=='\r'));
				cursorTeleport();
				return 2;
			}
			return 0;
		case VK_BACK:
			if(cursor!=selcur)
			{
				cont=0;
				removeText(cursor<selcur?cursor:selcur, cursor>selcur?cursor:selcur);
				cursorTeleport();
				return 2;
			}
			else if(cursor)
			{
				cont=0;
				removeText(cursor-(text[cursor-1]=='\n'?2:1), cursor);
				cursorTeleport();
				return 2;
			}
			return 0;
		case VK_RETURN:					character=						'\r';	break;
		case VK_UP:
			for(int k=cursor-2;k>=0;--k)
			{
				if(text[k]=='\r')
				{
					font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
					int x=font.getTextW(text, k+2, cursor), x2=0;
					for(;;--k)
						if(!k||text[k-1]=='\n')
							break;
					for(int k2=k;;++k2)
					{
						if(text[k2]=='\r')
						{
							cursor=k2;
							break;
						}
						int tx2;
						if(text[k2]=='\t')
							tx2=font.getTextW(text, k, k2+1);
						else
							tx2=x2+font.W[text[k2]];
						if(tx2>x)
						{
							cursor=tx2-(tx2-x2)/2>x?k2:k2+1;
							break;
						}
						x2=tx2;
					}
					font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
					cursorTeleport();
					cont=0;
					return 1;
				}
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_DOWN:
			for(int k=cursor;k<textlen;++k)
			{
				if(text[k]=='\n')
				{
					font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
					int k2=cursor;
					for(;k2>0;--k2)
						if(text[k2-1]=='\n')
							break;
					int x=font.getTextW(text, k2, cursor), x2=0;
					for(int k2=++k;;++k2)
					{
						if(text[k2]=='\r'||k2==textlen)
						{
							cursor=k2;
							break;
						}
						int tx2;
						if(text[k2]=='\t')
							tx2=font.getTextW(text, k, k2+1);
						else
							tx2=x2+font.W[text[k2]];
						if(tx2>x)
						{
							cursor=tx2-(tx2-x2)/2>x?k2:k2+1;
							break;
						}
						x2=tx2;
					}
					font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
					cursorTeleport();
					cont=0;
					return 1;
				}
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_LEFT:
			if(cursor)
			{
				cursor-=text[cursor-1]=='\n'?2:1, cont=0;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_RIGHT:
			if(text[cursor])
			{
				cursor+=text[cursor]=='\r'?2:1, cont=0;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_HOME:
			if(cursor&&text[cursor-1]!='\n')
			{
				for(;;--cursor)
					if(!cursor||text[cursor-1]=='\n')
					{
						cont=0;
						break;
					}
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_END:
			if(text[cursor]!='\r'&&text[cursor])
			{
				for(;;++cursor)
					if(text[cursor]=='\r'||!text[cursor])
					{
						cont=0;
						break;
					}
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_ESCAPE:case VK_F1:case VK_F2:case VK_F3:case VK_F4:case VK_F5:case VK_F6:case VK_F7:case VK_F8:case VK_F9:case VK_F10:case VK_F11:case VK_F12:case VK_INSERT:	return 0;
		case VK_F13:case VK_F14:case VK_F15:case VK_F16:case VK_F17:case VK_F18:case VK_F19:case VK_F20:case VK_F21:case VK_F22:case VK_F23:case VK_F24:						return 0;
		case VK_SHIFT:					return 0;
		case VK_CONTROL:case VK_LWIN:	return 0;
		case VK_PRIOR:case VK_NEXT:		return 0;
		default:						return 0;
		}
		if(character>0)
		{
			int start, end;
			if(cursor<selcur)
				start=cursor, end=selcur;
			else
				start=selcur, end=cursor;
			if(character!='\r')
				replaceText(start, end, &character, 1), cont=1;
			else
				replaceText(start, end, "\r\n", 2), cont=0;
		//	toTeleportCursor=true;
			cursorTeleport();
			return 2;
		}
	}
	return 0;
}
void			InputTextBox::draw()
{
	int xc, yc;
	SelectClipRgn(ghMemDC, hRgn);
	tw=th=0;
	int bkMode=GetBkMode(ghMemDC), bkColor=GetBkColor(ghMemDC);
//	SetBkMode(ghMemDC, TRANSPARENT);
	int const selectColor=active?0xFFFF96:0x969696, errorColor=0x0000FF, selectErrorColor=active?0x7F7FCA:0x4B4BCA;
//	int const selectColor=active?0xFFFF96:0x969696, errorColor=0x7F7FFF, selectErrorColor=active?0xBFBFCA:0x8A8ACA;
/*	unsigned char errorBkR=0xFF, errorBkG=0x7F, errorBkB=0x7F;
//	unsigned char errorBkR=0xFF, errorBkG=0, errorBkB=0;
	unsigned char selectionBkR, selectionBkG, selectionBkB;
	if(active)
		selectionBkR=0x96, selectionBkG=0xFF, selectionBkB=0xFF;
	else
		selectionBkR=0x96, selectionBkG=0x96, selectionBkB=0x96;//*/
	{
		bool firstBoundFunction=bounds.size()&&bounds[0].second=='f';
		Expression *it=firstBoundFunction?&userFunctionDefinitions[0]:&expr[0];
	//	Expression *it=bounds.size()?bounds[0].second=='f'?&userFunctionDefinitions[0]:&expr[0]:nullptr;
		unsigned kSE=0;
		int k, k2;
		if(cursor<selcur)
			k=cursor, k2=selcur;
		else
			k=selcur, k2=cursor;
		bool inError=false;
		for(int k3=0, k4=0, x=0, y=0, b=0, bEnd=bounds.size(), e=-int(firstBoundFunction), func=int(firstBoundFunction)-1;k4<=textlen;++k4)
		{
			if(k4==bounds[b].first)
			{
				++b;
				if(b<bEnd)
				{
					if(bounds[b].second=='e')
					{
						++e;
						it=&expr[e];
					}
					else
					{
						++func;
						it=&userFunctionDefinitions[func];
					}
					kSE=0;
				}
			}
			if(kSE<it->syntaxErrors.size())
			{
				if(k4==it->syntaxErrors[kSE].first)//red text
				{
				//	if(k3<k4)
				//	{
						x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
						k3=k4;
				//	}//*/
				//	if(k4==cursor)
				//		xc=x, yc=y;
					if(k4>k&&k4<k2)//has been in selection: average color
						SetBkColor(ghMemDC, selectErrorColor);
					else
						SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, errorColor);
				//	SetBkMode(ghMemDC, OPAQUE);
				//	SetBkColor(ghMemDC, k4>k&&k4<k2?selectErrorColor:errorColor);
				/*	int bg=GetBkColor(ghMemDC);
					auto pbg=(unsigned char*)&bg;
					SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, (pbg[2]+errorBkB)/2<<16|(pbg[1]+errorBkG)/2<<8|(pbg[0]+errorBkR)/2);//*/
				//	SetBkColor(ghMemDC, ((bg>>16)+0)/2<<16|(unsigned char(bg>>8)+0)/2<<8|(unsigned char(bg)+0)/2<<16);
				//	SetTextColor(ghMemDC, 0x0000FF);
					inError=true;
				}
				if(k4==it->syntaxErrors[kSE].second)//black text
				{
				//	k4+=it->syntaxErrors[kSE].first==it->syntaxErrors[kSE].second&&text[it->syntaxErrors[kSE].second]!='\r';
					x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
					k3=k4;
					++kSE;
					if(kSE>=it->syntaxErrors.size()||k4!=it->syntaxErrors[kSE].first)
					{
						if(k4>k&&k4<k2)//has been in selection
							SetBkColor(ghMemDC, selectColor);
						else
							SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
					/*	int bg=GetBkColor(ghMemDC);
						auto pbg=(unsigned char*)&bg;
						SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, (2*pbg[2]-errorBkB)<<16|(2*pbg[1]-errorBkG)<<8|(2*pbg[0]-errorBkR));//*/
					//	SetTextColor(ghMemDC, 0);
						inError=false;
					}
				}
			}
			if(k4==k)
			{
				if(k3<k4)
				{
					x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
					k3=k4;
				}
				if(k4==cursor)
					xc=x, yc=y;
				if(inError)
					SetBkColor(ghMemDC, selectErrorColor);
				else
					SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, selectColor);
			/*	int bg=GetBkColor(ghMemDC);
				auto pbg=(unsigned char*)&bg;
				SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, (pbg[2]+selectionBkB)/2<<16|(pbg[1]+selectionBkG)/2<<8|(pbg[0]+selectionBkR)/2);//*/
			//	SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, active?0x00FFFF96:0x00969696);
			}
			if(k4==k2)
			{
				if(k3<k4)
				{
					x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
					k3=k4;
				}
				if(k4==cursor)
					xc=x, yc=y;
				if(inError)
					SetBkColor(ghMemDC, errorColor);
				else
					SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
			/*	int bg=GetBkColor(ghMemDC);
				auto pbg=(unsigned char*)&bg;
				SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, (2*pbg[2]-selectionBkB)<<16|(2*pbg[1]-selectionBkG)<<8|(2*pbg[0]-selectionBkR));//*/
			//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
			//	SetBkMode(ghMemDC, TRANSPARENT);
			}
			if(text[k4]=='\r'||k4==textlen)
			{
			/*	if(bounds[b].second=='e'&&inError)//expr: new line stops error (bad fix)
				{
					if(k4>k&&k4<k2)//has been in selection
						SetBkColor(ghMemDC, selectColor);
					else
						SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
					inError=false;
				}//*/
				if(k3<k4)
					x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				if(x>tw)
					tw=x;
				k3=k4+2, x=0, th+=font.H, y+=font.H;
			}
		}
	}//*/
/*	{
		int x=0, y=0;
		int selStart, selEnd;
		if(cursor<selcur)
			selStart=cursor, selEnd=selcur;
		else
			selStart=selcur, selEnd=cursor;
		bool selection=selStart<selEnd;
		for(int bound=0, kStart=0, e=0, lineStart=0, k=0, nBounds=bounds.size();bound<nBounds;++bound)
		{
			bool exprBound=bounds[bound].second=='e';
			k=kStart;
			for(int kEnd=bounds[bound].first;;++k)
			{
				if(k==selStart)
				{
					if(lineStart<k)
					{
						x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[lineStart], k-lineStart, 0, 0, bpx-tpx));
						lineStart=k;
					}
					if(k==cursor)
						xc=x, yc=y;
					SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, active?0x00FFFF96:0x00969696);
				}
				if(k==selEnd)
				{
					if(lineStart<k)
					{
						x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[lineStart], k-lineStart, 0, 0, bpx-tpx));
						lineStart=k;
					}
					if(k==cursor)
						xc=x, yc=y;
					SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
				}
				if(text[k]=='\r')
				{
					if(lineStart<k)
					{
						x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[lineStart], k-lineStart, 0, 0, bpx-tpx));
						lineStart=k;
					}
					if(x>tw)
						tw=x;
				//	lineStart=k+(text[k+1]=='\n')+1, x=0;
				}
				if(k==kEnd)
				{
					if(lineStart<k)
						x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[lineStart], k-lineStart, 0, 0, bpx-tpx));
					lineStart=k+(text[k+1]=='\n')+1, x=0;
					break;
				}
			}
		}
	}//*/
	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
//	if(toTeleportCursor)
//		cursorTeleport();
	if(active)
		MoveToEx(ghMemDC, bpx+xc-tpx, bpy+yc-tpy, 0), LineTo(ghMemDC, bpx+xc-tpx, bpy+yc-tpy+font.H);
	if(tw>bw&&th>bh)
	{
		int xi=bpx+17+int(double(bw-51)*tpx/tw), xf=bpx+17+int(double(bw-51)*(tpx+bw)/tw), yi=bpy+17+int(double(bh-51)*tpy/th), yf=bpy+17+int(double(bh-51)*(tpy+bh)/th);
		MoveToEx(ghMemDC, bpx		, bpy+bh-17	, 0), LineTo(ghMemDC, bpx+bw	, bpy+bh-17	);
		MoveToEx(ghMemDC, bpx+17	, bpy+bh-17	, 0), LineTo(ghMemDC, bpx+17	, bpy+bh	);
		MoveToEx(ghMemDC, xi		, bpy+bh-17	, 0), LineTo(ghMemDC, xi		, bpy+bh	);
		MoveToEx(ghMemDC, xf		, bpy+bh-17	, 0), LineTo(ghMemDC, xf		, bpy+bh	);
		MoveToEx(ghMemDC, bpx+bw-34	, bpy+bh-17	, 0), LineTo(ghMemDC, bpx+bw-34	, bpy+bh	);
		MoveToEx(ghMemDC, bpx+bw-17	, bpy		, 0), LineTo(ghMemDC, bpx+bw-17	, bpy+bh	);
		MoveToEx(ghMemDC, bpx+bw-17	, bpy+17	, 0), LineTo(ghMemDC, bpx+bw	, bpy+17	);
		MoveToEx(ghMemDC, bpx+bw-17	, yi		, 0), LineTo(ghMemDC, bpx+bw	, yi		);
		MoveToEx(ghMemDC, bpx+bw-17	, yf		, 0), LineTo(ghMemDC, bpx+bw	, yf		);
		MoveToEx(ghMemDC, bpx+bw-17	, bpy+bh-34	, 0), LineTo(ghMemDC, bpx+bw	, bpy+bh-34	);
	}
	else if(tw>bw)
	{
		tpy=0;
		int xi=bpx+17+int(double(bw-34)*tpx/tw), xf=bpx+17+int(double(bw-34)*(tpx+bw)/tw);
		MoveToEx(ghMemDC, bpx		, bpy+bh-17, 0), LineTo(ghMemDC, bpx+bw		, bpy+bh-17	);
		MoveToEx(ghMemDC, bpx+17	, bpy+bh-17, 0), LineTo(ghMemDC, bpx+17		, bpy+bh	);
		MoveToEx(ghMemDC, xi		, bpy+bh-17, 0), LineTo(ghMemDC, xi			, bpy+bh	);
		MoveToEx(ghMemDC, xf		, bpy+bh-17, 0), LineTo(ghMemDC, xf			, bpy+bh	);
		MoveToEx(ghMemDC, bpx+bw-17	, bpy+bh-17, 0), LineTo(ghMemDC, bpx+bw-17	, bpy+bh	);
	}
	else if(th>bh)
	{	
		tpx=0;
		int yi=bpy+17+int(double(bh-34)*tpy/th), yf=bpy+17+int(double(bh-34)*(tpy+bh)/th);
		MoveToEx(ghMemDC, bpx+bw-17, bpy		, 0), LineTo(ghMemDC, bpx+bw-17	, bpy+bh	);
		MoveToEx(ghMemDC, bpx+bw-17, bpy+17		, 0), LineTo(ghMemDC, bpx+bw	, bpy+17	);
		MoveToEx(ghMemDC, bpx+bw-17, yi			, 0), LineTo(ghMemDC, bpx+bw	, yi		);
		MoveToEx(ghMemDC, bpx+bw-17, yf			, 0), LineTo(ghMemDC, bpx+bw	, yf		);
		MoveToEx(ghMemDC, bpx+bw-17, bpy+bh-17	, 0), LineTo(ghMemDC, bpx+bw	, bpy+bh-17	);
	}
	else
		tpx=tpy=0;
	SelectClipRgn(ghMemDC, 0);
}
void			InputTextBox::draw_color(std::set<int>const &modes)
{
	int xc, yc;
	SelectClipRgn(ghMemDC, hRgn);
	tw=th=0;
	int bkMode=GetBkMode(ghMemDC), bkColor=GetBkColor(ghMemDC), txtColor=GetTextColor(ghMemDC), line=0;
//	SetBkMode(ghMemDC, TRANSPARENT);
	int const selectColor=active?0xFFFF96:0x969696, errorColor=0x0000FF, selectErrorColor=active?0x7F7FCA:0x4B4BCA;
//	int const selectColor=active?0xFFFF96:0x969696, errorColor=0x7F7FFF, selectErrorColor=active?0xBFBFCA:0x8A8ACA;
/*	unsigned char errorBkR=0xFF, errorBkG=0x7F, errorBkB=0x7F;
//	unsigned char errorBkR=0xFF, errorBkG=0, errorBkB=0;
	unsigned char selectionBkR, selectionBkG, selectionBkB;
	if(active)
		selectionBkR=0x96, selectionBkG=0xFF, selectionBkB=0xFF;
	else
		selectionBkR=0x96, selectionBkG=0x96, selectionBkB=0x96;//*/
	{
		int x=0, y=0;
		int selStart, selEnd;
		if(cursor<selcur)
			selStart=cursor, selEnd=selcur;
		else
			selStart=selcur, selEnd=cursor;
		bool selection=selStart<selEnd;
		bool inError=false;
		for(int bound=0, nBounds=bounds.size(), e=0, func=0, textoutStart=0, k=0;bound<nBounds;++bound)
	//	for(int bound=0, nBounds=bounds.size(), e=0, textoutStart=0, k=0;bound<nBounds;++bound)
		{
			bool exprBound=bounds[bound].second=='e';
			Expression *it=exprBound?&expr[e]:&userFunctionDefinitions[func];
			unsigned kSE=0;
			SetTextColor(ghMemDC, exprBound&&modes.find(expr[e].rmode[0])!=modes.end()?expr[e].winColor:txtColor);
			for(int kEnd=bounds[bound].first;;++k)
			{
				if(kSE<it->syntaxErrors.size())
				{
					if(k==it->syntaxErrors[kSE].first)//red text
					{
						if(textoutStart<k)
						{
							x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[textoutStart], k-textoutStart, 0, 0, bpx-tpx));
							textoutStart=k;
							if(x>tw)
								tw=x;
						}
						if(k>selStart&&k<selEnd)//has been in selection: average color
							SetBkColor(ghMemDC, selectErrorColor);
						else
							SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, errorColor);
					/*	int bg=GetBkColor(ghMemDC);
						auto pbg=(unsigned char*)&bg;
						SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, (pbg[2]+errorBkB)/2<<16|(pbg[1]+errorBkG)/2<<8|(pbg[0]+errorBkR)/2);//*/
					//	SetBkColor(ghMemDC, ((bg>>16)+0)/2<<16|(unsigned char(bg>>8)+0)/2<<8|(unsigned char(bg)+0)/2<<16);
					//	SetTextColor(ghMemDC, 0x0000FF);
						inError=true;
					}
					else if(k==it->syntaxErrors[kSE].second)//black text
					{
						if(textoutStart<k)
						{
							x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[textoutStart], k-textoutStart, 0, 0, bpx-tpx));
							textoutStart=k;
							if(x>tw)
								tw=x;
						}
						++kSE;
						if(kSE>=it->syntaxErrors.size()||k!=it->syntaxErrors[kSE].first)
						{
							if(k>selStart&&k<selEnd)//has been in selection
								SetBkColor(ghMemDC, selectColor);
							else
								SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
						/*	int bg=GetBkColor(ghMemDC);
							auto pbg=(unsigned char*)&bg;
							SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, (2*pbg[2]-errorBkB)<<16|(2*pbg[1]-errorBkG)<<8|(2*pbg[0]-errorBkR));//*/
						//	SetTextColor(ghMemDC, 0);
							inError=false;
						}
					}
				}
				if(k==selStart)
				{
					if(textoutStart<k)
					{
						x+=(short)TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[textoutStart], k-textoutStart, 0, 0, bpx-tpx);
						textoutStart=k;
						if(x>tw)
							tw=x;
					}
					if(k==cursor)
						xc=x, yc=y;
					if(inError)
						SetBkColor(ghMemDC, selectErrorColor);
					else
						SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, selectColor);
				/*	int bg=GetBkColor(ghMemDC);
					auto pbg=(unsigned char*)&bg;
					SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, (pbg[2]+selectionBkB)/2<<16|(pbg[1]+selectionBkG)/2<<8|(pbg[0]+selectionBkR)/2);//*/
				//	SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, active?0x00FFFF96:0x00969696);
				}
				if(k==selEnd)
				{
					if(textoutStart<k)
					{
						x+=(short)TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, text+textoutStart, k-textoutStart, 0, 0, bpx-tpx);
						textoutStart=k;
						if(x>tw)
							tw=x;
					}
					if(k==cursor)
						xc=x, yc=y;
					if(inError)
						SetBkColor(ghMemDC, errorColor);
					else
						SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
				/*	int bg=GetBkColor(ghMemDC);
					auto pbg=(unsigned char*)&bg;
					SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, (2*pbg[2]-selectionBkB)<<16|(2*pbg[1]-selectionBkG)<<8|(2*pbg[0]-selectionBkR));//*/
				//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
				}
				if(text[k]=='\r')
				{
					if(textoutStart<k)
					{
						x+=(short)TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, text+textoutStart, k-textoutStart, 0, 0, bpx-tpx);
						textoutStart=k;
						if(x>tw)
							tw=x;
					}
					k+=text[k+1]=='\n';
					x=0, th+=font.H, y+=font.H;
					if(k+1==kEnd)
					{
						++k;
						textoutStart=k;
						break;
					}
				//	textoutStart=k+(text[k+1]=='\n')+1, x=0, th+=font.H, y+=font.H;
				}
				if(k==kEnd)
				{
					if(textoutStart<k)
					{
						x+=(short)TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, text+textoutStart, k-textoutStart, 0, 0, bpx-tpx);
						textoutStart=k;
						if(x>tw)
							tw=x;
					}
				//	textoutStart=k+(text[k+1]=='\n')+1;//, x=0;
					break;
				}
			}
			e+=exprBound;
		}
	}//*/
/*	{
		int x=0, y=0;
		int selStart, selEnd;
		if(cursor<selcur)
			selStart=cursor, selEnd=selcur;
		else
			selStart=selcur, selEnd=cursor;
		bool selection=selStart<selEnd;
		for(int bound=0, nBounds=bounds.size(), e=0, textoutStart=0, k=0;bound<nBounds;++bound)
		{
			bool exprBound=bounds[bound].second=='e';
			SetTextColor(ghMemDC, exprBound&&modes.find(expr[e].rmode[0])!=modes.end()?expr[e].winColor:txtColor);
			for(int kEnd=bounds[bound].first;;++k)
			{
				if(k==selStart)
				{
					if(textoutStart<k)
					{
						x+=(short)TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[textoutStart], k-textoutStart, 0, 0, bpx-tpx);
						textoutStart=k;
						if(x>tw)
							tw=x;
					}
					if(k==cursor)
						xc=x, yc=y;
					SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, active?0x00FFFF96:0x00969696);
				}
				if(k==selEnd)
				{
					if(textoutStart<k)
					{
						x+=(short)TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, text+textoutStart, k-textoutStart, 0, 0, bpx-tpx);
						textoutStart=k;
						if(x>tw)
							tw=x;
					}
					if(k==cursor)
						xc=x, yc=y;
					SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
				}
				if(text[k]=='\r')
				{
					if(textoutStart<k)
					{
						x+=(short)TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, text+textoutStart, k-textoutStart, 0, 0, bpx-tpx);
						textoutStart=k;
						if(x>tw)
							tw=x;
					}
					k+=text[k+1]=='\n';
					x=0, th+=font.H, y+=font.H;
					if(k+1==kEnd)
					{
						++k;
						textoutStart=k;
						break;
					}
				//	textoutStart=k+(text[k+1]=='\n')+1, x=0, th+=font.H, y+=font.H;
				}
				if(k==kEnd)
				{
					if(textoutStart<k)
					{
						x+=(short)TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, text+textoutStart, k-textoutStart, 0, 0, bpx-tpx);
						textoutStart=k;
						if(x>tw)
							tw=x;
					}
				//	textoutStart=k+(text[k+1]=='\n')+1;//, x=0;
					break;
				}
			}
			e+=exprBound;
		}
	}//*/
/*	auto exprIT=expr.begin();
	SetTextColor(ghMemDC, modes.find(exprIT->rmode[0])!=modes.end()?exprIT->winColor:txtColor);
	for(int k=cursor<selcur?cursor:selcur, k2=cursor>selcur?cursor:selcur, k3=0, k4=0, x=0, y=0;k4<=textlen;++k4)
	{
		if(k4==k)
		{
			x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
			k3=k4;
			if(k4==cursor)
				xc=x, yc=y;
			SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, active?0x00FFFF96:0x00969696);
		}
		if(k4==k2)
		{
			x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
			k3=k4;
			if(k4==cursor)
				xc=x, yc=y;
			SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
		//	SetBkMode(ghMemDC, TRANSPARENT);
		}
		if(text[k4]=='\r')
		{
			x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
			if(x>tw)
				tw=x;
			k3=k4+2, x=0, th+=font.H, y+=font.H;
			if(k4==0||text[k4-1]!='\\')
				++exprIT, SetTextColor(ghMemDC, modes.find(exprIT->rmode[0])!=modes.end()?exprIT->winColor:txtColor);
		}
		else if(k4==textlen)
		{
			x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
			if(x>tw)
				tw=x;
			k3=k4+2, x=0, th+=font.H, y+=font.H;
		}
	}//*/
	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor), SetTextColor(ghMemDC, txtColor);
	if(active)
		MoveToEx(ghMemDC, bpx+xc-tpx, bpy+yc-tpy, 0), LineTo(ghMemDC, bpx+xc-tpx, bpy+yc-tpy+font.H);
	if(tw>bw&&th>bh)
	{
		int xi=bpx+17+int(double(bw-51)*tpx/tw), xf=bpx+17+int(double(bw-51)*(tpx+bw)/tw), yi=bpy+17+int(double(bh-51)*tpy/th), yf=bpy+17+int(double(bh-51)*(tpy+bh)/th);
		MoveToEx(ghMemDC, bpx		, bpy+bh-17	, 0), LineTo(ghMemDC, bpx+bw	, bpy+bh-17	);
		MoveToEx(ghMemDC, bpx+17	, bpy+bh-17	, 0), LineTo(ghMemDC, bpx+17	, bpy+bh	);
		MoveToEx(ghMemDC, xi		, bpy+bh-17	, 0), LineTo(ghMemDC, xi		, bpy+bh	);
		MoveToEx(ghMemDC, xf		, bpy+bh-17	, 0), LineTo(ghMemDC, xf		, bpy+bh	);
		MoveToEx(ghMemDC, bpx+bw-34	, bpy+bh-17	, 0), LineTo(ghMemDC, bpx+bw-34	, bpy+bh	);
		MoveToEx(ghMemDC, bpx+bw-17	, bpy		, 0), LineTo(ghMemDC, bpx+bw-17	, bpy+bh	);
		MoveToEx(ghMemDC, bpx+bw-17	, bpy+17	, 0), LineTo(ghMemDC, bpx+bw	, bpy+17	);
		MoveToEx(ghMemDC, bpx+bw-17	, yi		, 0), LineTo(ghMemDC, bpx+bw	, yi		);
		MoveToEx(ghMemDC, bpx+bw-17	, yf		, 0), LineTo(ghMemDC, bpx+bw	, yf		);
		MoveToEx(ghMemDC, bpx+bw-17	, bpy+bh-34	, 0), LineTo(ghMemDC, bpx+bw	, bpy+bh-34	);
	}
	else if(tw>bw)
	{
		tpy=0;
		int xi=bpx+17+int(double(bw-34)*tpx/tw), xf=bpx+17+int(double(bw-34)*(tpx+bw)/tw);
		MoveToEx(ghMemDC, bpx		, bpy+bh-17, 0), LineTo(ghMemDC, bpx+bw		, bpy+bh-17	);
		MoveToEx(ghMemDC, bpx+17	, bpy+bh-17, 0), LineTo(ghMemDC, bpx+17		, bpy+bh	);
		MoveToEx(ghMemDC, xi		, bpy+bh-17, 0), LineTo(ghMemDC, xi			, bpy+bh	);
		MoveToEx(ghMemDC, xf		, bpy+bh-17, 0), LineTo(ghMemDC, xf			, bpy+bh	);
		MoveToEx(ghMemDC, bpx+bw-17	, bpy+bh-17, 0), LineTo(ghMemDC, bpx+bw-17	, bpy+bh	);
	}
	else if(th>bh)
	{	
		tpx=0;
		int yi=bpy+17+int(double(bh-34)*tpy/th), yf=bpy+17+int(double(bh-34)*(tpy+bh)/th);
		MoveToEx(ghMemDC, bpx+bw-17, bpy		, 0), LineTo(ghMemDC, bpx+bw-17	, bpy+bh	);
		MoveToEx(ghMemDC, bpx+bw-17, bpy+17		, 0), LineTo(ghMemDC, bpx+bw	, bpy+17	);
		MoveToEx(ghMemDC, bpx+bw-17, yi			, 0), LineTo(ghMemDC, bpx+bw	, yi		);
		MoveToEx(ghMemDC, bpx+bw-17, yf			, 0), LineTo(ghMemDC, bpx+bw	, yf		);
		MoveToEx(ghMemDC, bpx+bw-17, bpy+bh-17	, 0), LineTo(ghMemDC, bpx+bw	, bpy+bh-17	);
	}
	else
		tpx=tpy=0;
	SelectClipRgn(ghMemDC, 0);
}
namespace	G2
{
	bool _2d_between(double x1, double y1, double x, double y, double x2, double y2)
	{
		if(x1==x2)
		{
			if(x==x1)
			{
				if(y1==y2)
					return x==x1&&y==y1;
				else
					return y1<y2?y1<=y&&y<=y2:y2<=y&&y<=y1;
			}
		}
		else
		{
			if(y1==y2)
			{
				if(y==y1)
					return x1<x2?x1<=x&&x<=x2:x2<=x&&x<=x1;
			}
			else if(x==x1)
				return y==y1;
			else if(x==x2)
				return y==y2;
			else if(y==y1)
				return x==x1;
			else if(y==y2)
				return x==x2;
			else if((y2-y1)*(x-x1)==(x2-x1)*(y-y1))
			{
				if(x1<x2)
				{
					if(x1<=x&&x<=x2)
						return y1<y2?y1<=y&&y<=y2:y2<=y&&y<=y1;
				}
				else
				{
					if(x2<=x&&x<=x1)
						return y1<y2?y1<=y&&y<=y2:y2<=y&&y<=y1;
				}
			}
		}
		return false;
	}
	bool _1d_int_in_range(double x0, double x1){return std::floor(x0)!=std::floor(x1)||std::ceil(x0)!=std::ceil(x1);}
	bool _1d_zero_in_range(double x0, double x1){return x0<0?x1>=0:x0==0?x1<0||x1>0:x1<0;}
	double _1d_zero_crossing(double x0, double y0, double x1, double y1){return x0+(0-y0)*(x1-x0)/(y1-y0);}
	const double ll_max=9.22337203685478e+018;
	inline long long convert_d2ll		(double const x){return x!=x||x<-ll_max||x>ll_max?(long long&)x	:(long long)x;}
	inline long long convert_d2ll_zero	(double const x){return x!=x||x<-ll_max||x>ll_max?0				:(long long)x;}

	std::complex<double>			floor					(std::complex<double>				const &x){return std::complex<double>(::floor(x.real()), ::floor(x.imag()));}
	boost::math::quaternion<double>	floor					(boost::math::quaternion<double>	const &x){return boost::math::quaternion<double>(::floor(x.R_component_1()), ::floor(x.R_component_2()), ::floor(x.R_component_3()), ::floor(x.R_component_4()));}
	double							arg						(boost::math::quaternion<double>	const &x){return ::acos(x.R_component_1()/boost::math::abs(x));}
	boost::math::quaternion<double>	log						(boost::math::quaternion<double>	const &x)
	{
		try
		{
			double t=boost::math::abs(boost::math::quaternion<double>(0, x.R_component_2(), x.R_component_3(), x.R_component_4()));
			if(t)
			{
				t=arg(x)/t;
				return boost::math::quaternion<double>(boost::math::log1p(abs(x)-1), t*x.R_component_2(), t*x.R_component_3(), t*x.R_component_4());
			}
			if(x.R_component_1()!=0)
				return boost::math::quaternion<double>(boost::math::log1p(abs(x)-1), 0, 0, 0);
			return boost::math::quaternion<double>(-_HUGE);
		}
		catch(std::overflow_error&)
		{
			return boost::math::quaternion<double>(-_HUGE);
		}
	}
	boost::math::quaternion<double>	pow						(boost::math::quaternion<double>	const &x, boost::math::quaternion<double>	const &y){return boost::math::exp(y*log(x));}
	boost::math::quaternion<double>	pow						(double								const &x, boost::math::quaternion<double>	const &y){return boost::math::exp(y*std::log(std::complex<double>(x)));}
	double							bitwise_xor				(double								const &x)
	{
		long long t1=convert_d2ll(x);
	//	const double ll_max=9.22337203685478e+018;
	//	long long t1=x!=x||x<-ll_max||x>ll_max?(long long&)x:(long long)x;

		//const double ll_max=9.22337203685478e+018;
		//if(x!=x||x<-ll_max||x>ll_max)
		//	return _qnan;
		//long long t1=(long long)x;//high truncation		breaks font & TabbedTextOut

		//long long t1=(long long&)x;

		t1^=t1>>32, t1^=t1>>16, t1^=t1>>8, t1^=t1>>4;
		t1&=15;
		return (0x6996>>t1)&1;
	//	return 0;
	}
	double							bitwise_xnor			(double								const &x)
	{
		long long t1=convert_d2ll(x);
		t1^=t1>>32, t1^=t1>>16, t1^=t1>>8, t1^=t1>>4;
		t1&=15;
		return ~((0x6996>>t1)&1);
	}

	double							sgn						(double								const &x){return (x>0)-(x<0);}
	std::complex<double>			sgn						(std::complex<double>				const &x)
	{
		double temp=std::abs(x);
		return temp?x/temp:std::complex<double>();
	}
	boost::math::quaternion<double>	sgn						(boost::math::quaternion<double>	const &x)
	{
		double q2=abs(x);
		if(q2!=0)
			return x/q2;
		return boost::math::quaternion<double>();
	}
	boost::math::quaternion<double>	sgnu					(boost::math::quaternion<double>	const &x){return sgn(boost::math::quaternion<double>(0, x.R_component_2(), x.R_component_3(), x.R_component_4()));}
	namespace gamma//http://en.wikipedia.org/wiki/Lanczos_approximation
	{
		const double g=7, p[]={0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7};
	}
	double							tgamma					(double								const &x)
	{
		try
		{
			return boost::math::tgamma(x);
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	std::complex<double>			tgamma					(std::complex<double>				const &x)
	{
		using namespace gamma;
		if(x.real()<.5)
		{
			std::complex<double> t1(p[0]);
			for(int k=1;k<g+2;++k)
				t1+=p[k]/(double(k)-x);
			std::complex<double> t2=g+.5-x;
			return _pi/(sin(_pi*x)*::sqrt(2*_pi)*std::pow(t2, .5-x)*std::exp(-t2)*t1);
		}
		else
		{
			std::complex<double> t1(p[0]);
			for(int k=1;k<g+2;++k)
				t1+=p[k]/(double(k)+x-1.);
			std::complex<double> t2=g+.5+x-1.;
			return ::sqrt(2*_pi)*std::pow(t2, .5+x-1.)*std::exp(-t2)*t1;
		}
	/*	if(x.real()<.5)
			return _pi/(sin(_pi*x)*tgamma(1.-x));
		else
		{
			std::complex<double> t1(p[0]);
			for(int k=1;k<g+2;++k)
				t1+=p[k]/(x-1.+double(k));
			std::complex<double> t2=x-1.+g+.5;
			return ::sqrt(2*_pi)*std::pow(t2, x-1.+.5)*std::exp(-t2)*t1;
		}*/
	}
	boost::math::quaternion<double>	tgamma					(boost::math::quaternion<double>	const &x)
	{
		using namespace gamma;
		if(x.real()<.5)
		{
			boost::math::quaternion<double> t1(p[0]);
			for(int k=1;k<g+2;++k)
				t1+=p[k]/(double(k)-x);
			boost::math::quaternion<double> t2=g+.5-x;
			return _pi/(sin(_pi*x)*::sqrt(2*_pi)*pow(t2, .5-x)*exp(-t2)*t1);
		}
		else
		{
			boost::math::quaternion<double> t1(p[0]);
			for(int k=1;k<g+2;++k)
				t1+=p[k]/(double(k)+x-1.);
			boost::math::quaternion<double> t2=g+.5+x-1.;
			return ::sqrt(2*_pi)*pow(t2, .5+x-1.)*exp(-t2)*t1;
		}
	}
	boost::math::quaternion<double>	sqrt					(boost::math::quaternion<double>	const &x){return exp(0.5*log(x));}
	boost::math::quaternion<double>	acosh					(boost::math::quaternion<double>	const &x){return log(x+sqrt(x*x-1.));}
	boost::math::quaternion<double>	asinh					(boost::math::quaternion<double>	const &x){return log(x+sqrt(x*x+1.));}
	boost::math::quaternion<double>	atanh					(boost::math::quaternion<double>	const &x){return (log(1.+x)-log(1.-x))/2.;}
	boost::math::quaternion<double>	acos					(boost::math::quaternion<double>	const &x){return -sgnu(x)*acosh(x);}
	boost::math::quaternion<double>	asin					(boost::math::quaternion<double>	const &x)
	{
		boost::math::quaternion<double> q2=sgnu(x);
		return -q2*asinh(x*q2);
	}
	boost::math::quaternion<double>	atan					(boost::math::quaternion<double>	const &x)
	{
		boost::math::quaternion<double> q2=sgnu(x);
		return -q2*atanh(x*q2);
	}
	double							step					(double								const &x){return .5+.5*sgn(x);}
	std::complex<double>			step					(std::complex<double>				const &x){return .5+.5*sgn(x);}
	boost::math::quaternion<double>	step					(boost::math::quaternion<double>	const &x){return .5+.5*sgn(x);}
	
	char  returns_rcq		(char optype){return optype;}
	char  returns_rrr		(char optype){return 'r';}
	char  returns_ccc		(char optype){return 'c';}
	char  returns_ccq		(char optype)
	{
		switch(optype)
		{
		case 'r':return 'c';
		case 'c':return 'c';
		case 'H':return 'H';
		}
		return 0;
	}
	char  returns_rXX		(char optype)
	{
		switch(optype)
		{
		case 'r':return 'r';


		}
		return 0;
	}
	char  returns_cXX		(char optype)
	{
		switch(optype)
		{
		case 'r':return 'r';


		}
		return 0;
	}
	char  returns_ccq_ccq_qqq(char op1type, char op2type)
	{
		switch(op1type)
		{
		case 'r':switch(op2type){case 'r':return 'c';	case 'c':return 'c';	case 'H':return 'H';}break;
		case 'c':switch(op2type){case 'r':return 'c';	case 'c':return 'c';	case 'H':return 'H';}break;
		case 'H':switch(op2type){case 'r':return 'H';	case 'c':return 'H';	case 'H':return 'H';}break;
		}
		return 0;
	}
	char  returns_rrr_rrr_rrr(char op1type, char op2type){return 'r';}
	char  returns_ccX_ccX_qXX(char op1type, char op2type)
//	char  returns_ccq_ccX_XXX(char op1type, char op2type)
	{
		switch(op1type)
		{
		case 'r':switch(op2type){case 'r':return 'c';	case 'c':return 'c';						}break;
		case 'c':switch(op2type){case 'r':return 'c';	case 'c':return 'c';						}break;
		case 'H':switch(op2type){case 'r':return 'H';												}break;
		}
		return 0;
	}
	char  returns_rXX_rXX_XXX(char op1type, char op2type)
//	char  returns_rrX_XXX_XXX(char op1type, char op2type)
	{
		switch(op1type)
		{
		case 'r':switch(op2type){case 'r':return 'r';												}break;
		case 'c':switch(op2type){case 'r':return 'r';												}break;
		case 'H':																					break;
		}
		return 0;
	}
	char  returns_rXX_XXX_XXX(char op1type, char op2type)
	{
		switch(op1type)
		{
		case 'r':switch(op2type){case 'r':return 'r';												}break;
		case 'c':																					break;
		case 'H':																					break;
		}
		return 0;
	}
	char  returns_cXX_XXX_XXX(char op1type, char op2type)
	{
		switch(op1type)
		{
		case 'r':switch(op2type){case 'r':return 'c';												}break;
		case 'c':																					break;
		case 'H':																					break;
		}
		return 0;
	}
	char  returns_rcq_ccq_qqq(char op1type, char op2type)
	{
		switch(op1type)
		{
		case 'r':switch(op2type){case 'r':return 'r';	case 'c':return 'c';	case 'H':return 'H';}break;
		case 'c':switch(op2type){case 'r':return 'c';	case 'c':return 'c';	case 'H':return 'H';}break;
		case 'H':switch(op2type){case 'r':return 'H';	case 'c':return 'H';	case 'H':return 'H';}break;
		}
		return 0;
	}
	char  returns_rrr_ccc_qqq(char op1type, char op2type){return op1type;}
	char  returns_rcq_rcq_rcq(char op1type, char op2type){return op2type;}
	char  returns_conditional(char op1type, char op2type, char op3type)
	{
		switch(op1type)
		{
		case 'r':
			switch(op2type)
			{
			case 'r':switch(op3type){case 'r':return 'r';	case 'c':return 'c';	case 'H':return 'H';}break;
			case 'c':switch(op3type){case 'r':return 'c';	case 'c':return 'c';	case 'H':return 'H';}break;
			case 'H':switch(op3type){case 'r':return 'H';	case 'c':return 'H';	case 'H':return 'H';}break;
			}
			break;
		case 'c':
			switch(op2type)
			{
			case 'r':switch(op3type){case 'r':return 'c';	case 'c':return 'c';	case 'H':return 'H';}break;
			case 'c':switch(op3type){case 'r':return 'c';	case 'c':return 'c';	case 'H':return 'H';}break;
			case 'H':switch(op3type){case 'r':return 'H';	case 'c':return 'H';	case 'H':return 'H';}break;
			}
			break;
		case 'H':
			switch(op2type)
			{
			case 'r':switch(op3type){case 'r':return 'H';	case 'c':return 'H';	case 'H':return 'H';}break;
			case 'c':switch(op3type){case 'r':return 'H';	case 'c':return 'H';	case 'H':return 'H';}break;
			case 'H':switch(op3type){case 'r':return 'H';	case 'c':return 'H';	case 'H':return 'H';}break;
			}
			break;
		}
		return 0;
	}

	Value  r_ceil					(Value const &x)				{return Value(::ceil((double)x));}
	Value  c_ceil					(Value const &x)				{return Value(::ceil(x.r), ::ceil(x.i));}
	Value  q_ceil					(Value const &x)				{return Value(::ceil(x.r), ::ceil(x.i), ::ceil(x.j), ::ceil(x.k));}
	bool disc_r_ceil_o				(Value const &o0, Value const &o1){return o0.r!=o1.r;}
	bool disc_c_ceil_o				(Value const &o0, Value const &o1){return o0.r!=o1.r||o0.i!=o1.i;}
	bool disc_q_ceil_o				(Value const &o0, Value const &o1){return o0.r!=o1.r||o0.i!=o1.i||o0.j!=o1.j||o0.k!=o1.k;}
	void d2r_r_ceil					(Value &x0, Value &x1)
	{
		double ceil_x0=std::ceil(x0.r), ceil_x1=std::ceil(x1.r);
		x0.r=ceil_x0<ceil_x1?ceil_x0:ceil_x1;
		x1.r=ceil_x0>ceil_x1?ceil_x0:ceil_x1;
	}

	Value  r_floor					(Value const &x)				{return Value(::floor((double)x));}
	Value  c_floor					(Value const &x)				{return Value(::floor(x.r), ::floor(x.i));}
	Value  q_floor					(Value const &x)				{return Value(::floor(x.r), ::floor(x.i), ::floor(x.j), ::floor(x.k));}
	auto disc_r_floor_o				=disc_r_ceil_o;
	auto disc_c_floor_o				=disc_c_ceil_o;
	auto disc_q_floor_o				=disc_q_ceil_o;

	Value  r_round					(Value const &x)				{return Value(::round((double)x));}
	Value  c_round					(Value const &x)				{return Value(::round(x.r), ::round(x.i));}
	Value  q_round					(Value const &x)				{return Value(::round(x.r), ::round(x.i), ::round(x.j), ::round(x.k));}
	auto  disc_r_round_o			=disc_r_ceil_o;
	auto  disc_c_round_o			=disc_c_ceil_o;
	auto  disc_q_round_o			=disc_q_ceil_o;

	Value  r_abs					(Value const &x)				{return ::abs(x);}
	Value  c_abs					(Value const &x)				{return std::abs((std::complex<double>)x);}
	Value  q_abs					(Value const &x)				{return boost::math::abs((boost::math::quaternion<double>)x);}
	
	Value  r_arg					(Value const &x)				{return x.r?_pi*std::signbit(x.r):_qnan;}//x.r<0?_pi:x.r>0?0:_qnan
	Value  c_arg					(Value const &x)				{return x.r||x.i?std::arg((std::complex<double>)x):_qnan;}//return x.r!=0||x.i!=0?std::arg((std::complex<double>)x):_qnan;
	Value  q_arg					(Value const &x)				{return ::acos(x.r/boost::math::abs((boost::math::quaternion<double>)x));}
	bool  disc_r_arg_i				(Value const &x0, Value const &x1){return x0.r<0?x1.r>=0:x0.r>0?x1.r<=0:x1.r!=0;}//return std::signbit(x0.r)!=std::signbit(x1.r);
	bool  disc_c_arg_i				(Value const &x0, Value const &x1)
	{
		if(x0.r<0)
		{
			if(x0.i<0)
			{
				if(x1.r<0)	return x1.i>=0;
				if(x1.r>0)	return x1.i>0&&x0.r+(0-x0.i)*(x1.r-x0.r)/(x1.i-x0.i)<=0;
							return x1.i>=0;
			}
			else if(x0.i>0)
			{
				if(x1.r<0)	return x1.i<0;
				if(x1.r>0)	return x1.i<0&&x0.r+(0-x0.r)*(x1.r-x0.r)/(x1.i-x1.i)<=0;
							return x1.i<=0;
			}
			else
			{
				if(x1.r<0)	return x1.i<0;
				if(x1.r>0)	return x1.i<=0;
							return x1.i<=0;
			}
		}
		else if(x0.r>0)
		{
			if(x0.i<0)
			{
				if(x1.r<0)	return x1.i>=0&&(x1.i==0||x0.r+(0-x0.r)*(x1.r-x0.r)/(x1.i-x1.i)<=0);
				if(x1.r>0)	return false;
							return x1.i==0;
			}
			else if(x0.i>0)
			{
				if(x1.r<0)	return x1.i<0&&x0.r+(0-x0.r)*(x1.r-x0.r)/(x1.i-x1.i)<=0;
				if(x1.r>0)	return false;
							return x1.i==0;
			}
			else
			{
				if(x1.r<0)	return x1.i==0;
				if(x1.r>0)	return false;
							return x1.i==0;
			}
		}
		else
		{
			if(x0.i<0)
			{
				if(x1.r<0)	return x1.i>=0;
				if(x1.r>0)	return false;
							return x1.i>=0;
			}
			else if(x0.i>0)
			{
				if(x1.r<0)	return x1.i<0;
				if(x1.r>0)	return false;
							return x1.i<=0;
			}
							return true;
		}
	}
	bool  disc_q_arg_i				(Value const &x0, Value const &x1){return false;}//

	Value  c_real					(Value const &x)				{return x.r;}

	Value  c_imag					(Value const &x)				{return x.i;}

	Value  r_conjugate				(Value const &x)				{return x.r;}
	Value  c_conjugate				(Value const &x)				{return std::complex<double>(x.r, -x.i);}
	Value  q_conjugate				(Value const &x)				{return boost::math::quaternion<double>(x.r, -x.i, -x.j, -x.k);}

	Value  r_polar					(Value const &x)				{return std::complex<double>(::abs(x.r), x.r>0?0:x.r<0?_pi:_qnan);}
	Value  c_polar					(Value const &x)
	{
		std::complex<double> cx=x;
		return std::complex<double>(std::abs(cx), x.r!=0||x.i!=0?std::arg(cx):_qnan);
	}
	Value  q_polar					(Value const &x)
	{
		double r=boost::math::abs((boost::math::quaternion<double>)x);//LOL_abs*exp(LOL_I*LOL_theta)		LOL_abs=sqrt(RR+II+JJ+KK)		LOL_I=(Ii+Jj+Kk)/sqrt(II+JJ+KK)		LOL_theta=acos(R/LOL_abs)		http://visualphysics.org/preprints/QMN1009.2352
		return std::complex<double>(r, ::acos(x.r/r));
	//	double rx=x.r, ix=x.i, jx=x.j, kx=x.k,
	//		rx2=rx*rx, rx2ix2=rx2+ix*ix, rx2ix2jx2=rx2ix2+jx*jx;
	//	return boost::math::quaternion<double>(::sqrt(rx2ix2jx2+kx*kx), ::atan2(ix, rx), ::atan2(jx, ::sqrt(rx2ix2)), ::atan2(kx, ::sqrt(rx2ix2jx2)));
	}
	auto disc_r_polar_i				=disc_r_arg_i;
	auto disc_c_polar_i				=disc_c_arg_i;
	auto disc_q_polar_i				=disc_q_arg_i;

	Value  r_cartesian				(Value const &x)				{return x.r;}
	Value  c_cartesian				(Value const &x)				{return std::complex<double>(x.r*::cos(x.i), x.r*::sin(x.i));}
	Value  q_cartesian				(Value const &x)
	{
		double cjx=::cos(x.j), ckx=::cos(x.k);
		return boost::math::quaternion<double>(x.r*::cos(x.i)*cjx*ckx, x.r*::sin(x.i)*cjx*ckx, x.r*::sin(x.j)*ckx, x.r*::sin(x.k));//
	}

	Value rr_plus					(Value const &x, Value const &y){return x+y;}
	Value rc_plus					(Value const &x, Value const &y){return (double)x+(std::complex<double>)y;}
	Value rq_plus					(Value const &x, Value const &y){return (double)x+(boost::math::quaternion<double>)y;}
	Value cr_plus					(Value const &x, Value const &y){return (std::complex<double>)x+(double)y;}
	Value cc_plus					(Value const &x, Value const &y){return (std::complex<double>)x+(std::complex<double>)y;}
	Value cq_plus					(Value const &x, Value const &y){return (std::complex<double>)x+(boost::math::quaternion<double>)y;}
	Value qr_plus					(Value const &x, Value const &y){return (boost::math::quaternion<double>)x+(double)y;}
	Value qc_plus					(Value const &x, Value const &y){return (boost::math::quaternion<double>)x+(std::complex<double>)y;}
	Value qq_plus					(Value const &x, Value const &y){return (boost::math::quaternion<double>)x+(boost::math::quaternion<double>)y;}

	Value  r_minus					(Value const &x)				{return -x;}
	Value  c_minus					(Value const &x)				{return -(std::complex<double>)x;}
	Value  q_minus					(Value const &x)				{return -(boost::math::quaternion<double>)x;}
	Value rr_minus					(Value const &x, Value const &y){return x-y;}
	Value rc_minus					(Value const &x, Value const &y){return (double)x-(std::complex<double>)y;}
	Value rq_minus					(Value const &x, Value const &y){return (double)x-(boost::math::quaternion<double>)y;}
	Value cr_minus					(Value const &x, Value const &y){return (std::complex<double>)x-(double)y;}
	Value cc_minus					(Value const &x, Value const &y){return (std::complex<double>)x-(std::complex<double>)y;}
	Value cq_minus					(Value const &x, Value const &y){return (std::complex<double>)x-(boost::math::quaternion<double>)y;}
	Value qr_minus					(Value const &x, Value const &y){return (boost::math::quaternion<double>)x-(double)y;}
	Value qc_minus					(Value const &x, Value const &y){return (boost::math::quaternion<double>)x-(std::complex<double>)y;}
	Value qq_minus					(Value const &x, Value const &y){return (boost::math::quaternion<double>)x-(boost::math::quaternion<double>)y;}

	Value rr_multiply				(Value const &x, Value const &y){return x*y;}
	Value rc_multiply				(Value const &x, Value const &y){return (double)x*(std::complex<double>)y;}
	Value rq_multiply				(Value const &x, Value const &y){return (double)x*(boost::math::quaternion<double>)y;}
	Value cr_multiply				(Value const &x, Value const &y){return (std::complex<double>)x*(double)y;}
	Value cc_multiply				(Value const &x, Value const &y){return (std::complex<double>)x*(std::complex<double>)y;}
	Value cq_multiply				(Value const &x, Value const &y){return (std::complex<double>)x*(boost::math::quaternion<double>)y;}
	Value qr_multiply				(Value const &x, Value const &y){return (boost::math::quaternion<double>)x*(double)y;}
	Value qc_multiply				(Value const &x, Value const &y){return (boost::math::quaternion<double>)x*(std::complex<double>)y;}
	Value qq_multiply				(Value const &x, Value const &y){return (boost::math::quaternion<double>)x*(boost::math::quaternion<double>)y;}

	Value  r_divide					(Value const &x)				{return 1/x;}
	Value  c_divide					(Value const &x)				{return 1./(std::complex<double>)x;}
	Value  q_divide					(Value const &x)				{return 1./(boost::math::quaternion<double>)x;}
	Value rr_divide					(Value const &x, Value const &y){return x/y;}
	Value rc_divide					(Value const &x, Value const &y){return (double)x/(std::complex<double>)y;}
	Value rq_divide					(Value const &x, Value const &y){return (double)x/(boost::math::quaternion<double>)y;}
	Value cr_divide					(Value const &x, Value const &y){return (std::complex<double>)x/(double)y;}
	Value cc_divide					(Value const &x, Value const &y){return (std::complex<double>)x/(std::complex<double>)y;}
	Value cq_divide					(Value const &x, Value const &y){return (std::complex<double>)x/(boost::math::quaternion<double>)y;}
	Value qr_divide					(Value const &x, Value const &y){return (boost::math::quaternion<double>)x/(double)y;}
	Value qc_divide					(Value const &x, Value const &y){return (boost::math::quaternion<double>)x/(std::complex<double>)y;}
	Value qq_divide					(Value const &x, Value const &y){return (boost::math::quaternion<double>)x/(boost::math::quaternion<double>)y;}
	auto disc_r_divide_i			=disc_r_arg_i;
	bool disc_c_divide_i			(Value const &x0, Value const &x1)
	{
		double const pole[2]={0, 0};
		if(x0.r<0)
		{
			if(x0.i<0)
			{
				if(x1.r<0)	return false;
				if(x1.r>0)	return _2d_between(x0.r, x0.i, pole[0], pole[1], x1.r, x1.i);
							return x1.i==0;
			}
			if(x0.i>0)
			{
				if(x1.r<0)	return false;
				if(x1.r>0)	return _2d_between(x0.r, x0.i, pole[0], pole[1], x1.r, x1.i);
							return x1.i==0;
			}
			{
				if(x1.r<0)	return false;
				if(x1.r>0)	return x1.i==0;
							return true;
			}
		}
		if(x0.r>0)
		{
			if(x0.i<0)
			{
				if(x1.r<0)	return _2d_between(x0.r, x0.i, pole[0], pole[1], x1.r, x1.i);
				if(x1.r>0)	return false;
							return x1.i==0;
			}
			if(x0.i>0)
			{
				if(x1.r<0)	return _2d_between(x0.r, x0.i, pole[0], pole[1], x1.r, x1.i);
				if(x1.r>0)	return false;
							return x1.i==0;
			}
			{
				if(x1.r<0)	return x1.i==0;
				if(x1.r>0)	return false;
							return true;
			}
		}
		{
			if(x0.i<0)
			{
				if(x1.r<0)	return false;
				if(x1.r>0)	return false;
							return x1.i>=0;
			}
			if(x0.i>0)
			{
				if(x1.r<0)	return false;
				if(x1.r>0)	return false;
							return x1.i<=0;
			}
			{
							return true;
			}
		}
	}
	bool disc_q_divide_i			(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_r_divide_i(y0, y1);}
	bool disc_rc_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_c_divide_i(y0, y1);}
	bool disc_rq_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_q_divide_i(y0, y1);}
	bool disc_cr_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_r_divide_i(y0, y1);}
	bool disc_cc_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_c_divide_i(y0, y1);}
	bool disc_cq_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_q_divide_i(y0, y1);}
	bool disc_qr_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_r_divide_i(y0, y1);}
	bool disc_qc_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_c_divide_i(y0, y1);}
	bool disc_qq_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_q_divide_i(y0, y1);}
	
	Value rr_logic_divides			(Value const &x, Value const &y)
	{
		if(x.r_isTrue())
		{
			double r=y.r/x.r;
			return Value(r==std::floor(r));
		}
		return false;
	}
	Value rc_logic_divides			(Value const &x, Value const &y)
	{
		if(x.r_isTrue())
		{
			auto r=(std::complex<double>)y/x.r;
			return Value(r.real()==std::floor(r.real())&&r.imag()==std::floor(r.imag()));
		}
		return false;
	}
	Value rq_logic_divides			(Value const &x, Value const &y)
	{
		if(x.r_isTrue())
		{
			auto r=(boost::math::quaternion<double>)y/x.r;
			return Value(r.R_component_1()==std::floor(r.R_component_1())&&r.R_component_2()==std::floor(r.R_component_2())&&r.R_component_3()==std::floor(r.R_component_3())&&r.R_component_4()==std::floor(r.R_component_4()));
		}
		return false;
	}
	Value cr_logic_divides			(Value const &x, Value const &y)
	{
		if(x.c_isTrue())
		{
			auto r=y.r/(std::complex<double>)x;
			return Value(r.real()==std::floor(r.real())&&r.imag()==std::floor(r.imag()));
		}
		return false;
	}
	Value cc_logic_divides			(Value const &x, Value const &y)
	{
		if(x.c_isTrue())
		{
			auto r=(std::complex<double>)y/(std::complex<double>)x;
			return Value(r.real()==std::floor(r.real())&&r.imag()==std::floor(r.imag()));
		}
		return false;
	}
	Value cq_logic_divides			(Value const &x, Value const &y)
	{
		if(x.c_isTrue())
		{
			auto r=(boost::math::quaternion<double>)y/(std::complex<double>)x;
			return Value(r.R_component_1()==std::floor(r.R_component_1())&&r.R_component_2()==std::floor(r.R_component_2())&&r.R_component_3()==std::floor(r.R_component_3())&&r.R_component_4()==std::floor(r.R_component_4()));
		}
		return false;
	}
	Value qr_logic_divides			(Value const &x, Value const &y)
	{
		if(x.q_isTrue())
		{
			auto r=y.r/(boost::math::quaternion<double>)x;
			return Value(r.R_component_1()==std::floor(r.R_component_1())&&r.R_component_2()==std::floor(r.R_component_2())&&r.R_component_3()==std::floor(r.R_component_3())&&r.R_component_4()==std::floor(r.R_component_4()));
		}
		return false;
	}
	Value qc_logic_divides			(Value const &x, Value const &y)
	{
		if(x.q_isTrue())
		{
			auto r=(std::complex<double>)y/(boost::math::quaternion<double>)x;
			return Value(r.R_component_1()==std::floor(r.R_component_1())&&r.R_component_2()==std::floor(r.R_component_2())&&r.R_component_3()==std::floor(r.R_component_3())&&r.R_component_4()==std::floor(r.R_component_4()));
		}
		return false;
	}
	Value qq_logic_divides			(Value const &x, Value const &y)
	{
		if(x.q_isTrue())
		{
			auto r=(boost::math::quaternion<double>)y/(boost::math::quaternion<double>)x;
			return Value(r.R_component_1()==std::floor(r.R_component_1())&&r.R_component_2()==std::floor(r.R_component_2())&&r.R_component_3()==std::floor(r.R_component_3())&&r.R_component_4()==std::floor(r.R_component_4()));
		}
		return false;
	}

	Value cr_pow					(Value const &x, Value const &y){return std::pow((std::complex<double>)x, (double)y);}
	Value cc_pow					(Value const &x, Value const &y){return std::pow((std::complex<double>)x, (std::complex<double>)y);}
	Value cq_pow					(Value const &x, Value const &y){return exp((boost::math::quaternion<double>)y*std::log((std::complex<double>)x));}
	Value qr_pow					(Value const &x, Value const &y){return exp((double)y*log((boost::math::quaternion<double>)x));}
	Value qc_pow					(Value const &x, Value const &y){return exp((std::complex<double>)y*log((boost::math::quaternion<double>)x));}
	Value qq_pow					(Value const &x, Value const &y){return pow((boost::math::quaternion<double>)x, (boost::math::quaternion<double>)x);}
	bool disc_cr_pow_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1)
	{//pole: y<0: x.r<=0, x.i=0;	y>0: x.r<0, x.i=0
		if(y0.r==y1.r)
		{
		}
		else
		{
		}
	//	if(x0.i==0&&x1.i==0&&std::signbit(x0.r)!=std::signbit(x1.r))
	//	{
	//	}
		return false;
	}
	bool disc_cc_pow_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_pow_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_pow_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_pow_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_pow_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value  c_ln						(Value const &x)				{return std::log((std::complex<double>)x);}
	Value  q_ln						(Value const &x)
	{
		try
		{
			return log((boost::math::quaternion<double>)x);
		}
		catch(std::domain_error&)
		{
			return Value(_qnan, _qnan, _qnan, _qnan);
		}
	}
	auto disc_c_ln_i				=disc_c_arg_i;
	bool disc_q_ln_i				(Value const &x0, Value const &x1){return false;}//

	Value  c_log					(Value const &x)				{return std::log10((std::complex<double>)x);}
	Value  q_log					(Value const &x)				{return log((boost::math::quaternion<double>)x)/::log(10);}
	Value cc_log					(Value const &x, Value const &y)
	{
		return std::log((std::complex<double>)y)/std::log((std::complex<double>)x);
	}
	Value cq_log					(Value const &x, Value const &y){return log((boost::math::quaternion<double>)y)/std::log((std::complex<double>)x);}
	Value qc_log					(Value const &x, Value const &y){return std::log((std::complex<double>)y)/log((boost::math::quaternion<double>)x);}
	Value qq_log					(Value const &x, Value const &y){return log((boost::math::quaternion<double>)y)/log((boost::math::quaternion<double>)x);}
	auto disc_c_log_i				=disc_c_arg_i;
	bool disc_q_log_i				(Value const &x0, Value const &x1){return false;}//
	bool disc_cc_log_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_log_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_log_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_log_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	class Tetrate//http://en.citizendium.org/wiki/Fit1.cin
	{
		static std::complex<double> _fit1(std::complex<double> x, std::complex<double> y)
		{
			if(x.real()<.001)
			{
				if(y.real()>-1)
					return 1.;
				if(y.real()<-1)
					return -990.;
			}
			std::complex<double> q=std::sqrt(x);
			return (y+1.)*(
				(
					x.real()>::log(2.)?
						(q*(0.137467+q*(4.94969+q*0.0474179))/(1.+q*(3.23171+q*0.471222))+(-.5+::log(2.))/x-1.)
						+y*	(
								(q*(-0.424278+q*(1.75166+q*(-1.46524+q*0.93347)))/(0.0312142+q*(-0.267478+q))+(-.625+::log(2.))/x-1.)
								+y*	(
										(q*(3.39255+q*(16.1046+q*(-19.5216+q*10.7458)))/(1.+q*(4.1274+q*5.25449))+(-2./3+::log(2.))/x-1.)
										+y*(0.16*q*(1.+q*(27.7934+q*(358.688+q*(-259.233+x*61.6566))))/(1.-8.1192*q+37.087*x)+(-131./192.+::log(2))/x-1.)
									)
							)
					:
						(-1.0018+(0.15128484821526975*(1.+33.04715298851381*q-3.51771875598067*x)*q)/(1.+3.2255053261256337*q)+(-0.5+::log(2.))/x)
						+y*	(
								(1.1-2.608785958462561*(1.-0.6663562294911147*sqrt(x))*sqrt(x)-(-0.625+::log(2.))/x)
								+y*	(
										(-0.96+3.0912038297987596*(1.+0.6021398048785328*x)*q/(1.+ 4.240467556480155*x)+(-2./3+::log(2.))/x)
										+y*(1.2-10.44604984418533*(1.+0.2137568928431227*q+0.3693275254470449*x)*q/(1.+4.95715636660691*q + 7.70233216637738*x)-(-131./192.+::log(2.))/x)
									)
							)
				)*y+1.)+log(y+2.)/x-::log(2.)/x*(1.+y);
		}
	public:
		static std::complex<double> fit1(std::complex<double> x, std::complex<double> y)
		{
			x=std::log(x);
			if(x.real()<.03)
			{
				if(y.real()<-1.)
					return -30.;
				return 1.;
			}
			int h=int(::floor(y.real()-.5)+1);
			std::complex<double> result=_fit1(x, y-(double)h);
			for(;h>0;--h)
				result=exp(x*result);
			for(;h<0;++h)
				result=std::log(result)/x;
			return result;
		}
	};
	Value rr_tetrate				(Value const &x, Value const &y)
	{
		auto const ln_2=::log(2);
		double log_x=std::log((double)x), ry=y;
		int h=int(::floor(ry-.5)+1);//rounded real part
		std::complex<double> t(ry-(double)h);//real-round(real)+i*imag
		{
			auto q=std::sqrt(log_x);
			t=(t+1.)*(
				(
					log_x>ln_2?
						(q*(0.137467+q*(4.94969+q*0.0474179))/(1.+q*(3.23171+q*0.471222))+(-.5+ln_2)/log_x-1.)
						+t*	(
								(q*(-0.424278+q*(1.75166+q*(-1.46524+q*0.93347)))/(0.0312142+q*(-0.267478+q))+(-.625+ln_2)/log_x-1.)
								+t*	(
										(q*(3.39255+q*(16.1046+q*(-19.5216+q*10.7458)))/(1.+q*(4.1274+q*5.25449))+(-2./3+ln_2)/log_x-1.)
										+t*(0.16*q*(1.+q*(27.7934+q*(358.688+q*(-259.233+log_x*61.6566))))/(1.-8.1192*q+37.087*log_x)+(-131./192.+ln_2)/log_x-1.)
									)
							)
					:
						(-1.0018+(0.15128484821526975*(1.+33.04715298851381*q-3.51771875598067*log_x)*q)/(1.+3.2255053261256337*q)+(-0.5+ln_2)/log_x)
						+t*	(
								(1.1-2.608785958462561*(1.-0.6663562294911147*q)*q-(-0.625+ln_2)/log_x)
								+t*	(
										(-0.96+3.0912038297987596*(1.+0.6021398048785328*log_x)*q/(1.+ 4.240467556480155*log_x)+(-2./3+ln_2)/log_x)
										+t*(1.2-10.44604984418533*(1.+0.2137568928431227*q+0.3693275254470449*log_x)*q/(1.+4.95715636660691*q + 7.70233216637738*log_x)-(-131./192.+ln_2)/log_x)
									)
							)
				)*t+1.)+std::log(t+2.)/log_x-ln_2/log_x*(1.+t);
		}
		for(;h>0;--h)
			t=std::exp(log_x*t);
		for(;h<0;++h)
			t=std::log(t)/log_x;
		return t;
	//	return Tetrate::fit1(x, y);
	}
	Value cr_tetrate				(Value const &x, Value const &y)
	{
		auto const ln_2=::log(2);
		std::complex<double> log_x=std::log((std::complex<double>)x);
		double ry=y;
		int h=int(::floor(ry-.5)+1);//rounded real part
		std::complex<double> t(ry-(double)h);//real-round(real)+i*imag
		{
			auto q=std::sqrt(log_x);
			t=(t+1.)*(
				(
					log_x.real()>ln_2?
						(q*(0.137467+q*(4.94969+q*0.0474179))/(1.+q*(3.23171+q*0.471222))+(-.5+ln_2)/log_x-1.)
						+t*	(
								(q*(-0.424278+q*(1.75166+q*(-1.46524+q*0.93347)))/(0.0312142+q*(-0.267478+q))+(-.625+ln_2)/log_x-1.)
								+t*	(
										(q*(3.39255+q*(16.1046+q*(-19.5216+q*10.7458)))/(1.+q*(4.1274+q*5.25449))+(-2./3+ln_2)/log_x-1.)
										+t*(0.16*q*(1.+q*(27.7934+q*(358.688+q*(-259.233+log_x*61.6566))))/(1.-8.1192*q+37.087*log_x)+(-131./192.+ln_2)/log_x-1.)
									)
							)
					:
						(-1.0018+(0.15128484821526975*(1.+33.04715298851381*q-3.51771875598067*log_x)*q)/(1.+3.2255053261256337*q)+(-0.5+ln_2)/log_x)
						+t*	(
								(1.1-2.608785958462561*(1.-0.6663562294911147*q)*q-(-0.625+ln_2)/log_x)
								+t*	(
										(-0.96+3.0912038297987596*(1.+0.6021398048785328*log_x)*q/(1.+ 4.240467556480155*log_x)+(-2./3+ln_2)/log_x)
										+t*(1.2-10.44604984418533*(1.+0.2137568928431227*q+0.3693275254470449*log_x)*q/(1.+4.95715636660691*q + 7.70233216637738*log_x)-(-131./192.+ln_2)/log_x)
									)
							)
				)*t+1.)+std::log(t+2.)/log_x-ln_2/log_x*(1.+t);
		}
		for(;h>0;--h)
			t=std::exp(log_x*t);
		for(;h<0;++h)
			t=std::log(t)/log_x;
		return t;
	//	return Tetrate::fit1(x, y);
	}
	Value qr_tetrate				(Value const &x, Value const &y)
	{
		boost::math::quaternion<double> qx=x;
		double ry=y;
		if(ry<-1)
		{
			int steps=int(abs(ry));
			boost::math::quaternion<double> t(ry-::floor(ry)), lrx=log(qx);
			for(int k=0;k<steps;++k)
				t=log(t)/lrx;
			return t;
		}
		else if(ry<=0)
			return 1+ry;
		else
		{
			int h=int(ry)+1;
			boost::math::quaternion<double> t(ry-::floor(ry));
			for(int k=0;k<h;++k)
				t=pow(qx, t);
			return t;
		}
	}
	Value rc_tetrate				(Value const &x, Value const &y)
	{
		auto const ln_2=::log(2);
		double log_x=std::log((double)x);
		std::complex<double> cy=y;
		int h=int(::floor(cy.real()-.5)+1);//rounded real part
		std::complex<double> t(cy-(double)h);//real-round(real)+i*imag
		{
			auto q=std::sqrt(log_x);
			t=(t+1.)*(
				(
					log_x>ln_2?
						(q*(0.137467+q*(4.94969+q*0.0474179))/(1.+q*(3.23171+q*0.471222))+(-.5+ln_2)/log_x-1.)
						+t*	(
								(q*(-0.424278+q*(1.75166+q*(-1.46524+q*0.93347)))/(0.0312142+q*(-0.267478+q))+(-.625+ln_2)/log_x-1.)
								+t*	(
										(q*(3.39255+q*(16.1046+q*(-19.5216+q*10.7458)))/(1.+q*(4.1274+q*5.25449))+(-2./3+ln_2)/log_x-1.)
										+t*(0.16*q*(1.+q*(27.7934+q*(358.688+q*(-259.233+log_x*61.6566))))/(1.-8.1192*q+37.087*log_x)+(-131./192.+ln_2)/log_x-1.)
									)
							)
					:
						(-1.0018+(0.15128484821526975*(1.+33.04715298851381*q-3.51771875598067*log_x)*q)/(1.+3.2255053261256337*q)+(-0.5+ln_2)/log_x)
						+t*	(
								(1.1-2.608785958462561*(1.-0.6663562294911147*q)*q-(-0.625+ln_2)/log_x)
								+t*	(
										(-0.96+3.0912038297987596*(1.+0.6021398048785328*log_x)*q/(1.+ 4.240467556480155*log_x)+(-2./3+ln_2)/log_x)
										+t*(1.2-10.44604984418533*(1.+0.2137568928431227*q+0.3693275254470449*log_x)*q/(1.+4.95715636660691*q + 7.70233216637738*log_x)-(-131./192.+ln_2)/log_x)
									)
							)
				)*t+1.)+std::log(t+2.)/log_x-ln_2/log_x*(1.+t);
		}
		for(;h>0;--h)
			t=std::exp(log_x*t);
		for(;h<0;++h)
			t=std::log(t)/log_x;
		return t;
	//	return Tetrate::fit1(x, y);
	}
	Value cc_tetrate				(Value const &x, Value const &y)
	{
		std::complex<double> log_x=std::log((std::complex<double>)x), cy=y;
	//	if(log_x.real()<.03)//abs(log_x)<1.03045453395352
	//	{
	//		if(cy.real()<-1.)
	//			return -30.;
	//		return 1.;
	//	}
		int h=int(::floor(cy.real()-.5)+1);
		std::complex<double> t(cy-(double)h);//real-round(real)+i*imag
		{
		//	bool unassigned=true;
		//	if(log_x.real()<.001)//abs(log_x)<1.00100050016671
		//	{
		//		if(t.real()>-1)//real-round(real)>-1
		//			unassigned=false, t=1.;
		//		else if(t.real()<-1)
		//			unassigned=false, t=-990.;
		//	}
		//	if(unassigned)
		//	{
				std::complex<double> q=std::sqrt(log_x);
				t=(t+1.)*(
					(
						log_x.real()>::log(2.)?
							(q*(0.137467+q*(4.94969+q*0.0474179))/(1.+q*(3.23171+q*0.471222))+(-.5+::log(2.))/log_x-1.)
							+t*	(
									(q*(-0.424278+q*(1.75166+q*(-1.46524+q*0.93347)))/(0.0312142+q*(-0.267478+q))+(-.625+::log(2.))/log_x-1.)
									+t*	(
											(q*(3.39255+q*(16.1046+q*(-19.5216+q*10.7458)))/(1.+q*(4.1274+q*5.25449))+(-2./3+::log(2.))/log_x-1.)
											+t*(0.16*q*(1.+q*(27.7934+q*(358.688+q*(-259.233+log_x*61.6566))))/(1.-8.1192*q+37.087*log_x)+(-131./192.+::log(2))/log_x-1.)
										)
								)
						:
							(-1.0018+(0.15128484821526975*(1.+33.04715298851381*q-3.51771875598067*log_x)*q)/(1.+3.2255053261256337*q)+(-0.5+::log(2.))/log_x)
							+t*	(
									(1.1-2.608785958462561*(1.-0.6663562294911147*sqrt(log_x))*sqrt(log_x)-(-0.625+::log(2.))/log_x)
									+t*	(
											(-0.96+3.0912038297987596*(1.+0.6021398048785328*log_x)*q/(1.+ 4.240467556480155*log_x)+(-2./3+::log(2.))/log_x)
											+t*(1.2-10.44604984418533*(1.+0.2137568928431227*q+0.3693275254470449*log_x)*q/(1.+4.95715636660691*q + 7.70233216637738*log_x)-(-131./192.+::log(2.))/log_x)
										)
								)
					)*t+1.)+log(t+2.)/log_x-::log(2.)/log_x*(1.+t);
		//	}
		}
		for(;h>0;--h)
			t=exp(log_x*t);
		for(;h<0;++h)
			t=std::log(t)/log_x;
		return t;
	//	return Tetrate::fit1(x, y);
	}
	bool disc_rr_tetrate_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_tetrate_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_tetrate_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rc_tetrate_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cc_tetrate_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value rr_pentate				(Value const &x, Value const &y)
	{
		long long h=convert_d2ll_zero(y.r);
	//	long long h=y.r!=y.r||y.r<-ll_max||y.r>ll_max?0:long long(y);
	//	long long h=std::isnan(y.r)||std::isinf(y.r)?0:long long(y);
		if(h<-2)	return _HUGE;//1/::sin(0);
		if(h==-2)	return -1;
		if(h==-1)	return 0;
		if(h==0)	return 1;
		if(h==1)	return x;
		double rx=x;
		std::complex<double> result(rx);
		for(int k=0;k<h;++k)
			result=Tetrate::fit1(rx, result);
		return result;
	}
	Value cr_pentate				(Value const &x, Value const &y)
	{
		long long h=convert_d2ll_zero(y.r);
		if(h<-2)	return _HUGE;//1/::sin(0);
		if(h==-2)	return -1;
		if(h==-1)	return 0;
		if(h==0)	return 1;
		if(h==1)	return x;
		std::complex<double> cx=x, result(cx);
		for(int k=0;k<h;++k)
			result=Tetrate::fit1(cx, result);
		return result;
	}
	bool disc_rr_pentate_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_pentate_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value  r_bitwise_shift_left_l	(Value const &x)				{return ::exp(::floor(x)*::log(2.));}
	Value  c_bitwise_shift_left_l	(Value const &x)				{return std::exp(floor((std::complex<double>)x)*::log(2.));}
	Value  q_bitwise_shift_left_l	(Value const &x)				{return exp(floor((boost::math::quaternion<double>)x)*::log(2.));}
	Value  r_bitwise_shift_left_r	(Value const &x)				{return (double)x*2;}
	Value  c_bitwise_shift_left_r	(Value const &x)				{return (std::complex<double>)x*2.;}
	Value  q_bitwise_shift_left_r	(Value const &x)				{return (boost::math::quaternion<double>)x*2.;}
	Value rr_bitwise_shift_left		(Value const &x, Value const &y){return x*::exp(::floor(y)*::log(2.));}
	Value rc_bitwise_shift_left		(Value const &x, Value const &y){return (double)x*std::exp(floor((std::complex<double>)y)*::log(2.));}
	Value rq_bitwise_shift_left		(Value const &x, Value const &y){return (double)x*exp(floor((boost::math::quaternion<double>)y)*::log(2.));}
	Value cr_bitwise_shift_left		(Value const &x, Value const &y){return (std::complex<double>)x*::exp(::floor(y)*::log(2.));}
	Value cc_bitwise_shift_left		(Value const &x, Value const &y){return (std::complex<double>)x*std::exp(floor((std::complex<double>)y)*::log(2.));}
	Value cq_bitwise_shift_left		(Value const &x, Value const &y){return (std::complex<double>)x*exp(floor((boost::math::quaternion<double>)y)*::log(2.));}
	Value qr_bitwise_shift_left		(Value const &x, Value const &y){return (boost::math::quaternion<double>)x*::exp(::floor(y)*::log(2.));}
	Value qc_bitwise_shift_left		(Value const &x, Value const &y){return (boost::math::quaternion<double>)x*std::exp(floor((std::complex<double>)y)*::log(2.));}
	Value qq_bitwise_shift_left		(Value const &x, Value const &y){return (boost::math::quaternion<double>)x*exp(floor((boost::math::quaternion<double>)y)*::log(2.));}
	auto disc_r_bitwise_shift_left_l_o	=disc_r_ceil_o;
	auto disc_c_bitwise_shift_left_l_o	=disc_c_ceil_o;
	auto disc_q_bitwise_shift_left_l_o	=disc_q_ceil_o;
	bool disc_rr_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0;}
	bool disc_rc_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0;}
	bool disc_rq_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0;}
	bool disc_cr_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0||std::floor(x1.i)-std::floor(x0.i)!=0;}
	bool disc_cc_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0||std::floor(x1.i)-std::floor(x0.i)!=0;}
	bool disc_cq_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0||std::floor(x1.i)-std::floor(x0.i)!=0;}
	bool disc_qr_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0||std::floor(x1.i)-std::floor(x0.i)!=0||std::floor(x1.j)-std::floor(x0.j)!=0||std::floor(x1.k)-std::floor(x0.k)!=0;}
	bool disc_qc_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0||std::floor(x1.i)-std::floor(x0.i)!=0||std::floor(x1.j)-std::floor(x0.j)!=0||std::floor(x1.k)-std::floor(x0.k)!=0;}
	bool disc_qq_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0||std::floor(x1.i)-std::floor(x0.i)!=0||std::floor(x1.j)-std::floor(x0.j)!=0||std::floor(x1.k)-std::floor(x0.k)!=0;}

	Value  r_bitwise_shift_right_l	(Value const &x)				{return ::exp(-::floor(x)*::log(2.));}
	Value  c_bitwise_shift_right_l	(Value const &x)				{return std::exp(-floor((std::complex<double>)x)*::log(2.));}
	Value  q_bitwise_shift_right_l	(Value const &x)				{return exp(-floor((boost::math::quaternion<double>)x)*::log(2.));}
	Value  r_bitwise_shift_right_r	(Value const &x)				{return (double)x/2;}
	Value  c_bitwise_shift_right_r	(Value const &x)				{return (std::complex<double>)x/2.;}
	Value  q_bitwise_shift_right_r	(Value const &x)				{return (boost::math::quaternion<double>)x/2.;}
	Value rr_bitwise_shift_right	(Value const &x, Value const &y){return x*::exp(-::floor(y)*::log(2.));}
	Value rc_bitwise_shift_right	(Value const &x, Value const &y){return (double)x*std::exp(-floor((std::complex<double>)y)*::log(2.));}
	Value rq_bitwise_shift_right	(Value const &x, Value const &y){return (double)x*exp(-floor((boost::math::quaternion<double>)y)*::log(2.));}
	Value cr_bitwise_shift_right	(Value const &x, Value const &y){return (std::complex<double>)x*::exp(-::floor(y)*::log(2.));}
	Value cc_bitwise_shift_right	(Value const &x, Value const &y){return (std::complex<double>)x*std::exp(-floor((std::complex<double>)y)*::log(2.));}
	Value cq_bitwise_shift_right	(Value const &x, Value const &y){return (std::complex<double>)x*exp(-floor((boost::math::quaternion<double>)y)*::log(2.));}
	Value qr_bitwise_shift_right	(Value const &x, Value const &y){return (boost::math::quaternion<double>)x*::exp(-::floor(y)*::log(2.));}
	Value qc_bitwise_shift_right	(Value const &x, Value const &y){return (boost::math::quaternion<double>)x*std::exp(-floor((std::complex<double>)y)*::log(2.));}
	Value qq_bitwise_shift_right	(Value const &x, Value const &y){return (boost::math::quaternion<double>)x*exp(-floor((boost::math::quaternion<double>)y)*::log(2.));}
	auto disc_r_bitwise_shift_right_l_o	=disc_r_ceil_o;
	auto disc_c_bitwise_shift_right_l_o	=disc_c_ceil_o;
	auto disc_q_bitwise_shift_right_l_o	=disc_q_ceil_o;
	auto disc_rr_bitwise_shift_right_i	=disc_rr_bitwise_shift_left_i;
	auto disc_rc_bitwise_shift_right_i	=disc_rc_bitwise_shift_left_i;
	auto disc_rq_bitwise_shift_right_i	=disc_rq_bitwise_shift_left_i;
	auto disc_cr_bitwise_shift_right_i	=disc_cr_bitwise_shift_left_i;
	auto disc_cc_bitwise_shift_right_i	=disc_cc_bitwise_shift_left_i;
	auto disc_cq_bitwise_shift_right_i	=disc_cq_bitwise_shift_left_i;
	auto disc_qr_bitwise_shift_right_i	=disc_qr_bitwise_shift_left_i;
	auto disc_qc_bitwise_shift_right_i	=disc_qc_bitwise_shift_left_i;
	auto disc_qq_bitwise_shift_right_i	=disc_qq_bitwise_shift_left_i;

	Value  r_bitwise_not			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r))
			return 0;
		return double(~convert_d2ll(x));
	}
	Value  c_bitwise_not			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i))
			return 0;
		return Value(double(~convert_d2ll(x.r)), double(~convert_d2ll(x.i)));
	}
	Value  q_bitwise_not			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k))
			return 0;
		return Value(double(~convert_d2ll(x.r)), double(~convert_d2ll(x.i)), double(~convert_d2ll(x.j)), double(~convert_d2ll(x.k)));
	}
	auto disc_r_bitwise_not_i		=disc_r_divide_i;
	auto disc_c_bitwise_not_i		=disc_c_divide_i;
	bool disc_q_bitwise_not_i		(Value const &x0, Value const &x1){return false;}

	Value  r_bitwise_and			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r))
			return 0;
		return !~convert_d2ll(x);
	}
	Value  c_bitwise_and			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i))
			return 0;
		return Value(!~convert_d2ll(x.r), !~convert_d2ll(x.i));
	}
	Value  q_bitwise_and			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k))
			return 0;
		return Value(!~convert_d2ll(x.r), !~convert_d2ll(x.i), !~convert_d2ll(x.j), !~convert_d2ll(x.k));
	}
	Value rr_bitwise_and			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		return double(convert_d2ll(x)&convert_d2ll(y));
	}
	Value rc_bitwise_and			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long xr=convert_d2ll(x);
		return Value(double(xr&convert_d2ll(y.r)), double(xr&convert_d2ll(y.i)));
	}
	Value rq_bitwise_and			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long xr=convert_d2ll(x);
		return Value(double(xr&convert_d2ll(y.r)), double(xr&convert_d2ll(y.i)), double(xr&convert_d2ll(y.j)), double(xr&convert_d2ll(y.k)));
	}
	Value cr_bitwise_and			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		long long yr=convert_d2ll(y);
		return Value(double(convert_d2ll(x.r)&yr), double(convert_d2ll(x.i)&yr));
	}
	Value cc_bitwise_and			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long
			xr=convert_d2ll(x.r), xi=convert_d2ll(x.i),
			yr=convert_d2ll(y.r), yi=convert_d2ll(y.i);
		return Value(double((xr&yr)-(xi&yi)), double((xr&yi)+(xi&yr)));
	}
	Value cq_bitwise_and			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long
			xr=convert_d2ll(x.r), xi=convert_d2ll(x.i),
			yr=convert_d2ll(y.r), yi=convert_d2ll(y.i), yj=convert_d2ll(y.j), yk=convert_d2ll(y.k);
		return Value(double((xr&yr)-(xi&yi)), double((xr&yi)+(xi&yr)), double((xr&yj)-(xi&yk)), double((xr&yk)+(xi&yj)));
	}
	Value qr_bitwise_and			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		long long yr=convert_d2ll(y);
		return Value(double(convert_d2ll(x.r)&yr), double(convert_d2ll(x.i)&yr), double(convert_d2ll(x.j)&yr), double(convert_d2ll(x.k)&yr));
	}
	Value qc_bitwise_and			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long
			xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), xj=convert_d2ll(x.j), xk=convert_d2ll(x.k),
			yr=convert_d2ll(y.r), yi=convert_d2ll(y.i);
		return Value(double((xr&yr)-(xi&yi)), double((xr&yi)+(xi&yr)), double((xj&yr)+(xk&yi)), double(-(xj&yi)+(xk&yr)));
	}
	Value qq_bitwise_and			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long
			xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), xj=convert_d2ll(x.j), xk=convert_d2ll(x.k),
			yr=convert_d2ll(y.r), yi=convert_d2ll(y.i), yj=convert_d2ll(y.j), yk=convert_d2ll(y.k);
		return Value(double((xr&yr)-(xi&yi)-(xj&yj)-(xk&yk)), double((xr&yi)+(xi&yr)+(xj&yk)-(xk&yj)), double((xr&yj)-(xi&yk)+(xj&yr)+(xk&yi)), double((xr&yk)+(xi&yj)-(xj&yi)+(xk&yr)));
	}
	auto disc_r_bitwise_and_o		=disc_r_ceil_o;
	auto disc_c_bitwise_and_o		=disc_c_ceil_o;
	auto disc_q_bitwise_and_o		=disc_q_ceil_o;
	auto disc_rr_bitwise_and_o		=disc_r_ceil_o;
	auto disc_rc_bitwise_and_o		=disc_c_ceil_o;
	auto disc_rq_bitwise_and_o		=disc_q_ceil_o;
	auto disc_cr_bitwise_and_o		=disc_c_ceil_o;
	auto disc_cc_bitwise_and_o		=disc_c_ceil_o;
	auto disc_cq_bitwise_and_o		=disc_q_ceil_o;
	auto disc_qr_bitwise_and_o		=disc_q_ceil_o;
	auto disc_qc_bitwise_and_o		=disc_q_ceil_o;
	auto disc_qq_bitwise_and_o		=disc_q_ceil_o;

	Value  r_bitwise_nand			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r))
			return 0;
		return ~convert_d2ll(x)!=0;
	}
	Value  c_bitwise_nand			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i))
			return 0;
		return Value(~convert_d2ll(x.r)!=0, ~convert_d2ll(x.i)!=0);
	}
	Value  q_bitwise_nand			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k))
			return 0;
		return Value(~convert_d2ll(x.r)!=0, ~convert_d2ll(x.i)!=0, ~convert_d2ll(x.j)!=0, ~convert_d2ll(x.k)!=0);
	}
	Value rr_bitwise_nand			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		return double(~(convert_d2ll(x)&convert_d2ll(y)));
	}
	Value rc_bitwise_nand			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long xr=convert_d2ll(x);
		return Value(double(~(xr&convert_d2ll(y.r))), double(~(xr&convert_d2ll(y.i))));
	}
	Value rq_bitwise_nand			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long xr=convert_d2ll(x);
		return Value(double(~(xr&convert_d2ll(y.r))), double(~(xr&convert_d2ll(y.i))), double(~(xr&convert_d2ll(y.j))), double(~(xr&convert_d2ll(y.k))));
	}
	Value cr_bitwise_nand			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		long long yr=convert_d2ll(y);
		return Value(double(~(convert_d2ll(x.r)&yr)), double(~(convert_d2ll(x.i)&yr)));
	}
	Value cc_bitwise_nand			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long
			xr=convert_d2ll(x.r), xi=convert_d2ll(x.i),
			yr=convert_d2ll(y.r), yi=convert_d2ll(y.i);
		return Value(double(~((xr&yr)-(xi&yi))), double(~((xr&yi)+(xi&yr))));
	}
	Value cq_bitwise_nand			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long
			xr=convert_d2ll(x.r), xi=convert_d2ll(x.i),
			yr=convert_d2ll(y.r), yi=convert_d2ll(y.i), yj=convert_d2ll(y.j), yk=convert_d2ll(y.k);
		return Value(double(~((xr&yr)-(xi&yi))), double(~((xr&yi)+(xi&yr))), double(~((xr&yj)-(xi&yk))), double(~((xr&yk)+(xi&yj))));
	}
	Value qr_bitwise_nand			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		long long yr=convert_d2ll(y);
		return Value(double(~(convert_d2ll(x.r)&yr)), double(~(convert_d2ll(x.i)&yr)), double(~(convert_d2ll(x.j)&yr)), double(~(convert_d2ll(x.k)&yr)));
	}
	Value qc_bitwise_nand			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long
			xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), xj=convert_d2ll(x.j), xk=convert_d2ll(x.k),
			yr=convert_d2ll(y.r), yi=convert_d2ll(y.i);
		return Value(double(~((xr&yr)-(xi&yi))), double(~((xr&yi)+(xi&yr))), double(~((xj&yr)+(xk&yi))), double(~(-(xj&yi)+(xk&yr))));
	}
	Value qq_bitwise_nand			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long
			xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), xj=convert_d2ll(x.j),
			xk=convert_d2ll(x.k), yr=convert_d2ll(y.r), yi=convert_d2ll(y.i), yj=convert_d2ll(y.j), yk=convert_d2ll(y.k);
		return Value(double(~((xr&yr)-(xi&yi)-(xj&yj)-(xk&yk))), double(~((xr&yi)+(xi&yr)+(xj&yk)-(xk&yj))), double(~((xr&yj)-(xi&yk)+(xj&yr)+(xk&yi))), double(~((xr&yk)+(xi&yj)-(xj&yi)+(xk&yr))));
	}
	auto disc_r_bitwise_nand_o		=disc_r_bitwise_and_o;
	auto disc_c_bitwise_nand_o		=disc_c_bitwise_and_o;
	auto disc_q_bitwise_nand_o		=disc_q_bitwise_and_o;
	auto disc_rr_bitwise_nand_o		=disc_rr_bitwise_and_o;
	auto disc_rc_bitwise_nand_o		=disc_rc_bitwise_and_o;
	auto disc_rq_bitwise_nand_o		=disc_rq_bitwise_and_o;
	auto disc_cr_bitwise_nand_o		=disc_cr_bitwise_and_o;
	auto disc_cc_bitwise_nand_o		=disc_cc_bitwise_and_o;
	auto disc_cq_bitwise_nand_o		=disc_cq_bitwise_and_o;
	auto disc_qr_bitwise_nand_o		=disc_qr_bitwise_and_o;
	auto disc_qc_bitwise_nand_o		=disc_qc_bitwise_and_o;
	auto disc_qq_bitwise_nand_o		=disc_qq_bitwise_and_o;
	
	Value  r_bitwise_or				(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r))
			return 0;
		return x!=0;
	}
	Value  c_bitwise_or				(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i))
			return 0;
		return Value(x.r!=0, x.i!=0);
	}
	Value  q_bitwise_or				(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k))
			return 0;
		return Value(x.r!=0, x.i!=0, x.j!=0, x.k!=0);
	}
	Value rr_bitwise_or				(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		return double(convert_d2ll(x)|convert_d2ll(y));
	}
	Value rc_bitwise_or				(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long nxr=~convert_d2ll(x);
		return Value(double(~(nxr&~convert_d2ll(y.r))), double(~(nxr&~convert_d2ll(y.i))));
	}
	Value rq_bitwise_or				(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long nxr=~convert_d2ll(x);
		return Value(double(~(nxr&~convert_d2ll(y.r))), double(~(nxr&~convert_d2ll(y.i))), double(~(nxr&~convert_d2ll(y.j))), double(~(nxr&~convert_d2ll(y.k))));
	}
	Value cr_bitwise_or				(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		long long yr=~convert_d2ll(y);
		return Value(double(~(~convert_d2ll(x.r)&yr)), double(~(~convert_d2ll(x.i)&yr)));
	}
	Value cc_bitwise_or				(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long
			nxr=~convert_d2ll(x.r), nxi=~convert_d2ll(x.i),
			nyr=~convert_d2ll(y.r), nyi=~convert_d2ll(y.i);
		return Value(double(~((nxr&nyr)-(nxi&nyi))), double(~((nxr&nyi)+(nxi&nyr))));
	}
	Value cq_bitwise_or				(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long
			nxr=~convert_d2ll(x.r), nxi=~convert_d2ll(x.i),
			nyr=~convert_d2ll(y.r), nyi=~convert_d2ll(y.i), nyj=~convert_d2ll(y.j), nyk=~convert_d2ll(y.k);
		return Value(double(~((nxr&nyr)-(nxi&nyi))), double(~((nxr&nyi)+(nxi&nyr))), double(~((nxr&nyj)-(nxi&nyk))), double(~((nxr&nyk)+(nxi&nyj))));
	}
	Value qr_bitwise_or				(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		long long nyr=~convert_d2ll(y);
		return Value(double(~(~convert_d2ll(x.r)&nyr)), double(~(~convert_d2ll(x.i)&nyr)), double(~(~convert_d2ll(x.j)&nyr)), double(~(~convert_d2ll(x.k)&nyr)));
	}
	Value qc_bitwise_or				(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long
			nxr=~convert_d2ll(x.r), nxi=~convert_d2ll(x.i), nxj=~convert_d2ll(x.j), nxk=~convert_d2ll(x.k),
			nyr=~convert_d2ll(y.r), nyi=~convert_d2ll(y.i);
		return Value(double(~((nxr&nyr)-(nxi&nyi))), double(~((nxr&nyi)+(nxi&nyr))), double(~((nxj&nyr)+(nxk&nyi))), double(~(-(nxj&nyi)+(nxk&nyr))));
	}
	Value qq_bitwise_or				(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long
			nxr=~convert_d2ll(x.r), nxi=~convert_d2ll(x.i), nxj=~convert_d2ll(x.j), nxk=~convert_d2ll(x.k),
			nyr=~convert_d2ll(y.r), nyi=~convert_d2ll(y.i), nyj=~convert_d2ll(y.j), nyk=~convert_d2ll(y.k);
		return Value(double(~((nxr&nyr)-(nxi&nyi)-(nxj&nyj)-(nxk&nyk))), double(~((nxr&nyi)+(nxi&nyr)+(nxj&nyk)-(nxk&nyj))), double(~((nxr&nyj)-(nxi&nyk)+(nxj&nyr)+(nxk&nyi))), double(~((nxr&nyk)+(nxi&nyj)-(nxj&nyi)+(nxk&nyr))));
	}
	auto disc_r_bitwise_or_o		=disc_r_bitwise_and_o;
	auto disc_c_bitwise_or_o		=disc_c_bitwise_and_o;
	auto disc_q_bitwise_or_o		=disc_q_bitwise_and_o;
	auto disc_rr_bitwise_or_o		=disc_rr_bitwise_and_o;
	auto disc_rc_bitwise_or_o		=disc_rc_bitwise_and_o;
	auto disc_rq_bitwise_or_o		=disc_rq_bitwise_and_o;
	auto disc_cr_bitwise_or_o		=disc_cr_bitwise_and_o;
	auto disc_cc_bitwise_or_o		=disc_cc_bitwise_and_o;
	auto disc_cq_bitwise_or_o		=disc_cq_bitwise_and_o;
	auto disc_qr_bitwise_or_o		=disc_qr_bitwise_and_o;
	auto disc_qc_bitwise_or_o		=disc_qc_bitwise_and_o;
	auto disc_qq_bitwise_or_o		=disc_qq_bitwise_and_o;
	
	Value  r_bitwise_nor			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r))
			return 0;
		return !x;
	}
	Value  c_bitwise_nor			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i))
			return 0;
		return Value(!x.r, !x.i);
	}
	Value  q_bitwise_nor			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k))
			return 0;
		return Value(!x.r, !x.i, !x.j, !x.k);
	}
	Value rr_bitwise_nor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		return double(~(convert_d2ll(x)|convert_d2ll(y)));
	}
	Value rc_bitwise_nor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long nxr=~convert_d2ll(x);
		return Value(double(nxr&~convert_d2ll(y.r)), double(nxr&~convert_d2ll(y.i)));
	}
	Value rq_bitwise_nor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long nxr=~convert_d2ll(x);
		return Value(double(nxr&~convert_d2ll(y.r)), double(nxr&~convert_d2ll(y.i)), double(nxr&~convert_d2ll(y.j)), double(nxr&~convert_d2ll(y.k)));
	}
	Value cr_bitwise_nor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		long long yr=~convert_d2ll(y);
		return Value(double(~convert_d2ll(x.r)&yr), double(~convert_d2ll(x.i)&yr));
	}
	Value cc_bitwise_nor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long
			nxr=~convert_d2ll(x.r), nxi=~convert_d2ll(x.i),
			nyr=~convert_d2ll(y.r), nyi=~convert_d2ll(y.i);
		return Value(double((nxr&nyr)-(nxi&nyi)), double((nxr&nyi)+(nxi&nyr)));
	}
	Value cq_bitwise_nor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long
			nxr=~convert_d2ll(x.r), nxi=~convert_d2ll(x.i),
			nyr=~convert_d2ll(y.r), nyi=~convert_d2ll(y.i), nyj=~convert_d2ll(y.j), nyk=~convert_d2ll(y.k);
		return Value(double((nxr&nyr)-(nxi&nyi)), double((nxr&nyi)+(nxi&nyr)), double((nxr&nyj)-(nxi&nyk)), double((nxr&nyk)+(nxi&nyj)));
	}
	Value qr_bitwise_nor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		long long nyr=~convert_d2ll(y);
		return Value(double(~convert_d2ll(x.r)&nyr), double(~convert_d2ll(x.i)&nyr), double(~convert_d2ll(x.j)&nyr), double(~convert_d2ll(x.k)&nyr));
	}
	Value qc_bitwise_nor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long
			nxr=~convert_d2ll(x.r), nxi=~convert_d2ll(x.i), nxj=~convert_d2ll(x.j),
			nxk=~convert_d2ll(x.k), nyr=~convert_d2ll(y.r), nyi=~convert_d2ll(y.i);
		return Value(double((nxr&nyr)-(nxi&nyi)), double((nxr&nyi)+(nxi&nyr)), double((nxj&nyr)+(nxk&nyi)), double(-(nxj&nyi)+(nxk&nyr)));
	}
	Value qq_bitwise_nor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long
			nxr=~convert_d2ll(x.r), nxi=~convert_d2ll(x.i), nxj=~convert_d2ll(x.j), nxk=~convert_d2ll(x.k),
			nyr=~convert_d2ll(y.r), nyi=~convert_d2ll(y.i), nyj=~convert_d2ll(y.j), nyk=~convert_d2ll(y.k);
		return Value(double((nxr&nyr)-(nxi&nyi)-(nxj&nyj)-(nxk&nyk)), double((nxr&nyi)+(nxi&nyr)+(nxj&nyk)-(nxk&nyj)), double((nxr&nyj)-(nxi&nyk)+(nxj&nyr)+(nxk&nyi)), double((nxr&nyk)+(nxi&nyj)-(nxj&nyi)+(nxk&nyr)));
	}
	auto disc_r_bitwise_nor_o		=disc_r_bitwise_and_o;
	auto disc_c_bitwise_nor_o		=disc_c_bitwise_and_o;
	auto disc_q_bitwise_nor_o		=disc_q_bitwise_and_o;
	auto disc_rr_bitwise_nor_o		=disc_rr_bitwise_and_o;
	auto disc_rc_bitwise_nor_o		=disc_rc_bitwise_and_o;
	auto disc_rq_bitwise_nor_o		=disc_rq_bitwise_and_o;
	auto disc_cr_bitwise_nor_o		=disc_cr_bitwise_and_o;
	auto disc_cc_bitwise_nor_o		=disc_cc_bitwise_and_o;
	auto disc_cq_bitwise_nor_o		=disc_cq_bitwise_and_o;
	auto disc_qr_bitwise_nor_o		=disc_qr_bitwise_and_o;
	auto disc_qc_bitwise_nor_o		=disc_qc_bitwise_and_o;
	auto disc_qq_bitwise_nor_o		=disc_qq_bitwise_and_o;

	Value  r_bitwise_xor			(Value const &x)
	{
	//	if(std::isnan(x.r)||std::isinf(x.r))
	//		return 0;
		return bitwise_xor(x);
	}
	Value  c_bitwise_xor			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i))
			return 0;
		return Value(bitwise_xor(x.r), bitwise_xor(x.i));
	}
	Value  q_bitwise_xor			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k))
			return 0;
		return Value(bitwise_xor(x.r), bitwise_xor(x.i), bitwise_xor(x.j), bitwise_xor(x.k));
	}
	Value rr_bitwise_xor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		return double(convert_d2ll(x)^convert_d2ll(y));
	}
	Value rc_bitwise_xor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long xr=convert_d2ll(x.r), yr=convert_d2ll(y.r), yi=convert_d2ll(y.i);
		long long nxr=~xr, nyr=~yr, nyi=~yi;
		long long nar=~(xr&nyr), nai=~(xr&nyi);
		long long nbr=~(nxr&yr), nbi=~(nxr&yi);
		return Value(double(~((nar&nbr)-(nai&nbi))), double(~((nar&nbi)+(nai&nbr))));
	}
	Value rq_bitwise_xor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long xr=convert_d2ll(x.r), yr=convert_d2ll(y.r), yi=convert_d2ll(y.i), yj=convert_d2ll(y.j), yk=convert_d2ll(y.k);
		long long nxr=~xr, nyr=~yr, nyi=~yi, nyj=~yj, nyk=~yk;
		long long nar=~(xr&nyr), nai=~(xr&nyi), naj=~(xr&nyj), nak=~(xr&nyk);
		long long nbr=~(nxr&yr), nbi=~(nxr&yi), nbj=~(nxr&yj), nbk=~(nxr&yk);
		return Value(double(~((nar&nbr)-(nai&nbi)-(naj&nbj)-(nak&nbk))), double(~((nar&nbi)+(nai&nbr)+(naj&nbk)-(nak&nbj))), double(~((nar&nbj)-(nai&nbk)+(naj&nbr)+(nak&nbi))), double(~((nar&nbk)+(nai&nbj)-(naj&nbi)+(nak&nbr))));
	}
	Value cr_bitwise_xor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		long long xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), yr=convert_d2ll(y.r);
		long long nxr=~xr, nxi=~xi, nyr=~yr;
		long long nar=~(xr&nyr), nai=~(xi&nyr);
		long long nbr=~(nxr&yr), nbi=~(nxi&yr);
		return Value(double(~((nar&nbr)-(nai&nbi))), double(~((nar&nbi)+(nai&nbr))));
	}
	Value cc_bitwise_xor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), yr=convert_d2ll(y.r), yi=convert_d2ll(y.i);
		long long nxr=~xr, nxi=~xi, nyr=~yr, nyi=~yi;
		long long nar=~((xr&nyr)-(xi&nyi)), nai=~((xr&nyi)+(xi&nyr));
		long long nbr=~((nxr&yr)-(nxi&yi)), nbi=~((nxr&yi)+(nxi&yr));
		return Value(double(~((nar&nbr)-(nai&nbi))), double(~((nar&nbi)+(nai&nbr))));
	}
	Value cq_bitwise_xor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), yr=convert_d2ll(y.r), yi=convert_d2ll(y.i), yj=convert_d2ll(y.j), yk=convert_d2ll(y.k);
		long long nxr=~xr, nxi=~xi, nyr=~yr, nyi=~yi, nyj=~yj, nyk=~yk;
		long long nar=~((xr&nyr)-(xi&nyi)), nai=~((xr&nyi)+(xi&nyr)), naj=~((xr&nyj)-(xi&nyk)), nak=~((xr&nyk)+(xi&nyj));
		long long nbr=~((nxr&yr)-(nxi&yi)), nbi=~((nxr&yi)+(nxi&yr)), nbj=~((nxr&yj)-(nxi&yk)), nbk=~((nxr&yk)+(nxi&yj));
		return Value(double(~((nar&nbr)-(nai&nbi)-(naj&nbj)-(nak&nbk))), double(~((nar&nbi)+(nai&nbr)+(naj&nbk)-(nak&nbj))), double(~((nar&nbj)-(nai&nbk)+(naj&nbr)+(nak&nbi))), double(~((nar&nbk)+(nai&nbj)-(naj&nbi)+(nak&nbr))));
	}
	Value qr_bitwise_xor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		long long xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), xj=convert_d2ll(x.j), xk=convert_d2ll(x.k), yr=convert_d2ll(y.r);
		long long nxr=~xr, nxi=~xi, nxj=~xj, nxk=~xk, nyr=~yr;
		long long nar=~(xr&nyr), nai=~(xi&nyr), naj=~(xj&nyr), nak=~(xk&nyr);
		long long nbr=~(nxr&yr), nbi=~(nxi&yr), nbj=~(nxj&yr), nbk=~(nxk&yr);
		return Value(double(~((nar&nbr)-(nai&nbi)-(naj&nbj)-(nak&nbk))), double(~((nar&nbi)+(nai&nbr)+(naj&nbk)-(nak&nbj))), double(~((nar&nbj)-(nai&nbk)+(naj&nbr)+(nak&nbi))), double(~((nar&nbk)+(nai&nbj)-(naj&nbi)+(nak&nbr))));
	}
	Value qc_bitwise_xor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), xj=convert_d2ll(x.j), xk=convert_d2ll(x.k), yr=convert_d2ll(y.r), yi=convert_d2ll(y.i);
		long long nxr=~xr, nxi=~xi, nxj=~xj, nxk=~xk, nyr=~yr, nyi=~yi;
		long long nar=~((xr&nyr)-(xi&nyi)), nai=~((xr&nyi)+(xi&nyr)), naj=~((xj&nyr)+(xk&nyi)), nak=~(-(xj&nyi)+(xk&nyr));
		long long nbr=~((nxr&yr)-(nxi&yi)), nbi=~((nxr&yi)+(nxi&yr)), nbj=~((nxj&yr)+(nxk&yi)), nbk=~(-(nxj&yi)+(nxk&yr));
		return Value(double(~((nar&nbr)-(nai&nbi)-(naj&nbj)-(nak&nbk))), double(~((nar&nbi)+(nai&nbr)+(naj&nbk)-(nak&nbj))), double(~((nar&nbj)-(nai&nbk)+(naj&nbr)+(nak&nbi))), double(~((nar&nbk)+(nai&nbj)-(naj&nbi)+(nak&nbr))));
	}
	Value qq_bitwise_xor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		//(x'y'+xy)'	=(x'y')'(xy)'	=(x+y)(x'+y')	=0+xy'+x'y+0	=xy'+x'y
		long long xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), xj=convert_d2ll(x.j), xk=convert_d2ll(x.k), yr=convert_d2ll(y.r), yi=convert_d2ll(y.i), yj=convert_d2ll(y.j), yk=convert_d2ll(y.k);
		long long nxr=~xr, nxi=~xi, nxj=~xj, nxk=~xk, nyr=~yr, nyi=~yi, nyj=~yj, nyk=~yk;
	//	return Value((xr&yr)-(xi&yi)-(xj&yj)-(xk&yk), (xr&yi)+(xi&yr)+(xj&yk)-(xk&yj), (xr&yj)-(xi&yk)+(xj&yr)+(xk&yi), (xr&yk)+(xi&yj)-(xj&yi)+(xk&yr));	//and
		long long nar=~((xr&nyr)-(xi&nyi)-(xj&nyj)-(xk&nyk)), nai=~((xr&nyi)+(xi&nyr)+(xj&nyk)-(xk&nyj)), naj=~((xr&nyj)-(xi&nyk)+(xj&nyr)+(xk&nyi)), nak=~((xr&nyk)+(xi&nyj)-(xj&nyi)+(xk&nyr));
		long long nbr=~((nxr&yr)-(nxi&yi)-(nxj&yj)-(nxk&yk)), nbi=~((nxr&yi)+(nxi&yr)+(nxj&yk)-(nxk&yj)), nbj=~((nxr&yj)-(nxi&yk)+(nxj&yr)+(nxk&yi)), nbk=~((nxr&yk)+(nxi&yj)-(nxj&yi)+(nxk&yr));
	//	return Value(~((nxr&nyr)-(nxi&nyi)-(nxj&nyj)-(nxk&nyk)), ~((nxr&nyi)+(nxi&nyr)+(nxj&nyk)-(nxk&nyj)), ~((nxr&nyj)-(nxi&nyk)+(nxj&nyr)+(nxk&nyi)), ~((nxr&nyk)+(nxi&nyj)-(nxj&nyi)+(nxk&nyr)));	//or
		return Value(double(~((nar&nbr)-(nai&nbi)-(naj&nbj)-(nak&nbk))), double(~((nar&nbi)+(nai&nbr)+(naj&nbk)-(nak&nbj))), double(~((nar&nbj)-(nai&nbk)+(naj&nbr)+(nak&nbi))), double(~((nar&nbk)+(nai&nbj)-(naj&nbi)+(nak&nbr))));
	}
	auto disc_r_bitwise_xor_o		=disc_r_bitwise_and_o;
	auto disc_c_bitwise_xor_o		=disc_c_bitwise_and_o;
	auto disc_q_bitwise_xor_o		=disc_q_bitwise_and_o;
	auto disc_rr_bitwise_xor_o		=disc_rr_bitwise_and_o;
	auto disc_rc_bitwise_xor_o		=disc_rc_bitwise_and_o;
	auto disc_rq_bitwise_xor_o		=disc_rq_bitwise_and_o;
	auto disc_cr_bitwise_xor_o		=disc_cr_bitwise_and_o;
	auto disc_cc_bitwise_xor_o		=disc_cc_bitwise_and_o;
	auto disc_cq_bitwise_xor_o		=disc_cq_bitwise_and_o;
	auto disc_qr_bitwise_xor_o		=disc_qr_bitwise_and_o;
	auto disc_qc_bitwise_xor_o		=disc_qc_bitwise_and_o;
	auto disc_qq_bitwise_xor_o		=disc_qq_bitwise_and_o;
	
	Value  r_bitwise_xnor			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r))
			return 0;
		return bitwise_xnor(x);
	}
	Value  c_bitwise_xnor			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i))
			return 0;
		return Value(bitwise_xnor(x.r), bitwise_xnor(x.i));
	}
	Value  q_bitwise_xnor			(Value const &x)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k))
			return 0;
		return Value(bitwise_xnor(x.r), bitwise_xnor(x.i), bitwise_xnor(x.j), bitwise_xnor(x.k));
	}
	Value rr_bitwise_xnor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		return double(~(convert_d2ll(x)^convert_d2ll(y)));
	}
	Value rc_bitwise_xnor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long xr=convert_d2ll(x.r), yr=convert_d2ll(y.r), yi=convert_d2ll(y.i);
		long long nxr=~xr, nyr=~yr, nyi=~yi;
		long long nar=~(nxr&nyr), nai=~(nxr&nyi);
		long long nbr=~(xr&yr), nbi=~(xr&yi);
		return Value(double(~((nar&nbr)-(nai&nbi))), double(~((nar&nbi)+(nai&nbr))));
	}
	Value rq_bitwise_xnor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long xr=convert_d2ll(x.r), yr=convert_d2ll(y.r), yi=convert_d2ll(y.i), yj=convert_d2ll(y.j), yk=convert_d2ll(y.k);
		long long nxr=~xr, nyr=~yr, nyi=~yi, nyj=~yj, nyk=~yk;
		long long nar=~(nxr&nyr), nai=~(nxr&nyi), naj=~(nxr&nyj), nak=~(nxr&nyk);
		long long nbr=~(xr&yr), nbi=~(xr&yi), nbj=~(xr&yj), nbk=~(xr&yk);
		return Value(double(~((nar&nbr)-(nai&nbi)-(naj&nbj)-(nak&nbk))), double(~((nar&nbi)+(nai&nbr)+(naj&nbk)-(nak&nbj))), double(~((nar&nbj)-(nai&nbk)+(naj&nbr)+(nak&nbi))), double(~((nar&nbk)+(nai&nbj)-(naj&nbi)+(nak&nbr))));
	}
	Value cr_bitwise_xnor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		long long xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), yr=convert_d2ll(y.r);
		long long nxr=~xr, nxi=~xi, nyr=~yr;
		long long nar=~(nxr&nyr), nai=~(nxi&nyr);
		long long nbr=~(xr&yr), nbi=~(xi&yr);
		return Value(double(~((nar&nbr)-(nai&nbi))), double(~((nar&nbi)+(nai&nbr))));
	}
	Value cc_bitwise_xnor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), yr=convert_d2ll(y.r), yi=convert_d2ll(y.i);
		long long nxr=~xr, nxi=~xi, nyr=~yr, nyi=~yi;
		long long nar=~((nxr&nyr)-(nxi&nyi)), nai=~((nxr&nyi)+(nxi&nyr));
		long long nbr=~((xr&yr)-(xi&yi)), nbi=~((xr&yi)+(xi&yr));
		return Value(double(~((nar&nbr)-(nai&nbi))), double(~((nar&nbi)+(nai&nbr))));
	}
	Value cq_bitwise_xnor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		long long xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), yr=convert_d2ll(y.r), yi=convert_d2ll(y.i), yj=convert_d2ll(y.j), yk=convert_d2ll(y.k);
		long long nxr=~xr, nxi=~xi, nyr=~yr, nyi=~yi, nyj=~yj, nyk=~yk;
		long long nar=~((nxr&nyr)-(nxi&nyi)), nai=~((nxr&nyi)+(nxi&nyr)), naj=~((nxr&nyj)-(nxi&nyk)), nak=~((nxr&nyk)+(nxi&nyj));
		long long nbr=~((xr&yr)-(xi&yi)), nbi=~((xr&yi)+(xi&yr)), nbj=~((xr&yj)-(xi&yk)), nbk=~((xr&yk)+(xi&yj));
		return Value(double(~((nar&nbr)-(nai&nbi)-(naj&nbj)-(nak&nbk))), double(~((nar&nbi)+(nai&nbr)+(naj&nbk)-(nak&nbj))), double(~((nar&nbj)-(nai&nbk)+(naj&nbr)+(nak&nbi))), double(~((nar&nbk)+(nai&nbj)-(naj&nbi)+(nak&nbr))));
	}
	Value qr_bitwise_xnor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r))
			return 0;
		long long xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), xj=convert_d2ll(x.j), xk=convert_d2ll(x.k), yr=convert_d2ll(y.r);
		long long nxr=~xr, nxi=~xi, nxj=~xj, nxk=~xk, nyr=~yr;
		long long nar=~(nxr&nyr), nai=~(nxi&nyr), naj=~(nxj&nyr), nak=~(nxk&nyr);
		long long nbr=~(xr&yr), nbi=~(xi&yr), nbj=~(xj&yr), nbk=~(xk&yr);
		return Value(double(~((nar&nbr)-(nai&nbi)-(naj&nbj)-(nak&nbk))), double(~((nar&nbi)+(nai&nbr)+(naj&nbk)-(nak&nbj))), double(~((nar&nbj)-(nai&nbk)+(naj&nbr)+(nak&nbi))), double(~((nar&nbk)+(nai&nbj)-(naj&nbi)+(nak&nbr))));
	}
	Value qc_bitwise_xnor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i))
			return 0;
		long long xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), xj=convert_d2ll(x.j), xk=convert_d2ll(x.k), yr=convert_d2ll(y.r), yi=convert_d2ll(y.i);
		long long nxr=~xr, nxi=~xi, nxj=~xj, nxk=~xk, nyr=~yr, nyi=~yi;
		long long nar=~((nxr&nyr)-(nxi&nyi)), nai=~((nxr&nyi)+(nxi&nyr)), naj=~((nxj&nyr)+(nxk&nyi)), nak=~(-(nxj&nyi)+(nxk&nyr));
		long long nbr=~((xr&yr)-(xi&yi)), nbi=~((xr&yi)+(xi&yr)), nbj=~((xj&yr)+(xk&yi)), nbk=~(-(xj&yi)+(xk&yr));
		return Value(double(~((nar&nbr)-(nai&nbi)-(naj&nbj)-(nak&nbk))), double(~((nar&nbi)+(nai&nbr)+(naj&nbk)-(nak&nbj))), double(~((nar&nbj)-(nai&nbk)+(naj&nbr)+(nak&nbi))), double(~((nar&nbk)+(nai&nbj)-(naj&nbi)+(nak&nbr))));
	}
	Value qq_bitwise_xnor			(Value const &x, Value const &y)
	{
		if(std::isnan(x.r)||std::isinf(x.r)||std::isnan(x.i)||std::isinf(x.i)||std::isnan(x.j)||std::isinf(x.j)||std::isnan(x.k)||std::isinf(x.k)||
			std::isinf(y.r)||std::isinf(y.r)||std::isinf(y.i)||std::isinf(y.i)||std::isinf(y.j)||std::isinf(y.j)||std::isinf(y.k)||std::isinf(y.k))
			return 0;
		//(xy'+x'y)'	=(xy')'(x'y)'	=(x'+y)(x+y')	=0+x'y'+xy+0	=x'y'+xy
		long long xr=convert_d2ll(x.r), xi=convert_d2ll(x.i), xj=convert_d2ll(x.j), xk=convert_d2ll(x.k), yr=convert_d2ll(y.r), yi=convert_d2ll(y.i), yj=convert_d2ll(y.j), yk=convert_d2ll(y.k);
		long long nxr=~xr, nxi=~xi, nxj=~xj, nxk=~xk, nyr=~yr, nyi=~yi, nyj=~yj, nyk=~yk;
	//	return Value((xr&yr)-(xi&yi)-(xj&yj)-(xk&yk), (xr&yi)+(xi&yr)+(xj&yk)-(xk&yj), (xr&yj)-(xi&yk)+(xj&yr)+(xk&yi), (xr&yk)+(xi&yj)-(xj&yi)+(xk&yr));
		long long nar=~((nxr&nyr)-(nxi&nyi)-(nxj&nyj)-(nxk&nyk)), nai=~((nxr&nyi)+(nxi&nyr)+(nxj&nyk)-(nxk&nyj)), naj=~((nxr&nyj)-(nxi&nyk)+(nxj&nyr)+(nxk&nyi)), nak=~((nxr&nyk)+(nxi&nyj)-(nxj&nyi)+(nxk&nyr));
		long long nbr=~((xr&yr)-(xi&yi)-(xj&yj)-(xk&yk)), nbi=~((xr&yi)+(xi&yr)+(xj&yk)-(xk&yj)), nbj=~((xr&yj)-(xi&yk)+(xj&yr)+(xk&yi)), nbk=~((xr&yk)+(xi&yj)-(xj&yi)+(xk&yr));
		return Value(double(~((nar&nbr)-(nai&nbi)-(naj&nbj)-(nak&nbk))), double(~((nar&nbi)+(nai&nbr)+(naj&nbk)-(nak&nbj))), double(~((nar&nbj)-(nai&nbk)+(naj&nbr)+(nak&nbi))), double(~((nar&nbk)+(nai&nbj)-(naj&nbi)+(nak&nbr))));
	}
	auto disc_r_bitwise_xnor_o		=disc_r_bitwise_and_o;
	auto disc_c_bitwise_xnor_o		=disc_c_bitwise_and_o;
	auto disc_q_bitwise_xnor_o		=disc_q_bitwise_and_o;
	auto disc_rr_bitwise_xnor_o		=disc_rr_bitwise_and_o;
	auto disc_rc_bitwise_xnor_o		=disc_rc_bitwise_and_o;
	auto disc_rq_bitwise_xnor_o		=disc_rq_bitwise_and_o;
	auto disc_cr_bitwise_xnor_o		=disc_cr_bitwise_and_o;
	auto disc_cc_bitwise_xnor_o		=disc_cc_bitwise_and_o;
	auto disc_cq_bitwise_xnor_o		=disc_cq_bitwise_and_o;
	auto disc_qr_bitwise_xnor_o		=disc_qr_bitwise_and_o;
	auto disc_qc_bitwise_xnor_o		=disc_qc_bitwise_and_o;
	auto disc_qq_bitwise_xnor_o		=disc_qq_bitwise_and_o;

	Value  r_logic_equal			(Value const &x)				{return !x;}
	Value  c_logic_equal			(Value const &x)				{return !x.c_isTrue();}
	Value  q_logic_equal			(Value const &x)				{return !x.q_isTrue();}
	Value rr_logic_equal			(Value const &x, Value const &y){return x.r==y.r;}
	Value rc_logic_equal			(Value const &x, Value const &y){return x.r==y.r&&y.i==  0;}
	Value rq_logic_equal			(Value const &x, Value const &y){return x.r==y.r&&y.i==  0&&y.j==  0&&y.k==  0;}
	Value cr_logic_equal			(Value const &x, Value const &y){return x.r==y.r&&x.i==  0;}
	Value cc_logic_equal			(Value const &x, Value const &y){return x.r==y.r&&x.i==y.i;}
	Value cq_logic_equal			(Value const &x, Value const &y){return x.r==y.r&&x.i==y.i&&y.j==  0&&y.k==  0;}
	Value qr_logic_equal			(Value const &x, Value const &y){return x.r==y.r&&x.i==  0&&x.j==  0&&x.k==  0;}
	Value qc_logic_equal			(Value const &x, Value const &y){return x.r==y.r&&x.i==y.i&&x.j==  0&&x.k==  0;}
	Value qq_logic_equal			(Value const &x, Value const &y){return x.r==y.r&&x.i==y.i&&x.j==y.j&&x.k==y.k;}
	bool disc_x_logic_equal			(double x0, double x1)
	{
		if(x0<0)	return x1>=0;
		if(x0==0)	return x1<0||x1>0;
					return x1<=0;
	}
	bool disc_r_logic_equal_i		(Value const &x0, Value const &x1){return disc_x_logic_equal(x0.r, x1.r);}
	bool disc_c_logic_equal_i		(Value const &x0, Value const &x1){return disc_x_logic_equal(x0.r, x1.r)&&disc_x_logic_equal(x0.i, x1.i);}
	bool disc_q_logic_equal_i		(Value const &x0, Value const &x1){return disc_x_logic_equal(x0.r, x1.r)&&disc_x_logic_equal(x0.i, x1.i)&&disc_x_logic_equal(x0.j, x1.j)&&disc_x_logic_equal(x0.k, x1.k);}
	bool disc_rr_logic_equal_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_equal(x0.r-y0.r, x1.r-y1.r);}
	bool disc_rc_logic_equal_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_equal(x0.r-y0.r, x1.r-y1.r)&&disc_x_logic_equal(-y0.i, -y1.i);}
	bool disc_rq_logic_equal_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_equal(x0.r-y0.r, x1.r-y1.r)&&disc_x_logic_equal(-y0.i, -y1.i)&&disc_x_logic_equal(-y0.j, -y1.j)&&disc_x_logic_equal(-y0.k, -y1.k);}
	bool disc_cr_logic_equal_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_equal(x0.r-y0.r, x1.r-y1.r)&&disc_x_logic_equal(x0.i, x1.i);}
	bool disc_cc_logic_equal_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_equal(x0.r-y0.r, x1.r-y1.r)&&disc_x_logic_equal(x0.i-y0.i, x1.i-y1.i);}
	bool disc_cq_logic_equal_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_equal(x0.r-y0.r, x1.r-y1.r)&&disc_x_logic_equal(x0.i-y0.i, x1.i-y1.i)&&disc_x_logic_equal(-y0.j, -y1.j)&&disc_x_logic_equal(-y0.k, -y1.k);}
	bool disc_qr_logic_equal_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_equal(x0.r-y0.r, x1.r-y1.r)&&disc_x_logic_equal(x0.i, x1.i)&&disc_x_logic_equal(x0.j, x1.j)&&disc_x_logic_equal(x0.k, x1.k);}
	bool disc_qc_logic_equal_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_equal(x0.r-y0.r, x1.r-y1.r)&&disc_x_logic_equal(x0.i-y0.i, x1.i-y1.i)&&disc_x_logic_equal(x0.j, x1.j)&&disc_x_logic_equal(x0.k, x1.k);}
	bool disc_qq_logic_equal_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_equal(x0.r-y0.r, x1.r-y1.r)&&disc_x_logic_equal(x0.i-y0.i, x1.i-y1.i)&&disc_x_logic_equal(x0.j-y0.j, x1.j-y1.j)&&disc_x_logic_equal(x0.k-y0.k, x1.k-y1.k);}

	Value  r_logic_not_equal		(Value const &x)				{return x!=0;}
	Value  c_logic_not_equal		(Value const &x)				{return x.c_isTrue();}
	Value  q_logic_not_equal		(Value const &x)				{return x.q_isTrue();}
	Value rr_logic_not_equal		(Value const &x, Value const &y){return x.r!=y.r;}
	Value rc_logic_not_equal		(Value const &x, Value const &y){return x.r!=y.r||y.i!=  0;}
	Value rq_logic_not_equal		(Value const &x, Value const &y){return x.r!=y.r||y.i!=  0||y.j!=  0||y.k!=  0;}
	Value cr_logic_not_equal		(Value const &x, Value const &y){return x.r!=y.r||x.i!=  0;}
	Value cc_logic_not_equal		(Value const &x, Value const &y){return x.r!=y.r||x.i!=y.i;}
	Value cq_logic_not_equal		(Value const &x, Value const &y){return x.r!=y.r||x.i!=y.i||y.j!=  0||y.k!=  0;}
	Value qr_logic_not_equal		(Value const &x, Value const &y){return x.r!=y.r||x.i!=  0||x.j!=  0||x.k!=  0;}
	Value qc_logic_not_equal		(Value const &x, Value const &y){return x.r!=y.r||x.i!=y.i||x.j!=  0||x.k!=  0;}
	Value qq_logic_not_equal		(Value const &x, Value const &y){return x.r!=y.r||x.i!=y.i||x.j!=y.j||x.k!=y.k;}
	auto disc_r_logic_not_equal_i		=disc_r_logic_equal_i;
	auto disc_c_logic_not_equal_i		=disc_c_logic_equal_i;
	auto disc_q_logic_not_equal_i		=disc_q_logic_equal_i;
	auto disc_rr_logic_not_equal_i		=disc_rr_logic_equal_i;
	auto disc_rc_logic_not_equal_i		=disc_rc_logic_equal_i;
	auto disc_rq_logic_not_equal_i		=disc_rq_logic_equal_i;
	auto disc_cr_logic_not_equal_i		=disc_cr_logic_equal_i;
	auto disc_cc_logic_not_equal_i		=disc_cc_logic_equal_i;
	auto disc_cq_logic_not_equal_i		=disc_cq_logic_equal_i;
	auto disc_qr_logic_not_equal_i		=disc_qr_logic_equal_i;
	auto disc_qc_logic_not_equal_i		=disc_qc_logic_equal_i;
	auto disc_qq_logic_not_equal_i		=disc_qq_logic_equal_i;

	Value  r_logic_less_l			(Value const &x)				{return 0<x;}
	Value  c_logic_less_l			(Value const &x)				{return 0<x.r;}
	Value  q_logic_less_l			(Value const &x)				{return 0<x.r;}
	Value  r_logic_less_r			(Value const &x)				{return x<0;}
	Value  c_logic_less_r			(Value const &x)				{return x.r<0;}
	Value  q_logic_less_r			(Value const &x)				{return x.r<0;}
	Value rr_logic_less				(Value const &x, Value const &y){return x<y;}
	Value rc_logic_less				(Value const &x, Value const &y){return x<y.r;}
	Value rq_logic_less				(Value const &x, Value const &y){return x<y.r;}
	Value cr_logic_less				(Value const &x, Value const &y){return x.r<y.r;}
	Value cc_logic_less				(Value const &x, Value const &y){return x.r<y.r;}
	Value cq_logic_less				(Value const &x, Value const &y){return x.r<y.r;}
	Value qr_logic_less				(Value const &x, Value const &y){return x.r<y;}
	Value qc_logic_less				(Value const &x, Value const &y){return x.r<y.r;}
	Value qq_logic_less				(Value const &x, Value const &y){return x.r<y.r;}
	bool disc_x_logic_less			(double x0, double x1){return x0<0?x1>=0:x1<0;}//	__|0__
	bool disc_r_logic_less_l_i		(Value const &x0, Value const &x1){return disc_x_logic_less(-x0.r, -x1.r);}
	auto disc_c_logic_less_l_i		=disc_r_logic_less_l_i;
	auto disc_q_logic_less_l_i		=disc_r_logic_less_l_i;
	bool disc_r_logic_less_r_i		(Value const &x0, Value const &x1){return disc_x_logic_less(x0.r, x1.r);}
	auto disc_c_logic_less_r_i		=disc_r_logic_less_r_i;
	auto disc_q_logic_less_r_i		=disc_r_logic_less_r_i;
	bool disc_rr_logic_less_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_less(x0.r-y0.r, x1.r-y1.r);}
	auto disc_rc_logic_less_i		=disc_rr_logic_less_i;
	auto disc_rq_logic_less_i		=disc_rr_logic_less_i;
	auto disc_cr_logic_less_i		=disc_rr_logic_less_i;
	auto disc_cc_logic_less_i		=disc_rr_logic_less_i;
	auto disc_cq_logic_less_i		=disc_rr_logic_less_i;
	auto disc_qr_logic_less_i		=disc_rr_logic_less_i;
	auto disc_qc_logic_less_i		=disc_rr_logic_less_i;
	auto disc_qq_logic_less_i		=disc_rr_logic_less_i;

	Value  r_logic_less_equal_l		(Value const &x)				{return 0<=x;}
	Value  c_logic_less_equal_l		(Value const &x)				{return 0<=x.r;}
	Value  q_logic_less_equal_l		(Value const &x)				{return 0<=x.r;}
	Value  r_logic_less_equal_r		(Value const &x)				{return x<=0;}
	Value  c_logic_less_equal_r		(Value const &x)				{return x.r<=0;}
	Value  q_logic_less_equal_r		(Value const &x)				{return x.r<=0;}
	Value rr_logic_less_equal		(Value const &x, Value const &y){return x<=y;}
	Value rc_logic_less_equal		(Value const &x, Value const &y){return x<=y.r;}
	Value rq_logic_less_equal		(Value const &x, Value const &y){return x<=y.r;}
	Value cr_logic_less_equal		(Value const &x, Value const &y){return x.r<=y.r;}
	Value cc_logic_less_equal		(Value const &x, Value const &y){return x.r<=y.r;}
	Value cq_logic_less_equal		(Value const &x, Value const &y){return x.r<=y.r;}
	Value qr_logic_less_equal		(Value const &x, Value const &y){return x.r<=y;}
	Value qc_logic_less_equal		(Value const &x, Value const &y){return x.r<=y.r;}
	Value qq_logic_less_equal		(Value const &x, Value const &y){return x.r<=y.r;}
	bool disc_x_logic_less_equal		(double x0, double x1){return x0<=0?x1>0:x1<=0;}//	__0|__
	bool disc_r_logic_less_equal_l_i	(Value const &x0, Value const &x1){return disc_x_logic_less_equal(-x0.r, -x1.r);}
	auto disc_c_logic_less_equal_l_i	=disc_r_logic_less_equal_l_i;
	auto disc_q_logic_less_equal_l_i	=disc_r_logic_less_equal_l_i;
	bool disc_r_logic_less_equal_r_i	(Value const &x0, Value const &x1){return disc_x_logic_less_equal(x0.r, x1.r);}
	auto disc_c_logic_less_equal_r_i	=disc_r_logic_less_equal_r_i;
	auto disc_q_logic_less_equal_r_i	=disc_r_logic_less_equal_r_i;
	bool disc_rr_logic_less_equal_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_r_logic_less_equal_r_i(x0.r-y0.r, x1.r-y1.r);}
	auto disc_rc_logic_less_equal_i		=disc_rr_logic_less_equal_i;
	auto disc_rq_logic_less_equal_i		=disc_rr_logic_less_equal_i;
	auto disc_cr_logic_less_equal_i		=disc_rr_logic_less_equal_i;
	auto disc_cc_logic_less_equal_i		=disc_rr_logic_less_equal_i;
	auto disc_cq_logic_less_equal_i		=disc_rr_logic_less_equal_i;
	auto disc_qr_logic_less_equal_i		=disc_rr_logic_less_equal_i;
	auto disc_qc_logic_less_equal_i		=disc_rr_logic_less_equal_i;
	auto disc_qq_logic_less_equal_i		=disc_rr_logic_less_equal_i;

	Value  r_logic_greater_l		(Value const &x)				{return 0>x;}
	Value  c_logic_greater_l		(Value const &x)				{return 0>x.r;}
	Value  q_logic_greater_l		(Value const &x)				{return 0>x.r;}
	Value  r_logic_greater_r		(Value const &x)				{return x>0;}
	Value  c_logic_greater_r		(Value const &x)				{return x.r>0;}
	Value  q_logic_greater_r		(Value const &x)				{return x.r>0;}
	Value rr_logic_greater			(Value const &x, Value const &y){return x>y;}
	Value rc_logic_greater			(Value const &x, Value const &y){return x>y.r;}
	Value rq_logic_greater			(Value const &x, Value const &y){return x>y.r;}
	Value cr_logic_greater			(Value const &x, Value const &y){return x.r>y.r;}
	Value cc_logic_greater			(Value const &x, Value const &y){return x.r>y.r;}
	Value cq_logic_greater			(Value const &x, Value const &y){return x.r>y.r;}
	Value qr_logic_greater			(Value const &x, Value const &y){return x.r>y;}
	Value qc_logic_greater			(Value const &x, Value const &y){return x.r>y.r;}
	Value qq_logic_greater			(Value const &x, Value const &y){return x.r>y.r;}
	auto disc_r_logic_greater_l_i	=disc_r_logic_less_equal_l_i;
	auto disc_c_logic_greater_l_i	=disc_c_logic_less_equal_l_i;
	auto disc_q_logic_greater_l_i	=disc_q_logic_less_equal_l_i;
	auto disc_r_logic_greater_r_i	=disc_r_logic_less_equal_r_i;
	auto disc_c_logic_greater_r_i	=disc_c_logic_less_equal_r_i;
	auto disc_q_logic_greater_r_i	=disc_q_logic_less_equal_r_i;
	auto disc_rr_logic_greater_i	=disc_rr_logic_less_equal_i;
	auto disc_rc_logic_greater_i	=disc_rc_logic_less_equal_i;
	auto disc_rq_logic_greater_i	=disc_rq_logic_less_equal_i;
	auto disc_cr_logic_greater_i	=disc_cr_logic_less_equal_i;
	auto disc_cc_logic_greater_i	=disc_cc_logic_less_equal_i;
	auto disc_cq_logic_greater_i	=disc_cq_logic_less_equal_i;
	auto disc_qr_logic_greater_i	=disc_qr_logic_less_equal_i;
	auto disc_qc_logic_greater_i	=disc_qc_logic_less_equal_i;
	auto disc_qq_logic_greater_i	=disc_qq_logic_less_equal_i;

	Value  r_logic_greater_equal_l	(Value const &x)				{return 0>=x;}
	Value  c_logic_greater_equal_l	(Value const &x)				{return 0>=x.r;}
	Value  q_logic_greater_equal_l	(Value const &x)				{return 0>=x.r;}
	Value  r_logic_greater_equal_r	(Value const &x)				{return x>=0;}
	Value  c_logic_greater_equal_r	(Value const &x)				{return x.r>=0;}
	Value  q_logic_greater_equal_r	(Value const &x)				{return x.r>=0;}
	Value rr_logic_greater_equal	(Value const &x, Value const &y){return x>=y;}
	Value rc_logic_greater_equal	(Value const &x, Value const &y){return x>=y.r;}
	Value rq_logic_greater_equal	(Value const &x, Value const &y){return x>=y.r;}
	Value cr_logic_greater_equal	(Value const &x, Value const &y){return x.r>=y.r;}
	Value cc_logic_greater_equal	(Value const &x, Value const &y){return x.r>=y.r;}
	Value cq_logic_greater_equal	(Value const &x, Value const &y){return x.r>=y.r;}
	Value qr_logic_greater_equal	(Value const &x, Value const &y){return x.r>=y;}
	Value qc_logic_greater_equal	(Value const &x, Value const &y){return x.r>=y.r;}
	Value qq_logic_greater_equal	(Value const &x, Value const &y){return x.r>=y.r;}
	auto disc_r_logic_greater_equal_l_i	=disc_r_logic_less_l_i;
	auto disc_c_logic_greater_equal_l_i	=disc_c_logic_less_l_i;
	auto disc_q_logic_greater_equal_l_i	=disc_q_logic_less_l_i;
	auto disc_r_logic_greater_equal_r_i	=disc_r_logic_less_r_i;
	auto disc_c_logic_greater_equal_r_i	=disc_c_logic_less_r_i;
	auto disc_q_logic_greater_equal_r_i	=disc_q_logic_less_r_i;
	auto disc_rr_logic_greater_equal_i	=disc_rr_logic_less_i;
	auto disc_rc_logic_greater_equal_i	=disc_rc_logic_less_i;
	auto disc_rq_logic_greater_equal_i	=disc_rq_logic_less_i;
	auto disc_cr_logic_greater_equal_i	=disc_cr_logic_less_i;
	auto disc_cc_logic_greater_equal_i	=disc_cc_logic_less_i;
	auto disc_cq_logic_greater_equal_i	=disc_cq_logic_less_i;
	auto disc_qr_logic_greater_equal_i	=disc_qr_logic_less_i;
	auto disc_qc_logic_greater_equal_i	=disc_qc_logic_less_i;
	auto disc_qq_logic_greater_equal_i	=disc_qq_logic_less_i;

	Value  r_logic_not				(Value const &x)				{return !x;}
	Value  c_logic_not				(Value const &x)				{return !x.c_isTrue();}
	Value  q_logic_not				(Value const &x)				{return !x.q_isTrue();}
	auto disc_r_logic_not_i			=disc_r_divide_i;
	auto disc_c_logic_not_i			=disc_c_divide_i;
	auto disc_q_logic_not_i			=disc_q_divide_i;

	Value rr_logic_and				(Value const &x, Value const &y){return x&&y;}
	Value rc_logic_and				(Value const &x, Value const &y){return x&&y.c_isTrue();}
	Value rq_logic_and				(Value const &x, Value const &y){return x&&y.q_isTrue();}
	Value cr_logic_and				(Value const &x, Value const &y){return x.c_isTrue()&&y;}
	Value cc_logic_and				(Value const &x, Value const &y){return x.c_isTrue()&&y.c_isTrue();}
	Value cq_logic_and				(Value const &x, Value const &y){return x.c_isTrue()&&y.q_isTrue();}
	Value qr_logic_and				(Value const &x, Value const &y){return x.q_isTrue()&&y;}
	Value qc_logic_and				(Value const &x, Value const &y){return x.q_isTrue()&&y.c_isTrue();}
	Value qq_logic_and				(Value const &x, Value const &y){return x.q_isTrue()&&y.q_isTrue();}
	bool disc_x_logic_and			(double x0, double x1)
	{
		if(x0<0)	return x1>=0;
		if(x0==0)	return x1<0||x1>0;
					return x1<=0;
	}
	bool disc_rr_logic_and_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)||disc_x_logic_and(y0.r, y1.r);}
	bool disc_rc_logic_and_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)||disc_x_logic_and(y0.r, y1.r)&&disc_x_logic_and(y0.i, y1.i);}
	bool disc_rq_logic_and_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)||disc_x_logic_and(y0.r, y1.r)&&disc_x_logic_and(y0.i, y1.i)&&disc_x_logic_and(y0.j, y1.j)&&disc_x_logic_and(y0.k, y1.k);}
	bool disc_cr_logic_and_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)&&disc_x_logic_and(x0.i, x1.i)||disc_x_logic_and(y0.r, y1.r);}
	bool disc_cc_logic_and_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)&&disc_x_logic_and(x0.i, x1.i)||disc_x_logic_and(y0.r, y1.r)&&disc_x_logic_and(y0.i, y1.i);}
	bool disc_cq_logic_and_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)&&disc_x_logic_and(x0.i, x1.i)||disc_x_logic_and(y0.r, y1.r)&&disc_x_logic_and(y0.i, y1.i)&&disc_x_logic_and(y0.j, y1.j)&&disc_x_logic_and(y0.k, y1.k);}
	bool disc_qr_logic_and_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)&&disc_x_logic_and(x0.i, x1.i)&&disc_x_logic_and(x0.j, x1.j)&&disc_x_logic_and(x0.k, x1.k)||disc_x_logic_and(y0.r, y1.r);}
	bool disc_qc_logic_and_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)&&disc_x_logic_and(x0.i, x1.i)&&disc_x_logic_and(x0.j, x1.j)&&disc_x_logic_and(x0.k, x1.k)||disc_x_logic_and(y0.r, y1.r)&&disc_x_logic_and(y0.i, y1.i);}
	bool disc_qq_logic_and_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)&&disc_x_logic_and(x0.i, x1.i)&&disc_x_logic_and(x0.j, x1.j)&&disc_x_logic_and(x0.k, x1.k)||disc_x_logic_and(y0.r, y1.r)&&disc_x_logic_and(y0.i, y1.i)&&disc_x_logic_and(y0.j, y1.j)&&disc_x_logic_and(y0.k, y1.k);}

	Value rr_logic_or				(Value const &x, Value const &y){return x!=0||y!=0;}
	Value rc_logic_or				(Value const &x, Value const &y){return x!=0||y.c_isTrue();}
	Value rq_logic_or				(Value const &x, Value const &y){return x!=0||y.q_isTrue();}
	Value cr_logic_or				(Value const &x, Value const &y){return x.c_isTrue()||y;}
	Value cc_logic_or				(Value const &x, Value const &y){return x.c_isTrue()||y.c_isTrue();}
	Value cq_logic_or				(Value const &x, Value const &y){return x.c_isTrue()||y.q_isTrue();}
	Value qr_logic_or				(Value const &x, Value const &y){return x.q_isTrue()||y;}
	Value qc_logic_or				(Value const &x, Value const &y){return x.q_isTrue()||y.c_isTrue();}
	Value qq_logic_or				(Value const &x, Value const &y){return x.q_isTrue()||y.q_isTrue();}
	bool disc_rr_logic_or_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)&&disc_x_logic_and(y0.r, y1.r);}
	bool disc_rc_logic_or_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)&&disc_x_logic_and(y0.r, y1.r)&&disc_x_logic_and(y0.i, y1.i);}
	bool disc_rq_logic_or_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)&&disc_x_logic_and(y0.r, y1.r)&&disc_x_logic_and(y0.i, y1.i)&&disc_x_logic_and(y0.j, y1.j)&&disc_x_logic_and(y0.k, y1.k);}
	bool disc_cr_logic_or_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)&&disc_x_logic_and(x0.i, x1.i)&&disc_x_logic_and(y0.r, y1.r);}
	bool disc_cc_logic_or_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)&&disc_x_logic_and(x0.i, x1.i)&&disc_x_logic_and(y0.r, y1.r)&&disc_x_logic_and(y0.i, y1.i);}
	bool disc_cq_logic_or_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)&&disc_x_logic_and(x0.i, x1.i)&&disc_x_logic_and(y0.r, y1.r)&&disc_x_logic_and(y0.i, y1.i)&&disc_x_logic_and(y0.j, y1.j)&&disc_x_logic_and(y0.k, y1.k);}
	bool disc_qr_logic_or_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)&&disc_x_logic_and(x0.i, x1.i)&&disc_x_logic_and(x0.j, x1.j)&&disc_x_logic_and(x0.k, x1.k)&&disc_x_logic_and(y0.r, y1.r);}
	bool disc_qc_logic_or_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)&&disc_x_logic_and(x0.i, x1.i)&&disc_x_logic_and(x0.j, x1.j)&&disc_x_logic_and(x0.k, x1.k)&&disc_x_logic_and(y0.r, y1.r)&&disc_x_logic_and(y0.i, y1.i);}
	bool disc_qq_logic_or_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_x_logic_and(x0.r, x1.r)&&disc_x_logic_and(x0.i, x1.i)&&disc_x_logic_and(x0.j, x1.j)&&disc_x_logic_and(x0.k, x1.k)&&disc_x_logic_and(y0.r, y1.r)&&disc_x_logic_and(y0.i, y1.i)&&disc_x_logic_and(y0.j, y1.j)&&disc_x_logic_and(y0.k, y1.k);}

	Value rr_logic_xor				(Value const &x, Value const &y){return x.r_isTrue()^y.r_isTrue();}
	Value rc_logic_xor				(Value const &x, Value const &y){return x.r_isTrue()^y.c_isTrue();}
	Value rq_logic_xor				(Value const &x, Value const &y){return x.r_isTrue()^y.q_isTrue();}
	Value cr_logic_xor				(Value const &x, Value const &y){return x.c_isTrue()^y.r_isTrue();}
	Value cc_logic_xor				(Value const &x, Value const &y){return x.c_isTrue()^y.c_isTrue();}
	Value cq_logic_xor				(Value const &x, Value const &y){return x.c_isTrue()^y.q_isTrue();}
	Value qr_logic_xor				(Value const &x, Value const &y){return x.q_isTrue()^y.r_isTrue();}
	Value qc_logic_xor				(Value const &x, Value const &y){return x.q_isTrue()^y.c_isTrue();}
	Value qq_logic_xor				(Value const &x, Value const &y){return x.q_isTrue()^y.q_isTrue();}
	auto disc_rr_logic_xor_i		=disc_rr_logic_and_i;
	auto disc_rc_logic_xor_i		=disc_rc_logic_and_i;
	auto disc_rq_logic_xor_i		=disc_rq_logic_and_i;
	auto disc_cr_logic_xor_i		=disc_cr_logic_and_i;
	auto disc_cc_logic_xor_i		=disc_cc_logic_and_i;
	auto disc_cq_logic_xor_i		=disc_cq_logic_and_i;
	auto disc_qr_logic_xor_i		=disc_qr_logic_and_i;
	auto disc_qc_logic_xor_i		=disc_qc_logic_and_i;
	auto disc_qq_logic_xor_i		=disc_qq_logic_and_i;

	Value rr_logic_condition_zero	(Value const &x, Value const &y){return x!=0?x:y;}
	Value rc_logic_condition_zero	(Value const &x, Value const &y){return x!=0?x:y;}
	Value rq_logic_condition_zero	(Value const &x, Value const &y){return x!=0?x:y;}
	Value cr_logic_condition_zero	(Value const &x, Value const &y){return x.c_isTrue()?x:y;}
	Value cc_logic_condition_zero	(Value const &x, Value const &y){return x.c_isTrue()?x:y;}
	Value cq_logic_condition_zero	(Value const &x, Value const &y){return x.c_isTrue()?x:y;}
	Value qr_logic_condition_zero	(Value const &x, Value const &y){return x.q_isTrue()?x:y;}
	Value qc_logic_condition_zero	(Value const &x, Value const &y){return x.q_isTrue()?x:y;}
	Value qq_logic_condition_zero	(Value const &x, Value const &y){return x.q_isTrue()?x:y;}
	bool disc_rr_logic_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1)
	{
		return _1d_zero_in_range(x0.r, x1.r)||_1d_zero_in_range(x0.i, x1.i)||_1d_zero_in_range(x0.j, x1.j)||_1d_zero_in_range(x0.k, x1.k);
	//	if(x0<0)	return x0>=0;
	//	if(x0==0)	return x0<0||x0>0;
	//				return x0<=0;
	}
	bool disc_rc_logic_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rq_logic_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_logic_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cc_logic_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_logic_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_logic_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_logic_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_logic_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value  r_percent				(Value const &x)				{return x*.01;}
	Value  c_percent				(Value const &x)				{return (std::complex<double>)x*.01;}
	Value  q_percent				(Value const &x)				{return (boost::math::quaternion<double>)x*.01;}

	Value rr_modulo					(Value const &x, Value const &y)//http://en.wikipedia.org/wiki/Modulo_operation
	{
		if(y)//floored division
			return x-y*::floor(x/y);
		return 0;

	//	auto yr=(long long)y.r;//truncated division
	//	if(yr)
	//		return (long long)x.r%yr;
	//	return 0;
	}
	Value rc_modulo					(Value const &x, Value const &y)
	{
		if(y.c_isTrue())
		{
			double rx=x;
			std::complex<double> cy=y;
			return rx-cy*floor(rx/cy);
		}
		return Value();
	}
	Value rq_modulo					(Value const &x, Value const &y)
	{
		if(y.q_isTrue())
		{
			double rx=x;
			boost::math::quaternion<double> qy=y;
			return rx-qy*floor(rx/qy);
		}
		return Value();
	}
	Value cr_modulo					(Value const &x, Value const &y)
	{
		if(y)
		{
			std::complex<double> cx=x;
			double ry=y;
			return cx-ry*floor(cx/ry);
		}
		return Value();
	}
	Value cc_modulo					(Value const &x, Value const &y)
	{
		if(y)
		{
			std::complex<double> cx=x, cy=y;
			return cx-cy*floor(cx/cy);
		}
		return Value();
	}
	Value cq_modulo					(Value const &x, Value const &y)
	{
		if(y.q_isTrue())
		{
			std::complex<double> cx=x;
			boost::math::quaternion<double> qy=y;
			return cx-qy*floor(cx/qy);
		}
		return Value();
	}
	Value qr_modulo					(Value const &x, Value const &y)
	{
		if(y.q_isTrue())
		{
			boost::math::quaternion<double> qx=x;
			double ry=y;
			return qx-ry*floor(qx/ry);
		}
		return Value();
	}
	Value qc_modulo					(Value const &x, Value const &y)
	{
		if(y.q_isTrue())
		{
			boost::math::quaternion<double> qx=x;
			std::complex<double> cy=y;
			return qx-cy*floor(qx/cy);
		}
		return Value();
	}
	Value qq_modulo					(Value const &x, Value const &y)
	{
		if(y.q_isTrue())
		{
			boost::math::quaternion<double> qx=x, qy=y;
			return qx-qy*floor(qx/qy);
		}
		return Value();
	}
	bool disc_rr_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x0.r/y0.r)!=std::floor(x1.r/y1.r);}
	bool disc_rc_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rq_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cc_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value  r_sgn					(Value const &x)				{return sgn((double)x);}
	Value  c_sgn					(Value const &x)				{return sgn((std::complex<double>)x);}
	Value  q_sgn					(Value const &x)				{return sgn((boost::math::quaternion<double>)x);}
	auto disc_r_sgn_i				=disc_r_divide_i;
	auto disc_c_sgn_i				=disc_c_divide_i;
	auto disc_q_sgn_i				=disc_q_divide_i;

	Value  c_sqrt					(Value const &x)				{return std::sqrt((std::complex<double>)x);}
	Value  q_sqrt					(Value const &x)
	{
		boost::math::quaternion<double> t=log((boost::math::quaternion<double>)x);
		if(t.R_component_1()!=-_HUGE)
			return boost::math::exp(0.5*t);
		return boost::math::quaternion<double>();
	}

	Value  r_invsqrt				(Value const &x)//http://stackoverflow.com/questions/11513344/how-to-implement-the-fast-inverse-square-root-in-java
	{
		double t0;
		(long long&)t0=0x5FE6EC85E7DE30DA-((long long&)x.r>>1);
		return t0*(1.5-.5*x.r*t0*t0);
	}

	Value  r_cbrt					(Value const &x)
	{
	//	try
	//	{
			if(x.r!=x.r)
				return x;
			return boost::math::cbrt((double)x);
	//	}
	//	catch(...)
	//	{
	//		auto xr=(unsigned long long&)x.r, xi=(unsigned long long&)x.i, xj=(unsigned long long&)x.j, xk=(unsigned long long&)x.k;
	//		int LOL_1=0;
	//	}
	//	return 0;
	}
	Value  c_cbrt					(Value const &x)				{return std::exp(1./3*std::log((std::complex<double>)x));}
	Value  q_cbrt					(Value const &x)
	{
		boost::math::quaternion<double> t=log((boost::math::quaternion<double>)x);
		if(t.R_component_1()!=-_HUGE)
			return exp(1./3*t);
		return boost::math::quaternion<double>();
	}

	Value  r_gauss					(Value const &x)				{double rx=x; return ::exp(-rx*rx);}
	Value  c_gauss					(Value const &x)				{std::complex<double> cx=x; return std::exp(-cx*cx);}
	Value  q_gauss					(Value const &x)				{boost::math::quaternion<double> qx=x; return boost::math::exp(-qx*qx);}

	Value  r_erf					(Value const &x)				{return boost::math::erf((double)x);}

	Value  r_zeta					(Value const &x)				{return boost::math::zeta(x.r);}
	bool disc_r_zeta_i				(Value const &x0, Value const &x1){return x0.r<1?x1.r>=1:x0.r>1&&x1.r<=1;}

	Value  r_tgamma					(Value const &x)				{
		double LOL_1=lgamma(180);
		return tgamma((double)x);
	}
	Value  c_tgamma					(Value const &x)				{return tgamma((std::complex<double>)x);}
	Value  q_tgamma					(Value const &x)				{return tgamma((boost::math::quaternion<double>)x);}
	Value rr_tgamma					(Value const &x, Value const &y)
	{
		try
		{
			if(x.r>0)
			{
				if(y.r>=0)
					return boost::math::tgamma((double)x, (double)y);
			}
			else if(x.r==0)
				return _HUGE;
			long long cInf=0x7FF8000000000010;//x.r>0&&y.r<0||x.r<0
			return (double&)cInf;
		/*	if(x.r<0)
			{
				long long cInf=0x7FF8000000000010;
				return (double&)cInf;
			}
			else if(x.r==0)
				return _HUGE;
			else if(y.r<0)
			{
				long long cInf=0x7FF8000000000010;
				return (double&)cInf;
			}
			else
				return boost::math::tgamma((double)x, (double)y);//*/
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return (double&)divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	bool disc_r_tgamma_i			(Value const &x0, Value const &x1){return (x0.r<=0||x1.r<=0)&&_1d_int_in_range(x0.r, x1.r);}
	bool disc_c_tgamma_i			(Value const &x0, Value const &x1)
	{
		if(x0.r==x1.r)	return false;
		if(x0.i==x1.i)	return x0.i==0&&_1d_int_in_range(x0.r, x1.r);
		if(std::signbit(x0.i)!=std::signbit(x1.i))
		{
			double t=_1d_zero_crossing(x0.r, x0.i, x1.r, x1.i);
			return t<=0&&t==std::floor(t);
		}
		return false;
	}
	bool disc_q_tgamma_i			(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_tgamma_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value  r_loggamma				(Value const &x)				{return lgamma((double)x);}
	bool disc_r_loggamma_i			(Value const &x0, Value const &x1){return (x0.r<=0||x1.r<=0)&&_1d_int_in_range(x0.r, x1.r);}

	Value  r_factorial				(Value const &x)				{return tgamma((double)x+1);}
	Value  c_factorial				(Value const &x)				{return tgamma((std::complex<double>)x+1.);}
	Value  q_factorial				(Value const &x)				{return tgamma((boost::math::quaternion<double>)x+1.);}
	bool disc_r_factorial_i			(Value const &x0, Value const &x1)
	{
		Value _x0=x0.r+1, _x1=x1.r+1;
		return disc_r_tgamma_i(_x0, _x1);
	}
	bool disc_c_factorial_i			(Value const &x0, Value const &x1)
	{
		Value _x0=x0, _x1=x1.r;
		_x0.r+=1, _x1.r+=1;
		return disc_c_tgamma_i(_x0, _x1);
	}
	bool disc_q_factorial_i			(Value const &x0, Value const &x1)
	{
		Value _x0=x0, _x1=x1.r;
		_x0.r+=1, _x1.r+=1;
		return disc_q_tgamma_i(_x0, _x1);
	}

	Value  r_permutation			(Value const &x)				{return 1;}
	Value  c_permutation			(Value const &x)				{return 1;}
	Value  q_permutation			(Value const &x)				{return 1;}
	Value rr_permutation			(Value const &x, Value const &y)
	{
		try
		{
			double rx=x, ry=y;
			return boost::math::tgamma(rx+1)/boost::math::tgamma(rx-ry+1);
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value rc_permutation			(Value const &x, Value const &y)
	{
		try
		{
			double rx=x;
			std::complex<double> cy=y;
			return boost::math::tgamma(rx+1)/tgamma(rx-cy+1.);
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value rq_permutation			(Value const &x, Value const &y)
	{
		try
		{
			double rx=x;
			boost::math::quaternion<double> qy=y;
			return boost::math::tgamma(rx+1)/tgamma(rx-qy+1.);
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value cr_permutation			(Value const &x, Value const &y)
	{
		try
		{
			std::complex<double> cx=x;
			double ry=y;
			return tgamma(cx+1.)/tgamma(cx-ry+1.);
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value cc_permutation			(Value const &x, Value const &y)
	{
		try
		{
			std::complex<double> cx=x, cy=y;
			return tgamma(cx+1.)/tgamma(cx-cy+1.);
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value cq_permutation			(Value const &x, Value const &y)
	{
		try
		{
			std::complex<double> cx=x;
			boost::math::quaternion<double> qy=y;
			return tgamma(cx+1.)/tgamma(cx-qy+1.);
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value qr_permutation			(Value const &x, Value const &y)
	{
		try
		{
			boost::math::quaternion<double> qx=x;
			double ry=y;
			return tgamma(qx+1.)/tgamma(qx-ry+1.);
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value qc_permutation			(Value const &x, Value const &y)
	{
		try
		{
			boost::math::quaternion<double> qx=x;
			std::complex<double> cy=y;
			return tgamma(qx+1.)/tgamma(qx-cy+1.);
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value qq_permutation			(Value const &x, Value const &y)
	{
		try
		{
			boost::math::quaternion<double> qx=x, qy=y;
			return tgamma(qx+1.)/tgamma(qx-qy+1.);
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	bool disc_rr_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rc_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rq_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cc_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value  r_combination			(Value const &x)				{return 1;}
	Value  c_combination			(Value const &x)				{return 1;}
	Value  q_combination			(Value const &x)				{return 1;}
	Value rr_combination			(Value const &x, Value const &y)
	{
		try
		{
			double rx=x, ry=y;
			double r=boost::math::tgamma(rx+1)/(boost::math::tgamma(rx-ry+1)*boost::math::tgamma(ry+1));
			return r;
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value rc_combination			(Value const &x, Value const &y)
	{
		try
		{
			double rx=x;
			std::complex<double> cy=y;
			return boost::math::tgamma(rx+1)/(tgamma(rx-cy+1.)*tgamma(cy+1.));
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value rq_combination			(Value const &x, Value const &y)
	{
		try
		{
			double rx=x;
			boost::math::quaternion<double> qy=y;
			return boost::math::tgamma(rx+1)/(tgamma(rx-qy+1.)*tgamma(qy+1.));
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value cr_combination			(Value const &x, Value const &y)
	{
		try
		{
			std::complex<double> cx=x;
			double ry=y;
			return tgamma(cx+1.)/(tgamma(cx-ry+1.)*boost::math::tgamma(ry+1.));
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value cc_combination			(Value const &x, Value const &y)
	{
		try
		{
			std::complex<double> cx=x, cy=y;
			return tgamma(cx+1.)/(tgamma(cx-cy+1.)*tgamma(cy+1.));
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value cq_combination			(Value const &x, Value const &y)
	{
		try
		{
			std::complex<double> cx=x;
			boost::math::quaternion<double> qy=y;
			return tgamma(cx+1.)/(tgamma(cx-qy+1.)*tgamma(qy+1.));
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value qr_combination			(Value const &x, Value const &y)
	{
		try
		{
			boost::math::quaternion<double> qx=x;
			double ry=y;
			return tgamma(qx+1.)/(tgamma(qx-ry+1.)*boost::math::tgamma(ry+1.));
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value qc_combination			(Value const &x, Value const &y)
	{
		try
		{
			boost::math::quaternion<double> qx=x;
			std::complex<double> cy=y;
			return tgamma(qx+1.)/(tgamma(qx-cy+1.)*tgamma(cy+1.));
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Value qq_combination			(Value const &x, Value const &y)
	{
		try
		{
			boost::math::quaternion<double> qx=x, qy=y;
			return tgamma(qx+1.)/(tgamma(qx-qy+1.)*tgamma(qy+1.));
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	bool disc_rr_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rc_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rq_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cc_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value  r_cos					(Value const &x)				{return ::cos(x);}
	Value  c_cos					(Value const &x)				{return std::cos((std::complex<double>)x);}
	Value  q_cos					(Value const &x)				{return boost::math::cos((boost::math::quaternion<double>)x);}

	Value  c_acos					(Value const &x)				{return std::acos((std::complex<double>)x);}
	Value  q_acos					(Value const &x)
	{
		boost::math::quaternion<double> qx=x;
		return -sgnu(qx)*acosh(qx);
	}
	bool disc_c_acos_i				(Value const &x0, Value const &x1)
	{
		if(x0.i==x0.i)	return false;
		if(x0.r==x0.r)	return (x0.i<=0?x1.i>0:x1.i<=0)&&(x0.r<-1||x0.r>1);
		if(x0.i<=0&&x1.i>0||x1.i<=0&&x0.i>0)
		{
			double t=_1d_zero_crossing(x0.r, x0.i, x1.r, x1.i);
			return t<-1||t>1;
		}
		return false;
	}
	bool disc_q_acos_i				(Value const &x0, Value const &x1){return false;}//

	Value  r_cosh					(Value const &x)				{return ::cosh(x);}
	Value  c_cosh					(Value const &x)				{return std::cosh((std::complex<double>)x);}
	Value  q_cosh					(Value const &x)				{return boost::math::cosh((boost::math::quaternion<double>)x);}

	Value  c_acosh					(Value const &x)				{return std::acosh((std::complex<double>)x);}
	Value  q_acosh					(Value const &x)				{return acosh((boost::math::quaternion<double>)x);}

	Value  r_cosc					(Value const &x)				{return x.r?::cos(x.r)/x.r:std::numeric_limits<double>::infinity();}//::cos(x.r)/x.r	warning C4723: potential divide by 0
	Value  c_cosc					(Value const &x)				{std::complex<double> cx=x;return std::cos(cx)/cx;}
	Value  q_cosc					(Value const &x)				{boost::math::quaternion<double> qx=x;return boost::math::cos(qx)/qx;}
	auto disc_r_cosc_i				=disc_r_divide_i;
	auto disc_c_cosc_i				=disc_c_divide_i;
	auto disc_q_cosc_i				=disc_q_divide_i;

	Value  r_sec					(Value const &x)				{return 1/::cos(x);}
	Value  c_sec					(Value const &x)				{return 1./std::cos((std::complex<double>)x);}
	Value  q_sec					(Value const &x)				{return 1./boost::math::cos((boost::math::quaternion<double>)x);}
	bool disc_r_sec_i				(Value const &x0, Value const &x1)
	{
		if(std::abs(x1.r-x0.r)>3.2)	return true;
		return _1d_int_in_range(x0.r/_pi-.5, x1.r/_pi-.5);
	}
	bool disc_c_sec_i				(Value const &x0, Value const &x1)
	{
		if(x0.r==x1.r)
		{
			if(x0.i==x1.i)	return false;
			double t=x0.r/_pi-.5;
			return t==std::floor(t);
		}
		if(x0.i==x1.i)	return x0.i==0&&_1d_int_in_range(x0.r/_pi-.5, x1.r/_pi-.5);
		if(std::signbit(x0.i)!=std::signbit(x1.i))
		{
			double t=_1d_zero_crossing(x0.r, x0.i, x1.r, x0.i)/_pi-.5;
			return t==std::floor(t);
		}
		return false;
	}
	bool disc_q_sec_i				(Value const &x0, Value const &x1){return false;}//

	Value  c_asec					(Value const &x)				{return std::acos(1./(std::complex<double>)x);}
	Value  q_asec					(Value const &x)				{return acos(1./(boost::math::quaternion<double>)x);}
	auto disc_c_asec_i				=disc_c_divide_i;
	auto disc_q_asec_i				=disc_q_divide_i;

	Value  r_sech					(Value const &x)				{return 1/::cosh(x);}
	Value  c_sech					(Value const &x)				{return 1./std::cosh((std::complex<double>)x);}
	Value  q_sech					(Value const &x)				{return 1./boost::math::cosh((boost::math::quaternion<double>)x);}
	bool disc_c_sech_i				(Value const &x0, Value const &x1)
	{
		if(x0.i==x1.i)
		{
			if(x0.r==x1.r)
				return false;
			double i=x0.i/_pi+.5;
			return i==std::floor(i)&&(x0.r<0?x1.r>=0:x0.r>0?x1.r<=0:x1.r!=0);
		}
		if(x0.r==x1.r)
			return x0.r==0&&_1d_int_in_range(x0.i/_pi-.5, x1.i/_pi-.5);
		return false;
	/*	if(x0.i==x1.i)	return true;
		if(x0.r==x1.r)	return x0.r==0&&_1d_int_in_range(x0.i/_pi-.5, x1.i/_pi-.5);
		if(std::signbit(x0.r)!=std::signbit(x1.r))
		{
			double t=_1d_zero_crossing(x0.i, x0.r, x1.i, x1.r)/_pi-.5;
			return t==std::floor(t);
		}
		return false;//*/
	}
	bool disc_q_sech_i				(Value const &x0, Value const &x1){return false;}//

	Value  c_asech					(Value const &x)				{return std::acosh(1./(std::complex<double>)x);}
	Value  q_asech					(Value const &x)				{return acosh(1./(boost::math::quaternion<double>)x);}
	bool disc_c_asech_i				(Value const &x0, Value const &x1)
	{
		if(x0.i==x0.i)	return x0.i==0&&x0.r!=x0.r&&std::signbit(x0.r)!=std::signbit(x1.r);
		if(x0.r==x0.r)	return (x0.i<=0?x1.i>0:x1.i<=0)&&(x0.r<=0||x0.r>1);
		if(x0.i<=0&&x1.i>0||x0.i<=0&&x1.i>0)
		{
			double t=_1d_zero_crossing(x0.r, x0.i, x1.r, x1.i);
			return t<=0||t>1;
		}
		return false;
	}
	bool disc_q_asech_i				(Value const &x0, Value const &x1){return false;}//

	Value  r_sin					(Value const &x)				{return ::sin(x);}
	Value  c_sin					(Value const &x)				{return std::sin((std::complex<double>)x);}
	Value  q_sin					(Value const &x)				{return boost::math::sin((boost::math::quaternion<double>)x);}

	Value  c_asin					(Value const &x)				{return std::asin((std::complex<double>)x);}
	Value  q_asin					(Value const &x)				{boost::math::quaternion<double> qx=x, t=sgnu(qx);return -t*asinh(qx*t);}
	auto disc_c_asin_i				=disc_c_acos_i;
	auto disc_q_asin_i				=disc_q_acos_i;

	Value  r_sinh					(Value const &x)				{return ::sinh(x);}
	Value  c_sinh					(Value const &x)				{return std::sinh((std::complex<double>)x);}
	Value  q_sinh					(Value const &x)				{return boost::math::sinh((boost::math::quaternion<double>)x);}

	Value  r_asinh					(Value const &x)				{return boost::math::asinh((double)x);}
	Value  c_asinh					(Value const &x)				{return std::asinh((std::complex<double>)x);}
	Value  q_asinh					(Value const &x)				{return asinh((boost::math::quaternion<double>)x);}
	bool disc_c_asinh_i				(Value const &x0, Value const &x1)
	{
		Value _x0(x0.i, x0.r), _x1(x1.i, x0.r);
		return disc_c_acos_i(_x0, _x1);
	}
	bool disc_q_asinh_i				(Value const &x0, Value const &x1){return false;}//

	Value  r_sinc					(Value const &x)
	{
		double rx=x;
		if(rx)
			return ::sin(rx)/rx;
		return 1;
	}
	Value  c_sinc					(Value const &x)
	{
		if(x.c_isTrue())
		{
			std::complex<double> cx=x;
			return std::sin(cx)/cx;
		}
		return 1;
	}
	Value  q_sinc					(Value const &x)
	{
		if(x.q_isTrue())
		{
			boost::math::quaternion<double> qx=x;
			return boost::math::sin(qx)/qx;
		}
		return 1;
	}

	Value  r_sinhc					(Value const &x)
	{
		double rx=x;
		if(rx)
			return ::sinh(rx)/rx;
		return 1;
	}
	Value  c_sinhc					(Value const &x)
	{
		if(x.c_isTrue())
		{
			std::complex<double> cx=x;
			return std::sinh(cx)/cx;
		}
		return 1;
	}
	Value  q_sinhc					(Value const &x)
	{
		if(x.q_isTrue())
		{
			boost::math::quaternion<double> qx=x;
			return boost::math::sinh(qx)/qx;
		}
		return 1;
	}

	Value  r_csc					(Value const &x)				{return 1/::sin(x);}
	Value  c_csc					(Value const &x)				{return 1./std::sin((std::complex<double>)x);}
	Value  q_csc					(Value const &x)				{return 1./boost::math::sin((boost::math::quaternion<double>)x);}
	bool disc_r_csc_i				(Value const &x0, Value const &x1)
	{
		if(std::abs(x1.r-x0.r)>3.2)	return true;
		return _1d_int_in_range(x0.r/_pi, x1.r/_pi);
	}
	bool disc_c_csc_i				(Value const &x0, Value const &x1)
	{
		if(x0.r==x1.r)	return true;
		if(x0.i==x1.i)	return x0.i==0&&_1d_int_in_range(x0.r/_pi, x1.r/_pi);
		if(std::signbit(x0.i)!=std::signbit(x1.i))
		{
			double t=_1d_zero_crossing(x0.r, x0.i, x1.r, x0.i)/_pi;
			return t==std::floor(t);
		}
		return false;
	}
	bool disc_q_csc_i				(Value const &x0, Value const &x1){return false;}

	Value  c_acsc					(Value const &x)				{return std::asin(1./(std::complex<double>)x);}
	Value  q_acsc					(Value const &x)				{return asin(1./(boost::math::quaternion<double>)x);}
	bool disc_c_acsc_i				(Value const &x0, Value const &x1)
	{
		if(x0.i==x1.i)	return x0.i==0&&(x0.r<0?x1.r>=0:x0.r>0?x1.r<=0:x1.r!=0);//x1.r<0||x1.r>0);
		if(x0.r==x1.r)
		{
			if(x0.r<0)	return x0.r>-1&&(x0.i<=0?x1.i>0:x1.i<=0);
			if(x0.r==0)	return x0.i<0?x1.i>=0:x0.i==0?x1.i<0||x1.i>0:x1.i<=0;
						return x0.r<1&&(x0.i<0?x1.i>=0:x1.i<0);
		}
		return false;
	}
	bool disc_q_acsc_i				(Value const &x0, Value const &x1){return false;}//

	Value  r_csch					(Value const &x)				{return 1/::sinh(x);}
	Value  c_csch					(Value const &x)				{return 1./std::sinh((std::complex<double>)x);}
	Value  q_csch					(Value const &x)				{return 1./boost::math::sinh((boost::math::quaternion<double>)x);}
	auto disc_r_csch_i				=disc_r_divide_i;
	bool disc_c_csch_i				(Value const &x0, Value const &x1)
	{
		Value _x0(x0.i, x0.r), _x1(x1.i, x1.r);
		return disc_c_csc_i(_x0, _x1);
	}
	bool disc_q_csch_i				(Value const &x0, Value const &x1){return false;}//

	Value  r_acsch					(Value const &x)
	{
		try
		{
			return boost::math::asinh(1/x);
		}
		catch(std::overflow_error&)
		{
			long long valueBits=(long long&)x;
			if(valueBits)//==0x8000000000000000
				return -_HUGE;
			return _HUGE;
		}
	}
	Value  c_acsch					(Value const &x)				{return std::asinh(1./(std::complex<double>)x);}
	Value  q_acsch					(Value const &x)				{return asinh(1./(boost::math::quaternion<double>)x);}
	auto disc_r_acsch_i				=disc_r_divide_i;
	bool disc_c_acsch_i				(Value const &x0, Value const &x1)
	{
		Value _x0(x0.i, x0.r), _x1(x1.i, x1.r);
		return disc_c_acsc_i(_x0, _x1);
	}
	bool disc_q_acsch_i				(Value const &x0, Value const &x1){return false;}//

	Value  r_tan					(Value const &x)				{return ::tan(x);}
	Value  c_tan					(Value const &x)				{return std::tan((std::complex<double>)x);}
	Value  q_tan					(Value const &x)				{return boost::math::tan((boost::math::quaternion<double>)x);}
	auto disc_r_tan_i				=disc_r_sec_i;
	auto disc_c_tan_i				=disc_c_sec_i;
	auto disc_q_tan_i				=disc_q_sec_i;

	Value  r_atan					(Value const &x)				{return ::atan(x);}
	Value  c_atan					(Value const &x)				{return std::atan((std::complex<double>)x);}
	Value  q_atan					(Value const &x)				{boost::math::quaternion<double> qx=x, t=sgnu(qx);return -t*atanh(qx*t);}
	Value rr_atan					(Value const &x, Value const &y){return ::atan2((double)x, (double)y);}
	Value rc_atan					(Value const &x, Value const &y)
	{
		double rx=x;
		std::complex<double> t=std::atan((std::complex<double>)y/rx);
		return rx<0?y.r<0?t-_pi:t+_pi:t;
	}
	Value rq_atan					(Value const &x, Value const &y)
	{
		double rx=x;
		boost::math::quaternion<double> t=atan((boost::math::quaternion<double>)y/rx);
		return rx<0?y.r<0?t-_pi:t+_pi:t;
	}
	Value cr_atan					(Value const &x, Value const &y)
	{
		double ry=y;
		std::complex<double> t=atan(ry/(std::complex<double>)x);
		return x.r<0?ry<0?t-_pi:t+_pi:t;
	}
	Value cc_atan					(Value const &x, Value const &y)
	{
		std::complex<double> t=atan((std::complex<double>)y/(std::complex<double>)x);
		return x.r<0?y.r<0?t-_pi:t+_pi:t;
	}
	Value cq_atan					(Value const &x, Value const &y)
	{
		boost::math::quaternion<double> t=atan((boost::math::quaternion<double>)y/(std::complex<double>)x);
		return x.r<0?y.r<0?t-_pi:t+_pi:t;
	}
	Value qr_atan					(Value const &x, Value const &y)
	{
		double ry=y;
		boost::math::quaternion<double> t=atan(ry/(boost::math::quaternion<double>)x);
		return x.r<0?ry<0?t-_pi:t+_pi:t;
	}
	Value qc_atan					(Value const &x, Value const &y)
	{
		boost::math::quaternion<double> t=atan((std::complex<double>)y/(boost::math::quaternion<double>)x);
		return x.r<0?y.r<0?t-_pi:t+_pi:t;
	}
	Value qq_atan					(Value const &x, Value const &y)
	{
		boost::math::quaternion<double> t=atan((boost::math::quaternion<double>)y/(boost::math::quaternion<double>)x);
		return x.r<0?y.r<0?t-_pi:t+_pi:t;
	}
	bool disc_c_atan_i				(Value const &x0, Value const &x1)
	{
		Value _x0(x0.i, x0.r), _x1(x1.i, x1.r);
		return disc_c_acos_i(_x0, _x1);
	}
	bool disc_q_atan_i				(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1)
	{
		if(y0.r<0)
		{
			if(x0.r<0)
			{
				if(y1.r<0)	return x1.r>=0;
				if(y1.r>0)	return x1.r>0&&y0.r+(0-x0.r)*(y1.r-y0.r)/(x1.r-x0.r)<=0;
							return x1.r>=0;
			}
			else if(x0.r>0)
			{
				if(y1.r<0)	return x1.r<0;
				if(y1.r>0)	return x1.r<0&&y0.r+(0-y0.r)*(y1.r-y0.r)/(x1.r-x1.r)<=0;
							return x1.r<=0;
			}
			else
			{
				if(y1.r<0)	return x1.r<0;
				if(y1.r>0)	return x1.r<=0;
							return x1.r<=0;
			}
		}
		else if(y0.r>0)
		{
			if(x0.r<0)
			{
				if(y1.r<0)	return x1.r>=0&&(x1.r==0||y0.r+(0-y0.r)*(y1.r-y0.r)/(x1.r-x1.r)<=0);
				if(y1.r>0)	return false;
							return x1.r==0;
			}
			else if(x0.r>0)
			{
				if(y1.r<0)	return x1.r<0&&y0.r+(0-y0.r)*(y1.r-y0.r)/(x1.r-x1.r)<=0;
				if(y1.r>0)	return false;
							return x1.r==0;
			}
			else
			{
				if(y1.r<0)	return x1.r==0;
				if(y1.r>0)	return false;
							return x1.r==0;
			}
		}
		else
		{
			if(x0.r<0)
			{
				if(y1.r<0)	return x1.r>=0;
				if(y1.r>0)	return false;
							return x1.r>=0;
			}
			else if(x0.r>0)
			{
				if(y1.r<0)	return x1.r<0;
				if(y1.r>0)	return false;
							return x1.r<=0;
			}
							return true;
		}
	}
	bool disc_rc_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rq_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cc_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value  r_tanh					(Value const &x)				{return ::tanh(x);}
	Value  c_tanh					(Value const &x)				{return std::tanh((std::complex<double>)x);}
	Value  q_tanh					(Value const &x)				{return boost::math::tanh((boost::math::quaternion<double>)x);}
	auto disc_c_tanh_i				=disc_c_sech_i;
	auto disc_q_tanh_i				=disc_q_sech_i;

	Value  c_atanh					(Value const &x)				{return std::atanh((std::complex<double>)x);}
	Value  q_atanh					(Value const &x)				{return atanh((boost::math::quaternion<double>)x);}
	bool disc_c_atanh_i				(Value const &x0, Value const &x1)
	{
		Value _x0(x0.r, -x0.i), _x1(x1.r, -x1.i);
		return disc_c_acos_i(_x0, _x1);
	}
	bool disc_q_atanh_i				(Value const &x0, Value const &x1){return false;}//

	Value  r_tanc					(Value const &x)
	{
		double rx=x;
		if(rx)
			return ::tan(rx)/rx;
		return 1;
	}
	Value  c_tanc					(Value const &x)
	{
		if(x.c_isTrue())
		{
			std::complex<double> cx=x;
			return std::tan(cx)/cx;
		}
		return 1;
	}
	Value  q_tanc					(Value const &x)
	{
		if(x.q_isTrue())
		{
			boost::math::quaternion<double> qx=x;
			return boost::math::tan(qx)/qx;
		}
		return 1;
	}
	auto disc_r_tanc_i				=disc_r_sec_i;
	auto disc_c_tanc_i				=disc_c_sec_i;
	auto disc_q_tanc_i				=disc_q_sec_i;

	Value  r_cot					(Value const &x)				{return 1/::tan(x);}
	Value  c_cot					(Value const &x)				{return 1./std::tan((std::complex<double>)x);}
	Value  q_cot					(Value const &x)				{return 1./boost::math::tan((boost::math::quaternion<double>)x);}
	auto disc_r_cot_i				=disc_r_csc_i;
	auto disc_c_cot_i				=disc_c_csc_i;
	auto disc_q_cot_i				=disc_q_csc_i;

	Value  r_acot					(Value const &x)				{return x.r?::atan(1./x.r):_pi/2;}//::atan(1./x.r)	warning C4723: potential divide by 0
	Value  c_acot					(Value const &x)				{return std::atan(1./(std::complex<double>)x);}
	Value  q_acot					(Value const &x)				{return atan(1./(boost::math::quaternion<double>)x);}
	bool disc_r_acot_i				(Value const &x0, Value const &x1){return x0.r<0?x1.r>=0:x1.r<0;}
	auto disc_c_acot_i				=disc_c_acsch_i;
	auto disc_q_acot_i				=disc_q_acsch_i;

	Value  r_coth					(Value const &x)				{return 1/::tanh(x);}
	Value  c_coth					(Value const &x)				{return 1./std::tanh((std::complex<double>)x);}
	Value  q_coth					(Value const &x)				{return 1./boost::math::tanh((boost::math::quaternion<double>)x);}
	auto disc_r_coth_i				=disc_r_csch_i;
	auto disc_c_coth_i				=disc_c_csch_i;
	bool disc_q_coth_i				(Value const &x0, Value const &x1){return false;}//

	Value  c_acoth					(Value const &x)				{return std::atanh(1./(std::complex<double>)x);}
	Value  q_acoth					(Value const &x)				{return atanh(1./(boost::math::quaternion<double>)x);}
	bool disc_c_acoth_i				(Value const &x0, Value const &x1)
	{
		Value _x0(x0.r, -x0.i), _x1(x1.r, -x1.i);
		return disc_c_acsc_i(_x0, _x1);
	}
	bool disc_q_acoth_i				(Value const &x0, Value const &x1){return false;}//

	Value  r_exp					(Value const &x)				{return ::exp(x);}
	Value  c_exp					(Value const &x)				{return std::exp((std::complex<double>)x);}
	Value  q_exp					(Value const &x)				{return boost::math::exp((boost::math::quaternion<double>)x);}

	Value  r_fib					(Value const &x)				{return (::pow(_phi, x)-::cos(_pi*x)*::pow(_phi, -x))/::sqrt(5);}
	Value  c_fib					(Value const &x)				{std::complex<double> cx=x;return (std::pow(_phi, cx)-std::cos(_pi*cx)*std::pow(_phi, -cx))/std::sqrt(5);}
	Value  q_fib					(Value const &x)				{boost::math::quaternion<double> qx=x;return (pow(_phi, qx)-boost::math::cos(_pi*qx)*pow(_phi, -qx))/::sqrt(5);}

	namespace random
	{
		boost::mt19937 gen;
		boost::random::uniform_real_distribution<> dist;
	}
	Value  r_random					(Value const &x)
	{
		return (rand()<<15|rand())/1073741824.;
	//	return rand()%1000/1000.;
	/*	try
		{
			using namespace random;
			return dist(gen);
		}
		catch(...){return rand()%1000/1000.;}//*/
	}
	Value  c_random					(Value const &x)
	{
		return Value((rand()<<15|rand())/1073741824., (rand()<<15|rand())/1073741824.);
	//	return Value(rand()%1000/1000., rand()%1000/1000.);
	/*	try
		{
			using namespace random;
			return Value(dist(gen), dist(gen));
		}
		catch(...){return rand()%1000/1000.;}//*/
	}
	Value  q_random					(Value const &x)
	{
		return Value((rand()<<15|rand())/1073741824., (rand()<<15|rand())/1073741824., (rand()<<15|rand())/1073741824., (rand()<<15|rand())/1073741824.);
	//	return Value(rand()%1000/1000., rand()%1000/1000., rand()%1000/1000., rand()%1000/1000.);
	/*	try
		{
			using namespace random;
			return Value(dist(gen), dist(gen), dist(gen), dist(gen));
		}
		catch(...){return rand()%1000/1000.;}//*/
	}
	Value rr_random					(Value const &x, Value const &y)
	{
		return rand()%1000/1000.;
	/*	try
		{
			using namespace random;
			return dist(gen);
		}
		catch(...){return rand()%1000/1000.;}//*/
	}
	Value cc_random					(Value const &x, Value const &y)
	{
		return Value(rand()%1000/1000., rand()%1000/1000.);
	/*	try
		{
			using namespace random;
			return Value(dist(gen), dist(gen));
		}
		catch(...){return rand()%1000/1000.;}//*/
	}
	Value qq_random					(Value const &x, Value const &y)
	{
		return Value(rand()%1000/1000., rand()%1000/1000., rand()%1000/1000., rand()%1000/1000.);
	/*	try
		{
			using namespace random;
			return Value(dist(gen), dist(gen), dist(gen), dist(gen));
		}
		catch(...){return rand()%1000/1000.;}//*/
	}
	bool disc_r_random				(Value const &o0, Value const &o1){return true;}
	auto disc_c_random				=disc_r_random;
	auto disc_q_random				=disc_r_random;
	auto disc_rr_random				=disc_r_random;
//	auto disc_rc_random				=disc_r_random;
//	auto disc_rq_random				=disc_r_random;
//	auto disc_cr_random				=disc_r_random;
	auto disc_cc_random				=disc_r_random;
//	auto disc_cq_random				=disc_r_random;
//	auto disc_qr_random				=disc_r_random;
//	auto disc_qc_random				=disc_r_random;
	auto disc_qq_random				=disc_r_random;

	Value  r_beta					(Value const &x)
	{
		try
		{
			double rx=x;
			return boost::math::beta(rx, rx);
		}
	//	catch(std::domain_error&){return Value(_qnan, _qnan);}
		catch(...){return Value(_qnan, _qnan);}
	}
	Value rr_beta					(Value const &x, Value const &y)
	{
		try
		{
			if((double)x<0||(double)y<0)
				return Value(_qnan, _qnan);
			return boost::math::beta((double)x, (double)y);
		}
	//	catch(std::domain_error&){return Value(_qnan, _qnan);}
		catch(...){return Value(_qnan, _qnan);}
	}
	bool disc_r_beta_i				(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_beta_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value  r_cyl_bessel_j			(Value const &x)
	{
		try
		{
			return boost::math::cyl_bessel_j(0, (double)x);
		}
	//	catch(std::domain_error&){return _qnan;}
		catch(...){return _qnan;}
	}
	Value rr_cyl_bessel_j			(Value const &x, Value const &y)
	{
		try
		{
			if((double)y<0&&(double)x!=std::floor((double)x))//||(double)y==0&&(double)x<0&&(double)x!=std::floor((double)x))
				return _qnan;
			return boost::math::cyl_bessel_j((double)x, (double)y);
		}
	//	catch(std::domain_error&){return _qnan;}
		catch(...){return _qnan;}
	}
	bool disc_r_cyl_bessel_j_i		(Value const &x0, Value const &x1){return false;}
	bool disc_rr_cyl_bessel_j_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value  r_cyl_neumann			(Value const &x)
	{
		try
		{
			return boost::math::cyl_neumann(0, (double)x);
		}
		catch(std::domain_error&){return _qnan;}
		catch(std::overflow_error&){return -_HUGE;}
		catch(...){return _qnan;}
	}
	Value rr_cyl_neumann			(Value const &x, Value const &y)
	{
		if(y.r<0||y.r!=y.r)
			return _qnan;
		try
		{
			return boost::math::cyl_neumann((double)x, (double)y);
		}
		catch(std::domain_error&){return _qnan;}
		catch(std::overflow_error&){return -_HUGE;}
		catch(...){return _qnan;}
	}
	bool disc_r_cyl_neumann_i		(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_cyl_neumann_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value  r_hankel1				(Value const &x)
	{
		try
		{
			double rx=x;
			return boost::math::cyl_bessel_j(0, rx)+std::complex<double>(0, 1)*boost::math::cyl_neumann(0, rx);
		}
		catch(std::domain_error&){return _qnan;}
		catch(std::overflow_error&){return -_HUGE;}
		catch(...){return _qnan;}
	}
	Value rr_hankel1				(Value const &x, Value const &y)
	{
		if(y.r<0)
			return _qnan;
		try
		{
			double rx=x, ry=y;
			return boost::math::cyl_bessel_j(rx, ry)+std::complex<double>(0, 1)*boost::math::cyl_neumann(rx, ry);
		}
		catch(std::domain_error&){return _qnan;}
		catch(std::overflow_error&){return -_HUGE;}
		catch(...){return _qnan;}
	}
	bool disc_r_hankel1_i			(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_hankel1_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value  r_step					(Value const &x)				{return .5+.5*sgn((double)x);}
	Value  c_step					(Value const &x)				{return .5+.5*sgn((std::complex<double>)x);}
	Value  q_step					(Value const &x)				{return .5+.5*sgn((boost::math::quaternion<double>)x);}
	auto disc_r_step_i				=disc_r_divide_i;
	auto disc_c_step_i				=disc_c_divide_i;
	auto disc_q_step_i				=disc_q_divide_i;

	Value  r_rect					(Value const &x)				{double rx=x;							return step(rx+.5)-step(rx-.5);}
	Value  c_rect					(Value const &x)				{std::complex<double> cx=x;				return step(cx+.5)-step(cx-.5);}
	Value  q_rect					(Value const &x)				{boost::math::quaternion<double> qx=x;	return step(qx+.5)-step(qx-.5);}
	bool disc_rect(double x0, double x1)
	{
		double const d[2]={-.5, .5};
		if(x0<d[0])		return x1>=d[0];
		if(x0==d[0])	return x1<d[0]||x1>d[0];
		if(x0<d[1])		return x1>=d[1];
		if(x0==d[1])	return x1<d[1]||x1>d[1];
						return x1<=d[1];
	}
	bool disc_r_rect_i				(Value const &x0, Value const &x1){return disc_rect(x0.r, x1.r);}
	bool disc_c_rect_i				(Value const &x0, Value const &x1)
	{
		if(x0.i==x1.i)	return x0.i==0&&disc_rect(x0.r, x1.r);
		if(x0.r==x1.r)	return (x0.r==-.5||x0.r==.5)&&(x0.i<0?x1.i>=0:x0.i==0?x1.i<0||x1.i>0:x1.i<=0);
		double x=_1d_zero_crossing(x0.r, x0.i, x1.r, x1.i);
		return x==-.5||x==.5;
	}
	bool disc_q_rect_i				(Value const &x0, Value const &x1){return false;}//

	Value  r_trgl					(Value const &x)				{double t=::abs(x);												return t<1?1-t:0;}
	Value  c_trgl					(Value const &x)				{double t=std::abs((std::complex<double>)x);					return t<1?1-t:0;}
	Value  q_trgl					(Value const &x)				{double t=boost::math::abs((boost::math::quaternion<double>)x);	return t<1?1-t:0;}

	Value  r_sqwv					(Value const &x)				{double rx=x, t=rx-::floor(rx);							return step(t)-step(t-.5);}
	Value  c_sqwv					(Value const &x)				{std::complex<double> cx=x, t=cx-floor(cx);				return step(t)-step(t-.5);}
	Value  q_sqwv					(Value const &x)				{boost::math::quaternion<double> qx=x, t=qx-floor(qx);	return step(t)-step(t-.5);}
	Value rr_sqwv					(Value const &x, Value const &y)
	{
		double rx=x, ry=y, t=rx-::floor(rx), t2=::floor(ry);
		return step(t)-step(t-ry+t2)+t2;
	}
	Value rc_sqwv					(Value const &x, Value const &y)
	{
		double rx=x, t=rx-::floor(rx);
		std::complex<double> cy=y, t2=floor(cy);
		return step(t)-step(t-cy+t2)+t2;
	}
	Value rq_sqwv					(Value const &x, Value const &y)
	{
		double rx=x, t=rx-::floor(rx);
		boost::math::quaternion<double> qy=y, t2=floor(qy);
		return step(t)-step(t-qy+t2)+t2;
	}
	Value cr_sqwv					(Value const &x, Value const &y)
	{
		std::complex<double> cx=x, t=cx-floor(cx);
		double ry=y, t2=::floor(ry);
		return step(t)-step(t-ry+t2)+t2;
	}
	Value cc_sqwv					(Value const &x, Value const &y)
	{
		std::complex<double> cx=x, t1=cx-floor(cx), cy=y, t2=floor(cy);
		return step(t1)-step(t1-cy+t2)+t2;
	}
	Value cq_sqwv					(Value const &x, Value const &y)
	{
		std::complex<double> cx=x, t1=cx-floor(cx);
		boost::math::quaternion<double> cy=y, t2=floor(cy);
		return step(t1)-step(t1-cy+t2)+t2;
	}
	Value qr_sqwv					(Value const &x, Value const &y)
	{
		boost::math::quaternion<double> qx=x, t=qx-floor(qx);
		double ry=y, t2=::floor(ry);
		return step(t)-step(t-ry+t2)+t2;
	}
	Value qc_sqwv					(Value const &x, Value const &y)
	{
		boost::math::quaternion<double> qx=x, t=qx-floor(qx);
		std::complex<double> cy=y, t2=floor(cy);
		return step(t)-step(t-cy+t2)+t2;
	}
	Value qq_sqwv					(Value const &x, Value const &y)
	{
		boost::math::quaternion<double> qx=x, qy=y, t=qx-floor(qx), t2=floor(qy);
		return step(t)-step(t-qy+t2)+t2;
	}
	bool disc_r_sqwv_i				(Value const &x0, Value const &x1)
	{
		if(x0.r==x1.r)	return false;
		double t0=2*x0.r, t1=2*x1.r;
		if(t0==std::floor(t0)||t1==std::floor(t1))
			return true;
		return std::floor(t0)!=std::floor(t1);
	}
	bool disc_c_sqwv_i				(Value const &x0, Value const &x1)
	{
		if(std::floor(x0.r)!=std::floor(x1.r)||std::floor(x0.i)!=std::floor(x1.i))
			return true;
		if(x0.r==x1.r&&x0.i==x1.i)
			return true;
		{
			double r0=2*x0.r;
			if(r0==std::floor(r0)&&x0.i==std::floor(x0.i))
				return true;
		}
		{
			double r1=2*x1.r;
			if(r1==std::floor(r1)&&x1.i==std::floor(x1.i))
				return true;
		}
		return false;
	}
	bool disc_q_sqwv_i				(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_sqwv_o				(Value const &o0, Value const &o1){return o0.r!=o1.r;}
	bool disc_rc_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rq_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cc_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value  r_trwv					(Value const &x)				{double rx=x, t=rx-::floor(rx), t2=t-.5;						return t/.5*step(-t2)+(1 -t2/.5)*step(t2);}
	Value  c_trwv					(Value const &x)				{std::complex<double> cx=x, t=cx-floor(cx), t2=t-.5;			return t/.5*step(-t2)+(1.-t2/.5)*step(t2);}
	Value  q_trwv					(Value const &x)				{boost::math::quaternion<double> qx=x, t=qx-floor(qx), t2=t-.5;	return t/.5*step(-t2)+(1.-t2/.5)*step(t2);}
	Value rr_trwv					(Value const &x, Value const &y)
	{
		double rx=x, t=rx-::floor(rx), ry=y, t2=t-ry;
		if(ry==0)
			return (1-t)/(1-ry)*step(t2);
		else if(ry==1)
			return t/ry*step(-t2);
		return t/ry*step(-t2)+(1-t)/(1-ry)*step(t2);
	}
	Value rc_trwv					(Value const &x, Value const &y)
	{
		double rx=x, t=rx-::floor(rx);
		std::complex<double> cy=y, t2=t-cy;
		if(cy==0.)
			return (1-t)/(1.-cy)*step(t2);
		else if(cy==1.)
			return t/cy*step(-t2);
		return t/cy*step(-t2)+(1-t)/(1.-cy)*step(t2);
	}
	Value rq_trwv					(Value const &x, Value const &y)
	{
		double rx=x, ry=y, t=rx-::floor(rx);
		boost::math::quaternion<double> qy=y, t2=t-qy;
		if(qy==0.)
			return (1-t)/(1.-qy)*step(t2);
		else if(qy==1.)
			return t/qy*step(-t2);
		return t/qy*step(-t2)+(1-t)/(1.-qy)*step(t2);
	}
	Value cr_trwv					(Value const &x, Value const &y)
	{
		double ry=y;
		std::complex<double> cx=x, t=cx-floor(cx), t2=t-ry;
		if(ry==0)
			return (1.-t)/(1-ry)*step(t2);
		else if(ry==1)
			return t/ry*step(-t2);
		return t/ry*step(-t2)+(1.-t)/(1-ry)*step(t2);
	}
	Value cc_trwv					(Value const &x, Value const &y)
	{
		std::complex<double> cx=x, t=cx-floor(cx), cy=y, t2=t-cy;
		if(cy==0.)
			return (1.-t)/(1.-cy)*step(t2);
		else if(cy==1.)
			return t/cy*step(-t2);
		return t/cy*step(-t2)+(1.-t)/(1.-cy)*step(t2);
	}
	Value cq_trwv					(Value const &x, Value const &y)
	{
		std::complex<double> cx=x, t=cx-floor(cx);
		boost::math::quaternion<double> qy=y, t2=t-qy;
		if(qy==0.)
			return (1.-t)/(1.-qy)*step(t2);
		else if(qy==1.)
			return t/qy*step(-t2);
		return t/qy*step(-t2)+(1.-t)/(1.-qy)*step(t2);
	}
	Value qr_trwv					(Value const &x, Value const &y)
	{
		double ry=y;
		boost::math::quaternion<double> qx=x, t=qx-floor(qx), t2=t-ry;
		if(ry==0)
			return (1.-t)/(1.-ry)*step(t2);
		else if(ry==1)
			return t/ry*step(-t2);
		return t/ry*step(-t2)+(1.-t)/(1.-ry)*step(t2);
	}
	Value qc_trwv					(Value const &x, Value const &y)
	{
		std::complex<double> cy=y;
		boost::math::quaternion<double> qx=x, t=qx-floor(qx), t2=t-cy;
		if(cy==0.)
			return (1.-t)/(1.-cy)*step(t2);
		else if(cy==1.)
			return t/cy*step(-t2);
		return t/cy*step(-t2)+(1.-t)/(1.-cy)*step(t2);
	}
	Value qq_trwv					(Value const &x, Value const &y)
	{
		boost::math::quaternion<double> qx=x, qy=y, t=qx-floor(qx), t2=t-qy;
		if(qy==0.)
			return (1.-t)/(1.-qy)*step(t2);
		else if(qy==1.)
			return t/qy*step(-t2);
		return t/qy*step(-t2)+(1.-t)/(1.-qy)*step(t2);
	}
	bool disc_c_trwv_i				(Value const &x0, Value const &x1){return std::floor(x0.r)!=std::floor(x1.r)||std::floor(x0.i)!=std::floor(x1.i);}
	bool disc_q_trwv_i				(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_trwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x0.r)!=std::floor(x1.r);}
	bool disc_rc_trwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x0.r)!=std::floor(x1.r);}
	bool disc_rq_trwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x0.r)!=std::floor(x1.r);}
	bool disc_cr_trwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1)
	{
		if(std::floor(x0.r)!=std::floor(x1.r)||std::floor(x0.i)!=std::floor(x1.i))
			return true;
		return y0.r<1?y1.r>=1:y0.r==1?y1.r<1||y1.r>1:y1.r<=1;
	}
	bool disc_cc_trwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_trwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_trwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_trwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_trwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value  r_saw					(Value const &x)
	{
		double rx=x, t=rx-::floor(rx), t2=::floor(1-t);
		return (t2+1)*(t2/2+t);
	}
	Value  c_saw					(Value const &x)
	{
		std::complex<double> cx=x, t=cx-floor(cx), t2=floor(1.-t);
		return (t2+1.)*(t2/2.+t);
	}
	Value  q_saw					(Value const &x)
	{
		boost::math::quaternion<double> qx=x, t=qx-floor(qx), t2=floor(1.-t);
		return (t2+1.)*(t2/2.+t);
	}
	Value rr_saw					(Value const &x, Value const &y)
	{
		double rx=x, ry=y, t=rx-::floor(rx), t2=::floor(ry-t);
		return (t2+1)*(t2/2+t)/ry;
	}
	Value rc_saw					(Value const &x, Value const &y)
	{
		double rx=x, t=rx-::floor(rx);
		std::complex<double> cy=y, t2=floor(cy-t);
		return (t2+1.)*(t2/2.+t)/cy;
	}
	Value rq_saw					(Value const &x, Value const &y)
	{
		double rx=x, t=rx-::floor(rx);
		boost::math::quaternion<double> qy=y, t2=floor(qy-t);
		return (t2+1.)*(t2/2.+t)/qy;
	}
	Value cr_saw					(Value const &x, Value const &y)
	{
		std::complex<double> cx=x, cy=y, t=cx-floor(cx), t2=floor(cy-t);
		return (t2+1.)*(t2/2.+t)/cy;
	}
	Value cc_saw					(Value const &x, Value const &y)
	{
		std::complex<double> cx=x, cy=y, t=cx-floor(cx), t2=floor(cy-t);
		return (t2+1.)*(t2/2.+t)/cy;
	}
	Value cq_saw					(Value const &x, Value const &y)
	{
		std::complex<double> cx=x, t=cx-floor(cx);
		boost::math::quaternion<double> qy=y, t2=floor(qy-t);
		return (t2+1.)*(t2/2.+t)/qy;
	}
	Value qr_saw					(Value const &x, Value const &y)
	{
		double ry=y;
		boost::math::quaternion<double> qx=x, t=qx-floor(qx), t2=floor(ry-t);
		return (t2+1.)*(t2/2.+t)/ry;
	}
	Value qc_saw					(Value const &x, Value const &y)
	{
		std::complex<double> cy=y;
		boost::math::quaternion<double> qx=x, t=qx-floor(qx), t2=floor(cy-t);
		return (t2+1.)*(t2/2.+t)/cy;
	}
	Value qq_saw					(Value const &x, Value const &y)
	{
		boost::math::quaternion<double> qx=x, qy=y, t=qx-floor(qx), t2=floor(qy-t);
		return (t2+1.)*(t2/2.+t)/qy;
	}
	bool disc_r_saw_i				(Value const &x0, Value const &x1){return std::ceil(x0.r)!=std::ceil(x1.r);}
	bool disc_c_saw_i				(Value const &x0, Value const &x1){return _1d_int_in_range(x0.r, x1.r)||_1d_int_in_range(x0.i, x1.i);}
	bool disc_q_saw_i				(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1)
	{
		double t0=x0.r-y0.r, t1=x1.r-y1.r;
		return std::floor(t0)!=std::floor(t1);
	}
	bool disc_rc_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rq_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cc_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	Value  r_min					(Value const &x){return x;}
	auto c_min=r_min, q_min=r_min;
	//Value  c_min					(Value const &x){return x;}
	//Value  q_min					(Value const &x){return x;}
	Value rr_min					(Value const &x, Value const &y){return x.r!=x.r||y.r!=y.r?_qnan:(x.r+y.r-std::abs(x.r-y.r))/2;}
	auto rc_min=rr_min, rq_min=rr_min, cr_min=rr_min, cc_min=rr_min, cq_min=rr_min, qr_min=rr_min, qc_min=rr_min, qq_min=rr_min;
	//Value rc_min					(Value const &x, Value const &y){return x.r<y.r?x.r:y.r;}
	//Value rq_min					(Value const &x, Value const &y){return x.r<y.r?x.r:y.r;}
	//Value cr_min					(Value const &x, Value const &y){return x.r<y.r?x.r:y.r;}
	//Value cc_min					(Value const &x, Value const &y){return x.r<y.r?x.r:y.r;}
	//Value cq_min					(Value const &x, Value const &y){return x.r<y.r?x.r:y.r;}
	//Value qr_min					(Value const &x, Value const &y){return x.r<y.r?x.r:y.r;}
	//Value qc_min					(Value const &x, Value const &y){return x.r<y.r?x.r:y.r;}
	//Value qq_min					(Value const &x, Value const &y){return x.r<y.r?x.r:y.r;}

	Value  r_max					(Value const &x){return x;}
	auto c_max=r_max, q_max=r_max;
	Value rr_max					(Value const &x, Value const &y){return x.r!=x.r||y.r!=y.r?_qnan:(x.r+y.r+std::abs(x.r-y.r))/2;}
	auto rc_max=rr_max, rq_max=rr_max, cr_max=rr_max, cc_max=rr_max, cq_max=rr_max, qr_max=rr_max, qc_max=rr_max, qq_max=rr_max;

	Value    conditional_111		(Value const &x, Value const &y, Value const &z){return x.q_isTrue()?y:z;}
	Value    conditional_110		(Value const &x, Value const &y)				{return x.q_isTrue()?y:Value();}
	Value    conditional_101		(Value const &x, Value const &y)				{return x.q_isTrue()?Value():y;}
	Value    conditional_011		(Value const &x, Value const &y)				{return y;}
	bool disc_conditional_111_i		(Value const &x0, Value const &y0, Value const &z0, Value const &x1, Value const &y1, Value const &z1){return _1d_zero_in_range(x0.r, x1.r)||_1d_zero_in_range(x0.i, x1.i)||_1d_zero_in_range(x0.j, x1.j)||_1d_zero_in_range(x0.k, x1.k);}
	bool disc_conditional_110_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return _1d_zero_in_range(x0.r, x1.r)||_1d_zero_in_range(x0.i, x1.i)||_1d_zero_in_range(x0.j, x1.j)||_1d_zero_in_range(x0.k, x1.k);}
	auto disc_conditional_101_i		=disc_conditional_110_i;
	
	Value  increment				(Value const &x){return Value(x.r+1, x.i, x.j, x.k);}//wow
	Value  decrement				(Value const &x){return Value(x.r-1, x.i, x.j, x.k);}

	Value  r_assign					(Value const &x, Value const &y){return y.r;}
	Value  c_assign					(Value const &x, Value const &y){return (std::complex<double>)y;}
	Value  q_assign					(Value const &x, Value const &y){return y;}
	//rr_assign_multiply == rr_multiply
	//...
	//qq_assign_multiply == qq_multiply
	//... ...
	//rr_assign_or == rr_bitwise_or
	//...
	//qq_assign_or == qq_bitwise_or
}

bool UserFunctionsDefaultReturnZero=false;
bool markFunctionsStuck=false;//true: stuck once return nan regardless of input, false: stuck every time, return nan where stuck only
int userFunctionTimeLimit=400;//ms		4000
struct CallInfo
{
	int i;//call address		index in instructions vector
	Expression *func;
	CallInfo(Expression *func, int i):func(func), i(i){}
	std::vector<Value> fData;
};
struct CallInfo_LR//latest result
{
	int i;//call address		index in instructions vector
	Expression *func;
	Value latestResult;
	CallInfo_LR(Expression *func, int i, Value const&latestResult):func(func), i(i), latestResult(latestResult){}
	std::vector<Value> fData;
};
struct Solve_UserFunction
{
	Expression &expr;
	Instruction &in;
	Solve_UserFunction(Expression &expr, Instruction &in):expr(expr), in(in){}
	void operator()(int v)const
	{
		auto func=&userFunctionDefinitions[in.op1];
		std::vector<Value> fData(func->data.size());
		{
			int k=0;
			for(int kEnd=in.args.size();k<kEnd;++k)//copy args
				fData[k]=expr.n[in.args[k]].ndr[v];
			for(int kEnd=func->data.size();k<kEnd;++k)//initialize const data
				fData[k]=func->data[k];
		}
		int startTime=clock(), expiryTime=startTime+userFunctionTimeLimit, offset=(startTime>0&&expiryTime<0)*userFunctionTimeLimit;
		if(UserFunctionsDefaultReturnZero)
		{
			std::stack<CallInfo> callStack;
			for(int i2=0, nInstr=func->i.size();;)
			{
				if(i2>=nInstr)//return nothing	unreachable
				{
					if(callStack.size())
					{
						auto &cst=callStack.top();
						func=cst.func;
						i2=cst.i, nInstr=func->i.size();
						cst.fData[func->i[i2].result]=Value();
					//	cst.fData[func->i[i2].result]=fData[0];//
						std::swap(cst.fData, fData);
						callStack.pop();
						continue;
					}
					expr.n[in.result].ndr[v]=Value();
					break;
				}
				if(clock()+offset>expiryTime)
				{
					func->functionStuck=true;//mark function

					//return nan
					if(callStack.size())
					{
						auto &cst=callStack.top();
						func=cst.func;
						i2=cst.i, nInstr=func->i.size();
						cst.fData[func->i[i2].result]=G2::_qnan;
						std::swap(cst.fData, fData);
						callStack.pop();
						++i2;
						continue;
					}
					expr.n[in.result].ndr[v]=G2::_qnan;
					break;
				}
				auto &in2=func->i[i2];
				switch(in2.type)
				{
				case 'c'://call user function
					if(markFunctionsStuck&&userFunctionDefinitions[in2.op1].functionStuck)//return nan without call
					{
						fData[in2.result]=G2::_qnan;
						++i2;
					}
					else
					{
						callStack.push(CallInfo(func, i2));
						auto &cst=callStack.top();
						cst.fData=std::move(fData);
					//	func=in2.function;
						func=&userFunctionDefinitions[in2.op1], i2=0;
						fData.resize(func->data.size());
						{
							int k=0;
							for(int kEnd=in2.args.size();k<kEnd;++k)//copy args
								fData[k]=cst.fData[in2.args[k]];
							//	fData[k]=cst.func->data[in2.args[k]];
							for(int kEnd=func->data.size();k<kEnd;++k)//initialize const data
								fData[k]=func->data[k];
						}
					}
					continue;
				case 'b'://branch if
					if(fData[in2.op1].q_isTrue())
						i2=in2.result;
					else
						++i2;
					continue;
				case 'B'://branch if not
					if(!fData[in2.op1].q_isTrue())
						i2=in2.result;
					else
						++i2;
					continue;
				case 'j'://jump
					i2=in2.result;
					continue;
				case 'r'://return
					if(callStack.size())
					{
						auto &cst=callStack.top();
						func=cst.func;
						i2=cst.i, nInstr=func->i.size();
						cst.fData[func->i[i2].result]=fData[in2.result];
						std::swap(cst.fData, fData);
						callStack.pop();
						++i2;
						continue;
					}
					expr.n[in.result].ndr[v]=fData[in2.result];
					break;
				case 1:
					fData[in2.result]=in2.uf(fData[in2.op1]);
					++i2;
					continue;
				case 2:
					fData[in2.result]=in2.bf(fData[in2.op1], fData[in2.op2]);
					++i2;
					continue;
				case 3:
					fData[in2.result]=in2.tf(fData[in2.op1], fData[in2.op2], fData[in2.op3]);
					++i2;
					continue;
				}
				break;
			}
		}
		else//user functions default return latest result
		{
			Value latestResult;
			std::stack<CallInfo_LR> callStack;
			for(int i2=0, nInstr=func->i.size();;)
			{
				if(i2>=nInstr)//return nothing	unreachable
				{
					if(callStack.size())
					{
						auto &cst=callStack.top();
						func=cst.func;
						i2=cst.i, nInstr=func->i.size();
						cst.fData[func->i[i2].result]=cst.latestResult;
					//	cst.fData[func->i[i2].result]=fData[0];//
						std::swap(cst.fData, fData);
						callStack.pop();
						continue;
					}
					expr.n[in.result].ndr[v]=latestResult;
					break;
				}
				if(clock()+offset>expiryTime)
				{
					func->functionStuck=true;//mark function

					//return nan
					if(callStack.size())
					{
						auto &cst=callStack.top();
						func=cst.func;
						i2=cst.i, nInstr=func->i.size();
						cst.fData[func->i[i2].result]=G2::_qnan;
						std::swap(cst.fData, fData);
						callStack.pop();
						++i2;
						continue;
					}
					expr.n[in.result].ndr[v]=G2::_qnan;
					break;
				}
				auto &in2=func->i[i2];
				switch(in2.type)
				{
				case 'c'://call user function
					if(markFunctionsStuck&&userFunctionDefinitions[in2.op1].functionStuck)//return nan without call
					{
						fData[in2.result]=G2::_qnan;
						++i2;
					}
					else
					{
						callStack.push(CallInfo_LR(func, i2, latestResult));
						auto &cst=callStack.top();
						cst.fData=std::move(fData);
					//	func=in2.function;
						func=&userFunctionDefinitions[in2.op1], i2=0;
						fData.resize(func->data.size());
						{
							int k=0;
							for(int kEnd=in2.args.size();k<kEnd;++k)//copy args
								fData[k]=cst.fData[in2.args[k]];
							//	fData[k]=cst.func->data[in2.args[k]];
							for(int kEnd=func->data.size();k<kEnd;++k)//initialize const data
								fData[k]=func->data[k];
						}
					}
					continue;
				case 'b'://branch if
					if(fData[in2.op1].q_isTrue())
						i2=in2.result;
					else
						++i2;
					continue;
				case 'B'://branch if not
					if(!fData[in2.op1].q_isTrue())
						i2=in2.result;
					else
						++i2;
					continue;
				case 'j'://jump
					i2=in2.result;
					continue;
				case 'r'://return
					if(callStack.size())
					{
						auto &cst=callStack.top();
						func=cst.func;
						i2=cst.i, nInstr=func->i.size();
						latestResult=cst.fData[func->i[i2].result]=fData[in2.result];
						std::swap(cst.fData, fData);
						callStack.pop();
						++i2;
						continue;
					}
					expr.n[in.result].ndr[v]=fData[in2.result];
					break;
				case 1:
					latestResult=fData[in2.result]=in2.uf(fData[in2.op1]);
					++i2;
					continue;
				case 2:
					latestResult=fData[in2.result]=in2.bf(fData[in2.op1], fData[in2.op2]);
					++i2;
					continue;
				case 3:
					latestResult=fData[in2.result]=in2.tf(fData[in2.op1], fData[in2.op2], fData[in2.op3]);
					++i2;
					continue;
				}
				break;
			}
		}
	}
	void operator()()const
	{
		auto func=&userFunctionDefinitions[in.op1];
		std::vector<Value> fData(func->data.size());
		{
			int k=0;
			for(int kEnd=in.args.size();k<kEnd;++k)//copy args
				fData[k]=expr.data[in.args[k]];										//ONLY DIFFERENCE
			for(int kEnd=func->data.size();k<kEnd;++k)//initialize const data
				fData[k]=func->data[k];
		}
		int startTime=clock(), expiryTime=startTime+userFunctionTimeLimit, offset=(startTime>0&&expiryTime<0)*userFunctionTimeLimit;
		if(UserFunctionsDefaultReturnZero)
		{
			std::stack<CallInfo> callStack;
			for(int i2=0, nInstr=func->i.size();;)
			{
				if(i2>=nInstr)//return nothing	unreachable
				{
					if(callStack.size())
					{
						auto &cst=callStack.top();
						func=cst.func;
						i2=cst.i, nInstr=func->i.size();
						cst.fData[func->i[i2].result]=Value();
					//	cst.fData[func->i[i2].result]=fData[0];//
						std::swap(cst.fData, fData);
						callStack.pop();
						continue;
					}
					expr.data[in.result]=Value();
					break;
				}
				if(function_timeout&&clock()+offset>expiryTime)
				{
					func->functionStuck=true;//mark function

					//return nan
					if(callStack.size())
					{
						auto &cst=callStack.top();
						func=cst.func;
						i2=cst.i, nInstr=func->i.size();
						cst.fData[func->i[i2].result]=G2::_qnan;
						std::swap(cst.fData, fData);
						callStack.pop();
						++i2;
						continue;
					}
					expr.data[in.result]=G2::_qnan;
					break;
				}
				auto &in2=func->i[i2];
				switch(in2.type)
				{
				case 'c'://call user function
					if(markFunctionsStuck&&userFunctionDefinitions[in2.op1].functionStuck)//return nan without call
					{
						fData[in2.result]=G2::_qnan;
						++i2;
					}
					else
					{
						callStack.push(CallInfo(func, i2));
						auto &cst=callStack.top();
						cst.fData=std::move(fData);
					//	func=in2.function;
						func=&userFunctionDefinitions[in2.op1], i2=0;
						fData.resize(func->data.size());
						{
							int k=0;
							for(int kEnd=in2.args.size();k<kEnd;++k)//copy args
								fData[k]=cst.fData[in2.args[k]];
							for(int kEnd=func->data.size();k<kEnd;++k)//initialize const data
								fData[k]=func->data[k];
						}
					}
					continue;
				case 'b'://branch if
					if(fData[in2.op1].q_isTrue())
						i2=in2.result;
					else
						++i2;
					continue;
				case 'B'://branch if not
					if(!fData[in2.op1].q_isTrue())
						i2=in2.result;
					else
						++i2;
					continue;
				case 'j'://jump
					i2=in2.result;
					continue;
				case 'r'://return
					if(callStack.size())
					{
						auto &cst=callStack.top();
						func=cst.func;
						i2=cst.i, nInstr=func->i.size();
						cst.fData[func->i[i2].result]=fData[in2.result];
						std::swap(cst.fData, fData);
						callStack.pop();
						++i2;
						continue;
					}
					expr.data[in.result]=fData[in2.result];								//ONLY DIFFERENCE
					break;
				case 1:
					fData[in2.result]=in2.uf(fData[in2.op1]);
					++i2;
					continue;
				case 2:
					fData[in2.result]=in2.bf(fData[in2.op1], fData[in2.op2]);
					++i2;
					continue;
				case 3:
					fData[in2.result]=in2.tf(fData[in2.op1], fData[in2.op2], fData[in2.op3]);
					++i2;
					continue;
				}
				break;
			}
		}
		else
		{
			Value latestResult;
			std::stack<CallInfo_LR> callStack;
			for(int i2=0, nInstr=func->i.size();;)
			{
				if(i2>=nInstr)//return nothing	unreachable
				{
					if(callStack.size())
					{
						auto &cst=callStack.top();
						func=cst.func;
						i2=cst.i, nInstr=func->i.size();
						cst.fData[func->i[i2].result]=cst.latestResult;
					//	cst.fData[func->i[i2].result]=fData[0];//
						std::swap(cst.fData, fData);
						callStack.pop();
						continue;
					}
					expr.data[in.result]=latestResult;
					break;
				}
				if(function_timeout&&clock()+offset>expiryTime)
				{
					func->functionStuck=true;//mark function

					//return nan
					if(callStack.size())
					{
						auto &cst=callStack.top();
						func=cst.func;
						i2=cst.i, nInstr=func->i.size();
						cst.fData[func->i[i2].result]=G2::_qnan;
						std::swap(cst.fData, fData);
						callStack.pop();
						++i2;
						continue;
					}
					expr.data[in.result]=G2::_qnan;
					break;
				}
				auto &in2=func->i[i2];
				switch(in2.type)
				{
				case 'c'://call user function
					if(markFunctionsStuck&&userFunctionDefinitions[in2.op1].functionStuck)//return nan without call
					{
						fData[in2.result]=G2::_qnan;
						++i2;
					}
					else
					{
						callStack.push(CallInfo_LR(func, i2, latestResult));
						auto &cst=callStack.top();
						cst.fData=std::move(fData);
					//	func=in2.function;
						func=&userFunctionDefinitions[in2.op1], i2=0;
						fData.resize(func->data.size());
						{
							int k=0;
							for(int kEnd=in2.args.size();k<kEnd;++k)//copy args
								fData[k]=cst.fData[in2.args[k]];
							for(int kEnd=func->data.size();k<kEnd;++k)//initialize const data
								fData[k]=func->data[k];
						}
					}
					continue;
				case 'b'://branch if
					if(fData[in2.op1].q_isTrue())
						i2=in2.result;
					else
						++i2;
					continue;
				case 'B'://branch if not
					if(!fData[in2.op1].q_isTrue())
						i2=in2.result;
					else
						++i2;
					continue;
				case 'j'://jump
					i2=in2.result;
					continue;
				case 'r'://return
					if(callStack.size())
					{
						auto &cst=callStack.top();
						func=cst.func;
						i2=cst.i, nInstr=func->i.size();
						latestResult=cst.fData[func->i[i2].result]=fData[in2.result];
						std::swap(cst.fData, fData);
						callStack.pop();
						++i2;
						continue;
					}
					expr.data[in.result]=fData[in2.result];								//ONLY DIFFERENCE
					break;
				case 1:
					latestResult=fData[in2.result]=in2.uf(fData[in2.op1]);
					++i2;
					continue;
				case 2:
					latestResult=fData[in2.result]=in2.bf(fData[in2.op1], fData[in2.op2]);
					++i2;
					continue;
				case 3:
					latestResult=fData[in2.result]=in2.tf(fData[in2.op1], fData[in2.op2], fData[in2.op3]);
					++i2;
					continue;
				}
				break;
			}
		}
	}
};
bool inline_if_default_true=true;
bool verticalBarAbs=false;
bool const omitExprWithUnexpectedCommas=false;
class		Compile
{
	static char const *precedence;
	static int const nOperators;
	static char *ub;
	static struct CompileTerm
	{
		bool constant, fresh;
		char mathSet;
		CompileTerm(bool constant, char mathSet, bool fresh=true):constant(constant), mathSet(mathSet), fresh(fresh){}
	} *term;
	static int bi_mass		(int);
	static int prec_convert	(int);
	static char prec		(int, char, int, char);
	static int default_overload(int);

	static void compile_instruction_f_def	(int);
	static void compile_instruction_select_u(int, char, char, Value (*&)(Value const&), char (*&)(char), DiscontinuityFunction&);
	static void compile_instruction_select_b(int, char, char, Value (*&)(Value const&, Value const&), char (*&)(char, char), DiscontinuityFunction&);
	static void compile_instruction_u		(int, char, int, bool=false);
	static void compile_instruction_b		(int, int, int, bool=false);
//	static int compile_instruction_b		(int, int, int, bool=false);
//	static int compile_instruction_b		(int, int, int, bool=false, bool=false, bool=false);
//	static int compile_instruction_b		(int, int, int, bool=false);
//	static int compile_instruction_b		(int, int, int, char=0);
	static void compile_instruction_b2		(int, int, int);
	static void compile_instruction_condition_111	(int, int, int);
	static void compile_instruction_condition_110	(int, int);
	static void compile_instruction_condition_101	(int, int);
	static void compile_instruction_condition_100	(int);
	static void compile_instruction_condition_011	(int, int);
	static void compile_instruction_condition_010	(int);
	static char compile_instruction			(int, char, int=-1, int=-1, int=-1);
//	static int compile_instruction			(int, char, int=-1, int=-1, int=-1);
	
	static int compile_instruction_userFunctionCall(int, std::vector<int>const&, bool=false);
//	static int compile_instruction_userFunctionCall(int, std::vector<int>const&);
//	static void compile_instruction_userFunctionCall(int, std::vector<int>const&);
//	static void compile_instruction_userFunctionCall(int, std::vector<int>const&, int);
	static int compile_instruction_branch_if		(int);
	static int compile_instruction_branch_if_not	(int);
	static int compile_instruction_jump				();
	static int compile_instruction_return			(int);
	static int compile_instruction_return			(Value const&);
	static void compile_instruction_assign			(int, int);
	static void compile_instruction_assign_value	(int, Value const&);

	static void compile_execute				(int, int, int);
	static void compile_abs					(int, int, int);
	static void compile_inline_if			(int, int, int);
//	static void compile_inline_if			(int, int, int, bool);

	static void compile_assignment			(int, int);
	static void compile_expression_local	(int, int);
	static bool compile_exprStatement		(int&, int);
//	static void compile_exprStatement		(int&, int);
	static bool comp_seek_allowNewline		(int&, int, int);
	static bool comp_seek_condition			(int&, int, int&, int&);
	static bool comp_seek_forHeader			(int&, int, int&, int&, int&, int&);
	static bool comp_seek_block				(int&, int, int&, int&);

	static std::stack<std::pair<int, std::vector<int>>> loopInfo;//i_loop, i_break[]
//	static std::stack<int> loopStart, loopEnd;
//	static int n_lastResult;
	static void compile_statement			(int&, int);
	static void compile_block				(int, int);
public:
	static void compile_function			(Expression&);
	static void compile_expression_global	(Expression&);
	static int expressionResultLogicType();
	static char predictedMathSet;
	static Expression *expr;
	static bool procedural, recursiveFunction;
};
const char		*Compile::precedence=//"uu ub bu bb"	u: unary, b: binary
//<\>	++		!		%		~		p		t		^				*		+		s		c		=		&		#		|		a		x		o		@		f		_
/*++*/	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"_<_<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*!*/	"><><"	">><<"	">><<"	">><<"	">>>>"	">>>>"	">>>>"	"_>_<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*%*/	"><><"	">>>>"	"><><"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*~*/	"><><"	">>>>"	"><><"	"><><"	">>>>"	">>>>"	">>>>"	"_>_<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*p*/	"><><"	">>>>"	"><><"	">>>>"	">>>>"	"<<<<"	"<<<<"	"_>_>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*t*/	"><><"	">>>>"	"><><"	">>>>"	">>>>"	">>>>"	"<<<<"	"_>_>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*^*/	"><><"	">>>>"	"><><"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/* */	"__><"	"__>>"	"__><"	"__><"	"__>>"	"__>>"	"__>>"	"___<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"
/***/	"><><"	">>>>"	"><><"	"><><"	">>>>"	">>>>"	">>>>"	"_>_>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*+*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	"<<>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"//2^-2*3
/*s*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*c*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*=*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*&*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*#*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*|*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*a*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*x*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*o*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*@*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	">>>>"	"<<<<"
/*f*/	">>>>"	">>>>"	"><><"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*_*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<";
int const		Compile::nOperators=(int)std::sqrt(std::strlen(Compile::precedence)/4);
char			*Compile::ub;
Compile::CompileTerm *Compile::term=nullptr;
char			Compile::predictedMathSet;
Expression		*Compile::expr=nullptr;
bool			Compile::procedural=false, Compile::recursiveFunction=false;
int				Compile::bi_mass		(int m)
{
	using namespace G2;
//	if(m>M_FUNCTION_START)																					return  1;
	if(m>M_FSTART)																							return  1;
	switch(m)
	{
	case M_FACTORIAL_LOGIC_NOT:	case M_BITWISE_NOT:case M_DECREMENT:case M_INCREMENT:						return  1;
	case M_PLUS:				case M_MINUS:																return  2;
	case M_BITWISE_AND:			case M_BITWISE_NAND:														return  3;
	case M_BITWISE_XOR:			case M_BITWISE_XNOR:														return  4;
	case M_VERTICAL_BAR:		case M_BITWISE_NOR:															return  5;
	case M_MULTIPLY:			case M_DIVIDE:case M_MODULO_PERCENT:										return  6;
	case M_BITWISE_SHIFT_LEFT:	case M_BITWISE_SHIFT_RIGHT:													return  7;
	case M_POWER:																							return  8;
	case M_TETRATE:																							return  9;
	case M_PENTATE:																							return 10;
	case M_LOGIC_LESS:			case M_LOGIC_LESS_EQUAL:case M_LOGIC_GREATER:case M_LOGIC_GREATER_EQUAL:	return 11;
	case M_LOGIC_EQUAL:			case M_LOGIC_NOT_EQUAL:														return 12;
	case M_LOGIC_AND:																						return 13;
	case M_LOGIC_XOR:																						return 14;
	case M_LOGIC_OR:																						return 15;
	case M_LOGIC_CONDITION_ZERO:																			return 16;
	case M_S_EQUAL_ASSIGN:		case M_S_LESS:case M_S_LESS_EQUAL:case M_S_GREATER:case M_S_GREATER_EQUAL:	return 17;
	}
																											return -1;
}
int				Compile::prec_convert	(int m)
{
	using namespace G2;
	switch(m)
	{
	case M_DECREMENT:case M_INCREMENT:																		return  0;
	case M_FACTORIAL_LOGIC_NOT:																				return  1;
	case M_MODULO_PERCENT:																					return  2;
	case M_BITWISE_NOT:																						return  3;
	case M_PENTATE:																							return  4;
	case M_TETRATE:																							return  5;
	case M_POWER:																							return  6;
	case M_N:																								return  7;
	case M_MULTIPLY:case M_DIVIDE:																			return  8;
	case M_PLUS:case M_MINUS:																				return  9;
	case M_BITWISE_SHIFT_LEFT:	case M_BITWISE_SHIFT_RIGHT:													return 10;
	case M_LOGIC_LESS:			case M_LOGIC_LESS_EQUAL:case M_LOGIC_GREATER:case M_LOGIC_GREATER_EQUAL:	return 11;
	case M_LOGIC_EQUAL:			case M_LOGIC_NOT_EQUAL:														return 12;
	case M_BITWISE_AND:			case M_BITWISE_NAND:														return 13;
	case M_BITWISE_XOR:			case M_BITWISE_XNOR:														return 14;
	case M_VERTICAL_BAR:		case M_BITWISE_NOR:															return 15;
	case M_LOGIC_AND:																						return 16;
	case M_LOGIC_XOR:																						return 17;
	case M_LOGIC_OR:																						return 18;
	case M_LOGIC_CONDITION_ZERO:																			return 19;
	case M_S_EQUAL_ASSIGN:		case M_S_LESS:case M_S_LESS_EQUAL:case M_S_GREATER:case M_S_GREATER_EQUAL:	return 21;
	}
//	if(m>M_FUNCTION_START)																					return 20;
	if(m>M_FSTART)																							return 20;
																											return 0;
																											//return -1;//stuck
}
char			Compile::prec			(int lop, char lub, int rop, char rub){return precedence[((nOperators*prec_convert(lop)+prec_convert(rop))<<2)|((lub=='b')<<1)|(rub=='b')];}
void			Compile::compile_instruction_f_def		(int f)
{
	using namespace G2;
	Value x;
	switch(expr->m[f]._0)
	{
	case M_REAL:		x=c_real(x);			break;
	case M_IMAG:		x=c_imag(x);			break;
	case M_COS:			x=r_cos(x);				break;
	case M_ACOS:		x=c_acos(x);			break;
	case M_COSH:		x=r_cosh(x);			break;
	case M_ACOSH:		x=c_acosh(x);			break;
	case M_COSC:		x=r_cosc(x);			break;
	case M_SEC:			x=r_sec(x);				break;
	case M_ASEC:		x=c_asec(x);			break;
	case M_SECH:		x=r_sech(x);			break;
	case M_ASECH:		x=c_asech(x);			break;
	case M_SIN:			x=r_sin(x);				break;
	case M_ASIN:		x=c_asin(x);			break;
	case M_SINH:		x=r_sinh(x);			break;
	case M_ASINH:		x=r_asinh(x);			break;
	case M_SINC:		x=r_sinc(x);			break;
	case M_SINHC:		x=r_sinhc(x);			break;
	case M_CSC:			x=r_csc(x);				break;
	case M_ACSC:		x=c_acsc(x);			break;
	case M_CSCH:		x=r_csch(x);			break;
	case M_ACSCH:		x=r_acsch(x);			break;
	case M_TAN:			x=r_tan(x);				break;
	case M_TANH:		x=r_tanh(x);			break;
	case M_ATANH:		x=c_atanh(x);			break;
	case M_TANC:		x=r_tanc(x);			break;
	case M_COT:			x=r_cot(x);				break;
	case M_ACOT:		x=r_acot(x);			break;
	case M_COTH:		x=r_coth(x);			break;
	case M_ACOTH:		x=c_acoth(x);			break;
	case M_EXP:			x=r_exp(x);				break;
	case M_LN:			x=c_ln(x);				break;
	case M_SQRT:		x=c_sqrt(x);			break;
	case M_CBRT:		x=r_cbrt(x);			break;
	case M_INVSQRT:		x=r_invsqrt(x);			break;
	case M_ERF:			x=r_erf(x);				break;
	case M_FIB:			x=r_fib(x);				break;
	case M_ZETA:		x=r_zeta(x);			break;
	case M_STEP:		x=r_step(x);			break;
	case M_SGN:			x=r_sgn(x);				break;
	case M_RECT:		x=r_rect(x);			break;
	case M_TENT:		x=r_trgl(x);			break;
	case M_CEIL:		x=r_ceil(x);			break;
	case M_FLOOR:		x=r_floor(x);			break;
	case M_ROUND:		x=r_round(x);			break;
	case M_ABS:			x=r_abs(x);				break;
	case M_ARG:			x=r_arg(x);				break;
	case M_RAND:		x=r_random(x);			break;
	case M_ATAN:		x=r_atan(x);			break;
	case M_LOG:			x=c_log(x);				break;
	case M_BETA:		x=r_beta(x);			break;
	case M_GAMMA:		x=r_tgamma(x);			break;
	case M_LNGAMMA:		x=r_loggamma(x);		break;
	case M_GAUSS:		x=r_gauss(x);			break;
	case M_PERMUTATION:	x=r_permutation(x);		break;
	case M_COMBINATION:	x=r_combination(x);		break;
	case M_BESSEL:		x=r_cyl_bessel_j(x);	break;
	case M_NEUMANN:		x=r_cyl_neumann(x);		break;
	case M_HANKEL1:		x=r_hankel1(x);			break;
	case M_SQWV:		x=r_sqwv(x);			break;
	case M_TRWV:		x=r_trwv(x);			break;
	case M_SAW:			x=r_saw(x);				break;
	case M_MIN:			x=r_min(x);				break;
	case M_MAX:			x=r_max(x);				break;
	}
	expr->m[f]=::Map(expr->m[f].pos, expr->m[f].len, M_N, expr->n.size()), expr->insertData(x.i?'c':'r', x), term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm)), term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet);
//	expr->m[f]=::Map(M_N, expr->n.size()), expr->insertData(x.i?'C':'R', x), term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm)), term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet);
}
void			Compile::compile_instruction_select_u	(int f, char side, char op1type, Value (*&function)(Value const&), char (*&umts)(char), DiscontinuityFunction &d)
{
	using namespace G2;
	switch(op1type)
	{
	case 'r':
//	case 'R':
		switch(f)
		{
		case M_REAL:				function=c_real,					umts=returns_rrr,		d();								return;
		case M_IMAG:				function=c_imag,					umts=returns_rrr,		d();								return;
		case M_CONJUGATE:			function=r_conjugate,				umts=returns_rcq,		d();								return;
		case M_POLAR:				function=r_polar,					umts=returns_ccc,		d(disc_r_polar_i, true);			return;
		case M_CARTESIAN:			function=r_cartesian,				umts=returns_rcq,		d();								return;
		case M_DIVIDE:				function=r_divide,					umts=returns_rcq,		d(disc_r_divide_i, true);			return;
		case M_MINUS:				function=r_minus,					umts=returns_rcq,		d();								return;
		case M_MODULO_PERCENT:		function=r_percent,					umts=returns_rcq,		d();								return;
		case M_INCREMENT:			function=increment,					umts=returns_rcq,		d();								return;
		case M_DECREMENT:			function=decrement,					umts=returns_rcq,		d();								return;
		case M_BITWISE_NOT:			function=r_bitwise_not,				umts=returns_rcq,		d(disc_r_bitwise_not_i, true);		return;
		case M_BITWISE_SHIFT_LEFT:		 if(side=='<')	function=r_bitwise_shift_left_l,	umts=returns_rcq,	d(disc_r_bitwise_shift_left_l_o, false);
									else				function=r_bitwise_shift_left_r,	umts=returns_rcq,	d();										return;
		case M_BITWISE_SHIFT_RIGHT:		 if(side=='<')	function=r_bitwise_shift_right_l,	umts=returns_rcq,	d(disc_r_bitwise_shift_right_l_o, false);
									else				function=r_bitwise_shift_right_r,	umts=returns_rcq,	d();										return;
		case M_FACTORIAL_LOGIC_NOT:		 if(side=='<')	function=r_logic_not,				umts=returns_rrr,	d(disc_r_logic_not_i, true);
									else				function=r_factorial,				umts=returns_rcq,	d(disc_r_factorial_i, true);				return;
		case M_LOGIC_LESS:				 if(side=='<')	function=r_logic_less_l,			umts=returns_rrr,	d(disc_r_logic_less_l_i, true);
									else				function=r_logic_less_r,			umts=returns_rrr,	d(disc_r_logic_less_r_i, true);				return;
		case M_LOGIC_LESS_EQUAL:		 if(side=='<')	function=r_logic_less_equal_l,		umts=returns_rrr,	d(disc_r_logic_less_equal_l_i, true);
									else				function=r_logic_less_equal_r,		umts=returns_rrr,	d(disc_r_logic_less_equal_r_i, true);		return;
		case M_LOGIC_GREATER:			 if(side=='<')	function=r_logic_greater_l,			umts=returns_rrr,	d(disc_r_logic_greater_l_i, true);
									else				function=r_logic_greater_r,			umts=returns_rrr,	d(disc_r_logic_greater_r_i, true);			return;
		case M_LOGIC_GREATER_EQUAL:		 if(side=='<')	function=r_logic_greater_equal_l,	umts=returns_rrr,	d(disc_r_logic_greater_equal_l_i, true);
									else				function=r_logic_greater_equal_r,	umts=returns_rrr,	d(disc_r_logic_greater_equal_r_i, true);	return;
		case M_LOGIC_EQUAL:			function=r_logic_equal,				umts=returns_rrr,		d(disc_r_logic_equal_i, true);		return;
		case M_LOGIC_NOT_EQUAL:		function=r_logic_not_equal,			umts=returns_rrr,		d(disc_r_logic_not_equal_i, true);	return;
		case M_BITWISE_AND:			function=r_bitwise_and,				umts=returns_rcq,		d(disc_r_bitwise_and_o, false);		return;
		case M_BITWISE_NAND:		function=r_bitwise_nand,			umts=returns_rcq,		d(disc_r_bitwise_nand_o, false);	return;
		case M_BITWISE_XOR:			function=r_bitwise_xor,				umts=returns_rcq,		d(disc_r_bitwise_xor_o, false);		return;
		case M_BITWISE_XNOR:		function=r_bitwise_xnor,			umts=returns_rcq,		d(disc_r_bitwise_xnor_o, false);	return;
		case M_VERTICAL_BAR:		function=r_bitwise_or,				umts=returns_rcq,		d(disc_r_bitwise_or_o, false);		return;
		case M_BITWISE_NOR:			function=r_bitwise_nor,				umts=returns_rcq,		d(disc_r_bitwise_nor_o, false);		return;
		case M_COS:					function=r_cos,						umts=returns_rcq,		d();								return;
		case M_ACOS:				function=c_acos,					umts=returns_ccq,		d(disc_c_acos_i, true);				return;
		case M_COSH:				function=r_cosh,					umts=returns_rcq,		d();								return;
		case M_ACOSH:				function=c_acosh,					umts=returns_ccq,		d();								return;
		case M_COSC:				function=r_cosc,					umts=returns_rcq,		d(disc_r_cosc_i, true);				return;
		case M_SEC:					function=r_sec,						umts=returns_rcq,		d(disc_r_sec_i, true);				return;
		case M_ASEC:				function=c_asec,					umts=returns_ccq,		d(disc_c_asec_i, true);				return;
		case M_SECH:				function=r_sech,					umts=returns_rcq,		d();								return;
		case M_ASECH:				function=c_asech,					umts=returns_ccq,		d(disc_c_asech_i, true);			return;
		case M_SIN:					function=r_sin,						umts=returns_rcq,		d();								return;
		case M_ASIN:				function=c_asin,					umts=returns_ccq,		d(disc_c_asin_i, true);				return;
		case M_SINH:				function=r_sinh,					umts=returns_rcq,		d();								return;
		case M_ASINH:				function=r_asinh,					umts=returns_rcq,		d();								return;
		case M_SINC:				function=r_sinc,					umts=returns_rcq,		d();								return;
		case M_SINHC:				function=r_sinhc,					umts=returns_rcq,		d();								return;
		case M_CSC:					function=r_csc,						umts=returns_rcq,		d(disc_r_csc_i, true);				return;
		case M_ACSC:				function=c_acsc,					umts=returns_ccq,		d(disc_c_acsc_i, true);				return;
		case M_CSCH:				function=r_csch,					umts=returns_rcq,		d(disc_r_csch_i, true);				return;
		case M_ACSCH:				function=r_acsch,					umts=returns_rcq,		d(disc_r_acsch_i, true);			return;
		case M_TAN:					function=r_tan,						umts=returns_rcq,		d(disc_r_tan_i, true);				return;
		case M_ATAN:				function=r_atan,					umts=returns_rcq,		d(disc_c_atan_i, true);				return;
		case M_TANH:				function=r_tanh,					umts=returns_rcq,		d();								return;
		case M_ATANH:				function=c_atanh,					umts=returns_ccq,		d(disc_c_atanh_i, true);			return;
		case M_TANC:				function=r_tanc,					umts=returns_rcq,		d(disc_r_tanc_i, true);				return;
		case M_COT:					function=r_cot,						umts=returns_rcq,		d(disc_r_cot_i, true);				return;
		case M_ACOT:				function=r_acot,					umts=returns_rcq,		d(disc_r_acot_i, true);				return;
		case M_COTH:				function=r_coth,					umts=returns_rcq,		d(disc_r_coth_i, true);				return;
		case M_ACOTH:				function=c_acoth,					umts=returns_ccq,		d(disc_c_acoth_i, true);			return;
		case M_EXP:					function=r_exp,						umts=returns_rcq,		d();								return;
		case M_LN:					function=c_ln,						umts=returns_ccq,		d(disc_c_ln_i, true);				return;
		case M_LOG:					function=c_log,						umts=returns_ccq,		d(disc_c_log_i, true);				return;
		case M_SQRT:				function=c_sqrt,					umts=returns_ccq,		d();								return;
		case M_CBRT:				function=r_cbrt,					umts=returns_rcq,		d();								return;
		case M_INVSQRT:				function=r_invsqrt,					umts=returns_rXX,		d();								return;
		case M_ERF:					function=r_erf,						umts=returns_rXX,		d();								return;
		case M_FIB:					function=r_fib,						umts=returns_rcq,		d();								return;
		case M_ZETA:				function=r_zeta,					umts=returns_rXX,		d(disc_r_zeta_i, true);				return;
		case M_STEP:				function=r_step,					umts=returns_rcq,		d(disc_r_step_i, true);				return;
		case M_SGN:					function=r_sgn,						umts=returns_rcq,		d(disc_r_sgn_i, true);				return;
		case M_RECT:				function=r_rect,					umts=returns_rcq,		d(disc_r_rect_i, true);				return;
		case M_TENT:				function=r_trgl,					umts=returns_rrr,		d();								return;
		case M_CEIL:				function=r_ceil,					umts=returns_rcq,		d(disc_r_ceil_o, false);			return;
		case M_FLOOR:				function=r_floor,					umts=returns_rcq,		d(disc_r_floor_o, false);			return;
		case M_ROUND:				function=r_round,					umts=returns_rcq,		d(disc_r_round_o, false);			return;
		case M_ABS:					function=r_abs,						umts=returns_rrr,		d();								return;
		case M_ARG:					function=r_arg,						umts=returns_rrr,		d(disc_r_arg_i, true);				return;
		case M_RAND:				function=r_random,					umts=returns_rcq,		d(disc_r_random, false);			return;
		case M_GAMMA:				function=r_tgamma,					umts=returns_rcq,		d(disc_r_tgamma_i, true);			return;
		case M_LNGAMMA:				function=r_loggamma,				umts=returns_rXX,		d(disc_r_loggamma_i, true);			return;
		case M_GAUSS:				function=r_gauss,					umts=returns_rcq,		d();								return;
		case M_PERMUTATION:			function=r_permutation,				umts=returns_rcq,		d();								return;
		case M_COMBINATION:			function=r_combination,				umts=returns_rcq,		d();								return;
		case M_SQWV:				function=r_sqwv,					umts=returns_rcq,		d(disc_r_sqwv_i, true);				return;
		case M_TRWV:				function=r_trwv,					umts=returns_rcq,		d();								return;
		case M_SAW:					function=r_saw,						umts=returns_rcq,		d(disc_r_saw_i, true);				return;
		case M_MIN:					function=r_min,						umts=returns_rcq,		d();								return;
		case M_MAX:					function=r_max,						umts=returns_rcq,		d();								return;
		case M_BETA:				function=r_beta,					umts=returns_rXX,		d(disc_r_beta_i, true);				return;
		case M_BESSEL:				function=r_cyl_bessel_j,			umts=returns_rXX,		d(disc_r_cyl_bessel_j_i, true);		return;
		case M_NEUMANN:				function=r_cyl_neumann,				umts=returns_rXX,		d(disc_r_cyl_neumann_i, true);		return;
		case M_HANKEL1:				function=r_hankel1,					umts=returns_cXX,		d(disc_r_hankel1_i, true);			return;
		}
		break;
	case 'c':
//	case 'C':
		switch(f)
		{
		case M_REAL:				function=c_real,					umts=returns_rrr,		d();								return;
		case M_IMAG:				function=c_imag,					umts=returns_rrr,		d();								return;
		case M_CONJUGATE:			function=c_conjugate,				umts=returns_rcq,		d();								return;
		case M_POLAR:				function=c_polar,					umts=returns_ccc,		d(disc_c_polar_i, true);			return;
		case M_CARTESIAN:			function=c_cartesian,				umts=returns_rcq,		d();								return;
		case M_DIVIDE:				function=c_divide,					umts=returns_rcq,		d(disc_c_divide_i, true);			return;
		case M_MINUS:				function=c_minus,					umts=returns_rcq,		d();								return;
		case M_MODULO_PERCENT:		function=c_percent,					umts=returns_rcq,		d();								return;
		case M_INCREMENT:			function=increment,					umts=returns_rcq,		d();								return;
		case M_DECREMENT:			function=decrement,					umts=returns_rcq,		d();								return;
		case M_BITWISE_NOT:			function=c_bitwise_not,				umts=returns_rcq,		d(disc_c_bitwise_not_i, true);		return;
		case M_BITWISE_SHIFT_LEFT:		 if(side=='<')	function=c_bitwise_shift_left_l,	umts=returns_rcq,		d(disc_c_bitwise_shift_left_l_o, false);
									else				function=c_bitwise_shift_left_r,	umts=returns_rcq,		d();										return;
		case M_BITWISE_SHIFT_RIGHT:		 if(side=='<')	function=c_bitwise_shift_right_l,	umts=returns_rcq,		d(disc_c_bitwise_shift_right_l_o, false);
									else				function=c_bitwise_shift_right_r,	umts=returns_rcq,		d();										return;
		case M_FACTORIAL_LOGIC_NOT:		 if(side=='<')	function=c_logic_not,				umts=returns_rrr,		d(disc_c_logic_not_i, true);
									else				function=c_factorial,				umts=returns_rcq,		d(disc_c_factorial_i, true);				return;
		case M_LOGIC_LESS:				 if(side=='<')	function=c_logic_less_l,			umts=returns_rrr,		d(disc_c_logic_less_l_i, true);
									else				function=c_logic_less_r,			umts=returns_rrr,		d(disc_c_logic_less_r_i, true);				return;
		case M_LOGIC_LESS_EQUAL:		 if(side=='<')	function=c_logic_less_equal_l,		umts=returns_rrr,		d(disc_c_logic_less_equal_l_i, true);
									else				function=c_logic_less_equal_r,		umts=returns_rrr,		d(disc_c_logic_less_equal_r_i, true);		return;
		case M_LOGIC_GREATER:			 if(side=='<')	function=c_logic_greater_l,			umts=returns_rrr,		d(disc_c_logic_greater_l_i, true);
									else				function=c_logic_greater_r,			umts=returns_rrr,		d(disc_c_logic_greater_r_i, true);			return;
		case M_LOGIC_GREATER_EQUAL:		 if(side=='<')	function=c_logic_greater_equal_l,	umts=returns_rrr,		d(disc_c_logic_greater_equal_l_i, true);
									else				function=c_logic_greater_equal_r,	umts=returns_rrr,		d(disc_c_logic_greater_equal_r_i, true);	return;
		case M_LOGIC_EQUAL:			function=c_logic_equal,				umts=returns_rrr,		d(disc_c_logic_equal_i, true);		return;
		case M_LOGIC_NOT_EQUAL:		function=c_logic_not_equal,			umts=returns_rrr,		d(disc_c_logic_not_equal_i, true);	return;
		case M_BITWISE_AND:			function=c_bitwise_and,				umts=returns_rcq,		d(disc_c_bitwise_and_o, false);		return;
		case M_BITWISE_NAND:		function=c_bitwise_nand,			umts=returns_rcq,		d(disc_c_bitwise_nand_o, false);	return;
		case M_BITWISE_XOR:			function=c_bitwise_xor,				umts=returns_rcq,		d(disc_c_bitwise_xor_o, false);		return;
		case M_BITWISE_XNOR:		function=c_bitwise_xnor,			umts=returns_rcq,		d(disc_c_bitwise_xnor_o, false);	return;
		case M_VERTICAL_BAR:		function=c_bitwise_or,				umts=returns_rcq,		d(disc_c_bitwise_or_o, false);		return;
		case M_BITWISE_NOR:			function=c_bitwise_nor,				umts=returns_rcq,		d(disc_c_bitwise_nor_o, false);		return;
		case M_COS:					function=c_cos,						umts=returns_rcq,		d();								return;
		case M_ACOS:				function=c_acos,					umts=returns_ccq,		d(disc_c_ln_i, true);				return;
		case M_COSH:				function=c_cosh,					umts=returns_rcq,		d();								return;
		case M_ACOSH:				function=c_acosh,					umts=returns_ccq,		d();								return;
		case M_COSC:				function=c_cosc,					umts=returns_rcq,		d(disc_c_cosc_i, true);				return;
		case M_SEC:					function=c_sec,						umts=returns_rcq,		d(disc_c_sec_i, true);				return;
		case M_ASEC:				function=c_asec,					umts=returns_ccq,		d(disc_c_asec_i, true);				return;
		case M_SECH:				function=c_sech,					umts=returns_rcq,		d(disc_c_sech_i, true);				return;
		case M_ASECH:				function=c_asech,					umts=returns_ccq,		d(disc_c_asech_i, true);			return;
		case M_SIN:					function=c_sin,						umts=returns_rcq,		d();								return;
		case M_ASIN:				function=c_asin,					umts=returns_ccq,		d(disc_c_asin_i, true);				return;
		case M_SINH:				function=c_sinh,					umts=returns_rcq,		d();								return;
		case M_ASINH:				function=c_asinh,					umts=returns_rcq,		d(disc_c_asinh_i, true);			return;
		case M_SINC:				function=c_sinc,					umts=returns_rcq,		d();								return;
		case M_SINHC:				function=c_sinhc,					umts=returns_rcq,		d();								return;
		case M_CSC:					function=c_csc,						umts=returns_rcq,		d(disc_c_csc_i, true);				return;
		case M_ACSC:				function=c_acsc,					umts=returns_ccq,		d(disc_c_acsc_i, true);				return;
		case M_CSCH:				function=c_csch,					umts=returns_rcq,		d(disc_c_csch_i, true);				return;
		case M_ACSCH:				function=c_acsch,					umts=returns_rcq,		d(disc_c_acsch_i, true);			return;
		case M_TAN:					function=c_tan,						umts=returns_rcq,		d(disc_c_tan_i, true);				return;
		case M_ATAN:				function=c_atan,					umts=returns_rcq,		d(disc_c_atan_i, true);				return;
		case M_TANH:				function=c_tanh,					umts=returns_rcq,		d(disc_c_tanh_i, true);				return;
		case M_ATANH:				function=c_atanh,					umts=returns_ccq,		d(disc_c_atanh_i, true);			return;
		case M_TANC:				function=c_tanc,					umts=returns_rcq,		d(disc_c_tanc_i, true);				return;
		case M_COT:					function=c_cot,						umts=returns_rcq,		d(disc_c_cot_i, true);				return;
		case M_ACOT:				function=c_acot,					umts=returns_rcq,		d(disc_c_acot_i, true);				return;
		case M_COTH:				function=c_coth,					umts=returns_rcq,		d(disc_c_acoth_i, true);			return;
		case M_ACOTH:				function=c_acoth,					umts=returns_ccq,		d(disc_c_acoth_i, true);			return;
		case M_EXP:					function=c_exp,						umts=returns_rcq,		d();								return;
		case M_LN:					function=c_ln,						umts=returns_ccq,		d(disc_c_ln_i, true);				return;
		case M_LOG:					function=c_log,						umts=returns_ccq,		d(disc_c_log_i, true);				return;
		case M_SQRT:				function=c_sqrt,					umts=returns_ccq,		d();								return;
		case M_CBRT:				function=c_cbrt,					umts=returns_rcq,		d();								return;
		case M_FIB:					function=c_fib,						umts=returns_rcq,		d();								return;
		case M_SGN:					function=c_sgn,						umts=returns_rcq,		d(disc_c_sgn_i, true);				return;
		case M_STEP:				function=c_step,					umts=returns_rcq,		d(disc_c_step_i, true);				return;
		case M_RECT:				function=c_rect,					umts=returns_rcq,		d(disc_c_rect_i, true);				return;
		case M_TENT:				function=c_trgl,					umts=returns_rrr,		d();								return;
		case M_CEIL:				function=c_ceil,					umts=returns_rcq,		d(disc_c_ceil_o, false);			return;
		case M_FLOOR:				function=c_floor,					umts=returns_rcq,		d(disc_c_floor_o, false);			return;
		case M_ROUND:				function=c_round,					umts=returns_rcq,		d(disc_c_round_o, false);			return;
		case M_ABS:					function=c_abs,						umts=returns_rrr,		d();								return;
		case M_ARG:					function=c_arg,						umts=returns_rrr,		d(disc_c_arg_i, true);				return;
		case M_INVSQRT:				function=0;																						return;
		case M_ERF:					function=0;																						return;
		case M_ZETA:				function=0;																						return;
		case M_RAND:				function=c_random,					umts=returns_rcq,		d(disc_c_random, false);			return;
		case M_GAMMA:				function=c_tgamma,					umts=returns_rcq,		d(disc_c_tgamma_i, true);			return;
		case M_LNGAMMA:				function=0,							umts=returns_rXX,		d();								return;
		case M_GAUSS:				function=c_gauss,					umts=returns_rcq,		d();								return;
		case M_COMBINATION:			function=c_combination,				umts=returns_rcq,		d();								return;
		case M_PERMUTATION:			function=c_permutation,				umts=returns_rcq,		d();								return;
		case M_SQWV:				function=c_sqwv,					umts=returns_rcq,		d(disc_c_sqwv_i, true);				return;
		case M_TRWV:				function=c_trwv,					umts=returns_rcq,		d(disc_c_trwv_i, true);				return;
		case M_SAW:					function=c_saw,						umts=returns_rcq,		d(disc_c_saw_i, true);				return;
		case M_MIN:					function=c_min,						umts=returns_rcq,		d();								return;
		case M_MAX:					function=c_max,						umts=returns_rcq,		d();								return;
		case M_BETA:				function=0;																						return;
		case M_BESSEL:				function=0;																						return;
		case M_NEUMANN:				function=0;																						return;
		case M_HANKEL1:				function=0;																						return;
		}
		break;
	case 'H':
		switch(f)
		{
		case M_REAL:				function=c_real,					umts=returns_rrr,		d();								return;
		case M_IMAG:				function=c_imag,					umts=returns_rrr,		d();								return;
		case M_CONJUGATE:			function=q_conjugate,				umts=returns_rcq,		d();								return;
		case M_POLAR:				function=q_polar,					umts=returns_ccc,		d(disc_q_polar_i, true);			return;
		case M_CARTESIAN:			function=q_cartesian,				umts=returns_rcq,		d();								return;
		case M_DIVIDE:				function=q_divide,					umts=returns_rcq,		d(disc_q_divide_i, true);			return;
		case M_MINUS:				function=q_minus,					umts=returns_rcq,		d();								return;
		case M_MODULO_PERCENT:		function=q_percent,					umts=returns_rcq,		d();								return;
		case M_INCREMENT:			function=increment,					umts=returns_rcq,		d();								return;
		case M_DECREMENT:			function=decrement,					umts=returns_rcq,		d();								return;
		case M_BITWISE_NOT:			function=q_bitwise_not,				umts=returns_rcq,		d(disc_q_bitwise_not_i, true);		return;
		case M_BITWISE_SHIFT_LEFT:		 if(side=='<')	function=q_bitwise_shift_left_l,	umts=returns_rcq,		d(disc_q_bitwise_shift_left_l_o, false);
									else				function=q_bitwise_shift_left_r,	umts=returns_rcq,		d();										return;
		case M_BITWISE_SHIFT_RIGHT:		 if(side=='<')	function=q_bitwise_shift_right_l,	umts=returns_rcq,		d(disc_q_bitwise_shift_right_l_o, false);
									else				function=q_bitwise_shift_right_r,	umts=returns_rcq,		d();										return;
		case M_FACTORIAL_LOGIC_NOT:		 if(side=='<')	function=q_logic_not,				umts=returns_rrr,		d(disc_q_logic_not_i, true);
									else				function=q_factorial,				umts=returns_rcq,		d(disc_q_factorial_i, true);				return;
		case M_LOGIC_LESS:				 if(side=='<')	function=q_logic_less_l,			umts=returns_rrr,		d(disc_q_logic_less_l_i, true);
									else				function=q_logic_less_r,			umts=returns_rrr,		d(disc_q_logic_less_r_i, true);				return;
		case M_LOGIC_LESS_EQUAL:		 if(side=='<')	function=q_logic_less_equal_l,		umts=returns_rrr,		d(disc_q_logic_less_equal_l_i, true);
									else				function=q_logic_less_equal_r,		umts=returns_rrr,		d(disc_q_logic_less_equal_r_i, true);		return;
		case M_LOGIC_GREATER:			 if(side=='<')	function=q_logic_greater_l,			umts=returns_rrr,		d(disc_q_logic_greater_l_i, true);
									else				function=q_logic_greater_r,			umts=returns_rrr,		d(disc_q_logic_greater_r_i, true);			return;
		case M_LOGIC_GREATER_EQUAL:		 if(side=='<')	function=q_logic_greater_equal_l,	umts=returns_rrr,		d(disc_q_logic_greater_equal_l_i, true);
									else				function=q_logic_greater_equal_r,	umts=returns_rrr,		d(disc_q_logic_greater_equal_r_i, true);	return;
		case M_LOGIC_EQUAL:			function=q_logic_equal,				umts=returns_rrr,		d(disc_q_logic_equal_i, true);		return;
		case M_LOGIC_NOT_EQUAL:		function=q_logic_not_equal,			umts=returns_rrr,		d(disc_q_logic_not_equal_i, true);	return;
		case M_BITWISE_AND:			function=q_bitwise_and,				umts=returns_rcq,		d(disc_q_bitwise_and_o, false);		return;
		case M_BITWISE_NAND:		function=q_bitwise_nand,			umts=returns_rcq,		d(disc_q_bitwise_or_o, false);		return;
		case M_BITWISE_XOR:			function=q_bitwise_xor,				umts=returns_rcq,		d(disc_q_bitwise_xor_o, false);		return;
		case M_BITWISE_XNOR:		function=q_bitwise_xnor,			umts=returns_rcq,		d(disc_q_bitwise_xnor_o, false);	return;
		case M_VERTICAL_BAR:		function=q_bitwise_or,				umts=returns_rcq,		d(disc_q_bitwise_or_o, false);		return;
		case M_BITWISE_NOR:			function=q_bitwise_nor,				umts=returns_rcq,		d(disc_q_bitwise_nor_o, false);		return;
		case M_COS:					function=q_cos,						umts=returns_rcq,		d();								return;
		case M_ACOS:				function=q_acos,					umts=returns_ccq,		d(disc_q_acos_i, true);				return;
		case M_COSH:				function=q_cosh,					umts=returns_rcq,		d();								return;
		case M_ACOSH:				function=q_acosh,					umts=returns_ccq,		d();								return;
		case M_COSC:				function=q_cosc,					umts=returns_rcq,		d(disc_q_cosc_i, true);				return;
		case M_SEC:					function=q_sec,						umts=returns_rcq,		d(disc_q_sec_i, true);				return;
		case M_ASEC:				function=q_asec,					umts=returns_ccq,		d(disc_q_asec_i, true);				return;
		case M_SECH:				function=q_sech,					umts=returns_rcq,		d(disc_q_sech_i, true);				return;
		case M_ASECH:				function=q_asech,					umts=returns_ccq,		d(disc_q_asech_i, true);			return;
		case M_SIN:					function=q_sin,						umts=returns_rcq,		d();								return;
		case M_ASIN:				function=q_asin,					umts=returns_ccq,		d(disc_q_asin_i, true);				return;
		case M_SINH:				function=q_sinh,					umts=returns_rcq,		d();								return;
		case M_ASINH:				function=q_asinh,					umts=returns_rcq,		d(disc_q_asinh_i, true);			return;
		case M_SINC:				function=q_sinc,					umts=returns_rcq,		d();								return;
		case M_SINHC:				function=q_sinhc,					umts=returns_rcq,		d();								return;
		case M_CSC:					function=q_csc,						umts=returns_rcq,		d(disc_q_csc_i, true);				return;
		case M_ACSC:				function=q_acsc,					umts=returns_ccq,		d(disc_q_acsc_i, true);				return;
		case M_CSCH:				function=q_csch,					umts=returns_rcq,		d(disc_q_csch_i, true);				return;
		case M_ACSCH:				function=q_acsch,					umts=returns_rcq,		d(disc_q_acsch_i, true);			return;
		case M_TAN:					function=q_tan,						umts=returns_rcq,		d(disc_q_tan_i, true);				return;
		case M_ATAN:				function=q_atan,					umts=returns_rcq,		d(disc_q_atan_i, true);				return;
		case M_TANH:				function=q_tanh,					umts=returns_rcq,		d(disc_q_tanh_i, true);				return;
		case M_ATANH:				function=q_atanh,					umts=returns_ccq,		d(disc_q_atanh_i, true);			return;
		case M_TANC:				function=q_tanc,					umts=returns_rcq,		d(disc_q_tanc_i, true);				return;
		case M_COT:					function=q_cot,						umts=returns_rcq,		d(disc_q_cot_i, true);				return;
		case M_ACOT:				function=q_acot,					umts=returns_rcq,		d(disc_q_acot_i, true);				return;
		case M_COTH:				function=q_coth,					umts=returns_rcq,		d(disc_q_coth_i, true);				return;
		case M_ACOTH:				function=q_acoth,					umts=returns_ccq,		d(disc_q_acoth_i, true);			return;
		case M_EXP:					function=q_exp,						umts=returns_rcq,		d();								return;
		case M_LN:					function=q_ln,						umts=returns_ccq,		d(disc_q_ln_i, true);				return;
		case M_LOG:					function=q_log,						umts=returns_ccq,		d(disc_q_log_i, true);				return;
		case M_SQRT:				function=q_sqrt,					umts=returns_ccq,		d();								return;
		case M_CBRT:				function=q_cbrt,					umts=returns_rcq,		d();								return;
		case M_FIB:					function=q_fib,						umts=returns_rcq,		d();								return;
		case M_SGN:					function=q_sgn,						umts=returns_rcq,		d(disc_q_sgn_i, true);				return;
		case M_STEP:				function=q_step,					umts=returns_rcq,		d(disc_q_step_i, true);				return;
		case M_RECT:				function=q_rect,					umts=returns_rcq,		d(disc_q_rect_i, true);				return;
		case M_TENT:				function=q_trgl,					umts=returns_rrr,		d();								return;
		case M_CEIL:				function=q_ceil,					umts=returns_rcq,		d(disc_q_ceil_o, false);			return;
		case M_FLOOR:				function=q_floor,					umts=returns_rcq,		d(disc_q_floor_o, false);			return;
		case M_ROUND:				function=q_round,					umts=returns_rcq,		d(disc_q_round_o, false);			return;
		case M_ABS:					function=q_abs,						umts=returns_rrr,		d();								return;
		case M_ARG:					function=q_arg,						umts=returns_rrr,		d(disc_q_arg_i, true);				return;
		case M_INVSQRT:				function=0;																						return;
		case M_ERF:					function=0;																						return;
		case M_ZETA:				function=0;																						return;
		case M_RAND:				function=q_random,					umts=returns_rcq,		d(disc_q_random, false);			return;
		case M_GAMMA:				function=q_tgamma,					umts=returns_rcq,		d(disc_q_tgamma_i, true);			return;
		case M_LNGAMMA:				function=0,							umts=returns_rXX,		d();								return;
		case M_GAUSS:				function=q_gauss,					umts=returns_rcq,		d();								return;
		case M_PERMUTATION:			function=q_permutation,				umts=returns_rcq,		d();								return;
		case M_COMBINATION:			function=q_combination,				umts=returns_rcq,		d();								return;
		case M_SQWV:				function=q_sqwv,					umts=returns_rcq,		d(disc_q_sqwv_i, true);				return;
		case M_TRWV:				function=q_trwv,					umts=returns_rcq,		d(disc_q_trwv_i, true);				return;
		case M_SAW:					function=q_saw,						umts=returns_rcq,		d(disc_q_saw_i, true);				return;
		case M_MIN:					function=q_min,						umts=returns_rcq,		d();								return;
		case M_MAX:					function=q_max,						umts=returns_rcq,		d();								return;
		case M_BETA:				function=0;																						return;
		case M_BESSEL:				function=0;																						return;
		case M_NEUMANN:				function=0;																						return;
		case M_HANKEL1:				function=0;																						return;
		}
		break;
	}
	function=0;
}
void			Compile::compile_instruction_select_b	(int f, char op1type, char op2type, Value (*&function)(Value const&, Value const&), char (*&bmts)(char, char), DiscontinuityFunction &d)
{
	using namespace G2;
	switch(op1type)
	{
	case 'r':
//	case 'R':
		switch(op2type)
		{
		case 'r':
	//	case 'R':
			switch(f)
			{
			case M_POWER:				function=cr_pow,					bmts=returns_ccq_ccq_qqq,	d(disc_cr_pow_i);					return;
			case M_ASSIGN_DIVIDE:
			case M_DIVIDE:				function=rr_divide,					bmts=returns_rcq_ccq_qqq,	d(disc_rr_divide_i);				return;
			case M_ASSIGN_MINUS:
			case M_MINUS:				function=rr_minus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_PENTATE:				function=rr_pentate,				bmts=returns_rXX_rXX_XXX,	d(disc_rr_pentate_i);				return;
			case M_TETRATE:				function=rr_tetrate,				bmts=returns_ccX_ccX_qXX,	d(disc_rr_tetrate_i);				return;
			case M_ASSIGN_MULTIPLY:
			case M_MULTIPLY:			function=rr_multiply,				bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_ASSIGN_PLUS:
			case M_PLUS:				function=rr_plus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_LOGIC_AND:			function=rr_logic_and,				bmts=returns_rrr_rrr_rrr,	d(disc_rr_logic_and_i);				return;
			case M_LOGIC_XOR:			function=rr_logic_xor,				bmts=returns_rrr_rrr_rrr,	d(disc_rr_logic_xor_i);				return;
			case M_LOGIC_OR:			function=rr_logic_or,				bmts=returns_rrr_rrr_rrr,	d(disc_rr_logic_or_i);				return;
			case M_LOGIC_CONDITION_ZERO:function=rr_logic_condition_zero,	bmts=returns_rcq_ccq_qqq,	d(disc_rr_logic_condition_zero_i);	return;
			case M_ASSIGN_MOD:
			case M_MODULO_PERCENT:		function=rr_modulo,					bmts=returns_rcq_ccq_qqq,	d(disc_rr_modulo_i);				return;
			case M_ASSIGN_LEFT:
			case M_BITWISE_SHIFT_LEFT:	function=rr_bitwise_shift_left,		bmts=returns_rcq_ccq_qqq,	d(disc_rr_bitwise_shift_left_i);	return;
			case M_ASSIGN_RIGHT:
			case M_BITWISE_SHIFT_RIGHT:	function=rr_bitwise_shift_right,	bmts=returns_rcq_ccq_qqq,	d(disc_rr_bitwise_shift_right_i);	return;
			case M_LOGIC_LESS:			function=rr_logic_less,				bmts=returns_rrr_rrr_rrr,	d(disc_rr_logic_less_i);			return;
			case M_LOGIC_LESS_EQUAL:	function=rr_logic_less_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_rr_logic_less_equal_i);		return;
			case M_LOGIC_GREATER:		function=rr_logic_greater,			bmts=returns_rrr_rrr_rrr,	d(disc_rr_logic_greater_i);			return;
			case M_LOGIC_GREATER_EQUAL:	function=rr_logic_greater_equal,	bmts=returns_rrr_rrr_rrr,	d(disc_rr_logic_greater_equal_i);	return;
			case M_LOGIC_EQUAL:			function=rr_logic_equal,			bmts=returns_rrr_rrr_rrr,	d(disc_rr_logic_equal_i);			return;
			case M_LOGIC_NOT_EQUAL:		function=rr_logic_not_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_rr_logic_not_equal_i);		return;
			case M_ASSIGN_AND:
			case M_BITWISE_AND:			function=rr_bitwise_and,			bmts=returns_rcq_ccq_qqq,	d(disc_rr_bitwise_and_o, false);	return;
			case M_BITWISE_NAND:		function=rr_bitwise_nand,			bmts=returns_rcq_ccq_qqq,	d(disc_rr_bitwise_nand_o, false);	return;
			case M_ASSIGN_XOR:
			case M_BITWISE_XOR:			function=rr_bitwise_xor,			bmts=returns_rcq_ccq_qqq,	d(disc_rr_bitwise_xor_o, false);	return;
			case M_BITWISE_XNOR:		function=rr_bitwise_xnor,			bmts=returns_rcq_ccq_qqq,	d(disc_rr_bitwise_xnor_o, false);	return;
			case M_ASSIGN_OR:
			case M_VERTICAL_BAR:		function=rr_bitwise_or,				bmts=returns_rcq_ccq_qqq,	d(disc_rr_bitwise_or_o, false);		return;
			case M_BITWISE_NOR:			function=rr_bitwise_nor,			bmts=returns_rcq_ccq_qqq,	d(disc_rr_bitwise_nor_o, false);	return;
			case M_LOG:					function=cc_log,					bmts=returns_ccq_ccq_qqq,	d(disc_cc_log_i);					return;
			case M_RAND:				function=rr_random,					bmts=returns_rcq_ccq_qqq,	d(disc_rr_random, false);			return;
			case M_ATAN:				function=rr_atan,					bmts=returns_rcq_ccq_qqq,	d(disc_rr_atan_i);					return;
			case M_SQWV:				function=rr_sqwv,					bmts=returns_rcq_ccq_qqq,	d(disc_rr_sqwv_o, false);			return;
			case M_TRWV:				function=rr_trwv,					bmts=returns_rcq_ccq_qqq,	d(disc_rr_trwv_i);					return;
			case M_SAW:					function=rr_saw,					bmts=returns_rcq_ccq_qqq,	d(disc_rr_saw_i);					return;
			case M_MIN:					function=rr_min,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_MAX:					function=rr_max,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_BETA:				function=rr_beta,					bmts=returns_rXX_XXX_XXX,	d(disc_rr_beta_i);					return;
			case M_GAMMA:				function=rr_tgamma,					bmts=returns_rXX_XXX_XXX,	d(disc_rr_tgamma_i);				return;
			case M_PERMUTATION:			function=rr_permutation,			bmts=returns_rcq_ccq_qqq,	d(disc_rr_permutation_i);			return;
			case M_COMBINATION:			function=rr_combination,			bmts=returns_rcq_ccq_qqq,	d(disc_rr_combination_i);			return;
			case M_BESSEL:				function=rr_cyl_bessel_j,			bmts=returns_rXX_XXX_XXX,	d(disc_rr_cyl_bessel_j_i);			return;
			case M_NEUMANN:				function=rr_cyl_neumann,			bmts=returns_rXX_XXX_XXX,	d(disc_rr_cyl_neumann_i);			return;
			case M_HANKEL1:				function=rr_hankel1,				bmts=returns_cXX_XXX_XXX,	d(disc_rr_hankel1_i);				return;
			case M_ASSIGN:				function=r_assign,					bmts=returns_rcq_rcq_rcq,	d();								return;
			}
			break;
		case 'c':
	//	case 'C':
			switch(f)
			{
			case M_POWER:				function=cc_pow,					bmts=returns_ccq_ccq_qqq,	d(disc_cc_pow_i);					return;
			case M_ASSIGN_DIVIDE:
			case M_DIVIDE:				function=rc_divide,					bmts=returns_rcq_ccq_qqq,	d(disc_rc_divide_i);				return;
			case M_ASSIGN_MINUS:
			case M_MINUS:				function=rc_minus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_PENTATE:				function=0;																							return;
			case M_TETRATE:				function=rc_tetrate,				bmts=returns_ccX_ccX_qXX,	d(disc_rc_tetrate_i);				return;
			case M_ASSIGN_MULTIPLY:
			case M_MULTIPLY:			function=rc_multiply,				bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_ASSIGN_PLUS:
			case M_PLUS:				function=rc_plus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_LOGIC_AND:			function=rc_logic_and,				bmts=returns_rrr_rrr_rrr,	d(disc_rc_logic_and_i);				return;
			case M_LOGIC_XOR:			function=rc_logic_xor,				bmts=returns_rrr_rrr_rrr,	d(disc_rc_logic_xor_i);				return;
			case M_LOGIC_OR:			function=rc_logic_or,				bmts=returns_rrr_rrr_rrr,	d(disc_rc_logic_or_i);				return;
			case M_LOGIC_CONDITION_ZERO:function=rc_logic_condition_zero,	bmts=returns_rcq_ccq_qqq,	d(disc_rc_logic_condition_zero_i);	return;
			case M_ASSIGN_MOD:
			case M_MODULO_PERCENT:		function=rc_modulo,					bmts=returns_rcq_ccq_qqq,	d(disc_rc_modulo_i);				return;
			case M_ASSIGN_LEFT:
			case M_BITWISE_SHIFT_LEFT:	function=rc_bitwise_shift_left,		bmts=returns_rcq_ccq_qqq,	d(disc_rc_bitwise_shift_left_i);	return;
			case M_ASSIGN_RIGHT:
			case M_BITWISE_SHIFT_RIGHT:	function=rc_bitwise_shift_right,	bmts=returns_rcq_ccq_qqq,	d(disc_rq_bitwise_shift_right_i);	return;
			case M_LOGIC_LESS:			function=rc_logic_less,				bmts=returns_rrr_rrr_rrr,	d(disc_rc_logic_less_i);			return;
			case M_LOGIC_LESS_EQUAL:	function=rc_logic_less_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_rc_logic_equal_i);			return;
			case M_LOGIC_GREATER:		function=rc_logic_greater,			bmts=returns_rrr_rrr_rrr,	d(disc_rc_logic_greater_i);			return;
			case M_LOGIC_GREATER_EQUAL:	function=rc_logic_greater_equal,	bmts=returns_rrr_rrr_rrr,	d(disc_rc_logic_greater_equal_i);	return;
			case M_LOGIC_EQUAL:			function=rc_logic_equal,			bmts=returns_rrr_rrr_rrr,	d(disc_rc_logic_equal_i);			return;
			case M_LOGIC_NOT_EQUAL:		function=rc_logic_not_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_rc_logic_not_equal_i);		return;
			case M_ASSIGN_AND:
			case M_BITWISE_AND:			function=rc_bitwise_and,			bmts=returns_rcq_ccq_qqq,	d(disc_rc_bitwise_and_o, false);	return;
			case M_BITWISE_NAND:		function=rc_bitwise_nand,			bmts=returns_rcq_ccq_qqq,	d(disc_rc_bitwise_nand_o, false);	return;
			case M_ASSIGN_XOR:
			case M_BITWISE_XOR:			function=rc_bitwise_xor,			bmts=returns_rcq_ccq_qqq,	d(disc_rc_bitwise_xor_o, false);	return;
			case M_BITWISE_XNOR:		function=rc_bitwise_xnor,			bmts=returns_rcq_ccq_qqq,	d(disc_rc_bitwise_xnor_o, false);	return;
			case M_ASSIGN_OR:
			case M_VERTICAL_BAR:		function=rc_bitwise_or,				bmts=returns_rcq_ccq_qqq,	d(disc_rc_bitwise_or_o, false);		return;
			case M_BITWISE_NOR:			function=rc_bitwise_nor,			bmts=returns_rcq_ccq_qqq,	d(disc_rc_bitwise_nor_o, false);	return;
			case M_LOG:					function=cc_log,					bmts=returns_ccq_ccq_qqq,	d(disc_cc_log_i);					return;
			case M_RAND:				function=cc_random,					bmts=returns_rcq_ccq_qqq,	d(disc_cc_random, false);			return;
		//	case M_RAND:				function=rc_random,					bmts=returns_rcq_ccq_qqq,	d(disc_rc_random, false);			return;
			case M_ATAN:				function=rc_atan,					bmts=returns_rcq_ccq_qqq,	d(disc_rc_atan_i);					return;
			case M_SQWV:				function=rc_sqwv,					bmts=returns_rcq_ccq_qqq,	d(disc_rc_sqwv_i);					return;
			case M_TRWV:				function=rc_trwv,					bmts=returns_rcq_ccq_qqq,	d(disc_rc_trwv_i);					return;
			case M_SAW:					function=rc_saw,					bmts=returns_rcq_ccq_qqq,	d(disc_rc_saw_i);					return;
			case M_MIN:					function=rc_min,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_MAX:					function=rc_max,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_BETA:				function=0;																							return;
			case M_GAMMA:				function=0;																							return;
			case M_PERMUTATION:			function=rc_permutation,			bmts=returns_rcq_ccq_qqq,	d(disc_rc_permutation_i);			return;
			case M_COMBINATION:			function=rc_combination,			bmts=returns_rcq_ccq_qqq,	d(disc_rc_combination_i);			return;
			case M_BESSEL:				function=0;																							return;
			case M_NEUMANN:				function=0;																							return;
			case M_HANKEL1:				function=0;																							return;
			case M_ASSIGN:				function=c_assign,					bmts=returns_rcq_rcq_rcq,	d();								return;
			}
			break;
		case 'H':
			switch(f)
			{
			case M_POWER:				function=cq_pow,					bmts=returns_ccq_ccq_qqq,	d(disc_cq_pow_i);					return;
			case M_ASSIGN_DIVIDE:
			case M_DIVIDE:				function=rq_divide,					bmts=returns_rcq_ccq_qqq,	d(disc_rq_divide_i);				return;
			case M_ASSIGN_MINUS:
			case M_MINUS:				function=rq_minus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_PENTATE:				function=0;																							return;
			case M_TETRATE:				function=0;																							return;
			case M_ASSIGN_MULTIPLY:
			case M_MULTIPLY:			function=rq_multiply,				bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_ASSIGN_PLUS:
			case M_PLUS:				function=rq_plus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_LOGIC_AND:			function=rq_logic_and,				bmts=returns_rrr_rrr_rrr,	d(disc_rq_logic_and_i);				return;
			case M_LOGIC_XOR:			function=rq_logic_xor,				bmts=returns_rrr_rrr_rrr,	d(disc_rq_logic_xor_i);				return;
			case M_LOGIC_OR:			function=rq_logic_or,				bmts=returns_rrr_rrr_rrr,	d(disc_rq_logic_or_i);				return;
			case M_LOGIC_CONDITION_ZERO:function=rq_logic_condition_zero,	bmts=returns_rcq_ccq_qqq,	d(disc_rq_logic_condition_zero_i);	return;
			case M_ASSIGN_MOD:
			case M_MODULO_PERCENT:		function=rq_modulo,					bmts=returns_rcq_ccq_qqq,	d(disc_rq_modulo_i);				return;
			case M_ASSIGN_LEFT:
			case M_BITWISE_SHIFT_LEFT:	function=rq_bitwise_shift_left,		bmts=returns_rcq_ccq_qqq,	d(disc_rq_bitwise_shift_left_i);	return;
			case M_ASSIGN_RIGHT:
			case M_BITWISE_SHIFT_RIGHT:	function=rq_bitwise_shift_right,	bmts=returns_rcq_ccq_qqq,	d(disc_rq_bitwise_shift_right_i);	return;
			case M_LOGIC_LESS:			function=rq_logic_less,				bmts=returns_rrr_rrr_rrr,	d(disc_rq_logic_less_i);			return;
			case M_LOGIC_LESS_EQUAL:	function=rq_logic_less_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_rq_logic_less_equal_i);		return;
			case M_LOGIC_GREATER:		function=rq_logic_greater,			bmts=returns_rrr_rrr_rrr,	d(disc_rq_logic_greater_i);			return;
			case M_LOGIC_GREATER_EQUAL:	function=rq_logic_greater_equal,	bmts=returns_rrr_rrr_rrr,	d(disc_rq_logic_greater_equal_i);	return;
			case M_LOGIC_EQUAL:			function=rq_logic_equal,			bmts=returns_rrr_rrr_rrr,	d(disc_rq_logic_equal_i);			return;
			case M_LOGIC_NOT_EQUAL:		function=rq_logic_not_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_rq_logic_not_equal_i);		return;
			case M_ASSIGN_AND:
			case M_BITWISE_AND:			function=rq_bitwise_and,			bmts=returns_rcq_ccq_qqq,	d(disc_rq_bitwise_and_o, false);	return;
			case M_BITWISE_NAND:		function=rq_bitwise_nand,			bmts=returns_rcq_ccq_qqq,	d(disc_rq_bitwise_nand_o, false);	return;
			case M_ASSIGN_XOR:
			case M_BITWISE_XOR:			function=rq_bitwise_xor,			bmts=returns_rcq_ccq_qqq,	d(disc_rq_bitwise_xor_o, false);	return;
			case M_BITWISE_XNOR:		function=rq_bitwise_xnor,			bmts=returns_rcq_ccq_qqq,	d(disc_rq_bitwise_xnor_o, false);	return;
			case M_ASSIGN_OR:
			case M_VERTICAL_BAR:		function=rq_bitwise_or,				bmts=returns_rcq_ccq_qqq,	d(disc_rq_bitwise_or_o, false);		return;
			case M_BITWISE_NOR:			function=rq_bitwise_nor,			bmts=returns_rcq_ccq_qqq,	d(disc_rq_bitwise_nor_o, false);	return;
			case M_LOG:					function=cq_log,					bmts=returns_ccq_ccq_qqq,	d(disc_cq_log_i);					return;
			case M_RAND:				function=qq_random,					bmts=returns_rcq_ccq_qqq,	d(disc_qq_random, false);			return;
		//	case M_RAND:				function=rq_random,					bmts=returns_rcq_ccq_qqq,	d(disc_rq_random, false);			return;
			case M_ATAN:				function=rq_atan,					bmts=returns_rcq_ccq_qqq,	d(disc_rq_atan_i);					return;
			case M_SQWV:				function=rq_sqwv,					bmts=returns_rcq_ccq_qqq,	d(disc_rq_sqwv_i);					return;
			case M_TRWV:				function=rq_trwv,					bmts=returns_rcq_ccq_qqq,	d(disc_rq_trwv_i);					return;
			case M_SAW:					function=rq_saw,					bmts=returns_rcq_ccq_qqq,	d(disc_rq_saw_i);					return;
			case M_MIN:					function=rq_min,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_MAX:					function=rq_max,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_BETA:				function=0;																							return;
			case M_GAMMA:				function=0;																							return;
			case M_PERMUTATION:			function=rq_permutation,			bmts=returns_rcq_ccq_qqq,	d(disc_rq_permutation_i);			return;
			case M_COMBINATION:			function=rq_combination,			bmts=returns_rcq_ccq_qqq,	d(disc_rq_combination_i);			return;
			case M_BESSEL:				function=0;																							return;
			case M_NEUMANN:				function=0;																							return;
			case M_HANKEL1:				function=0;																							return;
			case M_ASSIGN:				function=q_assign,					bmts=returns_rcq_rcq_rcq,	d();								return;
			}
			break;
		}
		break;
	case 'c':
//	case 'C':
		switch(op2type)
		{
		case 'r':
	//	case 'R':
			switch(f)
			{
			case M_POWER:				function=cr_pow,					bmts=returns_ccq_ccq_qqq,	d(disc_cr_pow_i);					return;
			case M_ASSIGN_DIVIDE:
			case M_DIVIDE:				function=cr_divide,					bmts=returns_rcq_ccq_qqq,	d(disc_cr_divide_i);				return;
			case M_ASSIGN_MINUS:
			case M_MINUS:				function=cr_minus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_PENTATE:				function=cr_pentate;				bmts=returns_rXX_rXX_XXX,	d(disc_cr_pentate_i);				return;
			case M_TETRATE:				function=cr_tetrate,				bmts=returns_ccX_ccX_qXX,	d(disc_cr_tetrate_i);				return;
			case M_ASSIGN_MULTIPLY:
			case M_MULTIPLY:			function=cr_multiply,				bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_ASSIGN_PLUS:
			case M_PLUS:				function=cr_plus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_LOGIC_AND:			function=cr_logic_and,				bmts=returns_rrr_rrr_rrr,	d(disc_cr_logic_and_i);				return;
			case M_LOGIC_XOR:			function=cr_logic_xor,				bmts=returns_rrr_rrr_rrr,	d(disc_cr_logic_xor_i);				return;
			case M_LOGIC_OR:			function=cr_logic_or,				bmts=returns_rrr_rrr_rrr,	d(disc_cr_logic_or_i);				return;
			case M_LOGIC_CONDITION_ZERO:function=cr_logic_condition_zero,	bmts=returns_rcq_ccq_qqq,	d(disc_cr_logic_condition_zero_i);	return;
			case M_ASSIGN_MOD:
			case M_MODULO_PERCENT:		function=cr_modulo,					bmts=returns_rcq_ccq_qqq,	d(disc_cr_modulo_i);				return;
			case M_ASSIGN_LEFT:
			case M_BITWISE_SHIFT_LEFT:	function=cr_bitwise_shift_left,		bmts=returns_rcq_ccq_qqq,	d(disc_cr_bitwise_shift_left_i);	return;
			case M_ASSIGN_RIGHT:
			case M_BITWISE_SHIFT_RIGHT:	function=cr_bitwise_shift_right,	bmts=returns_rcq_ccq_qqq,	d(disc_cr_bitwise_shift_right_i);	return;
			case M_LOGIC_LESS:			function=cr_logic_less,				bmts=returns_rrr_rrr_rrr,	d(disc_cr_logic_less_i);			return;
			case M_LOGIC_LESS_EQUAL:	function=cr_logic_less_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_cr_logic_less_equal_i);		return;
			case M_LOGIC_GREATER:		function=cr_logic_greater,			bmts=returns_rrr_rrr_rrr,	d(disc_cr_logic_greater_i);			return;
			case M_LOGIC_GREATER_EQUAL:	function=cr_logic_greater_equal,	bmts=returns_rrr_rrr_rrr,	d(disc_cr_logic_greater_equal_i);	return;
			case M_LOGIC_EQUAL:			function=cr_logic_equal,			bmts=returns_rrr_rrr_rrr,	d(disc_cr_logic_equal_i);			return;
			case M_LOGIC_NOT_EQUAL:		function=cr_logic_not_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_cr_logic_not_equal_i);		return;
			case M_ASSIGN_AND:
			case M_BITWISE_AND:			function=cr_bitwise_and,			bmts=returns_rcq_ccq_qqq,	d(disc_cr_bitwise_and_o, false);	return;
			case M_BITWISE_NAND:		function=cr_bitwise_nand,			bmts=returns_rcq_ccq_qqq,	d(disc_cr_bitwise_nand_o, false);	return;
			case M_ASSIGN_XOR:
			case M_BITWISE_XOR:			function=cr_bitwise_xor,			bmts=returns_rcq_ccq_qqq,	d(disc_cr_bitwise_xor_o, false);	return;
			case M_BITWISE_XNOR:		function=cr_bitwise_xnor,			bmts=returns_rcq_ccq_qqq,	d(disc_cr_bitwise_xnor_o, false);	return;
			case M_ASSIGN_OR:
			case M_VERTICAL_BAR:		function=cr_bitwise_or,				bmts=returns_rcq_ccq_qqq,	d(disc_cr_bitwise_or_o, false);		return;
			case M_BITWISE_NOR:			function=cr_bitwise_nor,			bmts=returns_rcq_ccq_qqq,	d(disc_cr_bitwise_nor_o, false);	return;
			case M_LOG:					function=cc_log,					bmts=returns_ccq_ccq_qqq,	d(disc_cc_log_i);					return;
			case M_RAND:				function=cc_random,					bmts=returns_rcq_ccq_qqq,	d(disc_cc_random, false);			return;
		//	case M_RAND:				function=cr_random,					bmts=returns_rcq_ccq_qqq,	d(disc_cr_random, false);			return;
			case M_ATAN:				function=cr_atan,					bmts=returns_rcq_ccq_qqq,	d(disc_cr_atan_i);					return;
			case M_SQWV:				function=cr_sqwv,					bmts=returns_rcq_ccq_qqq,	d(disc_cr_sqwv_i);					return;
			case M_TRWV:				function=cr_trwv,					bmts=returns_rcq_ccq_qqq,	d(disc_cr_trwv_i);					return;
			case M_SAW:					function=cr_saw,					bmts=returns_rcq_ccq_qqq,	d(disc_cr_saw_i);					return;
			case M_MIN:					function=cr_min,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_MAX:					function=cr_max,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_BETA:				function=0;																							return;
			case M_GAMMA:				function=0;																							return;
			case M_PERMUTATION:			function=cr_permutation,			bmts=returns_rcq_ccq_qqq,	d(disc_cr_permutation_i);			return;
			case M_COMBINATION:			function=cr_combination,			bmts=returns_rcq_ccq_qqq,	d(disc_cr_combination_i);			return;
			case M_BESSEL:				function=0;																							return;
			case M_NEUMANN:				function=0;																							return;
			case M_HANKEL1:				function=0;																							return;
			case M_ASSIGN:				function=r_assign,					bmts=returns_rcq_rcq_rcq,	d();								return;
			}
			break;
		case 'c':
	//	case 'C':
			switch(f)
			{
			case M_POWER:				function=cc_pow,					bmts=returns_ccq_ccq_qqq,	d(disc_cc_pow_i);					return;
			case M_ASSIGN_DIVIDE:
			case M_DIVIDE:				function=cc_divide,					bmts=returns_rcq_ccq_qqq,	d(disc_cc_divide_i);				return;
			case M_ASSIGN_MINUS:
			case M_MINUS:				function=cc_minus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_PENTATE:				function=0;																							return;
			case M_TETRATE:				function=cc_tetrate,				bmts=returns_ccX_ccX_qXX,	d(disc_cc_tetrate_i);				return;
			case M_ASSIGN_MULTIPLY:
			case M_MULTIPLY:			function=cc_multiply,				bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_ASSIGN_PLUS:
			case M_PLUS:				function=cc_plus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_LOGIC_AND:			function=cc_logic_and,				bmts=returns_rrr_rrr_rrr,	d(disc_cc_logic_and_i);				return;
			case M_LOGIC_XOR:			function=cc_logic_xor,				bmts=returns_rrr_rrr_rrr,	d(disc_cc_logic_xor_i);				return;
			case M_LOGIC_OR:			function=cc_logic_or,				bmts=returns_rrr_rrr_rrr,	d(disc_cc_logic_or_i);				return;
			case M_LOGIC_CONDITION_ZERO:function=cc_logic_condition_zero,	bmts=returns_rcq_ccq_qqq,	d(disc_cc_logic_condition_zero_i);	return;
			case M_ASSIGN_MOD:
			case M_MODULO_PERCENT:		function=cc_modulo,					bmts=returns_rcq_ccq_qqq,	d(disc_cc_modulo_i);				return;
			case M_ASSIGN_LEFT:
			case M_BITWISE_SHIFT_LEFT:	function=cc_bitwise_shift_left,		bmts=returns_rcq_ccq_qqq,	d(disc_cc_bitwise_shift_left_i);	return;
			case M_ASSIGN_RIGHT:
			case M_BITWISE_SHIFT_RIGHT:	function=cc_bitwise_shift_right,	bmts=returns_rcq_ccq_qqq,	d(disc_cc_bitwise_shift_right_i);	return;
			case M_LOGIC_LESS:			function=cc_logic_less,				bmts=returns_rrr_rrr_rrr,	d(disc_cc_logic_less_i);			return;
			case M_LOGIC_LESS_EQUAL:	function=cc_logic_less_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_cc_logic_less_equal_i);		return;
			case M_LOGIC_GREATER:		function=cc_logic_greater,			bmts=returns_rrr_rrr_rrr,	d(disc_cc_logic_greater_i);			return;
			case M_LOGIC_GREATER_EQUAL:	function=cc_logic_greater_equal,	bmts=returns_rrr_rrr_rrr,	d(disc_cc_logic_greater_equal_i);	return;
			case M_LOGIC_EQUAL:			function=cc_logic_equal,			bmts=returns_rrr_rrr_rrr,	d(disc_cc_logic_equal_i);			return;
			case M_LOGIC_NOT_EQUAL:		function=cc_logic_not_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_cc_logic_not_equal_i);		return;
			case M_ASSIGN_AND:
			case M_BITWISE_AND:			function=cc_bitwise_and,			bmts=returns_rcq_ccq_qqq,	d(disc_cc_bitwise_and_o, false);	return;
			case M_BITWISE_NAND:		function=cc_bitwise_nand,			bmts=returns_rcq_ccq_qqq,	d(disc_cc_bitwise_nand_o, false);	return;
			case M_ASSIGN_XOR:
			case M_BITWISE_XOR:			function=cc_bitwise_xor,			bmts=returns_rcq_ccq_qqq,	d(disc_cc_bitwise_xor_o, false);	return;
			case M_BITWISE_XNOR:		function=cc_bitwise_xnor,			bmts=returns_rcq_ccq_qqq,	d(disc_cc_bitwise_xnor_o, false);	return;
			case M_ASSIGN_OR:
			case M_VERTICAL_BAR:		function=cc_bitwise_or,				bmts=returns_rcq_ccq_qqq,	d(disc_cc_bitwise_or_o, false);		return;
			case M_BITWISE_NOR:			function=cc_bitwise_nor,			bmts=returns_rcq_ccq_qqq,	d(disc_cc_bitwise_nor_o, false);	return;
			case M_LOG:					function=cc_log,					bmts=returns_ccq_ccq_qqq,	d(disc_cc_log_i);					return;
			case M_RAND:				function=cc_random,					bmts=returns_rcq_ccq_qqq,	d(disc_cc_random, false);			return;
			case M_ATAN:				function=cc_atan,					bmts=returns_rcq_ccq_qqq,	d(disc_cc_atan_i);					return;
			case M_SQWV:				function=cc_sqwv,					bmts=returns_rcq_ccq_qqq,	d(disc_cc_sqwv_i);					return;
			case M_TRWV:				function=cc_trwv,					bmts=returns_rcq_ccq_qqq,	d(disc_cc_trwv_i);					return;
			case M_SAW:					function=cc_saw,					bmts=returns_rcq_ccq_qqq,	d(disc_cc_saw_i);					return;
			case M_MIN:					function=cc_min,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_MAX:					function=cc_max,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_BETA:				function=0;																							return;
			case M_GAMMA:				function=0;																							return;
			case M_PERMUTATION:			function=cc_permutation,			bmts=returns_rcq_ccq_qqq,	d(disc_cc_permutation_i);			return;
			case M_COMBINATION:			function=cc_combination,			bmts=returns_rcq_ccq_qqq,	d(disc_cc_combination_i);			return;
			case M_BESSEL:				function=0;																							return;
			case M_NEUMANN:				function=0;																							return;
			case M_HANKEL1:				function=0;																							return;
			case M_ASSIGN:				function=c_assign,					bmts=returns_rcq_rcq_rcq,	d();								return;
			}
			break;
		case 'H':
			switch(f)
			{
			case M_POWER:				function=cq_pow,					bmts=returns_ccq_ccq_qqq,	d(disc_cq_pow_i);					return;
			case M_ASSIGN_DIVIDE:
			case M_DIVIDE:				function=cq_divide,					bmts=returns_rcq_ccq_qqq,	d(disc_cq_divide_i);				return;
			case M_ASSIGN_MINUS:
			case M_MINUS:				function=cq_minus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_PENTATE:				function=0;																							return;
			case M_TETRATE:				function=0;																							return;
			case M_ASSIGN_MULTIPLY:
			case M_MULTIPLY:			function=cq_multiply,				bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_ASSIGN_PLUS:
			case M_PLUS:				function=cq_plus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_LOGIC_AND:			function=cq_logic_and,				bmts=returns_rrr_rrr_rrr,	d(disc_cq_logic_and_i);				return;
			case M_LOGIC_XOR:			function=cq_logic_xor,				bmts=returns_rrr_rrr_rrr,	d(disc_cq_logic_xor_i);				return;
			case M_LOGIC_OR:			function=cq_logic_or,				bmts=returns_rrr_rrr_rrr,	d(disc_cq_logic_or_i);				return;
			case M_LOGIC_CONDITION_ZERO:function=cq_logic_condition_zero,	bmts=returns_rcq_ccq_qqq,	d(disc_cq_logic_condition_zero_i);	return;
			case M_ASSIGN_MOD:
			case M_MODULO_PERCENT:		function=cq_modulo,					bmts=returns_rcq_ccq_qqq,	d(disc_cq_modulo_i);				return;
			case M_ASSIGN_LEFT:
			case M_BITWISE_SHIFT_LEFT:	function=cq_bitwise_shift_left,		bmts=returns_rcq_ccq_qqq,	d(disc_cq_bitwise_shift_left_i);	return;
			case M_ASSIGN_RIGHT:
			case M_BITWISE_SHIFT_RIGHT:	function=cq_bitwise_shift_right,	bmts=returns_rcq_ccq_qqq,	d(disc_cq_bitwise_shift_right_i);	return;
			case M_LOGIC_LESS:			function=cq_logic_less,				bmts=returns_rrr_rrr_rrr,	d(disc_cq_logic_less_i);			return;
			case M_LOGIC_LESS_EQUAL:	function=cq_logic_less_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_cq_logic_less_equal_i);		return;
			case M_LOGIC_GREATER:		function=cq_logic_greater,			bmts=returns_rrr_rrr_rrr,	d(disc_cq_logic_greater_i);			return;
			case M_LOGIC_GREATER_EQUAL:	function=cq_logic_greater_equal,	bmts=returns_rrr_rrr_rrr,	d(disc_cq_logic_greater_equal_i);	return;
			case M_LOGIC_EQUAL:			function=cq_logic_equal,			bmts=returns_rrr_rrr_rrr,	d(disc_cq_logic_equal_i);			return;
			case M_LOGIC_NOT_EQUAL:		function=cq_logic_not_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_cq_logic_not_equal_i);		return;
			case M_ASSIGN_AND:
			case M_BITWISE_AND:			function=cq_bitwise_and,			bmts=returns_rcq_ccq_qqq,	d(disc_cq_bitwise_and_o, false);	return;
			case M_BITWISE_NAND:		function=cq_bitwise_nand,			bmts=returns_rcq_ccq_qqq,	d(disc_cq_bitwise_nand_o, false);	return;
			case M_ASSIGN_XOR:
			case M_BITWISE_XOR:			function=cq_bitwise_xor,			bmts=returns_rcq_ccq_qqq,	d(disc_cq_bitwise_xor_o, false);	return;
			case M_BITWISE_XNOR:		function=cq_bitwise_xnor,			bmts=returns_rcq_ccq_qqq,	d(disc_cq_bitwise_xnor_o, false);	return;
			case M_ASSIGN_OR:
			case M_VERTICAL_BAR:		function=cq_bitwise_or,				bmts=returns_rcq_ccq_qqq,	d(disc_cq_bitwise_or_o, false);		return;
			case M_BITWISE_NOR:			function=cq_bitwise_nor,			bmts=returns_rcq_ccq_qqq,	d(disc_cq_bitwise_nor_o, false);	return;
			case M_LOG:					function=cq_log,					bmts=returns_ccq_ccq_qqq,	d(disc_cq_log_i);					return;
			case M_RAND:				function=qq_random,					bmts=returns_rcq_ccq_qqq,	d(disc_qq_random, false);			return;
		//	case M_RAND:				function=cq_random,					bmts=returns_rcq_ccq_qqq,	d(disc_cq_random, false);			return;
			case M_ATAN:				function=cq_atan,					bmts=returns_rcq_ccq_qqq,	d(disc_cq_atan_i);					return;
			case M_SQWV:				function=cq_sqwv,					bmts=returns_rcq_ccq_qqq,	d(disc_cq_sqwv_i);					return;
			case M_TRWV:				function=cq_trwv,					bmts=returns_rcq_ccq_qqq,	d(disc_cq_trwv_i);					return;
			case M_SAW:					function=cq_saw,					bmts=returns_rcq_ccq_qqq,	d(disc_cq_saw_i);					return;
			case M_MIN:					function=cq_min,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_MAX:					function=cq_max,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_BETA:				function=0;																							return;
			case M_GAMMA:				function=0;																							return;
			case M_PERMUTATION:			function=cq_permutation,			bmts=returns_rcq_ccq_qqq,	d(disc_cq_permutation_i);			return;
			case M_COMBINATION:			function=cq_combination,			bmts=returns_rcq_ccq_qqq,	d(disc_cq_combination_i);			return;
			case M_BESSEL:				function=0;																							return;
			case M_NEUMANN:				function=0;																							return;
			case M_HANKEL1:				function=0;																							return;
			case M_ASSIGN:				function=q_assign,					bmts=returns_rcq_rcq_rcq,	d();								return;
			}
			break;
		}
	case 'H':
		switch(op2type)
		{
		case 'r':
	//	case 'R':
			switch(f)
			{
			case M_POWER:				function=qr_pow,					bmts=returns_ccq_ccq_qqq,	d(disc_qr_pow_i);					return;
			case M_ASSIGN_DIVIDE:
			case M_DIVIDE:				function=qr_divide,					bmts=returns_rcq_ccq_qqq,	d(disc_qr_divide_i);				return;
			case M_ASSIGN_MINUS:
			case M_MINUS:				function=qr_minus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_PENTATE:				function=0;																							return;
			case M_TETRATE:				function=qr_tetrate,				bmts=returns_ccX_ccX_qXX,	d(disc_qr_tetrate_i);				return;
			case M_ASSIGN_MULTIPLY:
			case M_MULTIPLY:			function=qr_multiply,				bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_ASSIGN_PLUS:
			case M_PLUS:				function=qr_plus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_LOGIC_AND:			function=qr_logic_and,				bmts=returns_rrr_rrr_rrr,	d(disc_qr_logic_and_i);				return;
			case M_LOGIC_XOR:			function=qr_logic_xor,				bmts=returns_rrr_rrr_rrr,	d(disc_qr_logic_xor_i);				return;
			case M_LOGIC_OR:			function=qr_logic_or,				bmts=returns_rrr_rrr_rrr,	d(disc_qr_logic_or_i);				return;
			case M_LOGIC_CONDITION_ZERO:function=qr_logic_condition_zero,	bmts=returns_rcq_ccq_qqq,	d(disc_qr_logic_condition_zero_i);	return;
			case M_ASSIGN_MOD:
			case M_MODULO_PERCENT:		function=qr_modulo,					bmts=returns_rcq_ccq_qqq,	d(disc_qr_modulo_i);				return;
			case M_ASSIGN_LEFT:
			case M_BITWISE_SHIFT_LEFT:	function=qr_bitwise_shift_left,		bmts=returns_rcq_ccq_qqq,	d(disc_qr_bitwise_shift_left_i);	return;
			case M_ASSIGN_RIGHT:
			case M_BITWISE_SHIFT_RIGHT:	function=qr_bitwise_shift_right,	bmts=returns_rcq_ccq_qqq,	d(disc_qr_bitwise_shift_right_i);	return;
			case M_LOGIC_LESS:			function=qr_logic_less,				bmts=returns_rrr_rrr_rrr,	d(disc_qr_logic_less_i);			return;
			case M_LOGIC_LESS_EQUAL:	function=qr_logic_less_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_qr_logic_less_equal_i);		return;
			case M_LOGIC_GREATER:		function=qr_logic_greater,			bmts=returns_rrr_rrr_rrr,	d(disc_qr_logic_greater_i);			return;
			case M_LOGIC_GREATER_EQUAL:	function=qr_logic_greater_equal,	bmts=returns_rrr_rrr_rrr,	d(disc_qr_logic_greater_equal_i);	return;
			case M_LOGIC_EQUAL:			function=qr_logic_equal,			bmts=returns_rrr_rrr_rrr,	d(disc_qr_logic_equal_i);			return;
			case M_LOGIC_NOT_EQUAL:		function=qr_logic_not_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_qr_logic_not_equal_i);		return;
			case M_ASSIGN_AND:
			case M_BITWISE_AND:			function=qr_bitwise_and,			bmts=returns_rcq_ccq_qqq,	d(disc_qr_bitwise_and_o, false);	return;
			case M_BITWISE_NAND:		function=qr_bitwise_nand,			bmts=returns_rcq_ccq_qqq,	d(disc_qr_bitwise_nand_o, false);	return;
			case M_ASSIGN_XOR:
			case M_BITWISE_XOR:			function=qr_bitwise_xor,			bmts=returns_rcq_ccq_qqq,	d(disc_qr_bitwise_xor_o, false);	return;
			case M_BITWISE_XNOR:		function=qr_bitwise_xnor,			bmts=returns_rcq_ccq_qqq,	d(disc_qr_bitwise_xnor_o, false);	return;
			case M_ASSIGN_OR:
			case M_VERTICAL_BAR:		function=qr_bitwise_or,				bmts=returns_rcq_ccq_qqq,	d(disc_qr_bitwise_or_o, false);		return;
			case M_BITWISE_NOR:			function=qr_bitwise_nor,			bmts=returns_rcq_ccq_qqq,	d(disc_qr_bitwise_nor_o, false);	return;
			case M_LOG:					function=qc_log,					bmts=returns_ccq_ccq_qqq,	d(disc_qc_log_i);					return;
			case M_RAND:				function=qq_random,					bmts=returns_rcq_ccq_qqq,	d(disc_qq_random, false);			return;
		//	case M_RAND:				function=qr_random,					bmts=returns_rcq_ccq_qqq,	d(disc_qr_random, false);			return;
			case M_ATAN:				function=qr_atan,					bmts=returns_rcq_ccq_qqq,	d(disc_qr_atan_i);					return;
			case M_SQWV:				function=qr_sqwv,					bmts=returns_rcq_ccq_qqq,	d(disc_qr_sqwv_i);					return;
			case M_TRWV:				function=qr_trwv,					bmts=returns_rcq_ccq_qqq,	d(disc_qr_trwv_i);					return;
			case M_SAW:					function=qr_saw,					bmts=returns_rcq_ccq_qqq,	d(disc_qr_saw_i);					return;
			case M_MIN:					function=qr_min,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_MAX:					function=qr_max,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_BETA:				function=0;																							return;
			case M_GAMMA:				function=0;																							return;
			case M_PERMUTATION:			function=qr_permutation,			bmts=returns_rcq_ccq_qqq,	d(disc_qr_permutation_i);			return;
			case M_COMBINATION:			function=qr_combination,			bmts=returns_rcq_ccq_qqq,	d(disc_qr_combination_i);			return;
			case M_BESSEL:				function=0;																							return;
			case M_NEUMANN:				function=0;																							return;
			case M_HANKEL1:				function=0;																							return;
			case M_ASSIGN:				function=r_assign,					bmts=returns_rcq_rcq_rcq,	d();								return;
			}
			break;
		case 'c':
	//	case 'C':
			switch(f)
			{
			case M_POWER:				function=qc_pow,					bmts=returns_ccq_ccq_qqq,	d(disc_qc_pow_i);					return;
			case M_ASSIGN_DIVIDE:
			case M_DIVIDE:				function=qc_divide,					bmts=returns_rcq_ccq_qqq,	d(disc_qc_divide_i);				return;
			case M_ASSIGN_MINUS:
			case M_MINUS:				function=qc_minus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_PENTATE:				function=0;																							return;
			case M_TETRATE:				function=0;																							return;
			case M_ASSIGN_MULTIPLY:
			case M_MULTIPLY:			function=qc_multiply,				bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_ASSIGN_PLUS:
			case M_PLUS:				function=qc_plus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_LOGIC_AND:			function=qc_logic_and,				bmts=returns_rrr_rrr_rrr,	d(disc_qc_logic_and_i);				return;
			case M_LOGIC_XOR:			function=qc_logic_xor,				bmts=returns_rrr_rrr_rrr,	d(disc_qc_logic_xor_i);				return;
			case M_LOGIC_OR:			function=qc_logic_or,				bmts=returns_rrr_rrr_rrr,	d(disc_qc_logic_or_i);				return;
			case M_LOGIC_CONDITION_ZERO:function=qc_logic_condition_zero,	bmts=returns_rcq_ccq_qqq,	d(disc_qc_logic_condition_zero_i);	return;
			case M_ASSIGN_MOD:
			case M_MODULO_PERCENT:		function=qc_modulo,					bmts=returns_rcq_ccq_qqq,	d(disc_qc_modulo_i);				return;
			case M_ASSIGN_LEFT:
			case M_BITWISE_SHIFT_LEFT:	function=qc_bitwise_shift_left,		bmts=returns_rcq_ccq_qqq,	d(disc_qc_bitwise_shift_left_i);	return;
			case M_ASSIGN_RIGHT:
			case M_BITWISE_SHIFT_RIGHT:	function=qc_bitwise_shift_right,	bmts=returns_rcq_ccq_qqq,	d(disc_qc_bitwise_shift_right_i);	return;
			case M_LOGIC_LESS:			function=qc_logic_less,				bmts=returns_rrr_rrr_rrr,	d(disc_qc_logic_less_i);			return;
			case M_LOGIC_LESS_EQUAL:	function=qc_logic_less_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_qc_logic_less_equal_i);		return;
			case M_LOGIC_GREATER:		function=qc_logic_greater,			bmts=returns_rrr_rrr_rrr,	d(disc_qc_logic_greater_i);			return;
			case M_LOGIC_GREATER_EQUAL:	function=qc_logic_greater_equal,	bmts=returns_rrr_rrr_rrr,	d(disc_qc_logic_greater_equal_i);	return;
			case M_LOGIC_EQUAL:			function=qc_logic_equal,			bmts=returns_rrr_rrr_rrr,	d(disc_qc_logic_equal_i);			return;
			case M_LOGIC_NOT_EQUAL:		function=qc_logic_not_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_qc_logic_not_equal_i);		return;
			case M_ASSIGN_AND:
			case M_BITWISE_AND:			function=qc_bitwise_and,			bmts=returns_rcq_ccq_qqq,	d(disc_qc_bitwise_and_o, false);	return;
			case M_BITWISE_NAND:		function=qc_bitwise_nand,			bmts=returns_rcq_ccq_qqq,	d(disc_qc_bitwise_nand_o, false);	return;
			case M_ASSIGN_XOR:
			case M_BITWISE_XOR:			function=qc_bitwise_xor,			bmts=returns_rcq_ccq_qqq,	d(disc_qc_bitwise_xor_o, false);	return;
			case M_BITWISE_XNOR:		function=qc_bitwise_xnor,			bmts=returns_rcq_ccq_qqq,	d(disc_qc_bitwise_xnor_o, false);	return;
			case M_ASSIGN_OR:
			case M_VERTICAL_BAR:		function=qc_bitwise_or,				bmts=returns_rcq_ccq_qqq,	d(disc_qc_bitwise_or_o, false);		return;
			case M_BITWISE_NOR:			function=qc_bitwise_nor,			bmts=returns_rcq_ccq_qqq,	d(disc_qc_bitwise_nor_o, false);	return;
			case M_LOG:					function=qc_log,					bmts=returns_ccq_ccq_qqq,	d(disc_qc_log_i);					return;
			case M_RAND:				function=qq_random,					bmts=returns_rcq_ccq_qqq,	d(disc_qq_random, false);			return;
		//	case M_RAND:				function=qc_random,					bmts=returns_rcq_ccq_qqq,	d(disc_qc_random, false);			return;
			case M_ATAN:				function=qc_atan,					bmts=returns_rcq_ccq_qqq,	d(disc_qc_atan_i);					return;
			case M_SQWV:				function=qc_sqwv,					bmts=returns_rcq_ccq_qqq,	d(disc_qc_sqwv_i);					return;
			case M_TRWV:				function=qc_trwv,					bmts=returns_rcq_ccq_qqq,	d(disc_qc_trwv_i);					return;
			case M_SAW:					function=qc_saw,					bmts=returns_rcq_ccq_qqq,	d(disc_qc_saw_i);					return;
			case M_MIN:					function=qc_min,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_MAX:					function=qc_max,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_BETA:				function=0;																							return;
			case M_GAMMA:				function=0;																							return;
			case M_PERMUTATION:			function=qc_permutation,			bmts=returns_rcq_ccq_qqq,	d(disc_qc_permutation_i);			return;
			case M_COMBINATION:			function=qc_combination,			bmts=returns_rcq_ccq_qqq,	d(disc_qc_combination_i);			return;
			case M_BESSEL:				function=0;																							return;
			case M_NEUMANN:				function=0;																							return;
			case M_HANKEL1:				function=0;																							return;
			case M_ASSIGN:				function=c_assign,					bmts=returns_rcq_rcq_rcq,	d();								return;
			}
			break;
		case 'H':
			switch(f)
			{
			case M_POWER:				function=qq_pow,					bmts=returns_ccq_ccq_qqq,	d(disc_qq_pow_i);					return;
			case M_ASSIGN_DIVIDE:
			case M_DIVIDE:				function=qq_divide,					bmts=returns_rcq_ccq_qqq,	d(disc_qq_divide_i);				return;
			case M_ASSIGN_MINUS:
			case M_MINUS:				function=qq_minus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_PENTATE:				function=0;																							return;
			case M_TETRATE:				function=0;																							return;
			case M_ASSIGN_MULTIPLY:
			case M_MULTIPLY:			function=qq_multiply,				bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_ASSIGN_PLUS:
			case M_PLUS:				function=qq_plus,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_LOGIC_AND:			function=qq_logic_and,				bmts=returns_rrr_rrr_rrr,	d(disc_qq_logic_and_i);				return;
			case M_LOGIC_XOR:			function=qq_logic_xor,				bmts=returns_rrr_rrr_rrr,	d(disc_qq_logic_xor_i);				return;
			case M_LOGIC_OR:			function=qq_logic_or,				bmts=returns_rrr_rrr_rrr,	d(disc_qq_logic_or_i);				return;
			case M_LOGIC_CONDITION_ZERO:function=qq_logic_condition_zero,	bmts=returns_rcq_ccq_qqq,	d(disc_qq_logic_condition_zero_i);	return;
			case M_ASSIGN_MOD:
			case M_MODULO_PERCENT:		function=qq_modulo,					bmts=returns_rcq_ccq_qqq,	d(disc_qq_modulo_i);				return;
			case M_ASSIGN_LEFT:
			case M_BITWISE_SHIFT_LEFT:	function=qq_bitwise_shift_left,		bmts=returns_rcq_ccq_qqq,	d(disc_qq_bitwise_shift_left_i);	return;
			case M_ASSIGN_RIGHT:
			case M_BITWISE_SHIFT_RIGHT:	function=qq_bitwise_shift_right,	bmts=returns_rcq_ccq_qqq,	d(disc_qq_bitwise_shift_right_i);	return;
			case M_LOGIC_LESS:			function=qq_logic_less,				bmts=returns_rrr_rrr_rrr,	d(disc_qq_logic_less_i);			return;
			case M_LOGIC_LESS_EQUAL:	function=qq_logic_less_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_qq_logic_less_equal_i);		return;
			case M_LOGIC_GREATER:		function=qq_logic_greater,			bmts=returns_rrr_rrr_rrr,	d(disc_qq_logic_greater_i);			return;
			case M_LOGIC_GREATER_EQUAL:	function=qq_logic_greater_equal,	bmts=returns_rrr_rrr_rrr,	d(disc_qq_logic_greater_equal_i);	return;
			case M_LOGIC_EQUAL:			function=qq_logic_equal,			bmts=returns_rrr_rrr_rrr,	d(disc_qq_logic_equal_i);			return;
			case M_LOGIC_NOT_EQUAL:		function=qq_logic_not_equal,		bmts=returns_rrr_rrr_rrr,	d(disc_qq_logic_not_equal_i);		return;
			case M_ASSIGN_AND:
			case M_BITWISE_AND:			function=qq_bitwise_and,			bmts=returns_rcq_ccq_qqq,	d(disc_qq_bitwise_and_o, false);	return;
			case M_BITWISE_NAND:		function=qq_bitwise_nand,			bmts=returns_rcq_ccq_qqq,	d(disc_qq_bitwise_nand_o, false);	return;
			case M_ASSIGN_XOR:
			case M_BITWISE_XOR:			function=qq_bitwise_xor,			bmts=returns_rcq_ccq_qqq,	d(disc_qq_bitwise_xor_o, false);	return;
			case M_BITWISE_XNOR:		function=qq_bitwise_xnor,			bmts=returns_rcq_ccq_qqq,	d(disc_qq_bitwise_xnor_o, false);	return;
			case M_ASSIGN_OR:
			case M_VERTICAL_BAR:		function=qq_bitwise_or,				bmts=returns_rcq_ccq_qqq,	d(disc_qq_bitwise_or_o, false);		return;
			case M_BITWISE_NOR:			function=qq_bitwise_nor,			bmts=returns_rcq_ccq_qqq,	d(disc_qq_bitwise_nor_o, false);	return;
			case M_LOG:					function=qq_log,					bmts=returns_ccq_ccq_qqq,	d(disc_qq_log_i);					return;
			case M_RAND:				function=qq_random,					bmts=returns_rcq_ccq_qqq,	d(disc_qq_random, false);			return;
			case M_ATAN:				function=qq_atan,					bmts=returns_rcq_ccq_qqq,	d(disc_qq_atan_i);					return;
			case M_SQWV:				function=qq_sqwv,					bmts=returns_rcq_ccq_qqq,	d(disc_qq_sqwv_i);					return;
			case M_TRWV:				function=qq_trwv,					bmts=returns_rcq_ccq_qqq,	d(disc_qq_trwv_i);					return;
			case M_SAW:					function=qq_saw,					bmts=returns_rcq_ccq_qqq,	d(disc_qq_saw_i);					return;
			case M_MIN:					function=qq_min,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_MAX:					function=qq_max,					bmts=returns_rcq_ccq_qqq,	d();								return;
			case M_BETA:				function=0;																							return;
			case M_GAMMA:				function=0;																							return;
			case M_PERMUTATION:			function=qq_permutation,			bmts=returns_rcq_ccq_qqq,	d(disc_qq_permutation_i);			return;
			case M_COMBINATION:			function=qq_combination,			bmts=returns_rcq_ccq_qqq,	d(disc_qq_combination_i);			return;
			case M_BESSEL:				function=0;																							return;
			case M_NEUMANN:				function=0;																							return;
			case M_HANKEL1:				function=0;																							return;
			case M_ASSIGN:				function=q_assign,					bmts=returns_rcq_rcq_rcq,	d();								return;
			}
			break;
		}
		break;
	}
	function=0;
}
void			Compile::compile_instruction_u			(int f, char side, int a1, bool assign)
//void			Compile::compile_instruction_u			(int f, char side, int _op, bool proceduralVariable)
{
	int result;
	int op=expr->m[a1]._1;
	if(procedural&&term[op].fresh&&(expr->n[op].constant||!assign))
	{
		char mathSet='r';
		expr->insertData(mathSet);//constant but doesn't matter
		result=expr->n.size()-1;
		bool constant=expr->n[result].constant=expr->n[op].constant;
		term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm));
		term[result]=CompileTerm(constant, mathSet, false);
	}
	else
		result=op;
	Value (*function)(Value const&);
	char (*umts)(char);
	DiscontinuityFunction d;
	compile_instruction_select_u(f, side, term[op].mathSet, function, umts, d);
	if(function)
	{
		char resultMathSet=umts(term[op].mathSet);
		if(!procedural||!term[result].fresh||!term[result].constant&&term[result].mathSet>resultMathSet)//'r' > 'c'
			term[result].mathSet=resultMathSet;
	//	term[result].mathSet=umts(term[op].mathSet);
		if(term[op].constant)
			expr->data[result]=function(expr->data[op]), expr->n[op].mathSet=term[op].mathSet;
		//	expr->n[op].val=function(expr->n[op].val), expr->n[op].mathSet=term[op].mathSet;
		else
			expr->i.push_back(Instruction(function, umts, op, result, d));
	}
	expr->m[a1]._1=result;
/*	if(proceduralVariable)
	{
		expr->insertData('R');
		terms=(CompileTerm*)realloc(terms, expr->n.size()*sizeof(CompileTerm));
		terms[expr->n.size()-1]=CompileTerm(expr.n.rbegin()->constant, expr.n.rbegin()->mathSet);
		compile_instruction_b2(G2::M_ASSIGN, expr->n.size()-1, _op);
		expr->m[_op]._1=expr->n.size()-1;
	}
	int op=expr->m[_op]._1;
	Value (*function)(Value const&);
	char (*umts)(char);
	DiscontinuityFunction d;
	compile_instruction_select_u(f, side, term[op].mathSet, function, umts, d);
	if(function)
	{
		term[op].mathSet=umts(term[op].mathSet);
		if(term[op].constant)
			expr->data[op]=function(expr->data[op]), expr->n[op].mathSet=term[op].mathSet;
		//	expr->n[op].val=function(expr->n[op].val), expr->n[op].mathSet=term[op].mathSet;
		else
			expr->i.push_back(Instruction(function, umts, op, d));
	}
	if(proceduralVariable)
		expr->m[_op]._1=expr->n.size()-1;//*/
}
void			Compile::compile_instruction_b			(int f, int a1, int a2, bool assign)
//int					Compile::compile_instruction_b			(int f, int a1, int a2, bool assign)
//int				Compile::compile_instruction_b			(int f, int _op1, int _op2, bool r_op1, bool _1procVar, bool _2procVar)//r: resultGoesTo_op1=r_op1||op1<op2, 1: resultGoesTo_op1=true, 2: resultGoesTo_op1=false
//int				Compile::compile_instruction_b			(int f, int _op1, int _op2, bool r_op1, bool r_op2)//r: resultGoesTo_op1=r_op1||op1<op2, 1: resultGoesTo_op1=true, 2: resultGoesTo_op1=false
//int				Compile::compile_instruction_b			(int f, int _op1, int _op2, char r_op1)//r: 0: resultGoesTo_op1=op1<op2, 1: resultGoesTo_op1=true, 2: resultGoesTo_op1=false
{
	int op1=expr->m[a1]._1, op2=expr->m[a2]._1, result;
	if(procedural)
	{
		if(term[op1].fresh&&(expr->n[op1].constant||!assign))
		{
			if(term[op2].fresh)
			{
				char mathSet='r';
				expr->insertData(mathSet);
				result=expr->n.size()-1;
				bool constant=expr->n.rbegin()->constant=expr->n[op1].constant&&expr->n[op2].constant;
				term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm));
				term[result]=CompileTerm(constant, mathSet, false);
			}
			else
				result=op2;
		}
		else
			result=op1;
	}
	else
		result=op1<op2?op1:op2;
	Value (*function)(Value const&, Value const&);
	char (*bmts)(char, char);
	DiscontinuityFunction d;
	compile_instruction_select_b(f, term[op1].mathSet, term[op2].mathSet, function, bmts, d);
	if(function)
	{
		char resultMathSet=bmts(term[op1].mathSet, term[op2].mathSet);
		if(!procedural||!term[result].fresh||!term[result].constant&&term[result].mathSet>resultMathSet)//'r' > 'c'
			term[result].mathSet=resultMathSet;
	//	term[result].mathSet=bmts(term[op1].mathSet, term[op2].mathSet);
		if(term[op1].constant&&term[op2].constant)
			expr->data[result]=function(expr->data[op1], expr->data[op2]), expr->n[result].mathSet=term[result].mathSet;
		//	expr->n[result].val=function(expr->n[op1].val, expr->n[op2].val), expr->n[result].mathSet=term[result].mathSet;
		else
			expr->i.push_back(Instruction(function, bmts, op1, op2, result, d)), term[result].constant=false;
	}
	expr->m[a1]._1=result, expr->m[a2]._0=G2::M_IGNORED;
//	return result;

/*	int op1=expr->m[_op1]._1, op2=expr->m[_op2]._1;
//	bool resultGoesTo_op1=(r_op1||op1<op2)&&!r_op2;
	bool resultGoesTo_op1=r_op1||op1<op2;
//	bool resultGoesTo_op1=r?2-r:op1<op2;

	if(_1procVar)
	{
		if(_2procVar)
		{
			expr->insertData('R');//new repositry
			terms=(CompileTerm*)realloc(terms, expr->n.size()*sizeof(CompileTerm));
			terms[expr->n.size()-1]=CompileTerm(expr.n.rbegin()->constant, expr.n.rbegin()->mathSet);
			compile_instruction_b2(G2::M_ASSIGN, expr->n.size()-1, _op1);//copy to new repositry
			expr->m[_op1]._1=expr->n.size()-1;//link to new repositry
			resultGoesTo_op1=true;//result goes to new repositry
		}
		else
			resultGoesTo_op1=false;
	}
	else if(_2procVar)
		resultGoesTo_op1=true;
	int result=resultGoesTo_op1?op1:op2;
	Value (*function)(Value const&, Value const&);
	char (*bmts)(char, char);
	DiscontinuityFunction d;
	compile_instruction_select_b(f, term[op1].mathSet, term[op2].mathSet, function, bmts, d);
	if(function)
	{
		term[result].mathSet=bmts(term[op1].mathSet, term[op2].mathSet);
		if(term[op1].constant&&term[op2].constant)
			expr->data[result]=function(expr->data[op1], expr->data[op2]), expr->n[result].mathSet=term[result].mathSet;
		//	expr->n[result].val=function(expr->n[op1].val, expr->n[op2].val), expr->n[result].mathSet=term[result].mathSet;
		else
			expr->i.push_back(Instruction(function, bmts, op1, op2, result, d)), term[result].constant=false;
	}
	expr->m[resultGoesTo_op1?_op2:_op1]._0=G2::M_IGNORED;
	return 4-resultGoesTo_op1-resultGoesTo_op1;//*/
}
void			Compile::compile_instruction_b2			(int f, int op1, int _op2)//M_ASSIGN n[op1]=m[n[_op2]], no m link removal
{
	int op2=expr->m[_op2]._1;
	int result=op1;
	Value (*function)(Value const&, Value const&);
	char (*bmts)(char, char);
	DiscontinuityFunction d;
	compile_instruction_select_b(f, term[op1].mathSet, term[op2].mathSet, function, bmts, d);
	if(function)
	{
		term[result].mathSet=bmts(term[op1].mathSet, term[op2].mathSet);
		if(term[op1].constant&&term[op2].constant)
			expr->data[result]=function(expr->data[op1], expr->data[op2]), expr->n[result].mathSet=term[result].mathSet;
		//	expr->n[result].val=function(expr->n[op1].val, expr->n[op2].val), expr->n[result].mathSet=term[result].mathSet;
		else
			expr->i.push_back(Instruction(function, bmts, op1, op2, result, d)), term[result].constant=false;
	}
}
void			Compile::compile_instruction_condition_111	(int op1, int op2, int op3)
{
	using namespace G2;
	int result=op1;
	term[result].mathSet=returns_conditional(term[op1].mathSet, term[op2].mathSet, term[op3].mathSet);
	if(term[op1].constant&&term[op2].constant&&term[op3].constant)
		expr->data[result]=conditional_111(expr->data[op1], expr->data[op2], expr->data[op3]), expr->n[result].mathSet=term[result].mathSet;
	//	expr->n[result].val=conditional_111(expr->n[op1].val, expr->n[op2].val, expr->n[op3].val), expr->n[result].mathSet=term[result].mathSet;
	else
		expr->i.push_back(Instruction(conditional_111, returns_conditional, op1, op2, op3, result, DiscontinuityFunction(disc_conditional_111_i))), term[result].constant=false;
}
void			Compile::compile_instruction_condition_110	(int op1, int op2)
{
	using namespace G2;
	int result=op1;
	term[result].mathSet=returns_rrr_ccc_qqq(term[op1].mathSet, term[op2].mathSet);
	if(term[op1].constant&&term[op2].constant)
		expr->data[result]=conditional_110(expr->data[op1], expr->data[op2]), expr->n[result].mathSet=term[result].mathSet;
	//	expr->n[result].val=conditional_110(expr->n[op1].val, expr->n[op2].val), expr->n[result].mathSet=term[result].mathSet;
	else
		expr->i.push_back(Instruction(conditional_110, returns_rrr_ccc_qqq, op1, op2, result, DiscontinuityFunction(disc_conditional_110_i))), term[result].constant=false;
}
void			Compile::compile_instruction_condition_101	(int op1, int op2)
{
	using namespace G2;
	int result=op1;
	term[result].mathSet=returns_rrr_ccc_qqq(term[op1].mathSet, term[op2].mathSet);
	if(term[op1].constant&&term[op2].constant)
		expr->data[result]=conditional_101(expr->data[op1], expr->data[op2]), expr->n[result].mathSet=term[result].mathSet;
	//	expr->n[result].val=conditional_101(expr->n[op1].val, expr->n[op2].val), expr->n[result].mathSet=term[result].mathSet;
	else
		expr->i.push_back(Instruction(conditional_101, returns_rrr_ccc_qqq, op1, op2, result, DiscontinuityFunction(disc_conditional_101_i))), term[result].constant=false;
}
void			Compile::compile_instruction_condition_100	(int op1){expr->data[op1]=Value(), term[op1].constant=true, expr->n[op1].mathSet=term[op1].mathSet='r';}
//void			Compile::compile_instruction_condition_100	(int op1){expr->data[op1]=Value(), term[op1].constant=true, expr->n[op1].mathSet=term[op1].mathSet='R';}
void			Compile::compile_instruction_condition_011	(int op1, int op2)
{
	using namespace G2;
	int result=op1;
	term[result].mathSet=returns_rrr_ccc_qqq(term[op1].mathSet, term[op2].mathSet);
	if(term[op1].constant&&term[op2].constant)
		expr->data[result]=conditional_011(expr->data[op1], expr->data[op2]), expr->n[result].mathSet=term[result].mathSet;
	//	expr->n[result].val=conditional_011(expr->n[op1].val, expr->n[op2].val), expr->n[result].mathSet=term[result].mathSet;
	else
		expr->i.push_back(Instruction(conditional_011, returns_rrr_ccc_qqq, op1, op2, result, DiscontinuityFunction())), term[result].constant=false;
}
void			Compile::compile_instruction_condition_010	(int op1){expr->data[op1]=Value(), term[op1].constant=true, expr->n[op1].mathSet=term[op1].mathSet='r';}
//void			Compile::compile_instruction_condition_010	(int op1){expr->data[op1]=Value(), term[op1].constant=true, expr->n[op1].mathSet=term[op1].mathSet='R';}
char			Compile::compile_instruction			(int f, char side, int a1, int a2, int a3)
//int				Compile::compile_instruction			(int f, char side, int a1, int a2, int a3)
{
	using namespace G2;
	expr->lastInstruction=expr->m[f]._0;
//	bool _1procVar=procedural&&a1!=-1&&!expr->n[expr->m[a1]._1].constant, _2procVar=procedural&&a2!=-1&&!expr->n[expr->m[a2]._1].constant;
	switch(expr->m[f]._0)
	{
	case M_FACTORIAL_LOGIC_NOT:
		if(ub[f]=='u')
			compile_instruction_u(expr->m[f]._0, side, a1);
		else if(ub[f]=='b')
			compile_instruction_u(expr->m[f]._0, '>', a1);//*/
	/*	if(ub[f]=='u')
			compile_instruction_u(expr->m[f]._0, side, a1, _1procVar);
		else if(ub[f]=='b')
			compile_instruction_u(expr->m[f]._0, '>', a1, _1procVar);//*/
	/*	if(procedural&&!expr->n[expr->m[a1]._1].constant)
		{
			expr->insertData('R');
			compile_instruction_b(M_ASSIGN, expr->n.size()-1, a1, true);
			if(ub[f]=='u')
				compile_instruction_u(expr->m[f]._0, side, a1);
			else if(ub[f]=='b')
				compile_instruction_u(expr->m[f]._0, '>', a1);
			expr->m[a1]._1=expr->n.size()-1;
		}
		else
		{
			if(ub[f]=='u')
				compile_instruction_u(expr->m[f]._0, side, a1);
			else if(ub[f]=='b')
				compile_instruction_u(expr->m[f]._0, '>', a1);
		}//*/
	//	if(ub[f]=='u')
	//		compile_instruction_u(expr->m[f]._0, side, a1);
	//	else if(ub[f]=='b')
	//		compile_instruction_u(expr->m[f]._0, '>', a1);
		break;
	case M_BITWISE_NOT:
		if(ub[f]=='u')
			compile_instruction_u(expr->m[f]._0, side, a1);
		else if(ub[f]=='b')
			compile_instruction_u(expr->m[f]._0, '<', a2);
	/*	if(ub[f]=='u')
			compile_instruction_u(expr->m[f]._0, side, a1, _1procVar);
		else if(ub[f]=='b')
			compile_instruction_u(expr->m[f]._0, '<', a2, _2procVar);//*/
	/*	if(procedural&&!expr->n[expr->m[a1]._1].constant)
		{
			expr->insertData('R');
			if(ub[f]=='u')
			{
				compile_instruction_b(M_ASSIGN, expr->n.size()-1, a1, true);
				compile_instruction_u(expr->m[f]._0, side, a1);
			}
			else if(ub[f]=='b')
			{
				compile_instruction_b(M_ASSIGN, expr->n.size()-1, a2, true);
				compile_instruction_u(expr->m[f]._0, '<', a2);
			}
			expr->m[a1]._1=expr->n.size()-1;
		}
		else
		{
			if(ub[f]=='u')
				compile_instruction_u(expr->m[f]._0, side, a1);
			else if(ub[f]=='b')
				compile_instruction_u(expr->m[f]._0, '<', a2);
		}//*/
	//	if(ub[f]=='u')
	//		compile_instruction_u(expr->m[f]._0, side, a1);
	//	else if(ub[f]=='b')
	//		compile_instruction_u(expr->m[f]._0, '<', a2);
		break;
	case M_PENTATE:
	case M_TETRATE:
	case M_MULTIPLY:
	case M_PLUS:
	case M_LOGIC_AND:
	case M_LOGIC_XOR:
	case M_LOGIC_OR:
	case M_LOGIC_CONDITION_ZERO:
		if(ub[f]=='b')
		{
			compile_instruction_b(expr->m[f]._0, a1, a2);
			return 'b';
		}
	//	if(ub[f]=='b')
	//		return compile_instruction_b(expr->m[f]._0, a1, a2);
	//	if(ub[f]=='b')
	//		return compile_instruction_b(expr->m[f]._0, a1, a2, false, _1procVar, _2procVar);
	/*	if(ub[f]=='b')
		{
			if(procedural)
			{
				if(expr->n[expr->m[a1]._1].constant)
					return compile_instruction_b(expr->m[f]._0, a1, a2, true);
				else
				{
					if(expr->n[expr->m[a2]._1].constant)
						return compile_instruction_b(expr->m[f]._0, a1, a2, false, true);
					else if(ub[f]=='b')
					{
						expr->insertData('R');
						compile_instruction_b(M_ASSIGN, expr->n.size()-1, a1, true);
						expr->m[a1]._1=expr->n.size()-1;
						return compile_instruction_b(expr->m[f]._0, a1, a2, true);
					}
				}
			}
			else
				return compile_instruction_b(expr->m[f]._0, a1, a2);
		}//*/
	//	if(ub[f]=='b')
	//		return compile_instruction_b(expr->m[f]._0, a1, a2);
		break;
	case M_DIVIDE:
	case M_MINUS:
		if(ub[f]=='u')
		{
			if(side=='<')
				compile_instruction_u(expr->m[f]._0, side, a1);
		}
		else if(ub[f]=='b')
		{
			compile_instruction_b(expr->m[f]._0, a1, a2);
			return 'b';
		}
	/*	if(ub[f]=='u')
		{
			if(side=='<')
				compile_instruction_u(expr->m[f]._0, side, a1);
		}
		else if(ub[f]=='b')
			return compile_instruction_b(expr->m[f]._0, a1, a2);//*/
	/*	if(ub[f]=='u')
		{
			if(side=='<')
				compile_instruction_u(expr->m[f]._0, side, a1, _1procVar);
		}
		else if(ub[f]=='b')
			return compile_instruction_b(expr->m[f]._0, a1, a2, false, _1procVar, _2procVar);//*/
	/*	if(ub[f]=='u')
		{
			if(side=='<')
			{
				if(procedural)
				{
					if(expr->n[expr->m[a1]._1].constant)
						compile_instruction_u(expr->m[f]._0, side, a1);
					else
					{
						expr->insertData('R');
						compile_instruction_b(M_ASSIGN, expr->n.size()-1, a1, true);
						expr->m[a1]._1=expr->n.size()-1;
						compile_instruction_u(expr->m[f]._0, side, a1);
					}
				}
				else
					compile_instruction_u(expr->m[f]._0, side, a1);
			}
		}
		else if(ub[f]=='b')
		{
			if(procedural)
			{
				if(expr->n[expr->m[a1]._1].constant)
					return compile_instruction_b(expr->m[f]._0, a1, a2, true);
				else
				{
					if(expr->n[expr->m[a2]._1].constant)
						return compile_instruction_b(expr->m[f]._0, a1, a2, false, true);
					else
					{
						expr->insertData('R');
						compile_instruction_b(M_ASSIGN, expr->n.size()-1, a1, true);
						expr->m[a1]._1=expr->n.size()-1;
						return compile_instruction_b(expr->m[f]._0, a1, a2, true);
					}
				}
			}
			else
				return compile_instruction_b(expr->m[f]._0, a1, a2);
		}//*/
	//	if(ub[f]=='u')
	//	{
	//		if(side=='<')
	//			compile_instruction_u(expr->m[f]._0, side, a1);
	//	}
	//	else if(ub[f]=='b')
	//		return compile_instruction_b(expr->m[f]._0, a1, a2);
		break;
	case M_POWER:
		if(ub[f]=='u')
		{
			if(side=='<')
				compile_instruction_u(M_EXP, side, a1);
		}
		else if(ub[f]=='b')
		{
			compile_instruction_b(expr->m[f]._0, a1, a2);
			return 'b';
		}
	/*	if(ub[f]=='u')
		{
			if(side=='<')
				compile_instruction_u(M_EXP, side, a1);
		}
		else if(ub[f]=='b')
			return compile_instruction_b(expr->m[f]._0, a1, a2);//*/
	/*	if(ub[f]=='u')
		{
			if(side=='<')
				compile_instruction_u(M_EXP, side, a1, _1procVar);
		}
		else if(ub[f]=='b')
			return compile_instruction_b(expr->m[f]._0, a1, a2, false, _1procVar, _2procVar);//*/
	/*	if(ub[f]=='u')
		{
			if(side=='<')
			{
				if(procedural&&!expr->n[expr->m[a1]._1].constant)
				{
					expr->insertData('R');
					compile_instruction_b(M_ASSIGN, expr->n.size()-1, a1, true);
					expr->m[a1]._1=expr->n.size()-1;
				}
				compile_instruction_u(M_EXP, side, a1);
			}
		}
		else if(ub[f]=='b')
		{
			if(procedural)
			{
				if(expr->n[expr->m[a1]._1].constant)
					return compile_instruction_b(expr->m[f]._0, a1, a2, true);
				else
				{
					if(expr->n[expr->m[a2]._1].constant)
						return compile_instruction_b(expr->m[f]._0, a1, a2, false, true);
					else
					{
						expr->insertData('R');
						compile_instruction_b(M_ASSIGN, expr->n.size()-1, a1, true);
						expr->m[a1]._1=expr->n.size()-1;
						return compile_instruction_b(expr->m[f]._0, a1, a2, true);
					}
				}
			}
			else
				return compile_instruction_b(expr->m[f]._0, a1, a2);
		}//*/
	//	if(ub[f]=='u')
	//	{
	//		if(side=='<')
	//			compile_instruction_u(M_EXP, side, a1);
	//	}
	//	else if(ub[f]=='b')
	//		return compile_instruction_b(expr->m[f]._0, a1, a2);
		break;
	case M_MODULO_PERCENT:
	case M_BITWISE_SHIFT_LEFT:case M_BITWISE_SHIFT_RIGHT:
	case M_LOGIC_LESS:case M_LOGIC_LESS_EQUAL:case M_LOGIC_GREATER:case M_LOGIC_GREATER_EQUAL:
	case M_LOGIC_EQUAL:case M_LOGIC_NOT_EQUAL:
	case M_BITWISE_AND:case M_BITWISE_NAND:
	case M_BITWISE_XOR:case M_BITWISE_XNOR:
	case M_VERTICAL_BAR:case M_BITWISE_NOR:
		if(ub[f]=='u')
			compile_instruction_u(expr->m[f]._0, side, a1);
		else if(ub[f]=='b')
		{
			compile_instruction_b(expr->m[f]._0, a1, a2);
			return 'b';
		}
	/*	if(ub[f]=='u')
			compile_instruction_u(expr->m[f]._0, side, a1);
		else if(ub[f]=='b')
			return compile_instruction_b(expr->m[f]._0, a1, a2);//*/
	/*	if(ub[f]=='u')
			compile_instruction_u(expr->m[f]._0, side, a1, _1procVar);
		else if(ub[f]=='b')
			return compile_instruction_b(expr->m[f]._0, a1, a2, false, _1procVar, _2procVar);//*/
	/*	if(ub[f]=='u')
		{
			if(procedural&&!expr->n[expr->m[a1]._1].constant)
			{
				expr->insertData('R');
				compile_instruction_b(M_ASSIGN, expr->n.size()-1, a1, true);
				expr->m[a1]._1=expr->n.size()-1;
			}
			compile_instruction_u(expr->m[f]._0, side, a1);
		}
		else if(ub[f]=='b')
		{
			if(procedural)
			{
				if(expr->n[expr->m[a1]._1].constant)
					return compile_instruction_b(expr->m[f]._0, a1, a2, true);
				else
				{
					if(expr->n[expr->m[a2]._1].constant)
						return compile_instruction_b(expr->m[f]._0, a1, a2, false, true);
					else
					{
						expr->insertData('R');
						compile_instruction_b(M_ASSIGN, expr->n.size()-1, a1, true);
						expr->m[a1]._1=expr->n.size()-1;
						return compile_instruction_b(expr->m[f]._0, a1, a2, true);
					}
				}
			}
			else
				return compile_instruction_b(expr->m[f]._0, a1, a2);
		}//*/
	//	if(ub[f]=='u')
	//		compile_instruction_u(expr->m[f]._0, side, a1);
	//	else if(ub[f]=='b')
	//		return compile_instruction_b(expr->m[f]._0, a1, a2);
		break;
	case M_N:
		compile_instruction_b(M_MULTIPLY, a1, a2);
		return 'b';
	//	return compile_instruction_b(M_MULTIPLY, a1, a2);
	//	return compile_instruction_b(M_MULTIPLY, a1, a2, false, _1procVar, _2procVar);
	/*	if(procedural)
		{
			if(expr->n[expr->m[a1]._1].constant)
				return compile_instruction_b(expr->m[f]._0, a1, a2, true);
			else
			{
				if(expr->n[expr->m[a2]._1].constant)
					return compile_instruction_b(expr->m[f]._0, a1, a2, false, true);
				else
				{
					expr->insertData('R');
					compile_instruction_b(M_ASSIGN, expr->n.size()-1, a1, true);
					expr->m[a1]._1=expr->n.size()-1;
					return compile_instruction_b(expr->m[f]._0, a1, a2, true);
				}
			}
		}
		else
			return compile_instruction_b(expr->m[f]._0, a1, a2);//*/
	//	return compile_instruction_b(M_MULTIPLY, a1, a2);
	case M_QUESTION_MARK://always not procedural
			 if(a1!=-1)	{		 if(a2!=-1)	{		 if(a3!=-1)		compile_instruction_condition_111(	expr->m[a1]._1,	expr->m[a2]._1,	expr->m[a3]._1	), expr->m[a2]._0=M_IGNORED, expr->m[a3]._0=M_IGNORED;
												else				compile_instruction_condition_110(	expr->m[a1]._1,	expr->m[a2]._1					), expr->m[a2]._0=M_IGNORED;							}
							else			{		 if(a3!=-1)		compile_instruction_condition_101(	expr->m[a1]._1,					expr->m[a3]._1	), expr->m[a3]._0=M_IGNORED;
												else				compile_instruction_condition_100(	expr->m[a1]._1									);														}}
		else			{		 if(a2!=-1)	{		 if(a3!=-1)		compile_instruction_condition_011(					expr->m[a2]._1, expr->m[a3]._1	), expr->m[a3]._0=M_IGNORED;
												else				compile_instruction_condition_010(					expr->m[a2]._1					);														}
							else			{		 if(a3!=-1)		;
												else				expr->m[f]._0=M_N, expr->m[f]._1=expr->n.size(), expr->insertData('r', Value()), term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm)), term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet); }}
		//										else				expr->m[f]=::Map(M_N, expr->n.size()), expr->insertData('r', Value()), term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm)), term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet); }}
		//										else				expr->m[f]=::Map(M_N, expr->n.size()), expr->insertData('R', Value()), term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm)), term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet); }}
		break;

	case M_ASSIGN://always procedural
	case M_ASSIGN_MULTIPLY:case M_ASSIGN_DIVIDE:case M_ASSIGN_MOD:
	case M_ASSIGN_PLUS:case M_ASSIGN_MINUS:
	case M_ASSIGN_LEFT:case M_ASSIGN_RIGHT:
	case M_ASSIGN_AND:case M_ASSIGN_XOR:case M_ASSIGN_OR:
		compile_instruction_b(expr->m[f]._0, a1, a2, true);
		return 'b';
	//	return compile_instruction_b(expr->m[f]._0, a1, a2, true);
	//	break;
	case M_INCREMENT:case M_DECREMENT:
		if(ub[f]=='u')
		{
			if(side=='<')//++a1
				compile_instruction_u(expr->m[f]._0, '_', a1, true);
			else if(side=='>')//a1++
			{
				if(procedural)
				{
					if(term[expr->m[a1]._1].fresh&&!expr->n[expr->m[a1]._1].constant)
					{
						expr->insertData('R');
						term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm));
						term[expr->n.size()-1]=CompileTerm(expr->n.rbegin()->constant, expr->n.rbegin()->mathSet, false);
						compile_instruction_b2(M_ASSIGN, expr->n.size()-1, a1);
						compile_instruction_u(expr->m[f]._0, '_', a1, true);
						expr->m[a1]._1=expr->n.size()-1;
					}
				}
			}
		}
		else if(ub[f]=='b')//a1 ++ a2
			compile_instruction_u(expr->m[f]._0, '_', a2, true);
	/*	if(ub[f]=='u')
		{
			if(side=='<')//++a1
				compile_instruction_u(expr->m[f]._0, '_', a1);
			else if(side=='>')//a1++
			{
				if(procedural&&!expr->n[expr->m[f]._1].constant)
				{
					expr->insertData('R');
					compile_instruction_b(M_ASSIGN, expr->n.size()-1, a1, true);
					compile_instruction_u(expr->m[f]._0, '_', a1);
					expr->m[a1]._1=expr->n.size()-1;
				}
				else
					compile_instruction_u(expr->m[f]._0, '_', a1);
			}
		}
		else if(ub[f]=='b')//a1 ++ a2
		{
			compile_instruction_u(expr->m[f]._0, '_', a2);
			return -1;
		}//*/
		break;
/*	case M_ASSIGN:
		return compile_instruction_b(expr->m[f]._0, a1, a2);
		break;
	case M_ASSIGN_MULTIPLY:
		return compile_instruction_b(M_MULTIPLY, a1, a2);
		return compile_instruction_b(M_ASSIGN, a1, a2);
		break;
	case M_ASSIGN_DIVIDE:
		return compile_instruction_b(M_DIVIDE, a1, a2);
		return compile_instruction_b(M_ASSIGN, a1, a2);
		break;//*/
	}
//	if(expr->m[f]._0>M_FUNCTION_START&&expr->m[f]._0<M_USER_FUNCTION_START)//default function
	if(expr->m[f]._0>M_FSTART&&expr->m[f]._0<M_USER_FUNCTION)//default function
	{
		if(a1!=-1)
		{
			if(ub[f]=='b')//n	f	n
			{
				if(a3!=-1)//binary		a1	f(	a2,	a3)			//a3 is gone but commas are handled outside compile_execute, outdated?
					compile_instruction_b(expr->m[f]._0, a2, a3);
				else//unary		a1	f	a2
					compile_instruction_u(expr->m[f]._0, side, a2);
			}
			else if(side=='<')//f	n
			{
				if(a2!=-1)//binary		f(	a1,	a2)			//a2 is gone but commas are handled outside compile_execute, outdated?
					compile_instruction_b(expr->m[f]._0, a1, a2);
				else//unary		f	a1
					compile_instruction_u(expr->m[f]._0, side, a1);
			}
			else if(side=='>')//	n	f
			{
				compile_instruction_f_def(f);
				return 'd';
			}
		}
		else//f
		{
			compile_instruction_f_def(f);
			return 'd';
		}
	}//*/
/*	{
		if(a1!=-1)
		{
			if(ub[f]=='b')//n	f	n
			{
				if(a3!=-1)//binary		a1	f(	a2,	a3)
					compile_instruction_b(expr->m[f]._0, a2, a3, false, _1procVar, _2procVar);
				else//unary		a1	f	a2
					compile_instruction_u(expr->m[f]._0, side, a2, _1procVar);
			}
			else if(side=='<')//f	n
			{
				if(a2!=-1)//binary		f(	a1,	a2)
					compile_instruction_b(expr->m[f]._0, a1, a2, false, _1procVar, _2procVar);
				else//unary		f	a1
					compile_instruction_u(expr->m[f]._0, side, a1, _1procVar);
			}
			else if(side=='>')//	n	f
			{
				compile_instruction_f_def(f);
				return -1;
			}
		}
		else//f
		{
			compile_instruction_f_def(f);
			return -1;
		}
	}//*/
/*	{
		if(a1!=-1)
		{
			if(ub[f]=='b')//n	f	n
			{
				if(a3!=-1)//binary		a1	f(	a2,	a3)
					compile_instruction_b(expr->m[f]._0, a2, a3);
				else//unary		a1	f	a2
					compile_instruction_u(expr->m[f]._0, side, a2);
			}
			else if(side=='<')//f	n
			{
				if(a2!=-1)//binary		f(	a1,	a2)
					compile_instruction_b(expr->m[f]._0, a1, a2);
				else//unary		f	a1
					compile_instruction_u(expr->m[f]._0, side, a1);
			}
			else if(side=='>')//	n	f
			{
				compile_instruction_f_def(f);
				return -1;
			}
		}
		else//f
		{
			compile_instruction_f_def(f);
			return -1;
		}
	}//*/
/*	if(expr->m[f]._0>M_FSTART&&expr->m[f]._0<M_FEND)//default function
	{
		if(a1!=-1)
		{
			if(ub[f]=='b')//n	f	n
			{
				if(expr->m[f]._1)
				{
					compile_instruction_b2(expr->m[f]._0, expr->m[a2]._1, expr->m[b2]._1, 1);
					expr->m[a2]._0=M_N, expr->m[b2]._0=M_IGNORED;
				}
				else
					compile_instruction_u(expr->m[f]._0, side, a2, b2);
			}
			else if(side=='<')//f	n
			{
				if(expr->m[f]._1)
				{
					compile_instruction_b2(expr->m[f]._0, expr->m[a1]._1, expr->m[b1]._1, 1);
					expr->m[a1]._0=M_N, expr->m[b1]._0=M_IGNORED;
				}
				else
					compile_instruction_u(expr->m[f]._0, side, a1, b1);
			}
			else if(side=='>')//	n	f
			{
				compile_instruction_f_def(f);
				return -1;
			}
		}
		else//f
		{
			compile_instruction_f_def(f);
			return -1;
		}
	}//*/
//	return false;
//	return -1;
	return 0;
}

int				Compile::compile_instruction_userFunctionCall(int function, std::vector<int> const &args, bool recursiveCall)
//int				Compile::compile_instruction_userFunctionCall(int function, std::vector<int> const &args)
//void			Compile::compile_instruction_userFunctionCall(int function, std::vector<int> const &args)
//void			Compile::compile_instruction_userFunctionCall(int function, std::vector<int> const &args, int n_result)
{
	int result;
//	bool new_repositry=false;
	if(!args.size())
	{
		char mathSet='r';
		expr->insertData(mathSet);
		result=expr->n.size()-1;
	//	bool constant=expr->n[result].constant=expr->n[op].constant;
		term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm));
		term[result]=CompileTerm(true, mathSet, false);
	//	term[result]=CompileTerm(constant, mathSet, false);
	//	new_repositry=true;
	}
	else if(procedural)
	{
		bool t=true;
		for(auto &arg:args)
		{
			if(!term[arg].fresh)
			{
				result=arg;
				t=false;
				break;
			}
		}
		if(t)
		{
			char mathSet='r';
			expr->insertData(mathSet);
			result=expr->n.size()-1;
		//	bool constant=expr->n[result].constant=expr->n[op].constant;
			term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm));
			term[result]=CompileTerm(true, mathSet, false);
		//	term[result]=CompileTerm(constant, mathSet, false);
		//	new_repositry=true;
		}
	}
	else
	{
		result=args[0];
		for(int k=1, kEnd=args.size();k<kEnd;++k)
			if(result>args[k])
				result=args[k];
	}
	//	result=args[0];
	
//	char resultMathSet=userFunctionDefinitions[function].resultMathSet;
	char resultMathSet=recursiveCall?predictedMathSet:userFunctionDefinitions[function].resultMathSet;
	if(!procedural||!term[result].fresh||!term[result].constant&&term[result].mathSet>resultMathSet)//'r' > 'c'
		term[result].mathSet=resultMathSet;
//	if(!recursiveCall)
//		term[result].mathSet=userFunctionDefinitions[function].resultMathSet;//
	bool result_constant=true;
	for(const auto &arg:args)
	{
		if(!expr->n[arg].constant)
		{
			result_constant=false;
			break;
		}
	}
	Instruction in(function, args, result);
	if(result_constant)
	{
		if(recursiveCall)
		{
			expr->i.push_back(in);
			term[result].constant=false;
		}
		else
			Solve_UserFunction(*expr, in)();
	}
	else
		expr->i.push_back(in);
/*	if(result_constant)
		Solve_UserFunction(*expr, in)();
	else
		expr->i.push_back(in);//*/
/*	{
		expr->i.push_back(in);
		if(new_repositry)
			term[result].constant=false;
	}//*/
	return result;
/*	term[n_result].mathSet=userFunctionDefinitions[function].resultMathSet;
	bool compile_time=true;
	for(const auto &arg:args)
	{
		if(!expr->n[arg].constant)
		{
			compile_time=false;
			break;
		}
	}

	Instruction in(function, args, n_result);
	if(compile_time)
		Solve_UserFunction(*expr, in)();
	else
		expr->i.push_back(in);//*/
/*	if(compile_time)
	{
		Instruction in(function, args, n_result);
		Solve_UserFunction(*expr, in)();
	}
	else
		expr->i.push_back(Instruction(function, args, n_result));//*/

//	term[n_result].mathSet=userFunctionDefinitions[function].resultMathSet;
//	expr->i.push_back(Instruction(function, args, n_result));

/*	int op1=expr->m[_op1]._1, op2=expr->m[_op2]._1;
	bool resultGoesTo_op1=r_op1||op1<op2;
//	bool resultGoesTo_op1=r?2-r:op1<op2;
	using namespace G2;
	int result=resultGoesTo_op1?op1:op2;
	Value (*function)(Value const&, Value const&);
	char (*bmts)(char, char);
	DiscontinuityFunction d;
	compile_instruction_select_b(f, term[op1].mathSet, term[op2].mathSet, function, bmts, d);
	if(function)
	{
		term[result].mathSet=bmts(term[op1].mathSet, term[op2].mathSet);
		if(term[op1].constant&&term[op2].constant)
			expr->data[result]=function(expr->data[op1], expr->data[op2]), expr->n[result].mathSet=term[result].mathSet;
		//	expr->n[result].val=function(expr->n[op1].val, expr->n[op2].val), expr->n[result].mathSet=term[result].mathSet;
		else
			expr->i.push_back(Instruction(function, bmts, op1, op2, result, d)), term[result].constant=false;
	}
	expr->m[resultGoesTo_op1?_op2:_op1]._0=G2::M_IGNORED;
	return 4-resultGoesTo_op1-resultGoesTo_op1;//*/

//	expr->i.push_back(Instruction(function, args, n_result));
}
int				Compile::compile_instruction_branch_if		(int n_condition){	expr->i.push_back(Instruction('b', n_condition));	return expr->i.size()-1;}
int				Compile::compile_instruction_branch_if_not	(int n_condition){	expr->i.push_back(Instruction('B', n_condition));	return expr->i.size()-1;}
int				Compile::compile_instruction_jump			(){					expr->i.push_back(Instruction());					return expr->i.size()-1;}
int				Compile::compile_instruction_return			(int n_result){		expr->i.push_back(Instruction(n_result));			return expr->i.size()-1;}
int				Compile::compile_instruction_return			(Value const &x)
{
	expr->insertData(x.j||x.k?'H':x.i?'c':'r', x);
//	expr->insertData(x.j||x.k?'H':x.i?'C':'R', x);
	term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm));
	term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet);
	expr->i.push_back(Instruction(expr->n.size()-1));
	return expr->i.size()-1;
}
void			Compile::compile_instruction_assign			(int dst, int src){compile_instruction_b(G2::M_ASSIGN, dst, src, true);}
void			Compile::compile_instruction_assign_value	(int dst, Value const &x)
{
	expr->insertData(x.j||x.k?'H':x.i?'c':'r', x);
//	expr->insertData(x.j||x.k?'H':x.i?'C':'R', x);
	term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm));
	term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet);
	compile_instruction_b(G2::M_ASSIGN, dst, expr->n.size()-1, true);
}

void			Compile::compile_execute				(int i, int f, int v)
{
	using namespace G2;
	std::list<int> pN;
	for(bool repeat=true;repeat;)
	{
		pN.clear();
		repeat=false;
		int lastF=-1;
		bool startField=true, binaryField=true;
		for(int k=i, kPeak, peak=0;k<f;++k)
		{
			auto &S=expr->m[k]._0;
			if(S==M_N)
			{
				pN.push_back(k);
				ub[k]='b';
				if(startField)
					startField=false;
				else if(peak)
					ub[kPeak]='b';
				peak=0, binaryField=true;
			}
			else if(S)
			{
				if(binaryField&&peak<bi_mass(S))
					kPeak=k, peak=bi_mass(S);
				ub[k]='u';
			//	if(S>M_FUNCTION_START)
				if(S>M_FSTART)
				{
					lastF=k;
					binaryField=false;
				}
			}
		}
		if(!pN.size()&&lastF>-1||pN.size()&&lastF>*pN.rbegin())
			compile_instruction_f_def(lastF), pN.push_back(lastF), ub[lastF]='b', repeat=true;
	}
	if(pN.size())
	{
		for(auto it=pN.begin();;)
		{
			int lOp=-1, rOp=-1;
			for(int k=*it-1;k>=i;--k)
			{
				if(expr->m[k]._0)
				{
					lOp=k;
					break;
				}
			}
			for(int k=*it+1;k<f;++k)
			{
				if(expr->m[k]._0)
				{
					if(v!=1||prec(M_COS, 'u', expr->m[k]._0, ub[k])=='>')//v==1: lazy call last arg f,[..]..	compare right op precedence to a function
						rOp=k;
					break;
				}
			}
			char s;
				 if(lOp>=0)	{		 if(rOp>=0)	s=prec(expr->m[lOp]._0, ub[lOp], expr->m[rOp]._0, ub[rOp]);
								else			s='<';}
			else			{		 if(rOp>=0)	s='>';
								else			s='_';}
			if(s=='<')
			{
				switch(ub[lOp])
				{
				case 'u'://			- [n]
				/*	{
						int result=compile_instruction(lOp, '<', *it);
						if(result!=-1)
							*it=result;
						expr->m[lOp]._0=M_IGNORED;
					}//*/
					compile_instruction(lOp, '<', *it);
					expr->m[lOp]._0=M_IGNORED;
					continue;
				case 'b'://			n + [n]
					{
						auto itPrev=it; --itPrev;
						if(compile_instruction(lOp, '_', *itPrev, *it)=='b')//called compile_instruction_b, a2 is gone
							pN.erase(it--);
					/*	int result=compile_instruction(lOp, '_', *itPrev, *it);
						if(result!=-1)
						{
							pN.erase(it--);
							*it=result;
						}//*/
					/*	switch(compile_instruction(lOp, '_', *itPrev, *it))
						{
						case 4://result to op2
							pN.erase(itPrev);
							break;
						case 2://result to op1
							pN.erase(it--);
							break;
						}//*/
						if(lOp!=*it)
							expr->m[lOp]._0=M_IGNORED;
					}
					continue;
				}
			}
			else if(s=='>')
			{
				switch(ub[rOp])
				{
				case 'u'://			[n] !
					if(compile_instruction(rOp, '>', *it)==-1)//called compile_instruction_f_def
						ub[rOp]='b';
					else
						expr->m[rOp]._0=M_IGNORED;
					continue;
				case 'b'://			[n] + n
					++it;
					continue;
				}
			}
			else if(s=='_')
			{
				expr->m[i]=expr->m[*it];
				if(*it!=i)
					expr->m[*it]._0=M_IGNORED;
				break;
			}
		}
	}
	else
	{
		for(int k=i;k<f;++k)
			expr->m[k]._0=M_IGNORED;
		if(i==expr->m.size())
			expr->m.push_back(::Map(0, 0, M_N, expr->n.size()));
		else
			expr->m[i]=::Map(0, 0, M_N, expr->n.size());
		expr->insertData('r', Value()), term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm)), term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet);
	//	expr->m[i]=::Map(M_N, expr->n.size()), expr->insertData('R', Value()), term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm)), term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet);
	}
}
void			Compile::compile_abs					(int i, int f, int v)
{
	if(verticalBarAbs)
	{
		bool field=false, active=false;
		for(int k=i, first=-1;k<f;++k)
		{
			if(expr->m[k]._0==G2::M_VERTICAL_BAR)
			{
				if(field)
				{
					compile_execute(first+1, k, 0);
					compile_instruction(first, '<', first+1);
					expr->m[first]._0=expr->m[k]._0=G2::M_IGNORED;
				}
				else
					first=k;
				field=!field;
			}
			else if(field&&expr->m[k]._0)
				active=true;
		}
	}
	compile_execute(i, f, v);
/*	using namespace G2;
	for(int k=i, i1=-1, field1=0;k<f;++k)	//old
	{
		if(expr->m[k]._0==M_MAG)
				i1=k, field1=0;
		else if(expr->m[k]._0==M_MAG_2)
		{
			if(field1)
			{
				compile_execute(i1+1, k, 0);
				compile_instruction(i1, '<', i1+1);
			}
			expr->m[i1]._0=M_IGNORED, expr->m[k]._0=M_IGNORED;
		}
		else if(expr->m[k]._0)
			field1=1;
	}
	compile_execute(i, f, v);//*/
}
void Compile::compile_inline_if(int i, int f, int v)
//void Compile::compile_inline_if(int i, int f, int v, bool SIMD)
{
	using namespace G2;
	for(;;)
	{
		int topLevel=0, i1=-1, f1=-1;
		{
			bool top=false;
			for(int k=i, level=0;k<f;++k)
			{
				auto &S=expr->m[k]._0;
				if(S==M_QUESTION_MARK)
				{
					++level;
					if(topLevel<=+level)
						topLevel=level, i1=k, top=true;
				}
				else if(S==M_COLON)
				{
					--level;
					if(top)
						f1=k, top=false;
				}
			}
		}
		if(topLevel)
		{
			int i0=f, f2=-1;
			for(int k=i1-1;k>=i;--k)
			{
				if(expr->m[k]._0==M_QUESTION_MARK||expr->m[k]._0==M_COLON)
				{
					if(k!=i1-1)
						i0=k+1;
					break;
				}
				if(k==i)
				{
					i0=k;
					break;
				}
			}
			for(int k=f1+1, mLevel=0;k<=f;++k)
			{
				if(k==f||expr->m[k]._0==M_QUESTION_MARK||expr->m[k]._0==M_COLON)
				{
					if(k!=f1+1)
						f2=k;
					break;
				}
			}
			if(procedural)
			{
				bool expr1=false;
				for(int k=i0;k<i1;++k)
				{
					if(expr->m[k]._0)
					{
						expr1=true;
						break;
					}
				}
				if(expr1)
				{
					if(expr->n[expr->m[i0+1]._1].constant)
					{
						if(expr->data[expr->m[i0+1]._1].q_isTrue())
					//	if(expr->n[expr->m[i0+1]._1].val.q_isTrue())
						{
							for(int k=i1+1;k<f1;++k)//just expr2
							{
								if(expr->m[k]._0)
								{
									compile_abs(i1+1, f1, 0);
									break;
								}
							}
							for(int k=f1+1;k<f2;++k)
								expr->m[k]=M_IGNORED;
						}
						else
						{
							for(int k=i1+1;k<f1;++k)//just expr3
								expr->m[k]=M_IGNORED;
							for(int k=f1+1;k<f2;++k)
							{
								if(expr->m[k]._0)
								{
									compile_abs(f1+1, f2, 0);
									break;
								}
							}
						}
					}
					else
					{
						bool expr2=false, expr3=false;
						for(int k=i1+1;k<f1;++k)
						{
							if(expr->m[k]._0)
							{
								expr2=true;
								break;
							}
						}
						for(int k=f1+1;k<f2;++k)
						{
							if(expr->m[k]._0)
							{
								expr3=true;
								break;
							}
						}
						if(expr2||expr3)
						{
						/*	expr1 ? expr2 : expr3

								<expr1>
								branch condition if
								<expr3>
								assign expr3
								jump end
							if:
								<expr2>
								assign expr2
							end:
							*/
							compile_abs(i0, i1, 0);//expr1
							int i_branch=compile_instruction_branch_if(expr->m[i0]._1);
							if(expr3)
							{
								compile_abs(f1+1, f2, 0);//expr3
								compile_instruction_assign(expr->m[i0]._1, expr->m[f1+1]._1);//n[i0]=n[f1+1]
							//	compile_instruction_assign(i0, f1+1);//n[i0]=n[f1+1]
							}
							else
								compile_instruction_assign_value(expr->m[i0]._1, Value());//n[i0]=0;
							//	compile_instruction_assign_value(i0, Value());//n[i0]=0;
							int i_jump=compile_instruction_jump();
							expr->i[i_branch].op2=expr->i.size();
							if(expr2)
							{
								compile_abs(i1+1, f1, 0);//expr2
								compile_instruction_assign(expr->m[i0]._1, expr->m[i1+1]._1);//n[i0]=n[i1+1]
							//	compile_instruction_assign(i0, i1+1);//n[i0]=n[i1+1]
							}
							else
								compile_instruction_assign_value(expr->m[i0]._1, Value());//n[i0]=0;
							//	compile_instruction_assign_value(i0, Value());//n[i0]=0;
							expr->i[i_jump].op1=expr->i.size();
							expr->m[i1+1]._0=M_IGNORED, expr->m[f1+1]._0=M_IGNORED;
#if 0//branch if not
						/*	expr1 ? expr2 : expr3

								<expr1>
								branch !condition else
								<expr2>
								assign expr2
								jump end
							else:
								<expr3>
								assign expr3
							end:
							*/
							compile_abs(i0, i1, 0);//expr1
							int i_branch=compile_instruction_branch_if_not(expr->m[i0]._1);
							if(expr2)
							{
								compile_abs(i1+1, f1, 0);//expr2
								compile_instruction_assign(expr.m[i0]._1, expr.m[i1+1]._1);//n[i0]=n[i1+1]
							//	compile_instruction_assign(i0, i1+1);//n[i0]=n[i1+1]
							}
							else
								compile_instruction_assign_value(expr.m[i0]._1, Value());//n[i0]=0;
							//	compile_instruction_assign_value(i0, Value());//n[i0]=0;
							int i_jump=compile_instruction_jump();
							expr->i[i_branch].op2=expr->i.size();
							if(expr3)
							{
								compile_abs(f1+1, f2, 0);//expr3
								compile_instruction_assign(expr.m[i0]._1, expr.m[f1+1]._1);//n[i0]=n[f1+1]
							//	compile_instruction_assign(i0, f1+1);//n[i0]=n[f1+1]
							}
							else
								compile_instruction_assign_value(expr.m[i0]._1, Value());//n[i0]=0;
							//	compile_instruction_assign_value(i0, Value());//n[i0]=0;
							expr->i[i_jump].op1=expr->i.size();
							expr->m[i1+1]._0=M_IGNORED, expr->m[f1+1]._0=M_IGNORED;
#endif
						}
						else
							compile_instruction(i1, '_', -1, -1, -1);
						//	compile_instruction_assign_value(i0, Value());//
					}
				}
				else if(inline_if_default_true)//condition (expr1) is empty: default true (like for loop condition)
				{
					bool expr2=false;
					for(int k=i1+1;k<f1;++k)//just expr2
					{
						if(expr->m[k]._0)
						{
							expr2=true;
							break;
						}
					}
					if(expr2)
						compile_abs(i1+1, f1, 0);
					else
						compile_instruction(i1, '_', -1, -1, -1);
					for(int k=f1+1;k<f2;++k)
						expr->m[k]=M_IGNORED;
				}
				else//default false when condition (expr1) is empty
				{
					bool expr3=false;
					for(int k=i1+1;k<f1;++k)//just expr3
						expr->m[k]=M_IGNORED;
					for(int k=f1+1;k<f2;++k)
					{
						if(expr->m[k]._0)
						{
							expr3=true;
							break;
						}
					}
					if(expr3)
						compile_abs(f1+1, f2, 0);
					else
						compile_instruction(i1, '_', -1, -1, -1);
				}
				expr->m[i1]._0=M_IGNORED, expr->m[f1]._0=M_IGNORED;
			}
			else
			{
				int r0=-1, r1=-1, r2=-1;
				for(int k=i0;k<i1;++k)
				{
					if(expr->m[k]._0)
					{
						compile_abs(r0=i0, i1, 0);
						break;
					}
				}
				for(int k=i1+1;k<f1;++k)
				{
					if(expr->m[k]._0)
					{
						compile_abs(r1=i1+1, f1, 0);
						break;
					}
				}
				for(int k=f1+1;k<f2;++k)
				{
					if(expr->m[k]._0)
					{
						compile_abs(r2=f1+1, f2, 0);
						break;
					}
				}
				compile_instruction(i1, '_', r0, r1, r2);
				expr->m[i1]._0=M_IGNORED, expr->m[f1]._0=M_IGNORED;
			}
		}
		else
			break;
	}
	compile_abs(i, f, v);
}

void Compile::compile_assignment(int i, int f)
{
	using namespace G2;
	bool notAssignExpr=true;
	for(int k=f-1;k>=i;--k)
	{
		auto &S=expr->m[k]._0;
		if(S>M_PROCEDURAL_ASSIGN_START&&S<M_PROCEDURAL_ASSIGN_END)
		{
			compile_inline_if(k+1, f, 0);
		//	compile_inline_if(k+1, f, 0, false);
			int lastA=k;
			for(int k2=k-1;k2>=i;--k2)
			{
				auto &S2=expr->m[k2]._0;
				if(S2>M_PROCEDURAL_ASSIGN_START&&S2<M_PROCEDURAL_ASSIGN_END)
				{
					compile_inline_if(k2+1, lastA, 0);
				//	compile_inline_if(k2+1, lastA, 0, false);
					compile_instruction(k2, '_', k2+1, lastA+1);
					S2=M_IGNORED;
					lastA=k2;
				}
			}
			compile_inline_if(i, lastA, 0);
		//	compile_inline_if(i, lastA, 0, false);
			compile_instruction(k, '_', i, lastA+1);
			S=M_IGNORED;
			notAssignExpr=false;
			break;
		}
	}
	if(notAssignExpr)
		compile_inline_if(i, f, 0);
	//	compile_inline_if(i, f, 0, false);
}
void Compile::compile_expression_local(int _i, int _f)
{
	using namespace G2;
	for(;;)
	{
		int topLevel=0, i=-1, f=-1;
		{
			bool peak=false;
			for(int k=_i, level=0;k<_f;++k)
		//	for(int k=0, kEnd=expr->m.size(), level=0;k<kEnd;++k)
			{
				if(expr->m[k]._0==M_LPR)
				{
					++level;
					if(level>=topLevel)
						topLevel=level, i=k+1, peak=true;
				}
				else if(expr->m[k]._0==M_RPR)
				{
					--level;
					if(peak)
						f=k, peak=false;
				}
			}
		}
			 if(i==-1)	i=_i;//0;
		else			expr->m[i-1]._0=M_IGNORED;
			 if(f==-1)	f=_f;//expr->m.size();
		else			expr->m[f  ]._0=M_IGNORED;
	//	if(topLevel>0&&i-2>=0&&expr->m[i-2]._0>M_FUNCTION_START)
		if(topLevel>0&&i-2>=0&&expr->m[i-2]._0>M_FSTART)//call level
		{
			auto &S=expr->m[i-2]._0;
			std::vector<int> commas;
			bool notVoidCall=false;
			for(int k=i;k<f;++k)
			{
				auto &S2=expr->m[k]._0;
				if(S2==M_COMMA)
					commas.push_back(k);
				notVoidCall|=S2!=M_IGNORED;
			}
			int exprNArgs=commas.size()+notVoidCall;
		//	if(S<M_USER_FUNCTION_START)
			if(S<M_USER_FUNCTION)//default function call level
			{
				int signature=default_overload(S);
				if(signature&(1<<exprNArgs))//default overload match
				{
					int start=i;
					for(int k=0, kEnd=commas.size();k<kEnd;++k)
					{
						expr->m[commas[k]]._0=M_IGNORED;
						compile_assignment(start, commas[k]);
						start=commas[k]+1;
					}
					compile_assignment(start, f);
					compile_instruction(i-2, '<', i);
					S=M_IGNORED;
				}
				else//syntax error, no such overload
				{
					if(exprNArgs>signature)//too many args: highlight unexpected args
						expr->insertSyntaxError(expr->m[commas[signature>0x3]].pos, expr->m[f].pos);
					else//highlight arglist contents
						expr->insertSyntaxError(expr->m[i].pos, expr->m[f].pos);
					expr->i.clear();
					expr->valid=false;
					return;
				}
			}
			else//user function call level
			{
				int name_id=expr->m[i-2]._1, d_match=-1;
				for(int d=0, dEnd=userFunctionDefinitions.size();d<dEnd&&expr->lineNo>=userFunctionDefinitions[d].lineNo;++d)
			//	for(int d=0, dEnd=userFunctionDefinitions.size();d<dEnd&&expr->lineNo>userFunctionDefinitions[d].lineNo;++d)//linearly through all user definitions		sorted by lineNo
				{
					auto &definition=userFunctionDefinitions[d];
					if(definition.valid&&definition.valid&&name_id==definition.name_id&&exprNArgs==definition.nArgs)//find overload instance
						d_match=d;
				}
				if(d_match!=-1)
				{
					std::vector<int> args(commas.size()+notVoidCall);
					if(notVoidCall)//compile args
					{
						int start=i;
						for(int k3=0, k3End=exprNArgs-1;k3<k3End;++k3)
						{
							expr->m[commas[k3]]._0=M_IGNORED;//before compile in case start==commas[k3]
							compile_assignment(start, commas[k3]);
							args[k3]=expr->m[start]._1, expr->m[start]._0=M_IGNORED;
							start=commas[k3]+1;
						}
						compile_assignment(start, f);
						args[exprNArgs-1]=expr->m[start]._1, expr->m[start]._0=M_IGNORED;
					}
					bool recursiveCall=&userFunctionDefinitions[d_match]==expr;
					recursiveFunction|=recursiveCall;
					int result=compile_instruction_userFunctionCall(d_match, args, recursiveCall);
				//	int result=compile_instruction_userFunctionCall(d_match, args, &userFunctionDefinitions[d_match]==expr);
					S=M_N, expr->m[i-2]._1=result;
				/*	std::vector<int> args(commas.size()+notVoidCall);
					if(notVoidCall)//compile args
					{
						int start=i;
						for(int k3=0, k3End=exprNArgs-1;k3<k3End;++k3)
						{
							expr->m[commas[k3]]._0=M_IGNORED;//before compile in case start==commas[k3]
							compile_assignment(start, commas[k3]);
							args[k3]=expr->m[start]._1;
							start=commas[k3]+1;
						}
						compile_assignment(start, f);
						args[exprNArgs-1]=expr->m[start]._1;
						int start=i;
						//args[0]=expr->m[start]._1;
						//for(int k3=0, k3End=exprNArgs-1;k3<k3End;++k3)
						//{
						//	expr->m[commas[k3]]._0=M_IGNORED;
						//	compile_assignment(start, commas[k3]);
						//	start=commas[k3]+1;
						//	args[k3+1]=expr->m[start]._1;
						//}
						//compile_assignment(start, f);
					}
					int result=compile_instruction_userFunctionCall(d_match, args);
				//	compile_instruction_userFunctionCall(d_match, args, expr->m[i]._1);
					if(notVoidCall)
						S=M_IGNORED;
					else
						S=M_N, expr->m[i-2]._1=result;//*/
				/*	{//compile args
						int start=i;
						for(int k3=0, k3End=exprNArgs-1;k3<k3End;++k3)
						{
							compile_assignment(start, commas[k3]);
							start=commas[k3]+1;
							expr->m[commas[k3]]._0=M_IGNORED;
						}
						compile_assignment(start, f);
					}
					std::vector<int> args(commas.size()+notVoidCall);
					args[0]=expr->m[i]._1;
					for(int k3=0, k3End=commas.size();k3<k3End;++k3)
						args[k3+1]=expr->m[commas[k3]+1]._1;
				//	args[0]=i;
				//	for(int k3=0, k3End=commas.size();k3<k3End;++k3)
				//		args[k3+1]=commas[k3]+1;
					compile_instruction_userFunctionCall(d_match, args);
				//	compile_instruction_userFunctionCall(d_match, args, expr->m[i]._1);
				//	compile_instruction_userFunctionCall(d_match, args, i);
					S=M_IGNORED;//*/
				}
				else//syntax error, no such overload
				{
					expr->insertSyntaxError(expr->m[i].pos, expr->m[f].pos);//arglist
				//	expr->insertSyntaxError(expr->m[k]._1);//mark the error		function call level: highlight id, parentheses and arglist
					expr->i.clear();
					expr->valid=false;
					return;
				}
			}
		}
		else//not a call level
		{
			int start=i;
			for(int k=i;k<f;++k)
			{
				if(expr->m[k]._0==M_COMMA)
				{
					compile_assignment(start, k);
					expr->m[start]._0=M_IGNORED, expr->m[k]._0=M_IGNORED;
					start=k+1;
				}
			}
			compile_assignment(start, f);
			if(start!=i)
				expr->m[i]=expr->m[start], expr->m[start]._0=M_IGNORED;
		}
	/*	if(topLevel>0)
		{
			if(expr.m[i-2]._0>M_FSTART&&expr.m[i-2]._0<M_FEND)
			{
				std::vector<int> commas;
				for(int k=i;k<f;++k)
					if(expr.m[k]._0==M_COMMA)
						commas.push_back(k);
				if(commas.size())
				{
					compile_assignment(i, commas[0]);
					for(int k=0, kEnd=commas.size()-1;k<kEnd;++k)
						compile_assignment(commas[k]+1, commas[k+1]);
					compile_assignment(*commas.rbegin()+1, f);
				}
				else
					compile_assignment(i, f);
				compile_instruction(i-2, '<', i);
			}
			else
			{
				//not function call: mark commas as syntax error & ignore the commas ?
				compile_assignment(i, f);
			}
		}
		else//ground level	no lazy calls inside function definition
			compile_assignment(i, f);//*/
		if(topLevel==0)
			break;
	}
}
bool Compile::compile_exprStatement(int &k, int mEnd)
//void Compile::compile_exprStatement(int &k, int mEnd)
{
	for(int k2=k;k2<mEnd;++k2)
	{
		auto &S=expr->m[k2]._0;
		if(S==G2::M_SEMICOLON)
		{
			compile_expression_local(k, k2);
			S=G2::M_IGNORED;//in case k==k2 & execute leaves a link: semicolon statements are expendable
			k=k2;
			return true;
		//	break;
		}
		else if(S>G2::M_PROCEDURAL_START&&S<G2::M_PROCEDURAL_ASSIGN_START)
	//	else if(S>G2::M_PROCEDURAL_START&&S<G2::M_PROCEDURAL_END)//X expression_local calls compile_assignments
		{
			//syntax error
			auto &S2=expr->m[k2-(k<k2-1)];
			expr->insertSyntaxError(expr->m[k].pos, S2.pos+S2.len);
			k=k2-1;
			break;
		}
	}
	return false;
}
bool Compile::comp_seek_allowNewline(int &k, int mEnd, int S)
{
	for(int k2=k;k2<mEnd;++k2)
	{
		auto &S2=expr->m[k2]._0;
		if(S2==S)
		{
			k=k2;
			return true;
		}
		if(S2!=G2::M_IGNORED)
			return false;
	}
	return false;
}
bool Compile::comp_seek_condition(int &k, int mEnd, int &conditionStart, int &conditionEnd)
{
	using namespace G2;
	int k2=k;
	if(comp_seek_allowNewline(k2, mEnd, M_LPR))
	{
		conditionStart=++k2;
		for(int level=1;k2<mEnd;++k2)//profile condition
		{
			auto &S=expr->m[k2]._0;
			if(S==M_LPR)
				++level;
			else if(S==M_RPR)
			{
				--level;
				if(!level)
				{
					conditionEnd=k2;
					k=k2;
					return true;
				}
			}
			else if(S==M_SEMICOLON)
				return false;
		}
	}
	return false;
}
bool Compile::comp_seek_forHeader(int &k, int mEnd, int &headerStart, int &sc1, int &sc2, int &headerEnd)
{
	using namespace G2;
	int k2=k;
	if(comp_seek_allowNewline(k2, mEnd, M_LPR))
	{
		headerStart=++k2;
		for(int level=1, nSemicolons=0;k2<mEnd;++k2)
		{
			auto &S=expr->m[k2]._0;
			if(S==M_LPR)
				++level;
			else if(S==M_RPR)
			{
				--level;
				if(!level)
				{
					if(nSemicolons==2)
					{
						k=headerEnd=k2;
						return true;
					}
					return false;
				}
			}
			else if(S==M_SEMICOLON)
			{
				if(level==1)
				{
					++nSemicolons;
					if(nSemicolons==1)
						sc1=k2;
					else
						sc2=k2;
				}
				else return false;
			}
		}
	}
	return false;
}
bool Compile::comp_seek_block(int &k, int mEnd, int &blockStart, int &blockEnd)
{
	using namespace G2;
	if(comp_seek_allowNewline(k, mEnd, M_LBRACE))
	{
		blockStart=k+1;
		for(int k2=blockStart, level=1;k2<mEnd;++k2)//profile block
		{
			auto &S=expr->m[k2]._0;
			if(S==M_LBRACE)
				++level;
			else if(S==M_RBRACE)
			{
				--level;
				if(!level)
				{
					k=blockEnd=k2;
					return true;
				}
			}
		}
	}
	return false;
}
/*struct CompileBlockInfo
{
	int k;
	int mStart, mEnd;
	CompileBlockInfo(int k, int mStart, int mEnd):k(k), mStart(mStart), mEnd(mEnd){}
};//*/
std::stack<std::pair<int, std::vector<int>>> Compile::loopInfo;
//std::stack<int> Compile::loopStart, Compile::loopEnd;
//int Compile::n_lastResult;
//std::stack<int> loopStart, loopEnd;
//int n_lastResult;
void Compile::compile_statement(int &k, int mEnd)
{
	using namespace G2;
	switch(expr->m[k]._0)
	{
	case M_IF:
		{
			int k2=k+1;
			int conditionStart, conditionEnd;
			if(comp_seek_condition(k2, mEnd, conditionStart, conditionEnd))
			{
			/*	<condition>
				branch !condition end
				<if body>
			end:

				<condition>
				branch !condition else
				<if body>
				jump end
			else:
				<else body>
			end:
				*/
				compile_expression_local(conditionStart, conditionEnd);//<condition>
				int n_condition=expr->m[conditionStart]._1;
			//	int n_condition;
			//	compile_expression_local(n_condition=conditionStart, conditionEnd);	//n_condition: op1, i_branch: result	if(ex.n[ex.i[i].op1].ndr[v].r_isTrue())i=ex.i[i].result;

				int i_branch=compile_instruction_branch_if_not(n_condition);
				{
					int blockStart=0, blockEnd=0;
					k2=conditionEnd+1;
					if(comp_seek_block(k2, mEnd, blockStart, blockEnd))//<if body>
					{
						compile_block(blockStart, blockEnd);						//double recursive for now
						expr->m[blockStart-1]._0=M_IGNORED, expr->m[blockEnd]._0=M_IGNORED;
					}
					else
						compile_statement(k2, mEnd);
					//	compile_exprStatement(start, mEnd);
				}
				if(comp_seek_allowNewline(k2, mEnd, M_ELSE))
				{
					int i_jump=compile_instruction_jump();
					expr->i[i_branch].result=expr->i.size();//branch to else
				//	expr->i[i_branch].op2=expr->i.size();
					++k2;
					compile_statement(k2, mEnd);//<else body> statement						//recursive for now
					expr->i[i_jump].result=expr->i.size();//jump to end
				//	expr->i[i_jump].op2=expr->i.size();
				}
				else
					expr->i[i_branch].result=expr->i.size();//branch to end
				//	expr->i[i_branch].op2=expr->i.size();
				k=k2;
			}
			else//syntax error: expected condition
				expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+2);
		}
		break;
	case M_FOR:
		{
			int k2=k+1;
			int headerStart, sc1, sc2, headerEnd;
			if(comp_seek_forHeader(k2, mEnd, headerStart, sc1, sc2, headerEnd))
			{
			/*		<start>
					jump condition
				loop:
					<body>
					<increment>
				condition:
					<condition>
					branch condition loop
				*/
			/*		<start>						//empty condition
				loop:
					<body>
					<increment>
					jump loop
				*/
				compile_expression_local(headerStart, sc1);//<start>
				bool conditionNotEmpty=sc1+1<sc2;
				int i_jump=-1;
				if(conditionNotEmpty)
					i_jump=compile_instruction_jump();
			//	int i_jump=compile_instruction_jump();//jump to condition below		//i_jump: result		i=expr->i[i].result;		//i_jump: op1		i=expr->i[i].op1;
				int i_loop=expr->i.size();
				loopInfo.push(std::pair<int, std::vector<int>>(i_loop, std::vector<int>()));
				{
					int blockStart=0, blockEnd=0;
					k2=headerEnd+1;
					if(comp_seek_block(k2, mEnd, blockStart, blockEnd))//<body>
						compile_block(blockStart, blockEnd);					//double recursive for now
					else
						compile_statement(k2, mEnd);
					//	compile_exprStatement(start, mEnd);
				}
				compile_expression_local(sc2+1, headerEnd);//<increment>
				if(conditionNotEmpty)
				{
					expr->i[i_jump].result=expr->i.size();
				//	expr->i[i_jump].op1=expr->i.size();
					compile_expression_local(sc1+1, sc2);//<condition>
					int n_condition=expr->m[sc1+1]._1;
				//	int n_condition;
				//	compile_expression_local(n_condition=sc1+1, sc2);

					int i_branch=compile_instruction_branch_if(n_condition);
					expr->i[i_branch].result=i_loop;
				//	expr->i[i_branch].op2=i_loop;
				}
				else
				{
					i_jump=compile_instruction_jump();
					expr->i[i_jump].result=i_loop;
				}
				int end=expr->i.size();
				for(auto const&i_break:loopInfo.top().second)
					expr->i[i_break].result=end;
				loopInfo.pop();
				k=k2;
			}
			else//expected for header
				expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+3);
		}
		break;
	case M_WHILE:
		{
			int k2=k+1;
			int conditionStart, conditionEnd;
			if(comp_seek_condition(k2, mEnd, conditionStart, conditionEnd))
			{
			/*		jump condition
				loop:
					<body>
				condition:
					<condition>
					branch condition loop
				*/
			/*	loop:							//empty condition (syntax error in c/c++)
					<body>
					jump loop
				*/
				bool conditionNotEmpty=conditionStart<conditionEnd;
				int i_jump=-1;
				if(conditionNotEmpty)
					i_jump=compile_instruction_jump();
			//	int i_jump=compile_instruction_jump();
				int i_loop=expr->i.size();
				loopInfo.push(std::pair<int, std::vector<int>>(i_loop, std::vector<int>()));
				{
					int blockStart=0, blockEnd=0;
					k2=conditionEnd+1;
					if(comp_seek_block(k2, mEnd, blockStart, blockEnd))//<body>
						compile_block(blockStart, blockEnd);						//double recursive for now
					else
						compile_statement(k2, mEnd);
					//	compile_exprStatement(conditionEnd, mEnd);
				}
				if(conditionNotEmpty)
					expr->i[i_jump].result=expr->i.size();
			//	expr->i[i_jump].op1=expr->i.size();
				
				if(conditionNotEmpty)
				{
					compile_expression_local(conditionStart, conditionEnd);//<condition>
					int n_condition=expr->m[conditionStart]._1;
				//	int n_condition;
				//	compile_expression_local(n_condition=conditionStart, conditionEnd);

					int i_branch=compile_instruction_branch_if(n_condition);
					expr->i[i_branch].result=i_loop;
				//	expr->i[i_branch].op2=i_loop;
				}
				else
				{
					i_jump=compile_instruction_jump();
					expr->i[i_jump].result=i_loop;
				}
				int end=expr->i.size();
				for(auto const&i_break:loopInfo.top().second)
					expr->i[i_break].result=end;
				loopInfo.pop();
				k=k2;
			}
			else//expected condition
				expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+5);
		}
		break;
	case M_DO:
		{
			int k2=k+1;
			int blockStart=0, blockEnd=0;
			bool block=comp_seek_block(k2, mEnd, blockStart, blockEnd);
			if(block)
				expr->m[blockStart-1]._0=M_IGNORED, expr->m[blockEnd]._0=M_IGNORED;
			if(comp_seek_allowNewline(k2, mEnd, M_WHILE))
			{
				int conditionStart, conditionEnd;
				++k2;
				if(comp_seek_condition(k2, mEnd, conditionStart, conditionEnd))
				{
				/*	loop:
						<body>
						<condition>
						branch condition loop
					*/
				/*	loop:							//empty condition (syntax error in c/c++)
						<body>
						jump loop
					*/
					int i_loop=expr->i.size();
					loopInfo.push(std::pair<int, std::vector<int>>(i_loop, std::vector<int>()));
					if(block)//<body>
						compile_block(blockStart, blockEnd);				//double recursive for now
					else
					{
						k2=conditionEnd+1;
						compile_statement(k2, mEnd);
					//	compile_exprStatement(conditionEnd, mEnd);
					}
					
					bool conditionNotEmpty=conditionStart<conditionEnd;
					if(conditionNotEmpty)
					{
						compile_expression_local(conditionStart, conditionEnd);//<conditions>
						int n_condition=expr->m[conditionStart]._1;
					//	int n_condition;
					//	compile_expression_local(n_condition=conditionStart, conditionEnd);

						int i_branch=compile_instruction_branch_if(n_condition);
						expr->i[i_branch].result=i_loop;
					//	expr->i[i_branch].op2=i_loop;
					}
					else
					{
						int i_jump=compile_instruction_jump();
						expr->i[i_jump].result=i_loop;
					}
					int end=expr->i.size();
					for(auto const&i_break:loopInfo.top().second)
						expr->i[i_break].result=end;
					k=k2;
				}
				else//expected condition
					expr->insertSyntaxError(expr->m[k].pos, expr->m[k2].pos+5);
			}
			else//expected do
				expr->insertSyntaxError(expr->m[k].pos, expr->m[blockEnd].pos);
		}
		break;
	case M_LBRACE:
		{
		//	int k2=k+1;//X comp_seek_block: seek '{' (in this case: again) then close with '}'
			int k2=k;
			int blockStart=0, blockEnd=0;
			if(comp_seek_block(k2, mEnd, blockStart, blockEnd))
			{
				compile_block(blockStart, blockEnd);				//double recursive for now
				k=k2;
			}
			else//unmatched brace, unreachable
				expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+1);
		}
		break;
	case M_CONTINUE:
		if(loopInfo.size())
		{
			int i_jump=compile_instruction_jump();
			expr->i[i_jump]=loopInfo.top().first;
		}
		else//continue not expected here
			expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+8);
	/*	if(loopStart.size())
		{
			int i_jump=compile_instruction_jump();
			expr->i[i_jump]=loopStart.top();
		}
		else//continue not expected here
			expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+8);//*/
		break;
	case M_BREAK:
		if(loopInfo.size())
		{
			int i_jump=compile_instruction_jump();
			loopInfo.top().second.push_back(i_jump);
		}
		else//break not expected here
			expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+5);
	/*	if(loopStart.size())
		{
			int i_jump=compile_instruction_jump();
			loopEnd.push(i_jump);//when loop is compiled	if(loopEnd.size())expr->i[loopEnd.top()].op1=expr->i.size(), loopEnd.pop();
		}
		else//break not expected here
			expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+5);//*/
		break;
	case M_RETURN:
		if(k+1<mEnd&&expr->m[k+1]._0==M_SEMICOLON)//return;		default return 0;
			compile_instruction_return(Value());
		else
		{
			int k2=k+1;
			if(compile_exprStatement(k2, mEnd))
			{
				compile_instruction_return(expr->m[k+1]._1);
				char mathSet=term[expr->m[k+1]._1].mathSet;
			//	char mathSet=expr->n[expr->m[k+1]._1].mathSet;//X not updated
				if(predictedMathSet>mathSet)
					expr->resultMathSet=predictedMathSet=mathSet;
			}//else syntax error: marked & ignored
			k=k2;

		//	++k;
		//	compile_exprStatement(k, mEnd);
		//	compile_instruction_return(k);
		}
		break;
	default:
	/*	{
			int start=k;
			compile_exprStatement(k, mEnd);
			n_lastResult=expr->m[start]._1;//when function is done compiling
		}//*/
		compile_exprStatement(k, mEnd);
	//	n_lastResult=k;//X
		break;
	}
}
void Compile::compile_block(int mStart, int mEnd)
{
//	std::stack<CompileBlockInfo> s;
	for(int k=mStart;k<mEnd;++k)
		compile_statement(k, mEnd);
}
void Compile::compile_function(Expression &expr)
{
	procedural=true, recursiveFunction=false;
//	expr.resultMathSet=predictedMathSet='r';
	predictedMathSet='r';
	Compile::expr=&expr;
	if(expr.m.size())
	{
		ub=new char[expr.m.size()];
		memset(ub, 0, expr.m.size()*sizeof(char));
	}
	else
		ub=nullptr;
	if(expr.n.size())
	{
		term=(CompileTerm*)malloc(expr.n.size()*sizeof(CompileTerm));
		for(unsigned n=0;n<expr.n.size();++n)
		{
			auto &t=expr.n[n];
			term[n]=CompileTerm(t.constant, t.mathSet);
		}
	}
	else
		term=nullptr;


	auto map=expr.m;
	int dataSize=expr.n.size();
	int f=expr.m.size()-1;
	compile_block(1, f);
	if(recursiveFunction&&predictedMathSet<'r')//'r' > 'c'
	{
		expr.m=map;
		delete[] ub;
		if(expr.m.size())
		{
			ub=new char[expr.m.size()];
			memset(ub, 0, expr.m.size()*sizeof(char));
		}
		else
			ub=nullptr;
		expr.n.resize(dataSize), expr.data.resize(dataSize);
		if(dataSize)
		{
			term=(CompileTerm*)realloc(term, dataSize*sizeof(CompileTerm));
			for(unsigned n=0;n<expr.n.size();++n)
			{
				auto &t=expr.n[n];
				term[n]=CompileTerm(t.constant, t.mathSet);
			}
		}
		else
			term=nullptr;
		expr.i.clear();
		compile_block(1, f);
	}
//	compile_block(1, expr.m.size()-1);

//	compile_block(0, expr.m.size());
//	int k=0;
//	compile_statement(k, expr.m.size());

	delete[] ub;

	if(expr.i.size())
	{
		bool noBranches=true;
		for(auto &in:expr.i)
		{
			if(in.type>3&&in.type!='c')
			{
				noBranches=false;
				break;
			}
		}
		if(noBranches)//last instruction affects predictedMathType
		{
			auto &lastInstr=*expr.i.rbegin();
			if(lastInstr.type<4)
			{
				char mathSet=term[lastInstr.result].mathSet;
				if(predictedMathSet>mathSet)
				//	expr.resultMathSet=predictedMathSet=mathSet;
					predictedMathSet=mathSet;
			}
			else if(lastInstr.type=='c')
			{
				auto &definition=userFunctionDefinitions[lastInstr.op1];
				if(&definition!=&expr)//not a recursive call
				{
					char mathSet=definition.resultMathSet;
					if(predictedMathSet>mathSet)
					//	expr.resultMathSet=predictedMathSet=mathSet;
						predictedMathSet=mathSet;
				}
			}//'r' handled in compile_statement
		}
	}
	else
		compile_instruction_return(Value());
/*	if(expr.i.size())
	{
		auto &lastInstr=*expr.i.rbegin();
		if(lastInstr.type<4)//unary binary ternary
		{
			char mathSet=term[lastInstr.result].mathSet;
			if(predictedMathSet>mathSet)
				predictedMathSet=mathSet;
		}
		else if(lastInstr.type=='c')//call
		{
			auto &definition=userFunctionDefinitions[lastInstr.op1];
			if(&definition!=&expr)//not a recursive call
			{
				char mathSet=definition.resultMathSet;
				if(predictedMathSet>mathSet)
					predictedMathSet=mathSet;
			}
		}//'r' in compile_statement			j b B ?
	}
	else
		predictedMathSet='r';//*/
//	if(expr.n.size())//
//		predictedMathSet=term[0].mathSet;//

	free(term);
}

int				Compile::expressionResultLogicType()
{
	using namespace G2;
//	if(expr->lastInstruction>M_FUNCTION_START)																return 0;
	if(expr->lastInstruction>M_FSTART)																		return 0;
	switch(expr->lastInstruction)
	{
	case M_FACTORIAL_LOGIC_NOT:	case M_BITWISE_NOT:															return 0;
	case M_PLUS:				case M_MINUS:																return 0;
	case M_BITWISE_AND:			case M_BITWISE_NAND:														return 0;
	case M_BITWISE_XOR:			case M_BITWISE_XNOR:														return 0;
	case M_VERTICAL_BAR:		case M_BITWISE_NOR:															return 0;
	case M_MULTIPLY:			case M_DIVIDE:case M_MODULO_PERCENT:case M_LOGIC_DIVIDES:					return 0;
	case M_BITWISE_SHIFT_LEFT:	case M_BITWISE_SHIFT_RIGHT:													return 0;
	case M_POWER:																							return 0;
	case M_TETRATE:																							return 0;
	case M_PENTATE:																							return 0;
	case M_LOGIC_LESS:			case M_LOGIC_LESS_EQUAL:case M_LOGIC_GREATER:case M_LOGIC_GREATER_EQUAL:	return 1;
	case M_LOGIC_EQUAL:																						return 2;
	case M_LOGIC_NOT_EQUAL:																					return 3;
	case M_LOGIC_AND:																						return 1;
	case M_LOGIC_XOR:																						return 1;
	case M_LOGIC_OR:																						return 1;
	case M_LOGIC_CONDITION_ZERO:																			return 0;
	case M_S_EQUAL_ASSIGN:																					return 2;
	case M_S_NOT_EQUAL:																						return 3;
	case M_S_LESS:case M_S_LESS_EQUAL:case M_S_GREATER:case M_S_GREATER_EQUAL:								return 1;
	}
																											return 0;//
}
int Compile::default_overload(int S)//each bit marks correponding overload
{
	using namespace G2;
	if(S>M_FSTART&&S<M_BFSTART)//unary function
		return 0x02;//B0010		only 1 arg overload (no 0 arg overload)
	if(S<M_USER_FUNCTION)
		return 0x06;//B0110		1 arg & 2 arg overloads
/*	switch(S)
	{
	case M_COS:case M_ACOS:case M_COSH:case M_ACOSH:case M_COSC:
	case M_SEC:case M_ASEC:case M_SECH:case M_ASECH:
	case M_SIN:case M_ASIN:case M_SINH:case M_ASINH:case M_SINC:case M_SINHC:
	case M_CSC:case M_ACSC:case M_CSCH:case M_ACSCH:
	case M_TAN:			   case M_TANH:case M_ATANH:case M_TANC:
	case M_COT:case M_ACOT:case M_COTH:case M_ACOTH:
	case M_EXP:case M_LN:case M_SQRT:case M_CBRT:case M_INVSQRT:
	case M_GAUSS:case M_ERF:case M_FIB:case M_ZETA:
	case M_STEP:case M_SGN:case M_RECT:case M_TENT:
	case M_CEIL:case M_FLOOR:case M_ROUND:
	case M_ABS:case M_ARG:case M_REAL:case M_IMAG:case M_CONJUGATE:case M_POLAR:case M_CARTESIAN:
		return 0x02;//B0010		only 1 arg overload (no 0 arg overload)

	case M_RAND:
	case M_ATAN:
	case M_LOG:
	case M_BETA:case M_GAMMA:case M_PERMUTATION:case M_COMBINATION:
	case M_BESSEL:case M_NEUMANN:case M_HANKEL1:
	case M_SQWV:case M_TRWV:case M_SAW:case M_MIN:case M_MAX:
		return 0x06;//B0110		1 arg & 2 arg overloads
	}//*/
	return 0;
}
void Compile::compile_expression_global(Expression &expr)
{
	using namespace G2;
	procedural=false;//, recursiveFunction=false;
	Compile::expr=&expr;
	if(expr.m.size())
	{
		ub=new char[expr.m.size()];
		memset(ub, 0, expr.m.size()*sizeof(char));
	}
	else
		ub=0;
	if(expr.n.size())
	{
		term=(CompileTerm*)malloc(expr.n.size()*sizeof(CompileTerm));
		for(unsigned n=0;n<expr.n.size();++n)
		{
			auto &t=expr.n[n];
			term[n]=CompileTerm(t.constant, t.mathSet);
		}
	}
	else
		term=0;
	for(;;)
	{
		int topLevel=0, i=-1, f=-1;
		{
			bool peak=false;
			for(int k=0, kEnd=expr.m.size(), level=0;k<kEnd;++k)
			{
				if(expr.m[k]._0==M_LPR)
				{
					++level;
					if(level>=topLevel)
						topLevel=level, i=k+1, peak=true;
				}
				else if(expr.m[k]._0==M_RPR)
				{
					--level;
					if(peak)
						f=k, peak=false;
				}
			}
		}
			 if(i==-1)	i=0;
		else			expr.m[i-1]._0=M_IGNORED;
			 if(f==-1)	f=expr.m.size();
		else			expr.m[f  ]._0=M_IGNORED;
	//	bool callLevel=topLevel>0&&i-2>=0&&expr.m[i-2]._0>M_FUNCTION_START;
		bool callLevel=topLevel>0&&i-2>=0&&expr.m[i-2]._0>M_FSTART;
		for(int k=i;k<f;++k)//parse lazy calls
		{
			auto &S=expr.m[k]._0;				//sys 20150525 overloads and redefinitions
		//	if(S>M_USER_FUNCTION_START)
			if(S==M_USER_FUNCTION)//user function lazy call
			{
				std::vector<int> commas;
				int k2=k+1;
			//	for(;k2<f&&expr.m[k2]._0<M_FUNCTION_START;++k2)
				for(;k2<f&&expr.m[k2]._0<M_FSTART;++k2)
					if(expr.m[k2]._0==M_COMMA)
						commas.push_back(k2);
				if(commas.size())//lazy call
				{
					int name_id=expr.m[k]._1, d_match=-1, exprNArgs=commas.size()+1;
					for(int d=0, dEnd=userFunctionDefinitions.size(), max_nArgs=-1;d<dEnd&&expr.lineNo>userFunctionDefinitions[d].lineNo;++d)//linearly through all user definitions
					{
						auto &definition=userFunctionDefinitions[d];
						if(definition.valid&&name_id==definition.name_id&&exprNArgs>=definition.nArgs&&max_nArgs<=definition.nArgs)
							d_match=d, max_nArgs=definition.nArgs;
					}
					if(d_match!=-1&&(!callLevel||exprNArgs==userFunctionDefinitions[d_match].nArgs))
				//	if(d_match!=-1)
					{
						std::vector<int> args(commas.size()+1);
						{
							int start=k;
							for(int k3=0, k3End=exprNArgs-1;k3<k3End;++k3)
							{
								expr.m[commas[k3]]._0=M_IGNORED;
								compile_assignment(start, commas[k3]);
								args[k3]=expr.m[start]._1, expr.m[start]._0=M_IGNORED;
								start=commas[k3]+1;
							}
							compile_assignment(start, f);
							args[exprNArgs-1]=expr.m[start]._1, expr.m[start]._0=M_IGNORED;
						}
						int result=compile_instruction_userFunctionCall(d_match, args);
						S=M_N, expr.m[k]._1=result;
					/*	std::vector<int> args(commas.size()+1);
						{
							int start=k;
							for(int k3=0, k3End=exprNArgs-1;k3<k3End;++k3)
							{
								expr.m[commas[k3]]._0=M_IGNORED;
								compile_assignment(start, commas[k3]);
								args[k3]=expr.m[start]._1;
								start=commas[k3]+1;
							}
							compile_assignment(start, f);
							args[exprNArgs-1]=expr.m[start]._1;
						}
						compile_instruction_userFunctionCall(d_match, args);
						S=M_IGNORED;//*/
					/*	{//compile args
							int start=k;
							for(int k3=0, k3End=commas.size();k3<k3End;++k3)
							{
								compile_inline_if(start+1, commas[k3], 0);
							//	compile_inline_if(start+1, commas[k3], 0, true);
								start=commas[k3];
								expr.m[commas[k3]]._0=M_IGNORED;
							}
							compile_inline_if(start+1, f, 3);//3: compile last arg
						//	compile_inline_if(start, f, 3, true);
						}
						std::vector<int> args(commas.size()+1);
						args[0]=expr.m[i]._1;
						for(int k3=0, k3End=commas.size();k3<k3End;++k3)
							args[k3+1]=expr.m[commas[k3]+1]._1;
					//	args[0]=i;
					//	for(int k3=0, k3End=commas.size();k3<k3End;++k3)
					//		args[k3+1]=commas[k3]+1;
						compile_instruction_userFunctionCall(d_match, args);
					//	compile_instruction_userFunctionCall(d_match, args, expr.m[i]._1);
					//	compile_instruction_userFunctionCall(d_match, args, i);
						S=G2::M_IGNORED;//*/
					}
					else//syntax error, no such overload
					{
						expr.insertSyntaxError(expr.m[k].pos, expr.m[*commas.rbegin()].pos+1);//function id and 'arglist'
				//		expr.insertSyntaxError(expr.m[k].pos, expr.m[k].len);//mark the error		lazy call mismatch: highlight function id
				//	//	expr.insertSyntaxError(expr.m[k]._1);
						expr.i.clear();
						expr.valid=false;
						return;
					}
				}
			}
		//	else if(S>M_BINARY_FUNCTION_START)
			else if(S>M_BFSTART)//default binary function lazy call
			{
				std::vector<int> commas;
				int k2=k+1;
			//	for(;k2<f&&expr.m[k2]._0<M_FUNCTION_START;++k2)
				for(;k2<f&&expr.m[k2]._0<M_FSTART;++k2)
					if(expr.m[k2]._0==M_COMMA)
						commas.push_back(k2);
				if(commas.size())
				{
					if(callLevel||commas.size()==1)
					{
						compile_inline_if(k+1, *commas.begin(), 0);
						int a2_start=commas[0]+1, a2_end=commas.size()>1?commas[1]:f;
						if(a2_start==a2_end)
							compile_instruction(k, '<', k+1);
						else
						{
							compile_inline_if(a2_start, a2_end, 3);
						//	compile_inline_if(commas[0]+1, commas.size()>1?commas[1]:f, 3);
						//	compile_inline_if(k+1, *commas.begin(), 0, true);
						//	compile_inline_if(commas[0]+1, commas.size()>1?commas[1]:f, 3, true);
							compile_instruction(k, '<', k+1, commas[0]+1);
						}
						S=G2::M_IGNORED, expr.m[commas[0]]._0=M_IGNORED;
					}
					else
					{
						expr.insertSyntaxError(expr.m[commas[1]].pos, expr.m[commas[1]].pos+1);//unexpected comma(s)
						expr.i.clear();
						expr.valid=false;
						return;
					}
				}
				else if(!(default_overload(S)&0x03))//no unary/void overload: call mismatch		later?
				{
				//	expr.insertSyntaxError(expr.m[k].pos, expr.m[k].len);//call mismatch, [function id]		default function: missing arguments get default values
					expr.i.clear();
					expr.valid=false;
					return;
				}
			}
		/*	else if(S==M_COMMA)//unexpected comma
			{
				//todo: mark comma as syntax error
				if(omitExprWithUnexpectedCommas)
				{
					expr.i.clear();
					return;
				}
				else
					expr.m[k]._0=M_IGNORED;
			}//*/
		}
		if(callLevel)
	//	if(topLevel>0&&i-2>=0&&expr.m[i-2]._0>M_FSTART)
		{
			auto &S=expr.m[i-2]._0;
			std::vector<int> commas;
			bool notVoidCall=false;
			for(int k=i;k<f;++k)
			{
				auto &S2=expr.m[k]._0;
				if(S2==M_COMMA)
					commas.push_back(k);
				notVoidCall|=S2!=M_IGNORED;
			}
			int exprNArgs=commas.size()+notVoidCall;
		//	if(S<M_USER_FUNCTION_START)
			if(S<M_USER_FUNCTION)//default function call level
			{
				int signature=default_overload(S);
				if(signature&(1<<exprNArgs))//default overload match
				{
					int start=i;
					for(int k=0, kEnd=commas.size();k<kEnd;++k)
					{
						expr.m[commas[k]]._0=M_IGNORED;
						compile_inline_if(start, commas[k], 0);
					//	compile_inline_if(start+1, commas[k], 0, true);
						start=commas[k]+1;
					}
					compile_inline_if(start, f, 0);
				//	compile_inline_if(start+1, f, 0, true);
					if(exprNArgs==1)
						compile_instruction(i-2, '<', i);
					else if(exprNArgs==2)
						compile_instruction(i-2, '<', i, commas[0]+1);
					S=G2::M_IGNORED;
				}
				else//syntax error, no such overload
				{
					if(exprNArgs>signature)//too many args: highlight unexpected args
						expr.insertSyntaxError(expr.m[commas[signature>0x3]].pos, expr.m[f].pos);
				//	else//highlight arglist contents
				//		expr.insertSyntaxError(expr.m[i].pos, expr.m[f].pos);		//default function: missing args get default values
					//	expr.insertSyntaxError(expr.m[i-(i==f)].pos, expr.m[f].pos);
					expr.i.clear();
					expr.valid=false;
					return;
				}
			}
			else//user function call level
			{
				int name_id=expr.m[i-2]._1, d_match=-1;
				for(int d=0, dEnd=userFunctionDefinitions.size();d<dEnd&&expr.lineNo>userFunctionDefinitions[d].lineNo;++d)//linearly through all user definitions
				{
					auto &definition=userFunctionDefinitions[d];
					if(definition.valid&&name_id==definition.name_id&&exprNArgs==definition.nArgs)//find overload instance		sorted by lineNo
						d_match=d;
				}
				if(d_match!=-1)
				{
					std::vector<int> args(commas.size()+notVoidCall);
					if(notVoidCall)//compile args
					{
						int start=i;
						for(int k3=0, k3End=exprNArgs-1;k3<k3End;++k3)
						{
							expr.m[commas[k3]]._0=M_IGNORED;
							compile_assignment(start, commas[k3]);
							args[k3]=expr.m[start]._1, expr.m[start]._0=M_IGNORED;
							start=commas[k3]+1;
						}
						compile_assignment(start, f);
						args[exprNArgs-1]=expr.m[start]._1, expr.m[start]._0=M_IGNORED;
					}
					int result=compile_instruction_userFunctionCall(d_match, args);
					S=M_N, expr.m[i-2]._1=result;
				/*	std::vector<int> args(commas.size()+notVoidCall);
					if(notVoidCall)//compile args
					{
						int start=i;
						for(int k3=0, k3End=exprNArgs-1;k3<k3End;++k3)
						{
							expr.m[commas[k3]]._0=M_IGNORED;
							compile_assignment(start, commas[k3]);
							args[k3]=expr.m[start]._1;
							start=commas[k3]+1;
						}
						compile_assignment(start, f);
						args[exprNArgs-1]=expr.m[start]._1;
						//args[0]=expr.m[start]._1;//X
						//for(int k3=0, k3End=exprNArgs-1;k3<k3End;++k3)
						//{
						//	expr.m[commas[k3]]._0=M_IGNORED;
						//	compile_assignment(start, commas[k3]);
						//	start=commas[k3]+1;
						//	args[k3+1]=expr.m[start]._1;
						//}
						//compile_assignment(start, f);
					}
					int result=compile_instruction_userFunctionCall(d_match, args);
				//	compile_instruction_userFunctionCall(d_match, args, expr.m[i]._1);
					if(notVoidCall)
						S=M_IGNORED;
					else
						S=M_N, expr.m[i-2]._1=result;
				//	S=M_IGNORED;//*/
				/*	{//compile args
						int start=i;
						for(int k3=0, k3End=exprNArgs-1;k3<k3End;++k3)
						{
							expr.m[commas[k3]]._0=M_IGNORED;
							compile_inline_if(start, commas[k3], 0);
						//	compile_inline_if(start+1, commas[k3], 0, true);
							start=commas[k3]+1;
						}
						compile_inline_if(start, f, 3);//3: compile last arg
					//	compile_inline_if(start+1, f, 3, true);
					//	compile_inline_if(start, f, 3, true);
					}
					std::vector<int> args(commas.size()+1);
					args[0]=expr.m[i]._1;
					for(int k3=0, k3End=commas.size();k3<k3End;++k3)
						args[k3+1]=expr.m[commas[k3]+1]._1;
				//	args[0]=i;
				//	for(int k3=0, k3End=commas.size();k3<k3End;++k3)
				//		args[k3+1]=commas[k3]+1;
					compile_instruction_userFunctionCall(d_match, args);
				//	compile_instruction_userFunctionCall(d_match, args, expr.m[i]._1);
					S=G2::M_IGNORED;//*/
				}
				else//syntax error, no such overload
				{
					expr.insertSyntaxError(expr.m[i-(i==f)].pos, expr.m[f].pos);//arglist
				//	expr.insertSyntaxError(expr.m[k]._1);//mark the error		function call level: highlight id, parentheses and arglist
					expr.i.clear();
					expr.valid=false;
					return;
				}
			}
		}
		else//not a call	or ground level
		{
			for(int k=i;k<f;++k)
			{
				if(expr.m[k]._0==M_COMMA)//unexpected comma
				{
					expr.insertSyntaxError(expr.m[k].pos, expr.m[k].pos+1);//just the comma
				//	expr.insertSyntaxError(expr.m[k]._1);//mark the error		unexpected commas: highlight
					if(omitExprWithUnexpectedCommas)
					{
						expr.i.clear();
						expr.valid=false;
						return;
					}
					expr.m[k]._0=M_IGNORED;
				//	break;
				}
			}
			compile_inline_if(i, f, 0);
		//	compile_inline_if(i, f, 0, true);
		}
		if(topLevel<=0)
			break;
	}
	delete[] ub;
	if(expr.n.size())
		predictedMathSet=term[0].mathSet;
	free(term);
}

void solve(Expression &expr)
{
	auto ndrSize=expr.n[0].ndr.size();
	for(auto &in:expr.i)
//	for(int i=0, nInstr=expr.i.size(), ndrSize=expr.n[0].ndr.size();i<nInstr;)
	{
	//	auto &in=expr.i[i];
		switch(in.type)
		{
		case 'c'://call user function
			concurrency::parallel_for(0u, ndrSize, Solve_UserFunction(expr, in));
			break;
		/*	concurrency::parallel_for(0u, unsigned(ndrSize), [&](int v)
			{
				auto func=&userFunctionDefinitions[in.op1];
				std::vector<Value> fData(func->data.size());
				{
					int k=0;
					for(int kEnd=in.args.size();k<kEnd;++k)//copy args
						fData[k]=expr.n[in.args[k]].ndr[v];
					for(int kEnd=func->data.size();k<kEnd;++k)//initialize const data
						fData[k]=func->data[k];
				}
				std::stack<CallInfo> callStack;
				for(int i2=0, nInstr=func->i.size();;)
				{
					if(i2>=nInstr)//return nothing	unreachable
					{
						if(callStack.size())
						{
							auto &cst=callStack.top();
							func=cst.func;
							i2=cst.i, nInstr=func->i.size();
							cst.fData[func->i[i2].result]=fData[0];//
							std::swap(cst.fData, fData);
							callStack.pop();
							continue;
						}
						break;
					}
					auto &in2=func->i[i2];
					switch(in2.type)
					{
					case 'c'://call user function
						{
							callStack.push(CallInfo(func, i2));
							auto &cst=callStack.top();
							cst.fData=std::move(fData);
						//	func=in2.function;
							func=&userFunctionDefinitions[in2.op1], i2=0;
							fData.resize(func->data.size());
							{
								int k=0;
								for(int kEnd=in2.args.size();k<kEnd;++k)//copy args
									fData[k]=cst.func->data[in2.args[k]];
								for(int kEnd=func->data.size();k<kEnd;++k)//initialize const data
									fData[k]=func->data[k];
							}
						}
						continue;
					case 'b'://branch if
						if(fData[in2.op1].q_isTrue())
							i2=in2.result;
						else
							++i2;
						continue;
					case 'B'://branch if not
						if(!fData[in2.op1].q_isTrue())
							i2=in2.result;
						else
							++i2;
						continue;
					case 'j'://jump
						i2=in2.result;
						continue;
					case 'r'://return
						if(callStack.size())
						{
							auto &cst=callStack.top();
							func=cst.func;
							i2=cst.i, nInstr=func->i.size();
							cst.fData[func->i[i2].result]=fData[0];
							std::swap(cst.fData, fData);
							callStack.pop();
							continue;
						}
						break;
					case 1:
						fData[in2.result]=in2.uf(fData[in2.op1]);
						++i2;
						continue;
					case 2:
						fData[in2.result]=in2.bf(fData[in2.op1], fData[in2.op2]);
						++i2;
						continue;
					case 3:
						fData[in2.result]=in2.tf(fData[in2.op1], fData[in2.op2], fData[in2.op3]);
						++i2;
						continue;
					}
					break;
				}
				expr.n[in.result].ndr[v]=fData[0];
			});//*/
		case 1:
			{
				auto &result=expr.n[in.result], &op1=expr.n[in.op1];
				concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), in.uf);//benchmark
			//	concurrency::parallel_for(0u, op1.ndr.size(), [&](int k){result.ndr[k]=i.uf(op1.ndr[k]);});
			//	std::transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), i.uf);
			//	for(unsigned k=0;k<op1.ndr.size();++k)result.ndr[k]=i.uf(op1.ndr[k]);
			}
			break;
		case 2:
			{
				auto &result=expr.n[in.result], &op1=expr.n[in.op1], &op2=expr.n[in.op2];
				concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), expr.n[in.op2].ndr.begin(), expr.n[in.result].ndr.begin(), in.bf);
			//	concurrency::parallel_for(0u, op1.ndr.size(), [&](int k){result.ndr[k]=i.bf(op1.ndr[k], op2_ndr[k]);});
			//	std::transform(op1.ndr.begin(), op1.ndr.end(), op2_ndr.begin(), result.ndr.begin(), i.bf);
			//	for(unsigned k=0;k<op1.ndr.size();++k)result.ndr[k]=i.bf(op1.ndr[k], op2_ndr[k]);
			}
			break;
		case 3:
			{
				auto &result=expr.n[in.result].ndr, &op1=expr.n[in.op1].ndr, &op2=expr.n[in.op2].ndr, &op3=expr.n[in.op3].ndr;
				concurrency::parallel_for(0u, op1.size(), [&](int k){result[k]=in.tf(op1[k], op2[k], op3[k]);});
			}
			break;
		}
	//	++i;
	}
}
/*void		solve(Expression &expr)
{
	for(auto &i:expr.i)
	{
		switch(i.nArgs)
		{
		case 1:
			{
				auto &op1=expr.n[i.op1], &result=expr.n[i.result];
				concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), i.uf);//bemchmark

			//	auto &o1=expr.n[i.op1].ndr;
			//	concurrency::parallel_transform(o1.begin(), o1.end(), expr.n[i.result].ndr.begin(), i.uf);

			//	auto &o1=expr.n[i.op1].ndr, &result=expr.n[i.result].ndr;
			//	concurrency::parallel_for(0u, o1.size(), [&](int k){result[k]=i.uf(o1[k]);});
			//	std::transform(o1.begin(), o1.end(), result.begin(), i.uf);
			//	for(unsigned k=0;k<o1.size();++k)result[k]=i.uf(o1[k]);
			}
			break;
		case 2:
			{
				auto &o1=expr.n[i.op1].ndr;
				concurrency::parallel_transform(o1.begin(), o1.end(), expr.n[i.op2].ndr.begin(), expr.n[i.result].ndr.begin(), i.bf);

			//	auto &o1=expr.n[i.op1].ndr, &o2=expr.n[i.op2].ndr, &result=expr.n[i.result].ndr;
			//	concurrency::parallel_transform(o1.begin(), o1.end(), o2.begin(), result.begin(), i.bf);
			//	concurrency::parallel_for(0u, o1.size(), [&](int k){result[k]=i.bf(o1[k], o2[k]);});
			//	std::transform(o1.begin(), o1.end(), o2.begin(), result.begin(), i.bf);
			//	for(unsigned k=0;k<o1.size();++k)result[k]=i.bf(o1[k], o2[k]);
			}
			break;
		case 3:
			{
				auto &o1=expr.n[i.op1].ndr, &o2=expr.n[i.op2].ndr, &o3=expr.n[i.op3].ndr, &result=expr.n[i.result].ndr;
				concurrency::parallel_for(0u, o1.size(), [&](int k){result[k]=i.tf(o1[k], o2[k], o3[k]);});
			}
			break;
		}
	}
}//*/
template<int _size>void append(char *&a, int &alen, char (&b)[_size], int &blen)
{
	a=(char*)realloc(a, (alen+blen+1)*sizeof(char));
	memcpy(&a[alen], b, (blen+1)*sizeof(char));
	alen+=blen;
}
namespace	modes
{
	bool active=0, ready=0;
	unsigned const _2dCheckColor=0x00E0E0E0,//0x00D0D0D0	0x00EFEFEF
		_3dGridColor=0x00D0D0D0;
	int const N_MODES=13;
	std::vector<int> nExpr(N_MODES, 0);
	struct		Label
	{
		std::string label;
		int exNo;
		Label(std::string &label, int exNo):label(label), exNo(exNo){}
	};
	struct		CLabel:public Label
	{
		bool isTime;
		double value;
		CLabel(std::string &label, int exNo):Label(label, exNo), isTime(true){}
		CLabel(std::string &label, int exNo, double value):Label(label, exNo), value(value), isTime(false){}
	};
	class		Labels
	{
		virtual void LOL(int, std::string&, int, double)=0;
	public:
		std::vector<CLabel> Clabels;
		void fill(int exNo)
		{
			for(auto &v:expr[exNo].variables)
			{
				switch(v.mathSet)
				{
				case 'r':
			//	case 'R':
					LOL(v.varTypeR, v.name, exNo, v.val.r);
					break;
				case 'c':
			//	case 'C':
					LOL(v.varTypeR, "Re("+v.name+")", exNo, v.val.r),
						LOL(v.varTypeI, "Im("+v.name+")", exNo, v.val.i);
					break;
				case 'H':
					LOL(v.varTypeR, "Re("+v.name+")", exNo, v.val.r),
						LOL(v.varTypeI, "I("+v.name+")", exNo, v.val.i),
						LOL(v.varTypeJ, "J("+v.name+")", exNo, v.val.j),
						LOL(v.varTypeK, "K("+v.name+")", exNo, v.val.k);
					break;
				}
			}
		}
	};
	class		Labels_0D:public Labels
	{
		std::unordered_set<int> exprs;
		void LOL(int LOL_1, std::string &str, int exNo, double value)
		{
			switch(LOL_1)
			{
			case 't':Clabels.push_back(CLabel(str, exNo)), exprs.insert(exNo);if(exprs.size()>1)colored=1;break;
			case 'c':Clabels.push_back(CLabel(str, exNo, value)), exprs.insert(exNo);if(exprs.size()>1)colored=1;break;
			}
		}
	public:
		int colored;
		void clear(){Clabels.clear(), colored=0, exprs.clear();}
	};
	class		Labels_1D:public Labels
	{
		void LOL(int LOL_1, std::string &str, int exNo, double value)
		{
			switch(LOL_1)
			{
			case 'x':Xlabels.push_back(Label(str, exNo));break;
			case 't':Clabels.push_back(CLabel(str, exNo));break;
			case 'c':Clabels.push_back(CLabel(str, exNo, value));break;
			}
		}
	public:
		std::vector<Label> Xlabels;
		void clear(){Xlabels.clear(), Clabels.clear();}
	};
	class		Labels_2D:public Labels
	{
		void LOL(int LOL_1, std::string &str, int exNo, double value)
		{
			switch(LOL_1)
			{
			case 'x':Xlabels.push_back(Label(str, exNo));break;
			case 'y':Ylabels.push_back(Label(str, exNo));break;
			case 't':Clabels.push_back(CLabel(str, exNo));break;
			case 'c':Clabels.push_back(CLabel(str, exNo, value));break;
			}
		}
	public:
		std::vector<Label> Xlabels, Ylabels;
		void clear(){Xlabels.clear(), Ylabels.clear(), Clabels.clear();}
	};
	class		Labels_3D:public Labels
	{
		void LOL(int LOL_1, std::string &str, int exNo, double value)
		{
			switch(LOL_1)
			{
			case 'x':Xlabels.push_back(Label(str, exNo));break;
			case 'y':Ylabels.push_back(Label(str, exNo));break;
			case 'z':Zlabels.push_back(Label(str, exNo));break;
			case 't':Clabels.push_back(CLabel(str, exNo));break;
			case 'c':Clabels.push_back(CLabel(str, exNo, value));break;
			}
		}
	public:
		std::vector<Label> Xlabels, Ylabels, Zlabels;
		void clear(){Xlabels.clear(), Ylabels.clear(), Zlabels.clear(), Clabels.clear();}
	};

	void		reduce_angle(double &th)
	{
		const double _2pi=2*G2::_pi, _1_2pi=1/(2*G2::_pi);
		th=th-_2pi*floor(th*_1_2pi);
		//for(;th<0;)th+=_2pi; for(;th>_2pi;)th-=_2pi;
	}
	void		change_angle(double &th, double &cth, double &sth)
	{
		const double _2pi=2*G2::_pi, _1_2pi=1/(2*G2::_pi);
		th=th-_2pi*floor(th*_1_2pi);
		cth=cos(th), sth=sin(th);
	}
	class		_2D
	{
		bool continuous;
		int c_x1;
		double c_y1;
	public:
		int lineColor;
		_2D():lineColor(0){}
		void curve_start(){continuous=false;}
		void curve_point(int x, double y)
		{
			if(continuous)
			{
				double abs_y1=abs(c_y1), abs_y2=abs(y);
				if(abs_y1<1e6)
				{
					if(abs_y2<1e6)
						MoveToEx(ghMemDC, c_x1, int(c_y1)-(c_y1<0), 0), LineTo(ghMemDC, x, int(y)-(y<0));			//-0.5 truncated as 0
					//	MoveToEx(ghMemDC, c_x1, int(std::floor(c_y1)), 0), LineTo(ghMemDC, x, int(std::floor(y)));
					else if(!isnan(y))
						MoveToEx(ghMemDC, c_x1, int(c_y1)-(c_y1<0), 0), LineTo(ghMemDC, c_x1, y>0?h:0);
					//	MoveToEx(ghMemDC, c_x1, int(std::floor(c_y1)), 0), LineTo(ghMemDC, c_x1, y>0?h:0);
				}
				else if(!isnan(c_y1))
				{
					if(abs_y2<1e6)
						MoveToEx(ghMemDC, x, c_y1>0?h:0, 0), LineTo(ghMemDC, x, int(y)-(y<0));
					//	MoveToEx(ghMemDC, x, c_y1>0?h:0, 0), LineTo(ghMemDC, x, int(std::floor(y)));
					else if(!isnan(y))
					{
						if(abs_y1>abs_y2)
							MoveToEx(ghMemDC, x, c_y1>0?h:0, 0), LineTo(ghMemDC, x, y>0?h:0);
						else
							MoveToEx(ghMemDC, c_x1, c_y1>0?h:0, 0), LineTo(ghMemDC, c_x1, y>0?h:0);
					}
				}
			}
			else
			{
				if(x>=0&&x<w&&y>=0&&y<h)
					rgb[w*int(y)+x]=lineColor;
				continuous=true;
			}
			c_x1=x, c_y1=y;
		}
		void set_point()
		{
			if(c_x1>=0&&c_x1<w&&c_y1>=0&&c_y1<h)
				rgb[w*int(c_y1)+c_x1]=0;
		}
	};
	class		_2D_L2D//interpolate	linear is best
	{
		bool continuous;
		double X0, Y0;
		bool cast(double X, int &x)
		{
			double const INT_LIMIT=2e9;
			int const int_limit=int(2e9);
			if(std::abs(X0)<INT_LIMIT)
			{
				x=int(X);
				return true;
			}
			if(!std::isnan(X))
			{
				x=X>0?int_limit:-int_limit;
				return true;
			}
			return false;

		}
		double linearY(double x1, double y1, double x2, double y2, double x){return (y2-y1)/(x2-x1)*(x-x1)+y1;}
		double linearX(double x1, double y1, double x2, double y2, double y){return (x2-x1)/(y2-y1)*(y-y1)+x1;}
	public:
		void curve_start(){continuous=false;}
		void curve_point(double X, double Y)
		{
			if(continuous)
			{
				double const INT_LIMIT=2e6;//2e9
				int const int_limit=int(INT_LIMIT);
				if(std::abs(X0)<INT_LIMIT&&std::abs(Y0)<INT_LIMIT&&std::abs(X)<INT_LIMIT&&std::abs(Y)<INT_LIMIT)
					MoveToEx(ghMemDC, int(X0)-(X0<0), int(Y0)-(Y0<0), 0), LineTo(ghMemDC, int(X)-(X<0), int(Y)-(Y<0));//-0.5 truncated as 0

				//	MoveToEx(ghMemDC, int(std::floor(X0)), int(std::floor(Y0)), 0), LineTo(ghMemDC, int(std::floor(X)), int(std::floor(Y)));
				else if(!(std::isnan(X0)||std::isnan(Y0)||std::isnan(X)||std::isnan(Y)||std::isinf(X0)||std::isinf(Y0)||std::isinf(X)||std::isinf(Y)))
			//	else if(!(std::isnan(X0)||std::isnan(Y0)||std::isnan(X)||std::isnan(Y)))
				{
					auto &x1=X0, &y1=Y0, x2=X, y2=Y;
					double const bx1=0, bx2=w, by1=0, by2=h;

					bool valid=true;
					//up
					if(y1<by1)
					{
						if(y2<by1)
							valid=false;
						else
							x1=linearX(x1, y1, x2, y2, by1), y1=by1;
					}
					else if(y2<by1)
						x2=linearX(x1, y1, x2, y2, by1), y2=by1;

					if(valid)
					{
						//right
						if(x1>bx2)
						{
							if(x2>bx2)
								valid=false;
							else
								y1=linearY(x1, y1, x2, y2, bx2), x1=bx2;
						}
						else if(x2>bx2)
							y2=linearY(x1, y1, x2, y2, bx2), x2=bx2;

						if(valid)
						{
							//bottom
							if(y1>by2)
							{
								if(y2>by2)
									valid=false;
								else
									x1=linearX(x1, y1, x2, y2, by2), y1=by2;
							}
							else if(y2>by2)
								x2=linearX(x1, y1, x2, y2, by2), y2=by2;

							if(valid)
							{
								//left
								if(x1<bx1)
								{
									if(x2<bx1)
										valid=false;
									else
										y1=linearY(x1, y1, x2, y2, bx1), x1=bx1;
								}
								else if(x2<bx1)
									y2=linearY(x1, y1, x2, y2, bx1), x2=bx1;

								if(valid)
									MoveToEx(ghMemDC, int(x1)-(x1<0), int(y1)-(y1<0), 0), LineTo(ghMemDC, int(x2)-(x2<0), int(y2)-(y2<0));//-0.5 truncated as 0
								//	MoveToEx(ghMemDC, int(std::floor(x1)), int(std::floor(y1)), 0), LineTo(ghMemDC, int(std::floor(x2)), int(std::floor(y2)));
							}
						}
					}
				}
			/*	if(std::abs(X0)<INT_LIMIT)
				{
					if(std::abs(Y0)<INT_LIMIT)
					{
						if(std::abs(X)<INT_LIMIT)
						{
							if(std::abs(Y)<INT_LIMIT)
							{
								MoveToEx(ghMemDC, int(X0), int(Y0), 0), LineTo(ghMemDC, int(X), int(Y));
							}
							else if(!std::isnan(Y))
							{

							}
						}
						else if(!std::isnan(X))
						{
							if(std::abs(Y)<INT_LIMIT)
							{
							}
							else if(!std::isnan(Y))
							{
							}
						}
					}
					else if(!std::isnan(Y0))
					{
						if(std::abs(X)<INT_LIMIT)
						{
							if(std::abs(Y)<INT_LIMIT)
							{
							}
							else if(!std::isnan(Y))
							{
							}
						}
						else if(!std::isnan(X))
						{
							if(std::abs(Y)<INT_LIMIT)
							{
							}
							else if(!std::isnan(Y))
							{
							}
						}
					}
				}
				else if(!std::isnan(X0))
				{
					if(std::abs(Y0)<INT_LIMIT)
					{
						if(std::abs(X)<INT_LIMIT)
						{
							if(std::abs(Y)<INT_LIMIT)
							{
							}
							else if(!std::isnan(Y))
							{
							}
						}
						else if(!std::isnan(X))
						{
							if(std::abs(Y)<INT_LIMIT)
							{
							}
							else if(!std::isnan(Y))
							{
							}
						}
					}
					else if(!std::isnan(Y0))
					{
						if(std::abs(X)<INT_LIMIT)
						{
							if(std::abs(Y)<INT_LIMIT)
							{
							}
							else if(!std::isnan(Y))
							{
							}
						}
						else if(!std::isnan(X))
						{
							if(std::abs(Y)<INT_LIMIT)
							{
							}
							else if(!std::isnan(Y))
							{
							}
						}
					}
				}//*/

			//	int x0, y0, x1, y1;
			//	if(cast(X0, x0)&&cast(Y0, y0)&&cast(X, x1)&&cast(Y, y1))
			//		MoveToEx(ghMemDC, x0, y0, 0), LineTo(ghMemDC, x1, y1);

			/*	bool toDraw=true;
				int x0;
				if(std::abs(X0)<INT_LIMIT)
					x0=int(X0);
				else if(!std::isnan(X0))
					x0=X0>0?int_limit:-int_limit;
				else
					toDraw=false;
				if(toDraw)
				{
					int y0;
					if(std::abs(Y0)<INT_LIMIT)
						y0=int(Y0);
					else if(!std::isnan(Y0))
						y0=Y0>0?int_limit:-int_limit;
					else
						toDraw=false;
					if(toDraw)
					{
						int x1;
						if(std::abs(X)<INT_LIMIT)
							x1=int(X);
						else if(!std::isnan(X))
							x1=X>0?int_limit:-int_limit;
						else
							toDraw=false;
						if(toDraw)
						{
							int y1;
							if(std::abs(Y)<INT_LIMIT)
								y1=int(Y);
							else if(!std::isnan(Y0))
								y1=Y>0?int_limit:-int_limit;
							else
								toDraw=false;
							if(toDraw)
								MoveToEx(ghMemDC, x0, y0, 0), LineTo(ghMemDC, x1, y1);
						}
					}
				}//*/

			/*	if(std::abs(X0)<INT_LIMIT)
				{
					if(std::abs(Y0)<INT_LIMIT)
					{
						if(std::abs(X)<INT_LIMIT)
						{
							if(std::abs(Y)<INT_LIMIT)
								MoveToEx(ghMemDC, int(X0), int(Y0), 0), LineTo(ghMemDC, int(X), int(Y));
							else if(!std::isnan(Y))
								MoveToEx(ghMemDC, int(X0), int(Y0), 0), LineTo(ghMemDC, int(X), Y>0?int_limit:-int_limit);
						}
						else if(!std::isnan(X))
						{
							if(std::abs(Y)<INT_LIMIT)
								MoveToEx(ghMemDC, int(X0), int(Y0), 0), LineTo(ghMemDC, X>0?int_limit:-int_limit, int(Y));
							else if(!std::isnan(Y))
								MoveToEx(ghMemDC, int(X0), int(Y0), 0), LineTo(ghMemDC, X>0?int_limit:-int_limit, Y>0?int_limit:-int_limit);
						}
					}
					else if(!std::isnan(Y0))
					{
						if(std::abs(X)<INT_LIMIT)
						{
							if(std::abs(Y)<INT_LIMIT)
							{
							}
							else if(!std::isnan(Y))
							{
							}
						}
						else if(!std::isnan(X))
						{
							if(std::abs(Y)<INT_LIMIT)
							{
							}
							else if(!std::isnan(Y))
							{
							}
						}
					}
				}
				else if(!std::isnan(X0))
				{
					if(std::abs(Y0)<INT_LIMIT)
					{
						if(std::abs(X)<INT_LIMIT)
						{
							if(std::abs(Y)<INT_LIMIT)
							{
							}
							else if(!std::isnan(Y))
							{
							}
						}
						else if(!std::isnan(X))
						{
							if(std::abs(Y)<INT_LIMIT)
							{
							}
							else if(!std::isnan(Y))
							{
							}
						}
					}
					else if(!std::isnan(Y0))
					{
						if(std::abs(X)<INT_LIMIT)
						{
							if(std::abs(Y)<INT_LIMIT)
							{
							}
							else if(!std::isnan(Y))
							{
							}
						}
						else if(!std::isnan(X))
						{
							if(std::abs(Y)<INT_LIMIT)
							{
							}
							else if(!std::isnan(Y))
							{
							}
						}
					}
				}//*/
			/*	if(abs_Y0<1e6)
				{
					if(abs_Y1<1e6)
						MoveToEx(ghMemDC, X0, int(Y0), 0), LineTo(ghMemDC, X, int(Y));
					else if(!isnan(Y))
						MoveToEx(ghMemDC, X0, int(Y0), 0), LineTo(ghMemDC, X0, Y>0?h:0);
				}
				else if(!isnan(Y0))
				{
					if(abs_Y1<1e6)
						MoveToEx(ghMemDC, X, Y0>0?h:0, 0), LineTo(ghMemDC, X, int(Y));
					else if(!isnan(Y))
					{
						if(abs_Y0>abs_Y1)
							MoveToEx(ghMemDC, X, Y0>0?h:0, 0), LineTo(ghMemDC, X, Y>0?h:0);
						else
							MoveToEx(ghMemDC, X0, Y0>0?h:0, 0), LineTo(ghMemDC, X0, Y>0?h:0);
					}
				}//*/
			}
			else
			{
				if(X>=0&&X<w&&Y>=0&&Y<h)
					rgb[w*int(Y)+int(X)]=0;
				continuous=true;
			}
			X0=X, Y0=Y;
		}
		void set_point()
		{
			if(X0>=0&&X0<w&&Y0>=0&&Y0<h)
				rgb[w*int(Y0)+int(X0)]=0;
		}
	};
	class		_3D//trash code here
	{
	public:
		struct Triangle
		{
			double X1, Y1, Z1, X2, Y2, Z2, X3, Y3, Z3;
			Triangle(double X1, double Y1, double Z1, double X2, double Y2, double Z2, double X3, double Y3, double Z3):X1(X1), Y1(Y1), Z1(Z1), X2(X2), Y2(Y2), Z2(Z2), X3(X3), Y3(Y3), Z3(Z3){}
		};
		struct Stick
		{
			double X1, Y1, Z1, X2, Y2, Z2;
			Stick(double X1, double Y1, double Z1, double X2, double Y2, double Z2):X1(X1), Y1(Y1), Z1(Z1), X2(X2), Y2(Y2), Z2(Z2){}
		};
		int bx1, bx2, by1, by2, bw, bh, X0, Y0;
		double camx, camy, camz, ax, ay, cax, sax, cay, say, da, dcam, tanfov, dtanfov, mouse_sensitivity, *wbuffer;
		_3D(double camx, double camy, double camz, double ax, double ay, double tanfov):camx(camx), camy(camy), camz(camz), ax(ax), ay(ay), cax(cos(ax)), sax(sin(ax)), cay(cos(ay)), say(sin(ay)), da(2*G2::_pi/180), dcam(.04), tanfov(tanfov), dtanfov(1.1), mouse_sensitivity(.003){}
		~_3D(){free(wbuffer);}
		void setDimentions(int x, int y, int w, int h)
		{
			bx1=x, by1=y, bx2=x+w, by2=h, bw=w, bh=h, X0=w/2, Y0=h/2;
			wbuffer=(double*)realloc(wbuffer, w*h*sizeof(double));
			libuffer=(int*)realloc(libuffer, h*sizeof(int)), lfbuffer=(int*)realloc(lfbuffer, h*sizeof(int));
			clipX1=x, clipY1=y, clipX2=x+w-50, clipY2=y+h-24;
		}
		void newFrame(){memset(wbuffer, 0, bw*bh*sizeof(double));}
		void teleport(double camx, double camy, double camz, double ax, double ay, double tanfov)
		{
			this->camx=camx, this->camy=camy, this->camz=camz;
			this->ax=ax, cax=cos(ax), sax=sin(ax);
			this->ay=ay, cay=cos(ay), say=sin(ay);
		}
		void teleport_degrees(double camx, double camy, double camz, double ax_deg, double ay_deg, double tanfov)
		{
			this->camx=camx, this->camy=camy, this->camz=camz;
			ax=ax_deg*G2::_pi/180, cax=cos(ax), sax=sin(ax);
			ay=ay_deg*G2::_pi/180, cay=cos(ay), say=sin(ay);
		}
		void zoomIn	(double A)	{tanfov/=A;}
		void zoomIn	()			{tanfov/=dtanfov;}
		void zoomOut()			{tanfov*=dtanfov;}
		void rotate(double dax, double day)
		{
			change_angle(ax+=dax, cax, sax);
			change_angle(ay+=day, cay, say);
			//for(;ax<0;)ax+=2*G2::_pi; for(;ax>2*G2::_pi;)ax-=2*G2::_pi; for(;ay<0;)ay+=2*G2::_pi; for(;ay>2*G2::_pi;)ay-=2*G2::_pi;
			//cax=cos(ax), sax=sin(ax), cay=cos(ay), say=sin(ay);
		}
		void rotate(int lParam)
		{
			change_angle(ax+=mouse_sensitivity*(X0-((short*)&lParam)[0]), cax, sax);
			change_angle(ay+=mouse_sensitivity*(Y0-((short*)&lParam)[1]), cay, say);
		//	ax+=mouse_sensitivity*(X0-short(lParam)), ay+=mouse_sensitivity*(Y0-short(lParam>>16));
		//	for(;ax<0;)ax+=2*G2::_pi; for(;ax>2*G2::_pi;)ax-=2*G2::_pi; for(;ay<0;)ay+=2*G2::_pi; for(;ay>2*G2::_pi;)ay-=2*G2::_pi;
			//cax=cos(ax), sax=sin(ax), cay=cos(ay), say=sin(ay);
		}
		void rotateUp	(double day){change_angle(ay+=day, cay, say);}
		void rotateUp	()			{change_angle(ay+=da,  cay, say);}
		void rotateDown	()			{change_angle(ay-=da,  cay, say);}
		void rotateLeft	(double dax){change_angle(ax+=dax, cax, sax);}
		void rotateLeft	()			{change_angle(ax+=da,  cax, sax);}
		void rotateRight()			{change_angle(ax-=da,  cax, sax);}

		void moveScaledForward		(double forward, double AR_Y, double AR_Z)	{camx+=forward*cax*cay,		camy+=AR_Y*forward*sax*cay,		camz+=AR_Z*forward*say;}
		void moveScaledForward		(double AR_Y, double AR_Z)					{camx+=dcam*cax*cay,		camy+=AR_Y*dcam*sax*cay,		camz+=AR_Z*dcam*say;}
		void moveScaledBack			(double AR_Y, double AR_Z)					{camx-=dcam*cax*cay,		camy-=AR_Y*dcam*sax*cay,		camz-=AR_Z*dcam*say;}
		void moveScaledForwardFast	(double AR_Y, double AR_Z)					{camx+=10.*dcam*cax*cay,	camy+=AR_Y*10.*dcam*sax*cay,	camz+=AR_Z*10.*dcam*say;}
		void moveScaledBackFast		(double AR_Y, double AR_Z)					{camx-=10.*dcam*cax*cay,	camy-=AR_Y*10.*dcam*sax*cay,	camz-=AR_Z*10.*dcam*say;}
		void moveScaledRight		(double right, double AR_Y, double AR_Z)	{camx+=right*sax,			camy-=AR_Y*right*cax;}
		void moveScaledRight		(double AR_Y, double AR_Z)					{camx+=dcam*sax,			camy-=AR_Y*dcam*cax;}
		void moveScaledLeft			(double AR_Y, double AR_Z)					{camx-=dcam*sax,			camy+=AR_Y*dcam*cax;}
		void moveScaledRightFast	(double AR_Y, double AR_Z)					{camx+=10.*dcam*sax,		camy-=AR_Y*10.*dcam*cax;}
		void moveScaledLeftFast		(double AR_Y, double AR_Z)					{camx-=10.*dcam*sax,		camy+=AR_Y*10.*dcam*cax;}

		void moveForward	(double forward){camx+=forward*cax*cay,		camy+=forward*sax*cay,	camz+=forward*say;}
		void moveForward	()				{camx+=dcam*cax*cay,		camy+=dcam*sax*cay,		camz+=dcam*say;}
		void moveBack		()				{camx-=dcam*cax*cay,		camy-=dcam*sax*cay,		camz-=dcam*say;}
		void moveForwardFast()				{camx+=10.*dcam*cax*cay,	camy+=10.*dcam*sax*cay,	camz+=10.*dcam*say;}
		void moveBackFast	()				{camx-=10.*dcam*cax*cay,	camy-=10.*dcam*sax*cay,	camz-=10.*dcam*say;}
		void moveRight		(double right)	{camx+=right*sax,			camy-=right*cax;}
		void moveRight		()				{camx+=dcam*sax,			camy-=dcam*cax;}
		void moveLeft		()				{camx-=dcam*sax,			camy+=dcam*cax;}
		void moveRightFast	()				{camx+=10.*dcam*sax,		camy-=10.*dcam*cax;}
		void moveLeftFast	()				{camx-=10.*dcam*sax,		camy+=10.*dcam*cax;}
		void faster(double A){dcam*=A;}
		void faster(){dcam*=2;}
		void slower(){dcam/=2;}
	private:
		void line_A_coeff_x(double Xcp1, double Ycp1, double Zcp1, double Xcp2, double Ycp2, double Zcp2, double &a, double &b)
		{
			double t=(Xcp2-Xcp1)*Zcp1-Xcp1*(Zcp2-Zcp1);
			a=(Zcp1-Zcp2)*tanfov/(X0*t), b=((Zcp2-Zcp1)*tanfov+Xcp2-Xcp1)/t;
		}
		void line_A_coeff_y(double Xcp1, double Ycp1, double Zcp1, double Xcp2, double Ycp2, double Zcp2, double &a, double &b)
		{
			double t=(Ycp2-Ycp1)*Zcp1-Ycp1*(Zcp2-Zcp1);
			a=(Zcp1-Zcp2)*tanfov/(X0*t), b=((Zcp2-Zcp1)*Y0*tanfov/X0+Ycp2-Ycp1)/t;
		}
		void _3dLineOnScreen_draw(double x1, double y1, double Xcp1, double Ycp1, double Zcp1, double x2, double y2, double Xcp2, double Ycp2, double Zcp2)
		{
			double xa, ya, xb, yb, dx=x2-x1, dy=y2-y1;
			if(abs(dx)>abs(dy))//horizontal
			{
				double dy_dx=dy/dx;
				if(x1<x2)
				{
					if(x1<bx1)
						xa=bx1, ya=y1+dy_dx*(bx1-x1);
					else
						xa=x1, ya=y1;
					if(x2>bx2-1)
						xb=bx2-1, yb=y1+dy_dx*(bx2-1-x1);
					else
						xb=x2, yb=y2;
				}
				else
				{
					if(x2<bx1)
						xa=bx1, ya=y1+dy_dx*(bx1-x1);
					else
						xa=x2, ya=y2;
					if(x1>bx2-1)
						xb=bx2-1, yb=y1+dy_dx*(bx2-1-x1);
					else
						xb=x1, yb=y1;
				}
				double a, b;
				line_A_coeff_x(Xcp1, Ycp1, Zcp1, Xcp2, Ycp2, Zcp2, a, b);
			/*	{
					double t=(Xcp2-Xcp1)*Zcp1-Xcp1*(Zcp2-Zcp1);
					a=(Zcp1-Zcp2)*tanfov/(X0*t), b=((Zcp2-Zcp1)*tanfov+Xcp2-Xcp1)/t;
				}*/
				int xEnd=int(xb-xa)-(int(xb-xa)&7);
				for(int x=0;x<xEnd;x+=4)
				{
					__m128 xf=_mm_set_ps(float(x+3), float(x+2), float(x+1), (float)x);
					xf=_mm_add_ps(xf, _mm_set1_ps((float)xa));
					__m128 yf=_mm_sub_ps(xf, _mm_set1_ps((float)x1));
					yf=_mm_mul_ps(yf, _mm_set1_ps((float)dy_dx));
					yf=_mm_add_ps(yf, _mm_set1_ps((float)y1));
					__m128i m_y=_mm_cvtps_epi32(yf);
					__m128i c1=_mm_cmpgt_epi32(m_y, _mm_set1_epi32(by1));//
					__m128i c2=_mm_cmplt_epi32(m_y, _mm_set1_epi32(by2));
					c1=_mm_and_si128(c1, c2);

					c2=_mm_srli_si128(c1, 8);
					c2=_mm_or_si128(c2, c1);
					__m128i c3=_mm_srli_si128(c2, 4);
					c2=_mm_or_si128(c2, c3);
					if(c2.m128i_i32[0])
					{
						__m128i m_x=_mm_cvtps_epi32(xf);
						__m128i pos=_mm_mullo_epi32(m_y, _mm_set1_epi32(w));
						pos=_mm_add_epi32(pos, m_x);
						__m128 A=_mm_mul_ps(xf, _mm_set1_ps((float)a));
						A=_mm_add_ps(A, _mm_set1_ps((float)b));
					//	__m128 wbk=_mm_set_ps(wbuffer+pos.m128i_i32[0], wbuffer+pos.m128i_i32[0]
						if(c1.m128i_i32[0]&&A.m128_f32[0]>wbuffer[pos.m128i_i32[0]])
							rgb[pos.m128i_i32[0]]=lineColor, wbuffer[pos.m128i_i32[0]]=A.m128_f32[0];
						if(c1.m128i_i32[1]&&A.m128_f32[1]>wbuffer[pos.m128i_i32[1]])
							rgb[pos.m128i_i32[1]]=lineColor, wbuffer[pos.m128i_i32[1]]=A.m128_f32[1];
						if(c1.m128i_i32[2]&&A.m128_f32[2]>wbuffer[pos.m128i_i32[2]])
							rgb[pos.m128i_i32[2]]=lineColor, wbuffer[pos.m128i_i32[2]]=A.m128_f32[2];
						if(c1.m128i_i32[3]&&A.m128_f32[3]>wbuffer[pos.m128i_i32[3]])
							rgb[pos.m128i_i32[3]]=lineColor, wbuffer[pos.m128i_i32[3]]=A.m128_f32[3];
					}
				}
				for(int x=xEnd<0?0:xEnd, xEnd2=int(xb-xa);x<=xEnd2;++x)//horizontal
				{
					int xx=x+(int)xa;
					int y=int(std::floor(y1+dy_dx*(xx-x1)));//-0.5 truncated as 0
					if(y>=by1&&y<by2)
					{
						int pos=w*y+xx;
						double A=a*xx+b;
						if(A>wbuffer[pos])
							rgb[pos]=lineColor, wbuffer[pos]=A;
						else if(A==wbuffer[pos])
						{
							auto p=(unsigned char*)&rgb[pos], c=(unsigned char*)&lineColor;//little endian
							p[0]=(p[0]+c[0])>>1;//b
							p[1]=(p[1]+c[1])>>1;//g
							p[2]=(p[2]+c[2])>>1;//r
						}
					}
				}
			/*	for(int x=int(xa), xEnd=int(xb);x<=xEnd;++x)//horizontal
				{
					//int y;
					//{
					//	double Y=y1+dy_dx*(x-x1);
					//	y=int(Y)-(Y<0);
					//}
					int y=int(std::floor(y1+dy_dx*(x-x1)));//-0.5 truncated as 0
					if(y>=by1&&y<by2)
					{
						int pos=w*y+x;
						double A=a*x+b;
						if(A>wbuffer[pos])
							rgb[pos]=lineColor, wbuffer[pos]=A;
						else if(A==wbuffer[pos])
						{
							auto p=(unsigned char*)&rgb[pos], c=(unsigned char*)&lineColor;//little endian
							p[0]=(p[0]+c[0])>>1;//b
							p[1]=(p[1]+c[1])>>1;//g
							p[2]=(p[2]+c[2])>>1;//r
						}
						//{
						//	((unsigned char*)&rgb[pos])[0]=((unsigned char*)&rgb[pos])[0]+((unsigned char*)&lineColor)[0]>>1;
						//	((unsigned char*)&rgb[pos])[1]=((unsigned char*)&rgb[pos])[1]+((unsigned char*)&lineColor)[1]>>1;
						//	((unsigned char*)&rgb[pos])[2]=((unsigned char*)&rgb[pos])[2]+((unsigned char*)&lineColor)[2]>>1;
						//}
						//	rgb[pos]=0xFFC0CB;
					}
				}//*/
			}
			else//vertical
			{
				double dx_dy=dx/dy;
				if(y1<y2)
				{
					if(y1<by1)
						xa=x1+dx_dy*(by1-y1), ya=by1;
					else
						xa=x1, ya=y1;
					if(y2>by2-1)
						xb=x1+dx_dy*(by2-1-y1), yb=by2-1;
					else
						xb=x2, yb=y2;
				}
				else
				{
					if(y2<by1)
						xa=x1+dx_dy*(by1-y1), ya=by1;
					else
						xa=x2, ya=y2;
					if(y1>by2-1)
						xb=x1+dx_dy*(by2-1-y1), yb=by2-1;
					else
						xb=x1, yb=y1;
				}
				double a, b;
				line_A_coeff_y(Xcp1, Ycp1, Zcp1, Xcp2, Ycp2, Zcp2, a, b);
			/*	{
					double t=(Ycp2-Ycp1)*Zcp1-Ycp1*(Zcp2-Zcp1);
					a=(Zcp1-Zcp2)*tanfov/(X0*t), b=((Zcp2-Zcp1)*Y0*tanfov/X0+Ycp2-Ycp1)/t;
				}*/
				int yEnd=int(yb-ya)-(int(yb-ya)&7);
				for(int y=0;y<yEnd;y+=4)
				{
					__m128 yf=_mm_set_ps(float(y+3), float(y+2), float(y+1), (float)y);
					yf=_mm_add_ps(yf, _mm_set1_ps((float)ya));
					__m128 xf=_mm_sub_ps(yf, _mm_set1_ps((float)y1));
					xf=_mm_mul_ps(xf, _mm_set1_ps((float)dx_dy));
					xf=_mm_add_ps(xf, _mm_set1_ps((float)x1));
					__m128i m_x=_mm_cvtps_epi32(xf);
					__m128i c1=_mm_cmpgt_epi32(m_x, _mm_set1_epi32(bx1));//
					__m128i c2=_mm_cmplt_epi32(m_x, _mm_set1_epi32(bx2));
					c1=_mm_and_si128(c1, c2);

					c2=_mm_srli_si128(c1, 8);
					c2=_mm_or_si128(c2, c1);
					__m128i c3=_mm_srli_si128(c2, 4);
					c2=_mm_or_si128(c2, c3);
					if(c2.m128i_i32[0])
					{
						__m128i m_y=_mm_cvtps_epi32(yf);
						__m128i pos=_mm_mullo_epi32(m_y, _mm_set1_epi32(w));
						pos=_mm_add_epi32(pos, m_x);
						__m128 A=_mm_mul_ps(yf, _mm_set1_ps((float)a));
						A=_mm_add_ps(A, _mm_set1_ps((float)b));
						if(c1.m128i_i32[0]&&A.m128_f32[0]>wbuffer[pos.m128i_i32[0]])
							rgb[pos.m128i_i32[0]]=lineColor, wbuffer[pos.m128i_i32[0]]=A.m128_f32[0];
						if(c1.m128i_i32[1]&&A.m128_f32[1]>wbuffer[pos.m128i_i32[1]])
							rgb[pos.m128i_i32[1]]=lineColor, wbuffer[pos.m128i_i32[1]]=A.m128_f32[1];
						if(c1.m128i_i32[2]&&A.m128_f32[2]>wbuffer[pos.m128i_i32[2]])
							rgb[pos.m128i_i32[2]]=lineColor, wbuffer[pos.m128i_i32[2]]=A.m128_f32[2];
						if(c1.m128i_i32[3]&&A.m128_f32[3]>wbuffer[pos.m128i_i32[3]])
							rgb[pos.m128i_i32[3]]=lineColor, wbuffer[pos.m128i_i32[3]]=A.m128_f32[3];
					}
				}
				for(int y=yEnd<0?0:yEnd, yEnd2=int(yb-ya);y<=yEnd2;++y)//vertical
				{
					int yy=y+(int)ya;
					int x=int(std::floor(x1+dx_dy*(yy-y1)));//-0.5 truncated as 0
					if(x>=bx1&&x<bx2)
					{
						int pos=w*yy+x;
						double A=a*yy+b;
						if(A>wbuffer[pos])
							rgb[pos]=lineColor, wbuffer[pos]=A;
						else if(A==wbuffer[pos])
						{
							auto p=(unsigned char*)&rgb[pos], c=(unsigned char*)&lineColor;
							p[0]=(p[0]+c[0])>>1;//b
							p[1]=(p[1]+c[1])>>1;//g
							p[2]=(p[2]+c[2])>>1;//r
						}
					}
				}
			/*	for(int y=int(ya), yEnd=int(yb);y<yEnd;++y)//vertical
				{
					int x=int(std::floor(x1+dx_dy*(y-y1)));//-0.5 truncated as 0
					if(x>=bx1&&x<bx2)
					{
						int pos=w*y+x;
						double A=a*y+b;
						if(A>wbuffer[pos])
							rgb[pos]=lineColor, wbuffer[pos]=A;
						else if(A==wbuffer[pos])
						{
							auto p=(unsigned char*)&rgb[pos], c=(unsigned char*)&lineColor;
							p[0]=(p[0]+c[0])>>1;//b
							p[1]=(p[1]+c[1])>>1;//g
							p[2]=(p[2]+c[2])>>1;//r
						}
					}
				}//*/
			}
		}
		double linearY(double x1, double y1, double x2, double y2, double x){return (y2-y1)/(x2-x1)*(x-x1)+y1;}
		double linearX(double x1, double y1, double x2, double y2, double y){return (x2-x1)/(y2-y1)*(y-y1)+x1;}
		void _3dLineOnScreen(double x1, double y1, double Xcp1, double Ycp1, double Zcp1, double x2, double y2, double Xcp2, double Ycp2, double Zcp2)
		{
			if(abs(x1)>2e9||abs(y1)>2e9||abs(x2)>2e9||abs(y2)>2e9)
			{
				bool valid=true;
				//up
				if(y1<by1)
				{
					if(y2<by1)
						valid=false;
					else
						x1=linearX(x1, y1, x2, y2, by1), y1=by1;
				}
				else if(y2<by1)
					x2=linearX(x1, y1, x2, y2, by1), y2=by1;

				if(valid)
				{
					//right
					if(x1>bx2)
					{
						if(x2>bx2)
							valid=false;
						else
							y1=linearY(x1, y1, x2, y2, bx2), x1=bx2;
					}
					else if(x2>bx2)
						y2=linearY(x1, y1, x2, y2, bx2), x2=bx2;

					if(valid)
					{
						//bottom
						if(y1>by2)
						{
							if(y2>by2)
								valid=false;
							else
								x1=linearX(x1, y1, x2, y2, by2), y1=by2;
						}
						else if(y2>by2)
							x2=linearX(x1, y1, x2, y2, by2), y2=by2;

						if(valid)
						{
							//left
							if(x1<bx1)
							{
								if(x2<bx1)
									valid=false;
								else
									y1=linearY(x1, y1, x2, y2, bx1), x1=bx1;
							}
							else if(x2<bx1)
								y2=linearY(x1, y1, x2, y2, bx1), x2=bx1;

							if(valid)
								_3dLineOnScreen_draw(x1, y1, Xcp1, Ycp1, Zcp1, x2, y2, Xcp2, Ycp2, Zcp2);
						}
					}
				}
			}
			else
				_3dLineOnScreen_draw(x1, y1, Xcp1, Ycp1, Zcp1, x2, y2, Xcp2, Ycp2, Zcp2);
		}
		void _2dExtrapolateLine(double x1, double y1, double Xcp1, double Ycp1, double Zcp1, double x2, double y2, double Xcp2, double Ycp2, double Zcp2)//P1 behind
		{
			if(x1==x2&&y1==y2)
			{
				if(Zcp1>0)
				{
					double Acp1=1/Zcp1;
					if(x1>=bx1&&x1<bx2&&y1>=by1&&y1<by2)
					{
						int pos=int(x1)+bw*int(y1);
						if(Acp1>wbuffer[pos])
							rgb[pos]=lineColor, wbuffer[pos]=Acp1;
					}
				}
			}
			else
			{
				double dx=x2-x1, dy=y2-y1, r=sqrt(2)*(abs(x2)+abs(y2)+2*(X0+Y0))/(abs(dx)+abs(dy));
				_3dLineOnScreen(x2, y2, Xcp1, Ycp1, Zcp1, x2+r*dx, y2+r*dy, Xcp2, Ycp2, Zcp2);
			}
		}
		double x0, y0, z0,
			Xs1, Ys1, Xcp1, Ycp1, Zcp1,
			Xs2, Ys2, Xcp2, Ycp2, Zcp2;
	public:
		int lineColor;//rgb
	private:
		bool isNanOrInf(double x){return (((int*)&x)[1]&0x7FF00000)==0x7FF00000;}
		void doPoint1(double x, double y, double z)
		{
			double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax;
			Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay, Zcp1=cpt*cay+dz*say;
			cpt=Zcp1*tanfov/X0, Xs1=X0+Xcp1/cpt, Ys1=Y0+Ycp1/cpt;
		}
		//world coordinates -> camera coordinates
		void point_world_camera(double dx, double dy, double dz, double &Xcp, double &Ycp, double &Zcp)
		{
			double temp=dx*cax+dy*sax;
			Xcp=dx*sax-dy*cax, Ycp=temp*say-dz*cay, Zcp=temp*cay+dz*say;
		}
		//camera coordinates -> screen coordinates
		void point_camera_screen(double Xcp, double Ycp, double Zcp, double &Xs, double &Ys)
		{
			double temp=X0/(Zcp*tanfov);
			Xs=X0+Xcp*temp, Ys=Y0+Ycp*temp;
		}
		//world coordinates -> screen coordinates		with depth info
		void point_world_screen(double dx, double dy, double dz, double &Xcp, double &Ycp, double &Zcp, double &Xs, double &Ys)
		{
			double temp=dx*cax+dy*sax;
			Xcp=dx*sax-dy*cax, Ycp=temp*say-dz*cay, Zcp=temp*cay+dz*say;
			temp=X0/(Zcp*tanfov);
			Xs=X0+Xcp*temp, Ys=Y0+Ycp*temp;
		}
		void _2dExtrapolateInfRay(double x1, double y1, double Xcp1, double Ycp1, double Zcp1, double x2, double y2, double Xcp2, double Ycp2, double Zcp2)
		{
			if(x1==x2&&y1==y2)
			{
				if(Zcp1>0)
				{
					double Acp1=1/Zcp1;
					if(x1>=bx1&&x1<bx2&&y1>=by1&&y1<by2)
					{
						int pos=int(x1)+bw*int(y1);
						if(Acp1>wbuffer[pos])
							rgb[pos]=lineColor, wbuffer[pos]=Acp1;
					}
				}
			}
			else
			{
				double dx12=x2-x1, dy12=y2-y1, r=sqrt(2)*(abs(x2)+abs(y2)+2*(X0+Y0))/(abs(dx12)+abs(dy12));
				_3dLineOnScreen(x1, y1, Xcp1, Ycp1, Zcp1, x2+r*dx12, y2+r*dy12, Xcp2, Ycp2, Zcp2);//[1 2 ->]
			}
		}
		//draws a ray starting at P1 through P2
		void infiniteRay(double x1, double y1, double z1, double x2, double y2, double z2)//[1 2 -> inf]
		{
			double Xcp1, Ycp1, Zcp1;
			point_world_camera(x1-camx, y1-camy, z1-camz, Xcp1, Ycp1, Zcp1);//P1: starting point
			double XcpInf, YcpInf, ZcpInf;
			point_world_camera(x2-x1, y2-y1, z2-z1, XcpInf, YcpInf, ZcpInf);//Inf: direction from camera
			if(ZcpInf>0)//ray pointing forward
			{
				double XsInf, YsInf;
				point_camera_screen(XcpInf, YcpInf, ZcpInf, XsInf, YsInf);//Inf
				double Xcp2, Ycp2, Zcp2;
				point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);//P2
				if(Zcp1>0)//starts in front of the camera
				{
					double Xs1, Ys1;
					point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_3dLineOnScreen(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2);
				}
				else if(Zcp1==0)//starts at the camera plane
				{
					Xcp1+=Xcp1-Xcp2, Ycp1+=Ycp1-Ycp2, Zcp1+=Zcp1-Zcp2;//1 behind
					double Xs1, Ys1;
					point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
				/*	if(_2dNotInMyFace(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2))
					{
						double dx12, dy12, r;	_2dExtrapolate(Xs1, Ys1, XsInf, YsInf, dx12, dy12, r);
						_3dLineOnScreen(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2);
					}//*/
					_2dExtrapolateLine(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2);
				}
				else//starts behind the camera
				{
					double Xs1, Ys1;
					point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateLine(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2);
				}
			}
			else if(ZcpInf==0)//ray pointing parallel to camera plane
			{
				if(Zcp1>0)//starts in front of the camera
				{
					double Xcp2, Ycp2, Zcp2, Xs2, Ys2;
					point_world_screen(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2, Xs2, Ys2);//P2
					double Xs1, Ys1;
					point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateInfRay(Xs2, Ys2, Xcp1, Ycp1, Zcp1, Xs1, Ys1, Xcp2, Ycp2, Zcp2);
				}
			}
			else//ray pointing back
			{
				if(Zcp1>0)//starts in front of the camera
				{
					double XsInf, YsInf;
					point_camera_screen(XcpInf, YcpInf, ZcpInf, XsInf, YsInf);//Inf
					double Xcp2, Ycp2, Zcp2;
					point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);//P2
					double Xs1, Ys1;
					point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateLine(XsInf, YsInf, Xcp1, Ycp1, Zcp1, Xs1, Ys1, Xcp2, Ycp2, Zcp2);
				}
			}
		}
		void _2dExtrapolateInfLine(double x1, double y1, double Xcp1, double Ycp1, double Zcp1, double x2, double y2, double Xcp2, double Ycp2, double Zcp2)
		{
			if(x1==x2&&y1==y2)
			{
				if(Zcp1>0)
				{
					double Acp1=1/Zcp1;
					if(x1>=bx1&&x1<bx2&&y1>=by1&&y1<by2)
					{
						int pos=int(x1)+bw*int(y1);
						if(Acp1>wbuffer[pos])
							rgb[pos]=lineColor, wbuffer[pos]=Acp1;
					}
				}
			}
			else
			{
				double dx12=x2-x1, dy12=y2-y1, r=sqrt(2)*(abs(x2)+abs(y2)+2*(X0+Y0))/(abs(dx12)+abs(dy12));
				_3dLineOnScreen(x1-r*dx12, y1-r*dy12, Xcp1, Ycp1, Zcp1, x1+r*dx12, y1+r*dy12, Xcp2, Ycp2, Zcp2);//[<- 1 2 ->]
			}
		}
		//draws the line through P1 and P2
		void infiniteLine(double x1, double y1, double z1, double x2, double y2, double z2)//[inf <- 1 2 -> inf]
		{
			double Xcp1, Ycp1, Zcp1;
			point_world_camera(x1-camx, y1-camy, z1-camz, Xcp1, Ycp1, Zcp1);//P1
			double XcpInf, YcpInf, ZcpInf;
			point_world_camera(x2-x1, y2-y1, z2-z1, XcpInf, YcpInf, ZcpInf);//1-2 from cam
			if(ZcpInf>0)//1-2 points forward
			{
				double XsInf, YsInf;
				point_camera_screen(XcpInf, YcpInf, ZcpInf, XsInf, YsInf);//Inf

				double Xcp2, Ycp2, Zcp2;
				point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);//P2
				if(Zcp1>0)//P1 in front of the camera
				{
					double Xs1, Ys1;
					point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateInfRay(XsInf, YsInf, Xcp1, Ycp1, Zcp1, Xs1, Ys1, Xcp2, Ycp2, Zcp2);
				}
				else
				{
					if(Zcp1==0)//P1 at the camera plane
						Xcp1+=Xcp1-Xcp2, Ycp1+=Ycp1-Ycp2, Zcp1+=Zcp1-Zcp2;
					double Xs1, Ys1;
					point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateLine(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2);//P1 behind the camera
				}
			}
			else if(ZcpInf==0)//1-2 is parallel to cam plane
			{
				if(Zcp1>0)//in front of cam
				{
					double Xcp2, Ycp2, Zcp2, Xs2, Ys2;
					point_world_screen(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2, Xs2, Ys2);//P2
					double Xs1, Ys1;
					point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateInfLine(Xs2, Ys2, Xcp1, Ycp1, Zcp1, Xs1, Ys1, Xcp2, Ycp2, Zcp2);
				}
			}
			else//1-2 points back
			{
				double XsInf, YsInf;
				point_camera_screen(XcpInf, YcpInf, ZcpInf, XsInf, YsInf);//Inf

				double Xcp2, Ycp2, Zcp2;
				point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);//P2
				if(Zcp1>0)//P1 in front of cam
				{
					double Xs1, Ys1;
					point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateInfRay(XsInf, YsInf, Xcp1, Ycp1, Zcp1, Xs1, Ys1, Xcp2, Ycp2, Zcp2);
				}
				else
				{
					if(Zcp1==0)//P1 at cam plane
						Xcp1-=Xcp1-Xcp2, Ycp1-=Ycp1-Ycp2, Zcp1-=Zcp1-Zcp2;
					double Xs1, Ys1;
					point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateLine(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2);//P1 behind the camera
				}
			}
		}
		int continuous;
	public:
		void curve_start(){continuous=0;}
		void curve_point(double x, double y, double z)
		{
			if(continuous)
				line(x0, y0, z0, x, y, z);
			else
			{
				point(x, y, z);
				continuous=1;
			}
			x0=x, y0=y, z0=z;
		}

		void moveTo(double x, double y, double z){x0=x, y0=y, z0=z;}
		void lineTo(double x, double y, double z){line(x0, y0, z0, x, y, z);}
		void line(double x1, double y1, double z1, double x2, double y2, double z2)
		{
			int drawn=0;
			switch(isNanOrInf(x1)+isNanOrInf(y1)+isNanOrInf(z1)+isNanOrInf(x2)+isNanOrInf(y2)+isNanOrInf(z2))
			{
			case 0:
				{
					{
						double dx=x1-camx, dy=y1-camy, dz=z1-camz, cpt=dx*cax+dy*sax;
						Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay, Zcp1=cpt*cay+dz*say;
					}
					double dx=x2-camx, dy=y2-camy, dz=z2-camz, cpt=dx*cax+dy*sax, Xcp2=dx*sax-dy*cax, Ycp2=cpt*say-dz*cay, Zcp2=cpt*cay+dz*say;
					if(Zcp2>0)
					{
						if(Zcp1>0)
						{
							cpt=X0/(Zcp1*tanfov), Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
							cpt=X0/(Zcp2*tanfov), Xs2=X0+Xcp2*cpt, Ys2=Y0+Ycp2*cpt;
							_3dLineOnScreen(Xs1, Ys1, Xcp1, Ycp1, Zcp1, Xs2, Ys2, Xcp2, Ycp2, Zcp2);
						}
						else if(Zcp1==0)
						{
							Xcp1+=Xcp1-Xcp2, Ycp1+=Ycp1-Ycp2, Zcp1+=Zcp1-Zcp2;
							cpt=X0/(Zcp1*tanfov), Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
							cpt=X0/(Zcp2*tanfov), Xs2=X0+Xcp2*cpt, Ys2=Y0+Ycp2*cpt;
							_2dExtrapolateLine(Xs1, Ys1, Xcp1, Ycp1, Zcp1, Xs2, Ys2, Xcp2, Ycp2, Zcp2);
						}
						else
						{
							cpt=X0/(Zcp1*tanfov), Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
							cpt=X0/(Zcp2*tanfov), Xs2=X0+Xcp2*cpt, Ys2=Y0+Ycp2*cpt;
							_2dExtrapolateLine(Xs1, Ys1, Xcp1, Ycp1, Zcp1, Xs2, Ys2, Xcp2, Ycp2, Zcp2);
						}
						drawn=1;
					}
					else if(Zcp2==0)
					{
						if(Zcp1>0)
						{
							Xcp2+=Xcp2-Xcp1, Ycp2+=Ycp2-Ycp1, Zcp2+=Zcp2-Zcp1;
							cpt=X0/(Zcp1*tanfov), Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
							cpt=X0/(Zcp2*tanfov), Xs2=X0+Xcp2*cpt, Ys2=Y0+Ycp2*cpt;
							_2dExtrapolateLine(Xs2, Ys2, Xcp1, Ycp1, Zcp1, Xs1, Ys1, Xcp2, Ycp2, Zcp2), drawn=1;
						}
					}
					else if(Zcp1>0)
					{
						cpt=X0/(Zcp1*tanfov), Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
						cpt=X0/(Zcp2*tanfov), Xs2=X0+Xcp2*cpt, Ys2=Y0+Ycp2*cpt;
						_2dExtrapolateLine(Xs2, Ys2, Xcp1, Ycp1, Zcp1, Xs1, Ys1, Xcp2, Ycp2, Zcp2), drawn=1;
					}
				}
				break;
			case 1:
				{
					if(isinf(x1))
						infiniteRay(x2, y2, z2, x1==_HUGE?x2+1:x2-1, y2, z2), drawn=1;
					else if(isinf(y1))
						infiniteRay(x2, y2, z2, x2, y1==_HUGE?y2+1:y2-1, z2), drawn=1;
					else if(isinf(z1))
						infiniteRay(x2, y2, z2, x2, y2, z1==_HUGE?z2+1:z2-1), drawn=1;
					else if(isinf(x2))
						infiniteRay(x1, y1, z1, x2==_HUGE?x1+1:x1-1, y1, z1), drawn=1;
					else if(isinf(y2))
						infiniteRay(x1, y1, z1, x1, y2==_HUGE?y1+1:y1-1, z1), drawn=1;
					else if(isinf(z2))
						infiniteRay(x1, y1, z1, x1, y1, z2==_HUGE?z1+1:z1-1), drawn=1;
				}
				break;
			case 2:
				{
					if(isinf(x1)&&isinf(x2))
					{
						if(y1==x2&&z1==z2)
							infiniteLine(camx, x2, z2, camx+1, x2, z2), drawn=1;
					}
					else if(isinf(y1)&&isinf(x2))
					{
						if(z1==z2&&x1==x2)
							infiniteLine(x2, camy, z2, x2, camy+1, z2), drawn=1;
					}
					else if(isinf(z1)&&isinf(z2))
					{
						if(x1==x2&&y1==x2)
							infiniteLine(x2, x2, camz, x2, x2, camz+1), drawn=1;
					}
				}
				break;
			}
			if(!drawn)
			{
				if(!(isNanOrInf(x1)+isNanOrInf(y1)+isNanOrInf(z1)))
					point(x1, y1, z1);
				else if(!(isNanOrInf(x2)+isNanOrInf(x2)+isNanOrInf(z2)))
					point(x1, y1, z1);
			}
		}

	private:
		int *libuffer, *lfbuffer;
	public:
		void triangle_halfTransparent(Triangle &Tr, int color)
		{
			double dx, dy, dz, cpt, v1[5], v2[5], v3[5], admittance;
			dx=Tr.X1-camx, dy=Tr.Y1-camy, dz=Tr.Z1-camz, cpt=dx*cax+dy*sax, v1[2]=dx*sax-dy*cax, v1[3]=cpt*say-dz*cay, v1[4]=cpt*cay+dz*say, cpt=v1[4]*tanfov/X0, v1[0]=X0+v1[2]/cpt, v1[1]=Y0+v1[3]/cpt;
			dx=Tr.X2-camx, dy=Tr.Y2-camy, dz=Tr.Z2-camz, cpt=dx*cax+dy*sax, v2[2]=dx*sax-dy*cax, v2[3]=cpt*say-dz*cay, v2[4]=cpt*cay+dz*say, cpt=v2[4]*tanfov/X0, v2[0]=X0+v2[2]/cpt, v2[1]=Y0+v2[3]/cpt;
			dx=Tr.X3-camx, dy=Tr.Y3-camy, dz=Tr.Z3-camz, cpt=dx*cax+dy*sax, v3[2]=dx*sax-dy*cax, v3[3]=cpt*say-dz*cay, v3[4]=cpt*cay+dz*say, cpt=v3[4]*tanfov/X0, v3[0]=X0+v3[2]/cpt, v3[1]=Y0+v3[3]/cpt;
			if(v1[4]<0&&v2[4]<0&&v3[4]<0)		return;
			for(int k2=0;k2<h;++k2)libuffer[k2]=w; memset(lfbuffer, 0, h*sizeof(int));
			if(v1[4]<0||v2[4]<0||v3[4]<0)
			{
					 if(v1[4]<0	&&	v2[4]<0				)	draft_2behind(v3, v1, v2);
				else if(			v2[4]<0	&&	v3[4]<0	)	draft_2behind(v1, v2, v3);
				else if(v1[4]<0				&&	v3[4]<0	)	draft_2behind(v2, v3, v1);
				else if(v1[4]<0							)	draft_1behind(v2, v3, v1);
				else if(			v2[4]<0				)	draft_1behind(v3, v1, v2);
				else										draft_1behind(v1, v2, v3);
			}
			else											draft_start(v1, v2), draft(v2, v3), draft(v3, v1);
			double au12=v2[2]-v1[2],			bu12=v2[3]-v1[3],			cu12=v2[4]-v1[4];									//u12	=<12>
			double aux3=v3[2]-v1[2],			bux3=v3[3]-v1[3],			cux3=v3[4]-v1[4];									//ux3	=<13>
			double a=bu12*cux3-bux3*cu12,		b=aux3*cu12-au12*cux3,		c=au12*bux3-aux3*bu12;								//abc	=<n>	=<12>x<13>
			double t=a*v1[2]+b*v1[3]+c*v1[4];
			if(!t)return;
			double B7=a, B8=b, B9=c*X0/tanfov-a*X0-b*Y0;	cpt=t*X0/tanfov;
			double A1=B7/cpt, A2=B8/cpt, A3=B9/cpt;
			double *wbk=wbuffer;
			int libk, lfbk;
			int *rgbk=rgb;

			auto C=(unsigned char*)&color;
			for(int k2=0;k2<h;++k2)
			{
				libk=libuffer[k2]<0?0:libuffer[k2], lfbk=lfbuffer[k2]>w?w:lfbuffer[k2];
				admittance=A1*libk+A2*k2+A3;
				for(int k3=libk;k3<lfbk;++k3)
				{
					if(admittance>wbk[k3])
					{
						auto p=(unsigned char*)&rgbk[k3];
						p[0]=p[0]*C[0]>>8, p[1]=p[1]*C[1]>>8, p[2]=p[2]*C[2]>>8;
					}
					admittance+=A1;
				}
				wbk=wbk+w, rgbk=rgbk+w;
			}
		}
		void triangle_halfTransparent(double x1, double y1, double z1, double x2, double y2, double z2, double x3, double y3, double z3, int color)
		{
			double dx, dy, dz, cpt, v1[5], v2[5], v3[5], admittance;
			dx=x1-camx, dy=y1-camy, dz=z1-camz, cpt=dx*cax+dy*sax, v1[2]=dx*sax-dy*cax, v1[3]=cpt*say-dz*cay, v1[4]=cpt*cay+dz*say, cpt=v1[4]*tanfov/X0, v1[0]=X0+v1[2]/cpt, v1[1]=Y0+v1[3]/cpt;
			dx=x2-camx, dy=y2-camy, dz=z2-camz, cpt=dx*cax+dy*sax, v2[2]=dx*sax-dy*cax, v2[3]=cpt*say-dz*cay, v2[4]=cpt*cay+dz*say, cpt=v2[4]*tanfov/X0, v2[0]=X0+v2[2]/cpt, v2[1]=Y0+v2[3]/cpt;
			dx=x3-camx, dy=y3-camy, dz=z3-camz, cpt=dx*cax+dy*sax, v3[2]=dx*sax-dy*cax, v3[3]=cpt*say-dz*cay, v3[4]=cpt*cay+dz*say, cpt=v3[4]*tanfov/X0, v3[0]=X0+v3[2]/cpt, v3[1]=Y0+v3[3]/cpt;
			if(v1[4]<0&&v2[4]<0&&v3[4]<0)		return;
			for(int k2=0;k2<h;++k2)libuffer[k2]=w; memset(lfbuffer, 0, h*sizeof(int));
			if(v1[4]<0||v2[4]<0||v3[4]<0)
			{
					 if(v1[4]<0	&&	v2[4]<0				)	draft_2behind(v3, v1, v2);
				else if(			v2[4]<0	&&	v3[4]<0	)	draft_2behind(v1, v2, v3);
				else if(v1[4]<0				&&	v3[4]<0	)	draft_2behind(v2, v3, v1);
				else if(v1[4]<0							)	draft_1behind(v2, v3, v1);
				else if(			v2[4]<0				)	draft_1behind(v3, v1, v2);
				else										draft_1behind(v1, v2, v3);
			}
			else											draft_start(v1, v2), draft(v2, v3), draft(v3, v1);
			double au12=v2[2]-v1[2],			bu12=v2[3]-v1[3],			cu12=v2[4]-v1[4];									//u12	=<12>
			double aux3=v3[2]-v1[2],			bux3=v3[3]-v1[3],			cux3=v3[4]-v1[4];									//ux3	=<13>
			double a=bu12*cux3-bux3*cu12,		b=aux3*cu12-au12*cux3,		c=au12*bux3-aux3*bu12;								//abc	=<n>	=<12>x<13>
			double t=a*v1[2]+b*v1[3]+c*v1[4];
			if(!t)return;
			double B7=a, B8=b, B9=c*X0/tanfov-a*X0-b*Y0;	cpt=t*X0/tanfov;
			double A1=B7/cpt, A2=B8/cpt, A3=B9/cpt;
			double *wbk=wbuffer;
			int libk, lfbk;
			int *rgbk=rgb;

			auto C=(unsigned char*)&color;
			for(int k2=0;k2<h;++k2)
			{
				libk=libuffer[k2]<0?0:libuffer[k2], lfbk=lfbuffer[k2]>w?w:lfbuffer[k2];
				admittance=A1*libk+A2*k2+A3;
				for(int k3=libk;k3<lfbk;++k3)
				{
					if(admittance>wbk[k3])
					{
						auto p=(unsigned char*)&rgbk[k3];
						p[0]=p[0]*C[0]>>8, p[1]=p[1]*C[1]>>8, p[2]=p[2]*C[2]>>8;
					}
					admittance+=A1;
				}
				wbk=wbk+w, rgbk=rgbk+w;
			}
		}
		void draft_1behind		(double *v1, double *v2, double *v3)
		{
			draft_start(v1, v2);
			draft_crit(v3, v1);
			draft_crit(v3, v2);
			if(v3[1]>v1[1]&&v3[1]<v2[1]||v3[1]>v2[1]&&v3[1]<v1[1]){		 if(v3[0]<(v2[0]-v1[0])*(v3[1]-v1[1])/(v2[1]-v1[1])+v1[0])	for(int k=0;k<h;++k)lfbuffer[k]=w;
																	else															memset(libuffer, 0, h*sizeof(int));}
		}
		void draft_2behind		(double *v1, double *v2, double *v3)
		{
			draft_crit_start(v2, v1);
			draft_crit(v3, v1);
			if(v1[1]>v2[1]&&v1[1]<v3[1]||v1[1]>v3[1]&&v1[1]<v2[1]){		 if(v1[0]<(v3[0]-v2[0])*(v1[1]-v2[1])/(v3[1]-v2[1])+v2[0])	memset(libuffer, 0, h*sizeof(int));
																	else															for(int k=0;k<h;++k)lfbuffer[k]=w;}
		}
		void draft_start		(double *v1, double *v2)
		{
			int k2;double k3, A=(v2[0]-v1[0])/(v2[1]-v1[1]);
				 if(v1[1]<v2[1]){	k3=v1[0]+A*((long long)(v1[1]<0?0:v1[1])+1-v1[1]);		 if(v1[0]<v2[0])for(long long k=long long(v1[1])<0?	0:long long(v1[1])	+1;k<h&&k<v2[1]	;++k)	k2=int(k3), k2=k2<0?v1[0]>0?int(v1[0]):0:k2>w?v2[0]<w?int(v2[0]):w:k2<v1[0]?int(v1[0]):k2>v2[0]?int(v2[0]):k2, libuffer[k]=lfbuffer[k]=k2, k3+=A;
																						else				for(long long k=long long(v1[1])<0?	0:long long(v1[1])	+1;k<h&&k<v2[1]	;++k)	k2=int(k3), k2=k2<0?v2[0]>0?int(v2[0]):0:k2>w?v1[0]<w?int(v1[0]):w:k2<v2[0]?int(v2[0]):k2>v1[0]?int(v1[0]):k2, libuffer[k]=lfbuffer[k]=k2, k3+=A;}
			else				{	k3=v1[0]+A*((long long)(v2[1]<0?0:v2[1])+1-v1[1]);		 if(v1[0]<v2[0])for(long long k=long long(v2[1])<0?	0:long long(v2[1])	+1;k<h&&k<v1[1]	;++k)	k2=int(k3), k2=k2<0?v1[0]>0?int(v1[0]):0:k2>w?v2[0]<w?int(v2[0]):w:k2<v1[0]?int(v1[0]):k2>v2[0]?int(v2[0]):k2, libuffer[k]=lfbuffer[k]=k2, k3+=A;
																						else				for(long long k=long long(v2[1])<0?	0:long long(v2[1])	+1;k<h&&k<v1[1]	;++k)	k2=int(k3), k2=k2<0?v2[0]>0?int(v2[0]):0:k2>w?v1[0]<w?int(v1[0]):w:k2<v2[0]?int(v2[0]):k2>v1[0]?int(v1[0]):k2, libuffer[k]=lfbuffer[k]=k2, k3+=A;}
		}
		void draft				(double *v1, double *v2)
		{
			int k2;double k3, A=(v2[0]-v1[0])/(v2[1]-v1[1]);
				 if(v1[1]<v2[1]){	k3=v1[0]+A*((long long)(v1[1]<0?0:v1[1])+1-v1[1]);		 if(v1[0]<v2[0])for(long long k=long long(v1[1])<0?	0:long long(v1[1])	+1;k<h&&k<v2[1]	;++k)	k2=int(k3), k2=k2<0?v1[0]>0?int(v1[0]):0:k2>w?v2[0]<w?int(v2[0]):w:k2<v1[0]?int(v1[0]):k2>v2[0]?int(v2[0]):k2, libuffer[k]=k2>=libuffer[k]?libuffer[k]:k2, lfbuffer[k]=k2<=lfbuffer[k]?lfbuffer[k]:k2, k3+=A;
																						else				for(long long k=long long(v1[1])<0?	0:long long(v1[1])	+1;k<h&&k<v2[1]	;++k)	k2=int(k3), k2=k2<0?v2[0]>0?int(v2[0]):0:k2>w?v1[0]<w?int(v1[0]):w:k2<v2[0]?int(v2[0]):k2>v1[0]?int(v1[0]):k2, libuffer[k]=k2>=libuffer[k]?libuffer[k]:k2, lfbuffer[k]=k2<=lfbuffer[k]?lfbuffer[k]:k2, k3+=A;}
			else				{	k3=v1[0]+A*((long long)(v2[1]<0?0:v2[1])+1-v1[1]);		 if(v1[0]<v2[0])for(long long k=long long(v2[1])<0?	0:long long(v2[1])	+1;k<h&&k<v1[1]	;++k)	k2=int(k3), k2=k2<0?v1[0]>0?int(v1[0]):0:k2>w?v2[0]<w?int(v2[0]):w:k2<v1[0]?int(v1[0]):k2>v2[0]?int(v2[0]):k2, libuffer[k]=k2>=libuffer[k]?libuffer[k]:k2, lfbuffer[k]=k2<=lfbuffer[k]?lfbuffer[k]:k2, k3+=A;
																						else				for(long long k=long long(v2[1])<0?	0:long long(v2[1])	+1;k<h&&k<v1[1]	;++k)	k2=int(k3), k2=k2<0?v2[0]>0?int(v2[0]):0:k2>w?v1[0]<w?int(v1[0]):w:k2<v2[0]?int(v2[0]):k2>v1[0]?int(v1[0]):k2, libuffer[k]=k2>=libuffer[k]?libuffer[k]:k2, lfbuffer[k]=k2<=lfbuffer[k]?lfbuffer[k]:k2, k3+=A;}
		}
		void draft_crit_start	(double *v1, double *v2)
		{
			int k2;double k3, A=(v2[0]-v1[0])/(v2[1]-v1[1]);
				 if(v1[1]<v2[1]){	k3=v1[0]+A*((long long)(v2[1]<0?0:v2[1])+1-v1[1]);		 if(v1[0]<v2[0])for(long long k=long long(v2[1])<0?	0:long long(v2[1])	+1;k<h			;++k)	k2=int(k3), k2=k2<0?v2[0]>0?int(v2[0]):0:k2>w?w:k2<v2[0]?int(v2[0]):k2, libuffer[k]=lfbuffer[k]=k2, k3+=A;
																						else				for(long long k=long long(v2[1])<0?	0:long long(v2[1])	+1;k<h			;++k)	k2=int(k3), k2=k2<0?0:k2>w?v2[0]<w?int(v2[0]):w:k2>v2[0]?int(v2[0]):k2, libuffer[k]=lfbuffer[k]=k2, k3+=A;}
			else				{	k3=v1[0]-A*((long long)v1[1]+1);						 if(v1[0]<v2[0])for(long long k=					0					+1;k<h&&k<v2[1]	;++k)	k2=int(k3), k2=k2<0?v2[0]>0?int(v2[0]):0:k2>w?w:k2<v2[0]?int(v2[0]):k2, libuffer[k]=lfbuffer[k]=k2, k3+=A;
																						else				for(long long k=					0					+1;k<h&&k<v2[1]	;++k)	k2=int(k3), k2=k2<0?0:k2>w?v2[0]<w?int(v2[0]):w:k2>v2[0]?int(v2[0]):k2, libuffer[k]=lfbuffer[k]=k2, k3+=A;}
		}
		void draft_crit			(double *v1, double *v2)
		{
			int k2;double k3, A=(v2[0]-v1[0])/(v2[1]-v1[1]);
				 if(v1[1]<v2[1]){	k3=v1[0]+A*((long long)(v2[1]<0?0:v2[1])+1-v1[1]);		 if(v1[0]<v2[0])for(long long k=long long(v2[1])<0?	0:long long(v2[1])	+1;k<h			;++k)	k2=int(k3), k2=k2<0?v2[0]>0?int(v2[0]):0:k2>w?w:k2<v2[0]?int(v2[0]):k2, libuffer[k]=k2>=libuffer[k]?libuffer[k]:k2, lfbuffer[k]=k2<=lfbuffer[k]?lfbuffer[k]:k2, k3+=A;
																						else				for(long long k=long long(v2[1])<0?	0:long long(v2[1])	+1;k<h			;++k)	k2=int(k3), k2=k2<0?0:k2>w?v2[0]<w?int(v2[0]):w:k2>v2[0]?int(v2[0]):k2, libuffer[k]=k2>=libuffer[k]?libuffer[k]:k2, lfbuffer[k]=k2<=lfbuffer[k]?lfbuffer[k]:k2, k3+=A;}
			else				{	k3=v1[0]-A*((long long)v1[1]+1);						 if(v1[0]<v2[0])for(long long k=					0					+1;k<h&&k<v2[1]	;++k)	k2=int(k3), k2=k2<0?v2[0]>0?int(v2[0]):0:k2>w?w:k2<v2[0]?int(v2[0]):k2, libuffer[k]=k2>=libuffer[k]?libuffer[k]:k2, lfbuffer[k]=k2<=lfbuffer[k]?lfbuffer[k]:k2, k3+=A;
																						else				for(long long k=					0					+1;k<h&&k<v2[1]	;++k)	k2=int(k3), k2=k2<0?0:k2>w?v2[0]<w?int(v2[0]):w:k2>v2[0]?int(v2[0]):k2, libuffer[k]=k2>=libuffer[k]?libuffer[k]:k2, lfbuffer[k]=k2<=lfbuffer[k]?lfbuffer[k]:k2, k3+=A;}
		}
	private:
	//	char buf[128];
	//	int buflen;
	public:
		void label(double x, double y, double z, char const *format, ...)
		{
			double Xcp, Ycp, Zcp;
			point_world_camera(x-camx, y-camy, z-camz, Xcp, Ycp, Zcp);
			if(Zcp>0)
			{
				double Xs, Ys;
				point_camera_screen(Xcp, Ycp, Zcp, Xs, Ys);
				//auto LOL_0=&format;
				//auto LOL_05=&format+1;
				//auto LOL_06=(char*)&(const char&)format+4;
				//auto LOL_07=(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3);
				//auto LOL_1=(char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3);
				//auto LOL_2=(char*)(&format+1);
				if(abs(Xs)<1e6&&abs(Ys)<1e6&&vsprintf_s(g_buf, g_buf_size, format, (char*)(&format+1))>0)
				//if(abs(Xs)<1e6&&abs(Ys)<1e6&&vsprintf_s(g_buf, g_buf_size, format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3))>0)
					LOL_text[1/Zcp].push_back(Text(int(Xs)-(Xs<0), int(Ys)-(Ys<0), TRANSPARENT, g_buf));//-0.5 truncated as 0
			//	if(abs(Xs)<1e6&&abs(Ys)<1e6&&vsprintf_s(buf, sizeof(buf), format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3))>0)
			//		LOL_text[1/Zcp].push_back(Text(int(Xs)-(Xs<0), int(Ys)-(Ys<0), TRANSPARENT, buf));//-0.5 truncated as 0
			}
		}
	private:
		int clipX1, clipY1, clipX2, clipY2;
		//	->1->2->		+depth info
		bool arrowLabel_2dLine(double &x1, double &y1, double &x2, double &y2)
		{
			if(y1==y2)
			{
				if(y2<clipY1||y2>clipY2)
					return false;
				if(x1>x2)
				{
					double tx=x2, ty=y2;
					y2=linearY(x1, y1, x2, y2, clipX1), x2=clipX1;
					y1=linearY(x1, y1, tx, ty, clipX2), x1=clipX2;
				}
				else
				{
					double tx=x2, ty=y2;
					y2=linearY(x1, y1, x2, y2, clipX2), x2=clipX2;
					y1=linearY(x1, y1, tx, ty, clipX1), x1=clipX1;
				}
			}
			else
			{
				if(y1>y2)							//	<-	<-	Y1	<-	<-	Y2	<-	<-
				{
					double tx=x2, ty=y2;
					x2=linearX(x1, y1, x2, y2, clipY1), y2=clipY1;
					x1=linearX(x1, y1, tx, ty, clipY2), y1=clipY2;
				}
				else								//	->	->	Y1	->	->	Y2	->	->
				{
					double tx=x2, ty=y2;
					x2=linearX(x1, y1, x2, y2, clipY2), y2=clipY2;
					x1=linearX(x1, y1, tx, ty, clipY1), y1=clipY1;
				}
				if(x2<clipX1)
				{
					if(x1<clipX1)
						return false;
					else if(x1>clipX2)
					{
						double tx=x2, ty=y2;
						y2=linearY(x1, y1, x2, y2, clipX1), x2=clipX1;
						y1=linearY(x1, y1, tx, ty, clipX2), x1=clipX2;
					}
					else
						y2=linearY(x1, y1, x2, y2, clipX1), x2=clipX1;
				}
				else if(x2>clipX2)
				{
					if(x1<clipX1)
					{
						double tx=x2, ty=y2;
						y2=linearY(x1, y1, x2, y2, clipX2), x2=clipX2;
						y1=linearY(x1, y1, tx, ty, clipX1), x1=clipX1;
					}
					else if(x1>clipX2)
						return false;
					else
						y2=linearY(x1, y1, x2, y2, clipX2), x2=clipX2;
				}
				else
				{
					if(x1<clipX1)
						y1=linearY(x1, y1, x2, y2, clipX1), x1=clipX1;
					else if(x1>clipX2)
						y1=linearY(x1, y1, x2, y2, clipX2), x1=clipX2;
				}
			}
			return true;
		}
		//	->1->2		+depth info
		bool arrowLabel_2dRay(double &x1, double &y1, double &x2, double &y2)
		{
			if(y1==y2)
			{
				if(y2<clipY1||y2>clipY2)
					return false;
				if(x1>x2)
				{
					double tx=x2, ty=y2;
					y2=linearY(x1, y1, x2, y2, clipX1), x2=clipX1;
					y1=linearY(x1, y1, tx, ty, clipX2), x1=clipX2;
				}
				else
				{
					double tx=x2, ty=y2;
					y2=linearY(x1, y1, x2, y2, clipX2), x2=clipX2;
					y1=linearY(x1, y1, tx, ty, clipX1), x1=clipX1;
				}
			}
			else
			{
				if(y1>y2)
				{
					if(y2<clipY1)					//	y2	<-	Y1	<-	<-	Y2	<-	<-
					{
						double tx=x2, ty=y2;
						x2=linearX(x1, y1, x2, y2, clipY1), y2=clipY1;
						x1=linearX(x1, y1, tx, ty, clipY2), y1=clipY2;
					}
					else if(y2>clipY2)				//			Y1			Y2	y2	<-
						return false;
					else							//			Y1	y2	<-	Y2	<-	<-
						x1=linearX(x1, y1, x2, y2, clipY2), y1=clipY2;
				}
				else
				{
					if(y2<clipY1)					//	->	y2	Y1			Y2
						return false;
					else if(y2>clipY2)				//	->	->	Y1	->	->	Y2	->	y2
					{
						double tx=x2, ty=y2;
						x2=linearX(x1, y1, x2, y2, clipY2), y2=clipY2;
						x1=linearX(x1, y1, tx, ty, clipY1), y1=clipY1;
					}
					else							//	->	->	Y1	->	y2	Y2
						x1=linearX(x1, y1, x2, y2, clipY1), y1=clipY1;
				}
				if(x2<clipX1)
				{
					if(x1<clipX1)
						return false;
					else if(x1>clipX2)
					{
						double tx=x2, ty=y2;
						y2=linearY(x1, y1, x2, y2, clipX1), x2=clipX1;
						y1=linearY(x1, y1, tx, ty, clipX2), x1=clipX2;
					}
					else
						y2=linearY(x1, y1, x2, y2, clipX1), x2=clipX1;
				}
				else if(x2>clipX2)
				{
					if(x1<clipX1)
					{
						double tx=x2, ty=y2;
						y2=linearY(x1, y1, x2, y2, clipX2), x2=clipX2;
						y1=linearY(x1, y1, tx, ty, clipX1), x1=clipX1;
					}
					else if(x1>clipX2)
						return false;
					else
						y2=linearY(x1, y1, x2, y2, clipX2), x2=clipX2;
				}
				else
				{
					if(x1<clipX1)
						y1=linearY(x1, y1, x2, y2, clipX1), x1=clipX1;
					else if(x1>clipX2)
						y1=linearY(x1, y1, x2, y2, clipX2), x1=clipX2;
				}
			}
			return true;
		}
		//	1 2<-		+depth info
		bool arrowLabel_2dExtrapolateRay(double &Xs1, double &Ys1, double &Xs2, double &Ys2)
		{
			double dx=Xs2-Xs1, dy=Ys2-Ys1, r=sqrt(2)*(abs(Xs2)+abs(Ys2)+2*(X0+Y0))/(abs(dx)+abs(dy));
			return arrowLabel_2dRay(Xs1=Xs2+r*dx, Ys1=Ys2+r*dy, Xs2, Ys2);
		}
		void arrowLabel_finishPoint1(double &x1, double &y1, double Xcp1, double Ycp1, double Zcp1, double &x2, double &y2, double Xcp2, double Ycp2, double Zcp2, int &Xs, int &Ys, double &A)
		{
			double dx=x2-x1, dy=y2-y1, a, b;
			if(abs(dx)>abs(dy))
			{
				line_A_coeff_x(Xcp1, Ycp1, Zcp1, Xcp2, Ycp2, Zcp2, a, b);
				A=a*x1+b;
			}
			else
			{
				line_A_coeff_y(Xcp1, Ycp1, Zcp1, Xcp2, Ycp2, Zcp2, a, b);
				A=a*y1+b;
			}
			Xs=int(x1), Ys=int(y1);
		}
		void arrowLabel_finishPoint2(double &x1, double &y1, double Xcp1, double Ycp1, double Zcp1, double &x2, double &y2, double Xcp2, double Ycp2, double Zcp2, int &Xs, int &Ys, double &A)
		{
			double dx=x2-x1, dy=y2-y1, a, b;
			if(abs(dx)>abs(dy))
			{
				line_A_coeff_x(Xcp1, Ycp1, Zcp1, Xcp2, Ycp2, Zcp2, a, b);
				A=a*x2+b;
			}
			else
			{
				line_A_coeff_y(Xcp1, Ycp1, Zcp1, Xcp2, Ycp2, Zcp2, a, b);
				A=a*y2+b;
			}
			Xs=int(x2), Ys=int(y2);
		}
		bool arrowLabel_infiniteRay(double x1, double y1, double z1, double x2, double y2, double z2, int &Xs, int &Ys, double &A)
		{
			bool valid=false;
			double Xcp1, Ycp1, Zcp1;		point_world_camera(x1-camx, y1-camy, z1-camz, Xcp1, Ycp1, Zcp1);
			double XcpInf, YcpInf, ZcpInf;	point_world_camera(x2-x1, y2-y1, z2-z1, XcpInf, YcpInf, ZcpInf);
			if(ZcpInf>0)
			{
				double XsInf, YsInf;	point_camera_screen(XcpInf, YcpInf, ZcpInf, XsInf, YsInf);
				if(Zcp1>0)		//		|	P1	->Inf
				{
					double Xcp2, Ycp2, Zcp2;	point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);
					double Xs1, Ys1;			point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					if(arrowLabel_2dRay(Xs1, Ys1, XsInf, YsInf))
					{
						arrowLabel_finishPoint2(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2, Xs, Ys, A);
						return true;
					}
				}
				else if(Zcp1==0)//		|P1|	->Inf
				{
					double Xcp2, Ycp2, Zcp2;	point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);//P2
					Xcp1+=Xcp1-Xcp2, Ycp1+=Ycp1-Ycp2, Zcp1+=Zcp1-Zcp2;//P1 behind
					double Xs1, Ys1;			point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					if(arrowLabel_2dExtrapolateRay(Xs1, Ys1, XsInf, YsInf))
					{
						arrowLabel_finishPoint2(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2, Xs, Ys, A);
						return true;
					}
				}
				else			//P1	|	->Inf
				{
					double Xcp2, Ycp2, Zcp2;	point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);
					double Xs1, Ys1;			point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					if(arrowLabel_2dExtrapolateRay(Xs1, Ys1, XsInf, YsInf))
					{
						arrowLabel_finishPoint2(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2, Xs, Ys, A);
						return true;
					}
				}
			}
			else if(ZcpInf==0)
			{
				if(Zcp1>0)		//		|	//P1->Inf
				{
					double Xcp2, Ycp2, Zcp2, Xs2, Ys2;	point_world_screen(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2, Xs2, Ys2);
					double Xs1, Ys1;					point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					if(arrowLabel_2dLine(Xs1, Ys1, Xs2, Ys2))
					{
						arrowLabel_finishPoint2(Xs1, Ys1, Xcp1, Ycp1, Zcp1, Xcp2, Ycp2, Xcp2, Ycp2, Zcp2, Xs, Ys, A);
						return true;
					}
				}
			}
			else
			{
				double XsInf, YsInf;	point_camera_screen(XcpInf, YcpInf, ZcpInf, XsInf, YsInf);
				if(Zcp1>0)		//Inf<-	|	P1
				{
					double Xcp2, Ycp2, Zcp2;	point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);
					double Xs1, Ys1;			point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					if(arrowLabel_2dRay(Xs1, Ys1, XsInf, YsInf))
					{
						arrowLabel_finishPoint1(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2, Xs, Ys, A);
						return true;
					}
				}
				else if(Zcp1==0)//Inf<-	|P1|
				{
					double Xcp2, Ycp2, Zcp2;	point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);
					Xcp1+=Xcp1-Xcp2, Ycp1+=Ycp1-Ycp2, Zcp1+=Zcp1-Zcp2;//P1 behind
					double Xs1, Ys1;			point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					if(arrowLabel_2dExtrapolateRay(Xs1, Ys1, XsInf, YsInf))
					{
						arrowLabel_finishPoint1(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2, Xs, Ys, A);
						return true;
					}
				}
				else			//Inf<-	P1	|
				{
					double Xcp2, Ycp2, Zcp2;	point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);
					double Xs1, Ys1;			point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					if(arrowLabel_2dExtrapolateRay(Xs1, Ys1, XsInf, YsInf))
					{
						arrowLabel_finishPoint1(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2, Xs, Ys, A);
						return true;
					}
				}
			}
			return false;

		/*	posInf=doPointFromCam(x2-x1, y2-y1, z2-z1, Xs2, Ys2)>0;
			doPoint1(x1, y1, z1);
			if(Zcp1>0)
				_2dRay(Xs1, Ys1, Xs2, Ys2, valid);
			else
			{
				double dx=Xs2-Xs1, dy=Ys2-Ys1, r=sqrt(2)*(abs(Xs2)+abs(Ys2)+2*(X0+Y0))/(abs(dx)+abs(dy));
				_2dRay(Xs1=Xs2+r*dx, Ys1=Ys2+r*dy, Xs2, Ys2, valid);
			}//*/
		}
	public:
		void arrowLabel(double x1, double y1, double z1, double x2, double y2, double z2, char const *format)
		{
			int Xs, Ys;
			double A;
			if(arrowLabel_infiniteRay(x1, y1, z1, x2, y2, z2, Xs, Ys, A))
				LOL_text[A].push_back(Text(Xs, Ys, TRANSPARENT, format));
		}
		void arrowLabelsColor(double x1, double y1, double z1, double x2, double y2, double z2, std::vector<Label> &labels)
		{
			int Xs, Ys;
			double A;
			if(arrowLabel_infiniteRay(x1, y1, z1, x2, y2, z2, Xs, Ys, A))
			{
				for(auto &label:labels)
				{
					LOL_text[A].push_back(Text(Xs, Ys, TRANSPARENT, expr[label.exNo].winColor, label.label));
					Ys+=16;
				}
			}
		}
		void arrowLabelsColor(double x1, double y1, double z1, double x2, double y2, double z2, char const *const *labels, int const *colors, unsigned nLabels)
		{
			int Xs, Ys;
			double A;
			if(arrowLabel_infiniteRay(x1, y1, z1, x2, y2, z2, Xs, Ys, A))
			{
				for(unsigned l=0;l<nLabels;++l)
				{
					LOL_text[A].push_back(Text(Xs, Ys, TRANSPARENT, colors[l], labels[l]));
					Ys+=16;
				}
			}
		}
		void arrowLabels(double x1, double y1, double z1, double x2, double y2, double z2, std::vector<Label> &labels)
		{
			int Xs, Ys;
			double A;
			if(arrowLabel_infiniteRay(x1, y1, z1, x2, y2, z2, Xs, Ys, A))
			{
				for(auto &label:labels)
				{
					LOL_text[A].push_back(Text(Xs, Ys, TRANSPARENT, label.label));
					Ys+=16;
				}
			}
		}
	private:
		void point(double x, double y, double z)
		{
			double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax, Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay;
			double Zcp1=cpt*cay+dz*say;
			if(Zcp1>0)
			{
				double Acp1=1/Zcp1;
				cpt=X0/(Zcp1*tanfov);
				double Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
				if((Xs1>=bx1)&(Xs1<bx2)&(Ys1>=by1)&(Ys1<by2))
				{
					int pos=int(Xs1)+bw*int(Ys1);
					if(Acp1>wbuffer[pos])
						rgb[pos]=lineColor, wbuffer[pos]=Acp1;
				}
			}
		}
		void _2dSet3dPoint(int x, int y, double a, int c)
		{
			if((x>=bx1)&(x<bx2)&(y>=by1)&(y<by2))
		//	if(x>=bx1&&x<bx2&&y>=by1&&y<by2)
			{
				int pos=int(x+bw*y);
				if(a>wbuffer[pos])
					rgb[pos]=c, wbuffer[pos]=a;
			}
		}
	public:
		void point(double x, double y, double z, int Rcolor)
		{
			double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax, Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay;
			double Zcp1=cpt*cay+dz*say;
			if(Zcp1>0)
			{
				double Acp1=1/Zcp1;
				cpt=X0/(Zcp1*tanfov);
				double Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
			//	GUIPrint(ghMemDC, Xs1, Ys1, Rcolor);
				int xs1=int(Xs1)-(Xs1<0), ys1=int(Ys1)-(Ys1<0);
				_2dSet3dPoint(xs1, ys1	, Acp1, Rcolor), _2dSet3dPoint(xs1+1, ys1	, Acp1, Rcolor);
				_2dSet3dPoint(xs1, ys1+1, Acp1, Rcolor), _2dSet3dPoint(xs1+1, ys1+1	, Acp1, Rcolor);
			}
		}
		void point(double x, double y, double z, int Rcolor, int Icolor, int Jcolor, int Kcolor)
		{
			double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax, Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay;
			double Zcp1=cpt*cay+dz*say;
			if(Zcp1>0)
			{
				double Acp1=1/Zcp1;
				cpt=X0/(Zcp1*tanfov);
				double Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
				int xs1=int(Xs1)-(Xs1<0), ys1=int(Ys1)-(Ys1<0);
				_2dSet3dPoint(xs1		, ys1		, Acp1, Rcolor);
				_2dSet3dPoint(xs1+1		, ys1		, Acp1, Rcolor);
				_2dSet3dPoint(xs1+1		, ys1+1		, Acp1, Rcolor);
				_2dSet3dPoint(xs1		, ys1+1		, Acp1, Rcolor);

				_2dSet3dPoint(xs1+3		, ys1		, Acp1, Icolor);
				_2dSet3dPoint(xs1+3+1	, ys1		, Acp1, Icolor);
				_2dSet3dPoint(xs1+3+1	, ys1+1		, Acp1, Icolor);
				_2dSet3dPoint(xs1+3		, ys1+1		, Acp1, Icolor);

				_2dSet3dPoint(xs1		, ys1+3		, Acp1, Jcolor);
				_2dSet3dPoint(xs1+1		, ys1+3		, Acp1, Jcolor);
				_2dSet3dPoint(xs1+1		, ys1+3+1	, Acp1, Jcolor);
				_2dSet3dPoint(xs1		, ys1+3+1	, Acp1, Jcolor);

				_2dSet3dPoint(xs1+3		, ys1+3		, Acp1, Kcolor);
				_2dSet3dPoint(xs1+3+1	, ys1+3		, Acp1, Kcolor);
				_2dSet3dPoint(xs1+3+1	, ys1+3+1	, Acp1, Kcolor);
				_2dSet3dPoint(xs1+3		, ys1+3+1	, Acp1, Kcolor);
			}
		}

		//calculate the screen coordinates of the point (x, y, z)
		//as integers
		//returns true if can be cast to integers
		bool pointCoordinates(double x, double y, double z, int &Xs, int &Ys)
		{
			double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax, Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay;
			double Zcp1=cpt*cay+dz*say;
			if(Zcp1>0)
			{
				double Acp1=1/Zcp1;
				cpt=X0/(Zcp1*tanfov);
				double _Xs=X0+Xcp1*cpt, _Ys=Y0+Ycp1*cpt;
				if(Xs1>-1e6&&Xs1<1e6&&Ys1>-1e6&&Ys1<1e6)
				{
					Xs=int(_Xs)-(_Xs<0), Ys=int(_Ys)-(_Ys<0);
					return true;
				}
			}
			return false;
		}

		//calculate the screen coordinates of the point (x, y, z)
		//as doubles
		//returns true if can be cast to integers
		bool pointCoordinates(double x, double y, double z, double &Xs, double &Ys)
		{
			double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax, Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay;
			double Zcp1=cpt*cay+dz*say;
			if(Zcp1>0)
			{
				double Acp1=1/Zcp1;
				cpt=X0/(Zcp1*tanfov);
				Xs=X0+Xcp1*cpt, Ys=Y0+Ycp1*cpt;
				if(Xs1>-1e6&&Xs1<1e6&&Ys1>-1e6&&Ys1<1e6)
					return true;
			}
			return false;
		}

		//calculate the screen coordinates of the point (x, y, z)
		//as doubles
		//return value:
		//3: can be cast to integers and is not obstructed so far
		//2: can be cast to integers but obstructed
		//1: can not be cast to integers
		//0: behind
		int pointCoordinatesRect(double x, double y, double z, double &Xs, double &Ys)
		{
			double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax, Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay;
			double Zcp1=cpt*cay+dz*say;
			if(Zcp1>0)
			{
				double Acp1=1/Zcp1;
				cpt=X0/(Zcp1*tanfov);
				Xs=X0+Xcp1*cpt, Ys=Y0+Ycp1*cpt;
				if(Xs1>=bx1&&Xs1<bx2&&Ys1>=by1&&Ys1<by2)
				{
					int pos=int(Xs1)+bw*int(Ys1);
					if(Acp1>wbuffer[pos])
						return 3;
					return 2;
				}
				return 1;
			}
			return 0;
		}

	private:
		struct Text
		{
			int x, y;
			int bkMode;
			bool enable_color;	int color;
			std::string str;
			Text(int x, int y, int bkMode, std::string &str)			:x(x), y(y), bkMode(bkMode), enable_color(false), str(str){}
			Text(int x, int y, int bkMode, const char *a)				:x(x), y(y), bkMode(bkMode), enable_color(false), str(a){}
			Text(int x, int y, int bkMode, int color, std::string &str)	:x(x), y(y), bkMode(bkMode), enable_color(true), color(color), str(str){}
			Text(int x, int y, int bkMode, int color, const char *a)	:x(x), y(y), bkMode(bkMode), enable_color(true), color(color), str(a){}
		};
		std::map<double, std::list<Text>> LOL_text;//closest to farthest

	public:
		//print text hud style in screen coordinates, always appears on top of text in 3d
		void textIn2D(int xs, int ys, int bkMode, char const *format, ...)
		{
			int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&format+1));
			//int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
			if(buflen>0)
				LOL_text[_HUGE].push_back(Text(xs, ys, bkMode, g_buf));
		//	buflen=vsprintf_s(buf, sizeof(buf), format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
		//	if(buflen>0)
		//		LOL_text[_HUGE].push_back(Text(xs, ys, bkMode, buf));
		}
		void textIn2D(int xs, int ys, int bkMode, int color, char const *format, ...)
		{
			int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&format+1));
			//int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
			if(buflen>0)
				LOL_text[_HUGE].push_back(Text(xs, ys, bkMode, color, g_buf));
		//	buflen=vsprintf_s(buf, sizeof(buf), format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
		//	if(buflen>0)
		//		LOL_text[_HUGE].push_back(Text(xs, ys, bkMode, color, buf));
		}

		//calculate the screen coordinates of the point (x, y, z) and writes the distance in Zcp1
		//as integers
		//returns true if can be cast to integers
		bool pointCoordinates3dText(double x, double y, double z, int &Xs, int &Ys)
		{
			double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax, Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay;
			if((Zcp1=cpt*cay+dz*say)>0)
			{
				double Acp1=1/Zcp1;
				cpt=X0/(Zcp1*tanfov);
				double _Xs=X0+Xcp1*cpt, _Ys=Y0+Ycp1*cpt;
				if(Xs1>-1e6&&Xs1<1e6&&Ys1>-1e6&&Ys1<1e6)
				{
					Xs=int(_Xs)-(_Xs<0), Ys=int(_Ys)-(_Ys<0);
					return true;
				}
			}
			return false;
		}

		//print text at (x, y, z) in 3d space coordinates
		void textIn3D(double x, double y, double z, int bkMode, const char *format, ...)
		{
			doPoint1(x, y, z);
			if(Zcp1>0&&abs(Xs1)<1e6&&abs(Ys1)<1e6)
			{
				int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&format+1));
				//int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
				if(buflen>0)
					LOL_text[double(1/Zcp1)].push_back(Text(int(Xs1)-(Xs1<0), int(Ys1)-(Ys1<0), bkMode, g_buf));
			//	buflen=vsprintf_s(buf, sizeof(buf), format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
			//	if(buflen>0)
			//		LOL_text[double(1/Zcp1)].push_back(Text(int(Xs1)-(Xs1<0), int(Ys1)-(Ys1<0), bkMode, buf));
			}
		}

		//print text at (xs, ys) in screen coordinates, given inverse of the distance (A)
		void textIn3D_screenCoord(int xs, int ys, double A, int bkMode, char *format, ...)
		{
			if(A>0)
			{
				int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&format+1));
				//int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
				if(buflen>0)
					LOL_text[A].push_back(Text(xs, ys, bkMode, g_buf));
			//	buflen=vsprintf_s(buf, sizeof(buf), format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
			//	if(buflen>0)
			//		LOL_text[A].push_back(Text(xs, ys, bkMode, buf));
			}
		}

		//print text at (xs, ys) in screen coordinates, after using a function that writes the point distance Zcp in (Zcp1)
		void textIn3D_screenCoord(int xs, int ys, int bkMode, char *format, ...)
		{
			if(Zcp1>0)
			{
				int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&format+1));
			//	int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
			//	int buflen=vsprintf_s(g_buf, sizeof(g_buf), format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
				if(buflen>0)
					LOL_text[double(1/Zcp1)].push_back(Text(xs, ys, bkMode, g_buf));
			//	buflen=vsprintf_s(buf, sizeof(buf), format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
			//	if(buflen>0)
			//		LOL_text[double(1/Zcp1)].push_back(Text(xs, ys, bkMode, buf));
			}
		}

		//show the text that was printed in 3d space
		void text_show()
		{
			for(auto &LOL:LOL_text)
			{
				for(auto &LOL_2:LOL.second)
				{
					SetBkMode(ghMemDC, LOL_2.bkMode);
					if(LOL_2.enable_color)
						SetTextColor(ghMemDC, LOL_2.color);
					TextOutA(ghMemDC, LOL_2.x, LOL_2.y, LOL_2.str.c_str(), LOL_2.str.size());
					if(LOL_2.enable_color)
						SetTextColor(ghMemDC, 0);
				}
			}
			LOL_text.clear();
		}
		void text_dump(){LOL_text.clear();}
	};

	int colorFunction_r(double &r)
	{
		if(r!=r)
			return 0x7F7F7F;
		else if(r==_HUGE)
			return 0x00ED7F11;//arg=0
		else if(r==-_HUGE)
			return 0x00117FED;//arg=pi
		double mag=255/G2::_pi*atan(std::abs(r));//, cosx=1, sinx=0;
	//	const double cos_pi_6=0.866025403784439, sin_pi_6=0.5;
		return unsigned char(mag*1.866025403784439)<<16|unsigned char(mag*0.133974596215561);
	//	return unsigned char(mag*(1+cosx*cos_pi_6-sinx*sin_pi_6))<<16|unsigned char(mag*(1+sinx))<<8|unsigned char(mag*(1+cosx*-cos_pi_6-sinx*sin_pi_6));

	/*	if(r!=r)
			return 0x7F7F7F;
		else if(r==_HUGE)
		{
			double mag=255/G2::_pi*atan(std::abs(r)), arg=(0);
			return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
		}
		else if(r==-_HUGE)
		{
			double mag=255/G2::_pi*atan(std::abs(r)), arg=(G2::_pi);
			return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
		}
		double mag=255/G2::_pi*atan(std::abs(r)), arg=atan2(0, r);
		return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));//*/
	}
	int colorFunction_i(double &i)
	{
		if(i!=i)
			return 0x7F7F7F;
		else if(i==_HUGE)
			return 0x003FFF3F;//arg=pi/2
		else if(i==-_HUGE)
			return 0x00BF00BF;//arg=-pi/2
	//	const double cos_pi_6=0.866025403784439, sin_pi_6=0.5;
		double mag=255/G2::_pi*atan(abs(i));//, cosx=0, sinx=1;
		return unsigned char(mag*0.5)<<16|unsigned char(mag*2)<<8|unsigned char(mag*0.5);
	//	return unsigned char(mag*(1-sin_pi_6))<<16|unsigned char(mag*(1+1))<<8|unsigned char(mag*(1-sin_pi_6));

	/*	if(i!=i)
			return 0x7F7F7F;
		else if(i==_HUGE)
		{
			double mag=255/G2::_pi*atan(std::abs(i)), arg=(G2::_pi/2);
			return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
		}
		else if(i==-_HUGE)
		{
			double mag=255/G2::_pi*atan(std::abs(i)), arg=(-G2::_pi/2);
			return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
		}
		double mag=255/G2::_pi*atan(std::abs(i)), arg=atan2(i, 0);
		return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));//*/
	}
	int colorFunction(double &r, double &i)
	{
		if(r!=r||i!=i)
			return 0x7F7F7F;
		if(r==_HUGE)
		{
			if(i==_HUGE||i==-_HUGE)
				return 0x00FFFFFF;
			else
				return 0x00ED7F11;//arg=0
		}
		else if(r==-_HUGE)
		{
			if(i==_HUGE||i==-_HUGE)
				return 0x00FFFFFF;
			else
				return 0x00117FED;//arg=pi
		}
		else if(i==_HUGE)
			return 0x003FFF3F;//arg=pi/2
		else if(i==-_HUGE)
			return 0x00BF00BF;//arg=-pi/2
		const double cos_pi_6=0.866025403784439, sin_pi_6=0.5;
		double hyp=sqrt(r*r+i*i), mag=255/G2::_pi*atan(hyp), cosx=r/hyp, sinx=i/hyp;
		return unsigned char(mag*(1+cosx*cos_pi_6-sinx*sin_pi_6))<<16|unsigned char(mag*(1+sinx))<<8|unsigned char(mag*(1+cosx*-cos_pi_6-sinx*sin_pi_6));
	}
	int colorFunction(Value &x)
	{
		if(x.r!=x.r||x.i!=x.i)
			return 0x7F7F7F;
		if(x.r==_HUGE)
		{
			if(x.i==_HUGE||x.i==-_HUGE)
				return 0x00FFFFFF;
			else
				return 0x00ED7F11;//arg=0
		}
		else if(x.r==-_HUGE)
		{
			if(x.i==_HUGE||x.i==-_HUGE)
				return 0x00FFFFFF;
			else
				return 0x00117FED;//arg=pi
		}
		else if(x.i==_HUGE)
			return 0x003FFF3F;//arg=pi/2
		else if(x.i==-_HUGE)
			return 0x00BF00BF;//arg=-pi/2
		const double cos_pi_6=0.866025403784439, sin_pi_6=0.5;//, cos_pi3_2=0, sin_pi3_2=-1, cos_pi5_6=-cos_pi_6, sin_pi5_6=sin_pi_6;
		double _1_hyp=inv_sqrt(x.r*x.r+x.i*x.i), mag=255/G2::_pi*atan(1/_1_hyp), cosx=x.r*_1_hyp, sinx=x.i*_1_hyp;
	//	double hyp=sqrt(x.r*x.r+x.i*x.i), mag=255/G2::_pi*atan(hyp), cosx=x.r/hyp, sinx=x.i/hyp;
		return unsigned char(mag*(1+cosx*cos_pi_6-sinx*sin_pi_6))<<16|unsigned char(mag*(1+sinx))<<8|unsigned char(mag*(1+cosx*-cos_pi_6-sinx*sin_pi_6));
	//	return unsigned char(mag*(1+cosx*cos_pi_6-sinx*sin_pi_6))<<16|unsigned char(mag*(1+cosx*cos_pi3_2-sinx*sin_pi3_2))<<8|unsigned char(mag*(1+cosx*cos_pi5_6-sinx*sin_pi5_6));
	/*	if(x.r!=x.r||x.i!=x.i)
			return 0x7F7F7F;
		if(x.r==_HUGE)
		{
			if(x.i==_HUGE||x.i==-_HUGE)
				return 0x00FFFFFF;
			else
			{
				double mag=127.5, arg=(0);
				return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
			}
		}
		else if(x.r==-_HUGE)
		{
			if(x.i==_HUGE||x.i==-_HUGE)
				return 0x00FFFFFF;
			else
			{
				double mag=-127.5, arg=(G2::_pi);
				return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
			}
		}
		else if(x.i==_HUGE)
		{
			double mag=255/G2::_pi*atan(sqrt(x.r*x.r+x.i*x.i)), arg=(G2::_pi/2);
			return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
		}
		else if(x.i==-_HUGE)
		{
			double mag=255/G2::_pi*atan(sqrt(x.r*x.r+x.i*x.i)), arg=(-G2::_pi/2);
			return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
		}
		mag=255/G2::_pi*atan(sqrt(x.r*x.r+x.i*x.i)); double arg=atan2(x.i, x.r);//600ms
		int v1=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));//*/
	}
	void colorFunction_q(Value &x, int &r, int &i, int &j, int &k)
	{
		const double f=255*2/G2::_pi;
		((unsigned char*)&r)[x.r<0]=unsigned char(atan(abs(x.r))*f);
		((unsigned char*)&i)[x.i<0]=unsigned char(atan(abs(x.i))*f);
		((unsigned char*)&j)[x.j<0]=unsigned char(atan(abs(x.j))*f);
		((unsigned char*)&k)[x.k<0]=unsigned char(atan(abs(x.k))*f);
		//r=unsigned char(f*atan(abs(x.r)))<<(16&-(x.r<0));
		//i=unsigned char(f*atan(abs(x.i)))<<(16&-(x.i<0));
		//j=unsigned char(f*atan(abs(x.j)))<<(16&-(x.j<0));
		//k=unsigned char(f*atan(abs(x.k)))<<(16&-(x.k<0));
		//r=x.r>=0?unsigned char(255*atan(x.r)*2/G2::_pi):unsigned char(255*atan(-x.r)*2/G2::_pi)<<16;
		//i=x.i>=0?unsigned char(255*atan(x.i)*2/G2::_pi):unsigned char(255*atan(-x.i)*2/G2::_pi)<<16;
		//j=x.j>=0?unsigned char(255*atan(x.j)*2/G2::_pi):unsigned char(255*atan(-x.j)*2/G2::_pi)<<16;
		//k=x.k>=0?unsigned char(255*atan(x.k)*2/G2::_pi):unsigned char(255*atan(-x.k)*2/G2::_pi)<<16;
	}
	class		Solve
	{
	public:
		long long Tstart;
		double T_elapsed, T;
		void reset()
		{
			LARGE_INTEGER li;
			QueryPerformanceFrequency(&li);
			long long freq=li.QuadPart;
			QueryPerformanceCounter(&li);
			Tstart=li.QuadPart;
			T_elapsed=0;
		}
		void synchronize()
		{
			LARGE_INTEGER li;
			QueryPerformanceFrequency(&li);
			long long freq=li.QuadPart;
			QueryPerformanceCounter(&li);
			T=T_elapsed+double(li.QuadPart-Tstart)/freq;
		}
		void pause(){T_elapsed=T;}
		void resume()
		{
			LARGE_INTEGER li;
			QueryPerformanceFrequency(&li);
			long long freq=li.QuadPart;
			QueryPerformanceCounter(&li);
			Tstart=li.QuadPart;
		}
	};
	class		Solve_0D:public Solve
	{
	public:
		void full(Expression &ex)
		{
			auto LOL_1=[&](Variable &variables, double *&p, int varType)
			{
				switch(varType)
				{
				case 'c':p=&variables.val.r;break;
				case 't':p=&T;break;
				}
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					n.ndr.assign(1, ex.data[kn]);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&T) r;
							LOL_1(variables, r, variables.varTypeR);
							ndr.assign(1, *r);
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&T) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							ndr.assign(1, Value(*r, *i));
						}
						break;
					case 'H':
						{
							decltype(&T) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							ndr.assign(1, Value(*r, *i, *j, *k));
						}
						break;
					}
				}
			}
			::solve(ex);
		}
	};
	class		Solve_1D_Implicit:public Solve
	{
	public:
		double Xsample, Xstart, Xstart_s, *aXstart;
		int Xplaces;
	private:
		int x;
		double *p;
		double fx(){return *aXstart+x*Xsample;}
	//	double fx(){return Xstart+x*Xsample;}
		double fc(){return *p;}
		int sa[6];//XsrcStart, XsrcEnd, XdestStart		+padded version
		int ra[4];//XsolveStart, XsolveEnd				+padded version
	public:
		void full_resize(double VX, double DX, int Xplaces)
		{
			this->Xplaces=Xplaces;
			Xsample=DX/Xplaces;
			Xstart_s=VX-DX/2, Xstart=Xstart_s+Xsample;
		//	Xstart=VX-DX/2, Xstart_s=Xstart-Xsample;
		}
	//	void full_resize(double VX, double DX, int Xplaces){this->Xplaces=Xplaces, this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces;}
		void full(Expression &ex)
		{
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_1D_Implicit::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_1D_Implicit::fx, LOL_1_const=0;break;
				case 'c':f=&Solve_1D_Implicit::fc, p=&variables.val.r;break;
				case 't':f=&Solve_1D_Implicit::fc, p=&T;break;
				}
			};
			int aXplaces;
			if(ex.resultLogicType>=2)
				aXstart=&Xstart_s, aXplaces=Xplaces+2;
			else
				aXstart=&Xstart, aXplaces=Xplaces;
		//	int aXplaces=Xplaces+(ex.resultLogicType>=2);
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					n.ndr.assign(aXplaces, ex.data[kn]);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(variables.mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_1D_Implicit::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								ndr.assign(aXplaces, (this->*r)());
							else
							{
								ndr.resize(aXplaces);
								auto ndrIT=ndr.begin();
								for(x=0;x<aXplaces;++x, ++ndrIT)
									*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_1D_Implicit::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								ndr.assign(aXplaces, Value((this->*r)(), (this->*i)()));
							else
							{
								ndr.resize(aXplaces);
								auto ndrIT=ndr.begin();
								for(x=0;x<aXplaces;++x, ++ndrIT)
									*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_1D_Implicit::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								ndr.assign(aXplaces, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								ndr.resize(aXplaces);
								auto ndrIT=ndr.begin();
								for(x=0;x<aXplaces;++x, ++ndrIT)
									*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			switch(ex.resultLogicType)
			{
			case 1://&& ## || < <= > >=		logic/inequality
				{
					unsigned ndrSize=ex.n[0].ndr.size();
					for(auto &i:ex.i)
					{
						switch(i.type)
					//	switch(i.nArgs)
						{
						case 'c'://user function call
							concurrency::parallel_for(0u, ndrSize, Solve_UserFunction(ex, i));
							break;
						case 1:
							{
								auto &result=ex.n[i.result], &op1=ex.n[i.op1];
								concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), i.uf);
							}
							break;
						case 2:
							{
								auto &result=ex.n[i.result], &op1=ex.n[i.op1], &op2=ex.n[i.op2];
								concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), op2.ndr.begin(), result.ndr.begin(), i.bf);
							}
							break;
						case 3:
							{
								auto &result=ex.n[i.result], &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
								concurrency::parallel_for(0u, op1.ndr.size(), [&](int k){result.ndr[k]=i.tf(op1.ndr[k], op2.ndr[k], op3.ndr[k]);});
							}
							break;
						}
					}
				}
				break;
			//ex.resultLogicType>=2		zero cross anti-aliasing
			case 2://=		equation
			case 3://!=		anti-equation
				{
					int Xplaces1=Xplaces+1, Xplaces2=Xplaces+2;
					ex.discontinuities.assign(Xplaces2, false);
					unsigned ndrSize=ex.n[0].ndr.size();
					for(int ik=0, ikEnd=ex.i.size()-1;ik<ikEnd;++ik)
				//	for(auto iIT=ex.i.begin(), iITend=ex.i.end()-1;iIT!=iITend;++iIT)
					{
						auto &i=ex.i[ik];
					//	auto &i=*iIT;
						auto &result=ex.n[i.result];
						switch(i.type)
					//	switch(i.nArgs)
						{
						case 'c'://user function call
							concurrency::parallel_for(0u, ndrSize, Solve_UserFunction(ex, i));
							break;
						case 1:
							{
								auto &op1=ex.n[i.op1];
								if(i.d.disc_in)
								{
									for(int x=0;x<Xplaces1;++x)
									{
										auto &condition=ex.discontinuities[x];
										condition=condition||i.d.ud_i(op1.ndr[x], op1.ndr[x+1]);
									}
								}
								concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), i.uf);
							}
							break;
						case 2:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2];
								if(i.d.disc_in)
								{
									for(int x=0;x<Xplaces1;++x)
									{
										auto &condition=ex.discontinuities[x];
										condition=condition||i.d.bd_i(op1.ndr[x], op2.ndr[x], op1.ndr[x+1], op2.ndr[x+1]);
									}
								}
								concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), op2.ndr.begin(), result.ndr.begin(), i.bf);
							}
							break;
						case 3:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
								if(i.d.disc_in)
								{
									for(int x=0;x<Xplaces1;++x)
									{
										auto &condition=ex.discontinuities[x];
										condition=condition||i.d.td_i(op1.ndr[x], op2.ndr[x], op3.ndr[x], op1.ndr[x+1], op2.ndr[x+1], op3.ndr[x+1]);
									}
								}
								concurrency::parallel_for(0u, op1.ndr.size(), [&](int k){result.ndr[k]=i.tf(op1.ndr[k], op2.ndr[k], op3.ndr[k]);});
							}
							break;
						}
						if(i.d.disc_out)
						{
							for(int x=0;x<Xplaces1;++x)
							{
								auto &condition=ex.discontinuities[x];
								condition=condition||i.d.d_o(result.ndr[x], result.ndr[x+1]);
							}
						}
					}
					{
						auto &i=*ex.i.rbegin();
						auto &op1=ex.n[i.op1], &result=ex.n[i.result];
						switch(i.type)
					//	switch(i.nArgs)
						{
						case 1:
							concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), G2::q_minus);
							break;
						case 2:
							{
								auto &op2=ex.n[i.op2];
								concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), op2.ndr.begin(), result.ndr.begin(), G2::qq_minus);
							}
							break;
						}
					}//*/
					auto &ndr=ex.n[0].ndr;
#if 0
					switch(ex.resultLogicType)
					{
					case 2://LR==0	zero cross	_/\_
						{
#endif
							switch(ex.resultMathSet)
						//	switch(ex.n[0].mathSet)
							{
							case 'r':
						//	case 'R':
								//{//same
								//	auto &V0=ndr[0].r, &V1=ndr[1].r;
								//	bool Tshade=std::signbit(V0)!=std::signbit(V1);//trans-pixel shade
								//	double Tx=V0/(V0-V1);
								//	for(int v=0, vEnd=ndr.size()-2;v<vEnd;++v)
								//	{
								//		auto &V0=ndr[v].r, &V1=ndr[v+1].r, &V2=ndr[v+2].r;
								//		if(V1==0)
								//			V0=true;
								//		else if(Tshade)
								//		{
								//			if(Tshade=std::signbit(V1)!=std::signbit(V2))	//LR
								//			{
								//				double Rx=V2/(V2-V1);
								//				V0=(std::abs(Tx+Rx)+std::abs(Tx-Rx))/2;
								//				Tx=1-Rx;
								//			}
								//			else	//L
								//				V0=Tx;
								//		}
								//		else
								//		{
								//			if(Tshade=std::signbit(V1)!=std::signbit(V2))	//R
								//			{
								//				V0=V2/(V2-V1);
								//				Tx=1-V0;
								//			}
								//			else
								//				V0=false;
								//		}
								//	}
								//}
								//{//dump
								//	auto &V0=ndr[0].r, &V1=ndr[1].r;
								//	bool Tshade=std::signbit(V0)!=std::signbit(V1);//trans-pixel shade
								//	double Tx=V0/(V0-V1);
								////	double Tx=(V1-0)/(V1-V0);
								//	for(int v=0, vEnd=ndr.size()-2;v<vEnd;++v)
								//	{
								//		auto &V0=ndr[v].r, &V1=ndr[v+1].r, &V2=ndr[v+2].r;
								//		if(V1==0)
								//			V0=true;
								//		else if(Tshade)
								//		{
								//			if(Tshade=std::signbit(V1)!=std::signbit(V2))	//LR
								//			{
								//				double Rx=V2/(V2-V1);
								//				V0=(std::abs(Tx+Rx)+std::abs(Tx-Rx))/2;
								//				Tx=1-Rx;
								//			//	double Rx=V1/(V1-V2);
								//			//	V0=1-(std::abs(Tx+Rx)-std::abs(Tx-Rx))/2;
								//			//	Tx=1-Rx;
								//			}
								//			else	//L
								//				V0=Tx;
								//			//	V0=1-Tx;
								//		}
								//		else
								//		{
								//			if(Tshade=std::signbit(V1)!=std::signbit(V2))	//R
								//			{
								//				V0=V2/(V2-V1);
								//				Tx=1-V0;
								//			//	Tx=V0=1-(V1-0)/(V1-V2);
								//			}
								//			else
								//				V0=false;
								//		}
								//		//else
								//		//{
								//		//	double d_min=Tshade?Tx:1;//cross at L?
								//		////	double d_min=std::signbit(V0)!=std::signbit(V1)?(V1-0)/(V1-V0):1;
								//		//	if(Tshade=std::signbit(V1)!=std::signbit(V2))//cross at R?
								//		//	{
								//		//		Tx=(V1-0)/(V1-V2);
								//		//		d_min=(std::abs(Tx+d_min)-std::abs(Tx-d_min))/2;//take minimum distance
								//		//	}
								//		//	V0=1-d_min;//cross true, no cross false
								//		//}
								//	}
								//}
								for(int v=0, vEnd=ndr.size()-2;v<vEnd;++v)//ndr.size()==Xplaces+2
								{
									auto &V0=ndr[v].r, &V1=ndr[v+1].r, &V2=ndr[v+2].r;//V0 <= cross(V0, V1, V2)
									if(V1==0)
										V0=true;
									else if(!ex.discontinuities[v]&&std::signbit(V0)!=std::signbit(V1))//cross at L?
									{
										double d_min=V0/(V0-V1);
										if(!ex.discontinuities[v+1]&&std::signbit(V1)!=std::signbit(V2))//cross at R?
										{
											double d=V2/(V2-V1);
											d_min=(std::abs(d_min+d)+std::abs(d_min-d))/2;
										}
										V0=d_min;
									}
									else
									{
										if(!ex.discontinuities[v+1]&&std::signbit(V1)!=std::signbit(V2))//cross at R?
											V0=(V2-0)/(V2-V1);
										else
											V0=false;
									}
								}
								//{//dump
								//	for(int v=0, vEnd=ndr.size()-2;v<vEnd;++v)//ndr.size()==Xplaces+2
								//	{
								//		auto &V0=ndr[v].r, &V1=ndr[v+1].r, &V2=ndr[v+2].r;//V0 <= cross(V0, V1, V2)
								//		if(V1==0)
								//			V0=true;
								//		else if(std::signbit(V0)!=std::signbit(V1))//cross at L?
								//		{
								//			double d_min=V0/(V0-V1);
								//			if(std::signbit(V1)!=std::signbit(V2))//cross at R?
								//			{
								//				double d=V2/(V2-V1);
								//				d_min=(std::abs(d_min+d)+std::abs(d_min-d))/2;
								//			}
								//			V0=d_min;
								//			//if(std::signbit(V1)!=std::signbit(V2))	//LR
								//			//{
								//			//	double Lx=(V0-0)/(V0-V1), Rx=(V2-0)/(V2-V1);
								//			//	V0=(std::abs(Lx+Rx)+std::abs(Lx-Rx))/2;
								//			////	double Lx=(V1-0)/(V1-V0), Rx=(V1-0)/(V1-V2);
								//			////	V0=1-(std::abs(Lx+Rx)-std::abs(Lx-Rx))/2;
								//			//}
								//			//else		//L
								//			//	V0=(V0-0)/(V0-V1);
								//			////	V0=1-(V1-0)/(V1-V0);
								//		}
								//		else
								//		{
								//			if(std::signbit(V1)!=std::signbit(V2))//cross at R?
								//				V0=(V2-0)/(V2-V1);
								//			//	V0=1-(V1-0)/(V1-V2);
								//			else
								//				V0=false;
								//		}
								//		//else
								//		//{
								//		//	double d_min=std::signbit(V0)!=std::signbit(V1)?(V1-0)/(V1-V0):1;//cross at L?
								//		//	if(std::signbit(V1)!=std::signbit(V2))//cross at R?
								//		//	{
								//		//		double d=(V1-0)/(V1-V2);
								//		//		d_min=(std::abs(d+d_min)-std::abs(d-d_min))/2;//take minimum distance
								//		//	}
								//		//	V0=1-d_min;//cross true, no cross false
								//		//}

								//		//else
								//		//{
								//		//	double d_min=1, d;
								//		//	if(std::signbit(V0)!=std::signbit(V1))
								//		//		d_min=(V1-0)/(V1-V0);
								//		//	if(std::signbit(V1)!=std::signbit(V2)&&d_min>(d=(V1-0)/(V1-V2)))
								//		//		d_min=d;
								//		//	V0=1-d_min;
								//		//}

								//		//else
								//		//{
								//		//	double Lx=0, Rx=0;
								//		//	if(std::signbit(V0)!=std::signbit(V1))
								//		//		Lx=(V1-0)/(V1-V0);
								//		//	if(std::signbit(V1)!=std::signbit(V2))
								//		//		Rx=(V1-0)/(V1-V2);
								//		//	double d_min=(std::abs(Lx+Rx)+std::abs(Lx-Rx))/2;
								//		//}
								//	}
								//}
								//{//dump
								//	double next=0;
								//	for(int v=0, vEnd=ndr.size()-1;v<vEnd;++v)
								//	{
								//		auto &V0=ndr[v].r, &V1=ndr[v+1].r;
								//		if(std::signbit(V0)!=std::signbit(V1))
								//		{
								//			double x=(0-V0)/(V1-V0);
								//			if(x<.5)
								//			{
								//				if(v>0)
								//					ndr[v-1].r*=1-(x+.5);
								//				V0=next*(1-(.5-x));
								//				next=0;
								//			}
								//			else
								//			{
								//				V0=next*(1-(x-.5));
								//				next=1-(1.5-x);
								//			}
								//		}
								//		else
								//			V0=next, next=0;
								//	}
								//}
								break;
							case 'c':
						//	case 'C':
								{
									bool Tshade=false;//trans-pixel shade
									double Tx;
									if(!ex.discontinuities[0])
									{
										auto &V0=ndr[0], &V1=ndr[1];
										double dr=V1.r-V0.r, di=V1.i-V0.i;
										double Tx=-.5*(V0.r*dr+V0.i*di)/(dr*dr+di*di);
										if(Tx>=0&&Tx<1)
										{
											double rx=V0.r+dr*Tx, ix=V0.i+di*Tx;
											Tshade=rx*rx+ix*ix<.25;
										}
									}
									for(int v=0, vEnd=ndr.size()-2;v<vEnd;++v)
									{
										auto &V0=ndr[v], &V1=ndr[v+1], &V2=ndr[v+2];
										if(V1.r==0&&V1.i==0)
											V0=true;
										else
										{
											bool shade=false;
											double Rx;
											if(!ex.discontinuities[v+1])
											{
												double dr=V2.r-V1.r, di=V2.i-V1.i;
												double Rx=-.5*(V1.r*dr+V1.i*di)/(dr*dr+di*di);
												if(Rx>=0&&Rx<1)
												{
													double rx=V1.r+dr*Rx, ix=V1.i+di*Rx;
													shade=rx*rx+ix*ix<.25;//why 0.25?
												}
											}
											if(shade)//cross at R?
											{
												if(Tshade)//cross at L?		LR
													V0=(std::abs(Tx+Rx)+std::abs(Tx-Rx))/2;
												else//	R
													V0=Rx;
												Tx=1-Rx;
											}
											else
											{
												if(Tshade)
													V0=Tx;
												else
													V0=false;
											}
											Tshade=shade;
										}
									}
								}
								//{//old, floorx==1 wrong
								//	auto &ndr=ex.n[0].ndr;
								//	double next=0;
								//	for(int v=0, vEnd=ndr.size()-1;v<vEnd;++v)
								//	{
								//		auto &V0=ndr[v], &V1=ndr[v+1];
								//		double dr=V1.r-V0.r, di=V1.i-V0.i;
								//		double x=-.5*(V0.r*dr+V0.i*di)/(dr*dr+di*di);
								//		bool assigned=false;
								//		if(x>=0&&x<1)
								//		{
								//			double rx=V0.r+dr*x, ix=V0.i+di*x;
								//			if(assigned=rx*rx+ix*ix<.25)
								//			{
								//				if(x<.5)
								//				{
								//					if(v>0)
								//						ndr[v-1].r*=1-(x+.5);
								//					V0.r=next*(1-(.5-x));
								//					next=0;
								//				}
								//				else
								//				{
								//					V0.r=next*(1-(x-.5));
								//					next=1-(1.5-x);
								//				}
								//			}
								//		}
								//		if(!assigned)
								//			V0.r=next, next=0;
								//	}
								//}
								break;
							case 'H':
								{
									bool Tshade=false;//trans-pixel shade
									double Tx;
									if(!ex.discontinuities[0])
									{
										auto &V0=ndr[0], &V1=ndr[1];
										double dr=V1.r-V0.r, di=V1.i-V0.i, dj=V1.j-V0.j, dk=V1.k-V0.k;
										double Tx=-.5*(V0.r*dr+V0.i*di+V0.j*dj+V0.k*dk)/(dr*dr+di*di+dj*dj+dk*dk);
										if(Tx>=0&&Tx<1)
										{
											double rx=V0.r+dr*Tx, ix=V0.i+di*Tx, jx=V1.j+dj*x, kx=V1.k+dk*x;
											Tshade=rx*rx+ix*ix+jx*jx+kx*kx<.25;//why 0.25?
										}
									}
									for(int v=0, vEnd=ndr.size()-2;v<vEnd;++v)
									{
										auto &V0=ndr[v], &V1=ndr[v+1], &V2=ndr[v+2];
										if(V1.r==0&&V1.i==0)
											V0=true;
										else
										{
											bool shade=false;
											double Rx;
											if(!ex.discontinuities[v+1])
											{
												double dr=V2.r-V1.r, di=V2.i-V1.i, dj=V2.j-V1.j, dk=V2.k-V1.k;
												double Rx=-.5*(V1.r*dr+V1.i*di+V0.j*dj+V0.k*dk)/(dr*dr+di*di+dj*dj+dk*dk);
												if(Rx>=0&&Rx<1)
												{
													double rx=V1.r+dr*Rx, ix=V1.i+di*Rx, jx=V1.j+dj*x, kx=V1.k+dk*x;
													shade=rx*rx+ix*ix+jx*jx+kx*kx<.25;
												}
											}
											if(shade)//cross at R?
											{
												if(Tshade)//cross at L?		LR
													V0=(std::abs(Tx+Rx)+std::abs(Tx-Rx))/2;
												else//	R
													V0=Rx;
												Tx=1-Rx;
											}
											else
											{
												if(Tshade)
													V0=Tx;
												else
													V0=false;
											}
											Tshade=shade;
										}
									}
								}
								//{
								//	auto &ndr=ex.n[0].ndr;
								//	double next=0;
								//	for(int v=0, vEnd=ndr.size()-1;v<vEnd;++v)
								//	{
								//		auto &V0=ndr[v], &V1=ndr[v+1];
								//		double dr=V1.r-V0.r, di=V1.i-V0.i, dj=V1.j-V0.j, dk=V1.k-V0.k;
								//		double x=-.5*(V0.r*dr+V0.i*di+V0.j*dj+V0.k*dk)/(dr*dr+di*di+dj*dj+dk*dk);
								//		bool assigned=false;
								//		if(x>=0&&x<1)
								//		{
								//			double rx=V0.r+dr*x, ix=V0.i+di*x, jx=V0.j+dj*x, kx=V0.k+dk*x;
								//			if(assigned=rx*rx+ix*ix+jx*jx+kx*kx<.25)
								//			{
								//				if(x<.5)
								//				{
								//					if(v>0)
								//						ndr[v-1].r*=1-(x+.5);
								//					V0.r=next*(1-(.5-x));
								//					next=0;
								//				}
								//				else
								//				{
								//					V0.r=next*(1-(x-.5));
								//					next=1-(1.5-x);
								//				}
								//			}
								//		}
								//		if(!assigned)
								//			V0.r=next, next=0;
								//	}
								//}
								break;
							}
#if 0
						}
						break;
					case 3:
						//	LR!=0		_  _
						//zero cross	 \/
						{
							switch(ex.resultMathSet)
						//	switch(ex.n[0].mathSet)
							{
							case 'r':
						//	case 'R':
								for(int v=0, vEnd=ndr.size()-2;v<vEnd;++v)//ndr.size()==Xplaces+2
								{
									auto &V0=ndr[v].r, &V1=ndr[v+1].r, &V2=ndr[v+2].r;//V0 <= cross(V0, V1, V2)
									if(V1==0)
										V0=false;//true
									else if(std::signbit(V0)!=std::signbit(V1))//cross at L?
									{
										double d_min=V0/(V0-V1);
										if(std::signbit(V1)!=std::signbit(V2))//cross at R?
										{
											double d=V2/(V2-V1);
											d_min=(std::abs(d_min+d)+std::abs(d_min-d))/2;
										}
										V0=1-d_min;
									}
									else
									{
										if(std::signbit(V1)!=std::signbit(V2))//cross at R?
											V0=1-(V2-0)/(V2-V1);
										else
											V0=true;//false
									}
								}//*/
							/*	{
									auto &ndr=ex.n[0].ndr;
									double next=1;
									for(int v=0, vEnd=ndr.size()-1;v<vEnd;++v)
									{
										auto &V0=ndr[v].r, &V1=ndr[v+1].r;
										if(std::signbit(V0)!=std::signbit(V1))
										{
											double x=(0-V0)/(V1-V0);
											if(x<.5)
											{
												if(v>0)
													ndr[v-1].r*=x+.5;
												V0=next*(.5-x);
												next=1;
											}
											else
											{
												V0=next*(x-.5);
												next=1.5-x;
											}
										}
										else
											V0=next, next=1;
									}
								}//*/
								break;
							case 'c':
						//	case 'C':
								{
									bool Tshade=false;//trans-pixel shade
									double Tx;
									{
										auto &V0=ndr[0], &V1=ndr[1];
										double dr=V1.r-V0.r, di=V1.i-V0.i;
										double Tx=-.5*(V0.r*dr+V0.i*di)/(dr*dr+di*di);
										if(Tx>=0&&Tx<1)
										{
											double rx=V0.r+dr*Tx, ix=V0.i+di*Tx;
											Tshade=rx*rx+ix*ix<.25;
										}
									}
									for(int v=0, vEnd=ndr.size()-2;v<vEnd;++v)
									{
										auto &V0=ndr[v], &V1=ndr[v+1], &V2=ndr[v+2];
										if(V1.r==0&&V1.i==0)
											V0=true;
										else
										{
											bool shade=false;
											double Rx;
											{
												double dr=V2.r-V1.r, di=V2.i-V1.i;
												Rx=-.5*(V1.r*dr+V1.i*di)/(dr*dr+di*di);
												if(Rx>=0&&Rx<1)
												{
													double rx=V1.r+dr*Rx, ix=V1.i+di*Rx;
													shade=rx*rx+ix*ix<.25;//why 0.25?
												}
											}
											if(shade)//cross at R?
											{
												if(Tshade)//cross at L?		LR
													V0=1-(std::abs(Tx+Rx)+std::abs(Tx-Rx))/2;
												else//	R
													V0=1-Rx;
												Tx=1-Rx;
											}
											else
											{
												if(Tshade)
													V0=1-Tx;
												else
													V0=true;//false
											}
											Tshade=shade;
										}
									}
								}//*/
							/*	{
									auto &ndr=ex.n[0].ndr;
									double next=1;
									for(int v=0, vEnd=ndr.size()-1;v<vEnd;++v)
									{
										auto &V0=ndr[v], &V1=ndr[v+1];
										double dr=V1.r-V0.r, di=V1.i-V0.i;
										double x=-.5*(V0.r*dr+V0.i*di)/(dr*dr+di*di);
										bool assigned=false;
										if(x>=0&&x<1)
										{
											double rx=V0.r+dr*x, ix=V0.i+di*x;
											if(assigned=rx*rx+ix*ix<.25)
											{
												if(x<.5)
												{
													if(v>0)
														ndr[v-1].r*=x+.5;
													V0.r=next*(.5-x);
													next=1;
												}
												else
												{
													V0.r=next*(x-.5);
													next=1.5-x;
												}
											}
										}
										if(!assigned)
											V0.r=next, next=1;
									}
								}//*/
								break;
							case 'H':
								{
									bool Tshade=false;//trans-pixel shade
									double Tx;
									{
										auto &V0=ndr[0], &V1=ndr[1];
										double dr=V1.r-V0.r, di=V1.i-V0.i, dj=V1.j-V0.j, dk=V1.k-V0.k;
										double Tx=-.5*(V0.r*dr+V0.i*di+V0.j*dj+V0.k*dk)/(dr*dr+di*di+dj*dj+dk*dk);
										if(Tx>=0&&Tx<1)
										{
											double rx=V0.r+dr*Tx, ix=V0.i+di*Tx, jx=V1.j+dj*x, kx=V1.k+dk*x;
											Tshade=rx*rx+ix*ix+jx*jx+kx*kx<.25;//why 0.25?
										}
									}
									for(int v=0, vEnd=ndr.size()-2;v<vEnd;++v)
									{
										auto &V0=ndr[v], &V1=ndr[v+1], &V2=ndr[v+2];
										if(V1.r==0&&V1.i==0)
											V0=true;
										else
										{
											bool shade=false;
											double Rx;
											{
												double dr=V2.r-V1.r, di=V2.i-V1.i, dj=V2.j-V1.j, dk=V2.k-V1.k;
												Rx=-.5*(V1.r*dr+V1.i*di+V0.j*dj+V0.k*dk)/(dr*dr+di*di+dj*dj+dk*dk);
												if(Rx>=0&&Rx<1)
												{
													double rx=V1.r+dr*Rx, ix=V1.i+di*Rx, jx=V1.j+dj*x, kx=V1.k+dk*x;
													shade=rx*rx+ix*ix+jx*jx+kx*kx<.25;
												}
											}
											if(shade)//cross at R?
											{
												if(Tshade)//cross at L?		LR
													V0=1-(std::abs(Tx+Rx)+std::abs(Tx-Rx))/2;
												else//	R
													V0=1-Rx;
												Tx=1-Rx;
											}
											else
											{
												if(Tshade)
													V0=1-Tx;//![1-]
												else
													V0=true;//false
											}
											Tshade=shade;
										}
									}
								}//*/
							/*	{
									auto &ndr=ex.n[0].ndr;
									double next=1;
									for(int v=0, vEnd=ndr.size()-1;v<vEnd;++v)
									{
										auto &V0=ndr[v], &V1=ndr[v+1];
										double dr=V1.r-V0.r, di=V1.i-V0.i, dj=V0.j-V1.j, dk=V1.k-V0.k;
										double x=-.5*(V0.r*dr+V0.i*di+V0.j*dj+V0.k*dk)/(dr*dr+di*di+dj*dj+dk*dk);
										bool assigned=false;
										if(x>=0&&x<1)
										{
											double rx=V0.r+dr*x, ix=V0.i+di*x, jx=V0.j+dj*x, kx=V0.k+dk*x;
											if(assigned=rx*rx+ix*ix+jx*jx+kx*kx<.25)
											{
												if(x<.5)
												{
													if(v>0)
														ndr[v-1].r*=x+.5;
													V0.r=next*(.5-x);
													next=1;
												}
												else
												{
													V0.r=next*(x-.5);
													next=1.5-x;
												}
											}
										}
										if(!assigned)
											V0.r=next, next=1;
									}
								}//*/
								break;
							}
						}
						break;
					}
#endif
				}
				break;
			}
		}
	private:
		void shift_		(std::vector<Value> &ndr, int *a, int)
		{
			int XSstart=a[0], XSend=a[1], XDstart=a[2];
		//	int XSstart=sa[0], XSend=sa[1], XDstart=sa[2];
			auto begin=ndr.begin();
			std::copy(begin+XSstart, begin+XSend, begin+XDstart);
		}
		void shift_r	(std::vector<Value> &ndr, int *a, int aXplaces)
		{
			int XSstart=a[0], XSend=a[1], XDstart=a[2];
			auto rbegin=ndr.rbegin();
			std::copy(rbegin+aXplaces-1-XSstart, rbegin+aXplaces-1-XSend, rbegin+aXplaces-1-XDstart);
		//	int XSstart=sa[0], XSend=sa[1], XDstart=sa[2];
		//	auto rbegin=ndr.rbegin();
		//	std::copy(rbegin+Xplaces-1-XSstart, rbegin+Xplaces-1-XSend, rbegin+Xplaces-1-XDstart);
		}
		decltype(&Solve_1D_Implicit::shift_) shift;
	public:
		void partial_bounds(double VX, double DX, int Xoffset)
		{
			Xsample=DX/Xplaces;
			Xstart_s=VX-DX/2, Xstart=Xstart_s+Xsample;
		//	Xstart=VX-DX/2, Xstart_s=Xstart-Xsample;
			int Xoffset2=std::abs(Xoffset)+2;
			int Xplaces2=Xplaces+2;
		//	this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces;
				 if(Xoffset>0)					shift=&Solve_1D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,				ra[0]=Xplaces-Xoffset,		ra[1]=Xplaces,
																					sa[3]=Xoffset,				sa[4]=Xplaces2,	sa[5]=0,				ra[2]=Xplaces2-Xoffset2,	ra[3]=Xplaces2;
			else if(Xoffset<0)Xoffset=-Xoffset,	shift=&Solve_1D_Implicit::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,		ra[0]=0,					ra[1]=Xoffset,
																					sa[3]=Xplaces2-1-Xoffset,	sa[4]=-1,		sa[5]=Xplaces2-1,		ra[2]=0,					ra[3]=Xoffset2;
		//		 if(Xoffset>0)					shift=&Solve_1D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,				ra[0]=Xplaces-Xoffset-1,	ra[1]=Xplaces;
		//	else if(Xoffset<0)Xoffset=-Xoffset,	shift=&Solve_1D_Implicit::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,		ra[0]=0,					ra[1]=Xoffset+1;
		}
		void partial(Expression &ex)
		{
			int saOffset, aXplaces;
			int x1, x2;
			Value overlap[2];//because value ndr size = logic ndr size + 2
			{
				auto &ndr=ex.n[0].ndr;
				if(ex.resultLogicType==1)
					saOffset=0, aXplaces=Xplaces,	x1=ra[0], x2=ra[1];
				else
				{
					saOffset=3, aXplaces=Xplaces+2,	x1=ra[2], x2=ra[3];
					if(x1==0)
						overlap[0]=ndr[0], overlap[1]=ndr[1];
				}
				(this->*shift)(ndr, sa+saOffset, aXplaces);
			}

		//	auto &ndr0=ex.n[0].ndr;
		//	(this->*shift)(ndr0);
		//	int x1=ra[0], x2=ra[1]+(ex.resultLogicType>=2);

		//	double transient;
		//	if(ex.resultLogicType>=2&&x2!=ndr0.size())//= != equation, ndr.size()=Xplaces+1, shift right: {Xplaces-1-Xoffset, -1, Xplaces-1}, solve left: {0, Xoffset}
		//		transient=ndr0[x2-1];

			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_1D_Implicit::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_1D_Implicit::fx, LOL_1_const=0;break;
				case 'c':f=&Solve_1D_Implicit::fc, p=&variables.val.r;break;
				case 't':f=&Solve_1D_Implicit::fc, p=&T;break;
				}
			};
			auto initialize_const=[&](std::vector<Value> &ndr, Value &value){std::fill(ndr.begin()+x1, ndr.begin()+x2, value);};
			auto initialize_const_r=[&](std::vector<Value> &ndr, double value){std::fill(ndr.begin()+x1, ndr.begin()+x2, value);};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					initialize_const(n.ndr, ex.data[kn]);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_1D_Implicit::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								initialize_const_r(ndr, (this->*r)());
							else
							{
								auto ndrIT=ndr.begin()+x1;
								for(x=x1;x<x2;++x, ++ndrIT)
									*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_1D_Implicit::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								initialize_const(ndr, Value((this->*r)(), (this->*i)()));
							else
							{
								auto ndrIT=ndr.begin()+x1;
								for(x=x1;x<x2;++x, ++ndrIT)
									*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_1D_Implicit::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								initialize_const(ndr, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								auto ndrIT=ndr.begin()+x1;
								for(x=x1;x<x2;++x, ++ndrIT)
									*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			switch(ex.resultLogicType)
			{
			case 1://&& ## || < <= > >=
				{
					for(auto &i:ex.i)
					{
						switch(i.type)
					//	switch(i.nArgs)
						{
						case 'c'://user function call
							concurrency::parallel_for(unsigned(x1), unsigned(x2), Solve_UserFunction(ex, i));
							break;
						case 1:
							{
								auto &result=ex.n[i.result], &op1=ex.n[i.op1];
								std::transform(op1.ndr.begin()+x1, op1.ndr.begin()+x2, result.ndr.begin()+x1, i.uf);
							}
							break;
						case 2:
							{
								auto &result=ex.n[i.result], &op1=ex.n[i.op1], &op2=ex.n[i.op2];
								std::transform(op1.ndr.begin()+x1, op1.ndr.begin()+x2, op2.ndr.begin()+x1, result.ndr.begin()+x1, i.bf);
							}
							break;
						case 3:
							{
								auto &result=ex.n[i.result], &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
								for(int v=x1;v<x2;++v)
									result.ndr[v]=i.tf(op1.ndr[v], op2.ndr[v], op3.ndr[v]);
							}
							break;
						}
					}
				}
				break;
			//ex.resultLogicType>=2		anti-aliasing
			case 2://=
			case 3://!=
				{
					int Xplaces1=Xplaces+1, Xplaces2=Xplaces+2;
					for(int x=x1, xEnd=x2-1;x<xEnd;++x)
						ex.discontinuities[x]=false;
					unsigned ndrSize=ex.n[0].ndr.size();
					for(auto iIT=ex.i.begin(), iITend=ex.i.end()-1;iIT!=iITend;++iIT)
					{
						auto &i=*iIT;
						auto &result=ex.n[i.result];
						switch(i.type)
					//	switch(i.nArgs)
						{
						case 'c'://user function call
							concurrency::parallel_for(unsigned(x1), unsigned(x2), Solve_UserFunction(ex, i));
							break;
						case 1:
							{
								auto &op1=ex.n[i.op1];
								if(i.d.disc_in)
								{
									for(int x=x1, xEnd=x2-1;x<xEnd;++x)
									{
										auto &condition=ex.discontinuities[x];
										condition=condition||i.d.ud_i(op1.ndr[x], op1.ndr[x+1]);
									}
								}
								std::transform(op1.ndr.begin()+x1, op1.ndr.begin()+x2, result.ndr.begin()+x1, i.uf);
							}
							break;
						case 2:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2];
								if(i.d.disc_in)
								{
									for(int x=x1, xEnd=x2-1;x<xEnd;++x)
									{
										auto &condition=ex.discontinuities[x];
										condition=condition||i.d.bd_i(op1.ndr[x], op2.ndr[x], op1.ndr[x+1], op2.ndr[x+1]);
									}
								}
								std::transform(op1.ndr.begin()+x1, op1.ndr.begin()+x2, op2.ndr.begin()+x1, result.ndr.begin()+x1, i.bf);
							}
							break;
						case 3:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
								if(i.d.disc_in)
								{
									for(int x=x1, xEnd=x2-1;x<xEnd;++x)
									{
										auto &condition=ex.discontinuities[x];
										condition=condition||i.d.td_i(op1.ndr[x], op2.ndr[x], op3.ndr[x], op1.ndr[x+1], op2.ndr[x+1], op3.ndr[x+1]);
									}
								}
								for(int v=x1;v<x2;++v)
									result.ndr[v]=i.tf(op1.ndr[v], op2.ndr[v], op3.ndr[v]);
							}
							break;
						}
						if(i.d.disc_out)
						{
							for(int x=x1, xEnd=x2-1;x<xEnd;++x)
							{
								auto &condition=ex.discontinuities[x];
								condition=condition||i.d.d_o(result.ndr[x], result.ndr[x+1]);
							}
						}
					}
					//for(int k=0, kEnd=ex.n[0].ndr.size();k<kEnd;++k)//
					//	ex.n[0].ndr[k].r*=255;//
					//{
					//	auto &i=*ex.i.rbegin();
					//	auto &op1=ex.n[i.op1], &result=ex.n[i.result];
					//	switch(i.type)
					////	switch(i.nArgs)
					//	{
					//	case 1:
					//		std::transform(op1.ndr.begin()+x1, op1.ndr.begin()+x2, result.ndr.begin()+x1, G2::q_minus);
					//	//	concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), G2::q_minus);
					//		break;
					//	case 2:
					//		{
					//			auto &op2=ex.n[i.op2];
					//			std::transform(op1.ndr.begin()+x1, op1.ndr.begin()+x2, op2.ndr.begin()+x1, result.ndr.begin()+x1, G2::qq_minus);
					//		//	concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), op2.ndr.begin(), result.ndr.begin(), G2::qq_minus);
					//		}
					//		break;
					//	}
					//}
					auto &ndr=ex.n[0].ndr;
#if 0
					switch(ex.resultLogicType)
					{
					case 2://zero cross	_/\_
						{
#endif
						//	auto &n0=ex.n[0];
						//	double next=1;
							switch(ex.resultMathSet)
						//	switch(n0.mathSet)
						//	switch(ex.n[0].mathSet)
							{
							case 'r':
						//	case 'R':
								for(int x=x1, vEnd=x2-2;x<vEnd;++x)//{x1,x2}={0,Xoffset2} or {Xplaces-Xoffset, Xplaces}		ndr.size()==Xplaces+2
							//	for(int x=0, vEnd=ndr.size()-2;x<vEnd;++x)//ndr.size()==Xplaces+2
								{
									auto &V0=ndr[x].r, &V1=ndr[x+1].r, &V2=ndr[x+2].r;//V0 <= cross(V0, V1, V2)
									if(V1==0)
										V0=true;
									else if(!ex.discontinuities[x]&&std::signbit(V0)!=std::signbit(V1))//cross at L?
									{
										double d_min=V0/(V0-V1);
										if(!ex.discontinuities[x+1]&&std::signbit(V1)!=std::signbit(V2))//cross at R?
										{
											double d=V2/(V2-V1);
											d_min=(std::abs(d_min+d)+std::abs(d_min-d))/2;
										}
										V0=d_min;
									}
									else
									{
										if(!ex.discontinuities[x+1]&&std::signbit(V1)!=std::signbit(V2))//cross at R?
											V0=V2/(V2-V1);
										else
											V0=false;
									}
								}
								//for(int v=x1, vEnd=x2-1;v<vEnd;++v)
								//{
								//	auto &V0=ndr0[v].r, &V1=ndr0[v+1].r;
								//	if(std::signbit(V0)!=std::signbit(V1))
								//	{
								//		double x=(0-V0)/(V1-V0);
								//		if(x<.5)
								//		{
								//			if(v>0)
								//				ndr0[v-1].r*=x+.5;
								//			V0=next*(.5-x);
								//			next=1;
								//		}
								//		else
								//		{
								//			V0=next*(x-.5);
								//			next=1.5-x;
								//		}
								//	}
								//	else
								//		V0=next, next=1;
								//}
								break;
							case 'c':
						//	case 'C':
								{
									bool Tshade=false;//trans-pixel shade
									double Tx;
									if(!ex.discontinuities[x1])
									{
										auto &V0=ndr[x1], &V1=ndr[x1+1];
									//	auto &V0=ndr[0], &V1=ndr[1];
										double dr=V1.r-V0.r, di=V1.i-V0.i;
										double Tx=-.5*(V0.r*dr+V0.i*di)/(dr*dr+di*di);
										if(Tx>=0&&Tx<1)
										{
											double rx=V0.r+dr*Tx, ix=V0.i+di*Tx;
											Tshade=rx*rx+ix*ix<.25;
										}
									}
									for(int v=x1, vEnd=x2-2;v<vEnd;++v)
								//	for(int v=0, vEnd=ndr.size()-2;v<vEnd;++v)//the only difference w/ full
									{
										auto &V0=ndr[v], &V1=ndr[v+1], &V2=ndr[v+2];
										if(V1.r==0&&V1.i==0)
											V0=true;
										else
										{
											bool shade=false;
											double Rx;
											if(!ex.discontinuities[v+1])
											{
												double dr=V2.r-V1.r, di=V2.i-V1.i;
												double Rx=-.5*(V1.r*dr+V1.i*di)/(dr*dr+di*di);
												if(Rx>=0&&Rx<1)
												{
													double rx=V1.r+dr*Rx, ix=V1.i+di*Rx;
													shade=rx*rx+ix*ix<.25;//why 0.25?
												}
											}
											if(shade)//cross at R?
											{
												if(Tshade)//cross at L?		LR
													V0=(std::abs(Tx+Rx)+std::abs(Tx-Rx))/2;
												else//	R
													V0=Rx;
												Tx=1-Rx;
											}
											else
											{
												if(Tshade)
													V0=Tx;
												else
													V0=false;
											}
											Tshade=shade;
										}
									}
								}
								//for(int v=x1, vEnd=x2-1;v<vEnd;++v)
								//{
								//	auto &V0=ndr0[v], &V1=ndr0[v+1];
								//	double dr=V1.r-V0.r, di=V1.i-V0.i;
								//	double x=-.5*(V0.r*dr+V0.i*di)/(dr*dr+di*di);
								//	bool assigned=false;
								//	if(x>=0&&x<1)
								//	{
								//		double rx=V0.r+dr*x, ix=V0.i+di*x;
								//		if(assigned=rx*rx+ix*ix<1)
								//		{
								//			if(x<.5)
								//			{
								//				if(v>0)
								//					ndr0[v-1].r*=x+.5;
								//				V0.r=next*(.5-x);
								//				next=1;
								//			}
								//			else
								//			{
								//				V0.r=next*(.5-x);
								//				next=1.5-x;
								//			}
								//		}
								//	}
								//	if(!assigned)
								//		V0.r=next, next=1;
								//}
								break;
							case 'H':
								{
									bool Tshade=false;//trans-pixel shade
									double Tx;
									if(!ex.discontinuities[x1])
									{
										auto &V0=ndr[x1], &V1=ndr[x1+1];
										double dr=V1.r-V0.r, di=V1.i-V0.i, dj=V1.j-V0.j, dk=V1.k-V0.k;
										double Tx=-.5*(V0.r*dr+V0.i*di+V0.j*dj+V0.k*dk)/(dr*dr+di*di+dj*dj+dk*dk);
										if(Tx>=0&&Tx<1)
										{
											double rx=V0.r+dr*Tx, ix=V0.i+di*Tx, jx=V1.j+dj*Tx, kx=V1.k+dk*Tx;
											Tshade=rx*rx+ix*ix+jx*jx+kx*kx<.25;//why 0.25?
										}
									}
									for(int v=x1, vEnd=x2-2;v<vEnd;++v)
									{
										auto &V0=ndr[v], &V1=ndr[v+1], &V2=ndr[v+2];
										if(V1.r==0&&V1.i==0)
											V0=true;
										else
										{
											bool shade=false;
											double Rx;
											if(!ex.discontinuities[v])
											{
												double dr=V2.r-V1.r, di=V2.i-V1.i, dj=V2.j-V1.j, dk=V2.k-V1.k;
												double Rx=-.5*(V1.r*dr+V1.i*di+V0.j*dj+V0.k*dk)/(dr*dr+di*di+dj*dj+dk*dk);
												if(Rx>=0&&Rx<1)
												{
													double rx=V1.r+dr*Rx, ix=V1.i+di*Rx, jx=V1.j+dj*Rx, kx=V1.k+dk*Rx;
													shade=rx*rx+ix*ix+jx*jx+kx*kx<.25;
												}
											}
											if(shade)//cross at R?
											{
												if(Tshade)//cross at L?		LR
													V0=(std::abs(Tx+Rx)+std::abs(Tx-Rx))/2;
												else//	R
													V0=Rx;
												Tx=1-Rx;
											}
											else
											{
												if(Tshade)
													V0=Tx;
												else
													V0=false;
											}
											Tshade=shade;
										}
									}
								}
								//for(int v=x1, vEnd=x2-1;v<vEnd;++v)
								//{
								//	auto &V0=ndr0[v], &V1=ndr0[v+1];
								//	double dr=V1.r-V0.r, di=V1.i-V0.i, dj=V0.j-V1.j, dk=V1.k-V0.k;
								//	double x=-.5*(V0.r*dr+V0.i*di+V0.j*dj+V0.k*dk)/(dr*dr+di*di+dj*dj+dk*dk);
								//	bool assigned=false;
								//	if(x>=0&&x<1)
								//	{
								//		double rx=V0.r+dr*x, ix=V0.i+di*x, jx=V0.j+dj*x, kx=V0.k+dk*x;
								//		if(assigned=rx*rx+ix*ix+jx*jx+kx*kx<1)
								//		{
								//			if(x<.5)
								//			{
								//				if(v>0)
								//					ndr0[v-1].r*=x+.5;
								//				V0.r=next*(.5-x);
								//				next=1;
								//			}
								//			else
								//			{
								//				V0.r=next*(.5-x);
								//				next=1.5-x;
								//			}
								//		}
								//	}
								//	if(!assigned)
								//		V0.r=next, next=1;
								//}
								break;
							}
						//	if(x2!=ndr0.size())
						//		ndr0[x2-1]=transient;
#if 0
						}
						break;
					case 3:
						//				_  _
						//zero cross	 \/
						{
						//	auto &n0=ex.n[0];
						//	double next=0;
							switch(ex.resultMathSet)
						//	switch(ex.n[0].mathSet)
							{
							case 'r':
						//	case 'R':
								for(int v=x1, vEnd=x2-2;v<vEnd;++v)//ndr.size()==Xplaces+2
								{
									auto &V0=ndr[v].r, &V1=ndr[v+1].r, &V2=ndr[v+2].r;//V0 <= cross(V0, V1, V2)
									if(V1==0)
										V0=false;//true
									else if(std::signbit(V0)!=std::signbit(V1))//cross at L?
									{
										double d_min=V0/(V0-V1);
										if(std::signbit(V1)!=std::signbit(V2))//cross at R?
										{
											double d=V2/(V2-V1);
											d_min=(std::abs(d_min+d)+std::abs(d_min-d))/2;
										}
										V0=1-d_min;
									}
									else
									{
										if(std::signbit(V1)!=std::signbit(V2))//cross at R?
											V0=1-(V2-0)/(V2-V1);
										else
											V0=true;//false
									}
								}//*/
							/*	for(int v=x1, vEnd=x2-1;v<vEnd;++v)
								{
									auto &V0=ndr0[v].r, &V1=ndr0[v+1].r;
									if(std::signbit(V0)!=std::signbit(V1))
									{
										double x=(0-V0)/(V1-V0);
										if(x<.5)
										{
											if(v>0)
												ndr0[v-1].r*=1-(x+.5);
											V0=next*(1-(.5-x));
											next=0;
										}
										else
										{
											V0=next*(1-(x-.5));
											next=1-(1.5-x);
										}
									}
									else
										V0=next, next=0;
								}//*/
								break;
							case 'c':
						//	case 'C':
								{
									bool Tshade=false;//trans-pixel shade
									double Tx;
									{
										auto &V0=ndr[x1], &V1=ndr[x1+1];
										double dr=V1.r-V0.r, di=V1.i-V0.i;
										double Tx=-.5*(V0.r*dr+V0.i*di)/(dr*dr+di*di);
										if(Tx>=0&&Tx<1)
										{
											double rx=V0.r+dr*Tx, ix=V0.i+di*Tx;
											Tshade=rx*rx+ix*ix<.25;
										}
									}
									for(int v=x1, vEnd=x2-2;v<vEnd;++v)
									{
										auto &V0=ndr[v], &V1=ndr[v+1], &V2=ndr[v+2];
										if(V1.r==0&&V1.i==0)
											V0=true;
										else
										{
											bool shade=false;
											double Rx;
											{
												double dr=V2.r-V1.r, di=V2.i-V1.i;
												Rx=-.5*(V1.r*dr+V1.i*di)/(dr*dr+di*di);
												if(Rx>=0&&Rx<1)
												{
													double rx=V1.r+dr*Rx, ix=V1.i+di*Rx;
													shade=rx*rx+ix*ix<.25;//why 0.25?
												}
											}
											if(shade)//cross at R?
											{
												if(Tshade)//cross at L?		LR
													V0=1-(std::abs(Tx+Rx)+std::abs(Tx-Rx))/2;
												else//	R
													V0=1-Rx;
												Tx=1-Rx;
											}
											else
											{
												if(Tshade)
													V0=1-Tx;
												else
													V0=true;//false
											}
											Tshade=shade;
										}
									}
								}//*/
							/*	for(int v=x1, vEnd=x2-1;v<vEnd;++v)
								{
									auto &V0=ndr0[v], &V1=ndr0[v+1];
									double dr=V1.r-V0.r, di=V1.i-V0.i;
									double x=-.5*(V0.r*dr+V0.i*di)/(dr*dr+di*di);
									bool assigned=false;
									if(x>=0&&x<1)
									{
										double rx=V0.r+dr*x, ix=V0.i+di*x;
										if(assigned=rx*rx+ix*ix<1)
										{
											if(x<.5)
											{
												if(v>0)
													ndr0[v-1].r*=1-(x+.5);
												V0.r=next*(1-(.5-x));
												next=0;
											}
											else
											{
												V0.r=next*(1-(.5-x));
												next=1-(1.5-x);
											}
										}
									}
									if(!assigned)
										V0.r=next, next=0;
								}//*/
								break;
							case 'H':
								{
									bool Tshade=false;//trans-pixel shade
									double Tx;
									{
										auto &V0=ndr[x1], &V1=ndr[x1+1];
										double dr=V1.r-V0.r, di=V1.i-V0.i, dj=V1.j-V0.j, dk=V1.k-V0.k;
										double Tx=-.5*(V0.r*dr+V0.i*di+V0.j*dj+V0.k*dk)/(dr*dr+di*di+dj*dj+dk*dk);
										if(Tx>=0&&Tx<1)
										{
											double rx=V0.r+dr*Tx, ix=V0.i+di*Tx, jx=V1.j+dj*Tx, kx=V1.k+dk*Tx;
											Tshade=rx*rx+ix*ix+jx*jx+kx*kx<.25;//why 0.25?
										}
									}
									for(int v=x1, vEnd=x2-2;v<vEnd;++v)
									{
										auto &V0=ndr[v], &V1=ndr[v+1], &V2=ndr[v+2];
										if(V1.r==0&&V1.i==0)
											V0=true;
										else
										{
											bool shade=false;
											double Rx;
											{
												double dr=V2.r-V1.r, di=V2.i-V1.i, dj=V2.j-V1.j, dk=V2.k-V1.k;
												Rx=-.5*(V1.r*dr+V1.i*di+V0.j*dj+V0.k*dk)/(dr*dr+di*di+dj*dj+dk*dk);
												if(Rx>=0&&Rx<1)
												{
													double rx=V1.r+dr*Rx, ix=V1.i+di*Rx, jx=V1.j+dj*Rx, kx=V1.k+dk*Rx;
													shade=rx*rx+ix*ix+jx*jx+kx*kx<.25;
												}
											}
											if(shade)//cross at R?
											{
												if(Tshade)//cross at L?		LR
													V0=1-(std::abs(Tx+Rx)+std::abs(Tx-Rx))/2;
												else//	R
													V0=1-Rx;
												Tx=1-Rx;
											}
											else
											{
												if(Tshade)
													V0=1-Tx;//![1-]
												else
													V0=true;//false
											}
											Tshade=shade;
										}
									}
								}//*/
							/*	for(int v=x1, vEnd=x2-1;v<vEnd;++v)
								{
									auto &V0=ndr0[v], &V1=ndr0[v+1];
									double dr=V1.r-V0.r, di=V1.i-V0.i, dj=V0.j-V1.j, dk=V1.k-V0.k;
									double x=-.5*(V0.r*dr+V0.i*di+V0.j*dj+V0.k*dk)/(dr*dr+di*di+dj*dj+dk*dk);
									bool assigned=false;
									if(x>=0&&x<1)
									{
										double rx=V0.r+dr*x, ix=V0.i+di*x, jx=V0.j+dj*x, kx=V0.k+dk*x;
										if(assigned=rx*rx+ix*ix+jx*jx+kx*kx<1)
										{
											if(x<.5)
											{
												if(v>0)
													ndr0[v-1].r*=1-(x+.5);
												V0.r=next*(1-(.5-x));
												next=0;
											}
											else
											{
												V0.r=next*(1-(.5-x));
												next=1-(1.5-x);
											}
										}
									}
									if(!assigned)
										V0.r=next, next=0;
								}//*/
								break;
							}
						//	if(x2!=ndr0.size())
						//		ndr0[x2-1]=transient;
						}
						break;
					}
#endif
					if(x1==0)
						ndr[x2-2]=overlap[0], ndr[x2-1]=overlap[1];
				}
				break;
			}
		}
	};
	class		Solve_1D_Disc:public Solve
	{
	public:
		double Xstart, Xsample;
		int Xplaces;
	private:
		int x;
		double *p;
		double fx(){return Xstart+x*Xsample;}
		double fc(){return *p;}
		int sa[3], ra[2];
	public:
		void full_resize(double VX, double DX, int Xplaces){this->Xplaces=Xplaces, this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces;}
		void full(Expression &ex)
		{
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_1D_Disc::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_1D_Disc::fx, LOL_1_const=0;break;
				case 'c':f=&Solve_1D_Disc::fc, p=&variables.val.r;break;
				case 't':f=&Solve_1D_Disc::fc, p=&T;break;
				}
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					n.ndr.assign(Xplaces, ex.data[kn]);
				//	n.ndr.assign(Xplaces, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_1D_Disc::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								ndr.assign(Xplaces, (this->*r)());
							else
							{
								ndr.resize(Xplaces);
								auto ndrIT=ndr.begin();
								for(x=0;x<Xplaces;++x, ++ndrIT)
									*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_1D_Disc::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								ndr.assign(Xplaces, Value((this->*r)(), (this->*i)()));
							else
							{
								ndr.resize(Xplaces);
								auto ndrIT=ndr.begin();
								for(x=0;x<Xplaces;++x, ++ndrIT)
									*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_1D_Disc::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								ndr.assign(Xplaces, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								ndr.resize(Xplaces);
								auto ndrIT=ndr.begin();
								for(x=0;x<Xplaces;++x, ++ndrIT)
									*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			ex.discontinuities.assign(Xplaces-1, false);
			unsigned ndrSize=ex.n[0].ndr.size();
			for(auto &i:ex.i)
			{
				auto &result=ex.n[i.result];
				switch(i.type)
			//	switch(i.nArgs)
				{
				case 'c'://user function call
					concurrency::parallel_for(0u, ndrSize, Solve_UserFunction(ex, i));
					break;
				case 1:
					{
						auto &op1=ex.n[i.op1];
						if(i.d.disc_in)
						{
							concurrency::parallel_for(0u, op1.ndr.size()-1, [&](int k)
							{
								auto &condition=ex.discontinuities[k];
								condition=condition||i.d.ud_i(op1.ndr[k], op1.ndr[k+1]);
							});
						}
						concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), i.uf);//benchmark
					//	concurrency::parallel_for(0u, op1.ndr.size(), [&](int k){result.ndr[k]=i.uf(op1.ndr[k]);});
					//	std::transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), i.uf);
					//	for(unsigned k=0;k<op1.ndr.size();++k)result.ndr[k]=i.uf(op1.ndr[k]);
					}
					break;
				case 2:
					{
						auto &op1=ex.n[i.op1], &op2=ex.n[i.op2];
						if(i.d.disc_in)
						{
							concurrency::parallel_for(0u, op1.ndr.size()-1, [&](int k)
							{
								auto &condition=ex.discontinuities[k];
								condition=condition||i.d.bd_i(op1.ndr[k], op2.ndr[k], op1.ndr[k+1], op2.ndr[k+1]);
							});
						}
						concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), op2.ndr.begin(), result.ndr.begin(), i.bf);
					//	concurrency::parallel_for(0u, op1.ndr.size(), [&](int k){result.ndr[k]=i.bf(op1.ndr[k], op2_ndr[k]);});
					//	std::transform(op1.ndr.begin(), op1.ndr.end(), op2_ndr.begin(), result.ndr.begin(), i.bf);
					//	for(unsigned k=0;k<op1.ndr.size();++k)result.ndr[k]=i.bf(op1.ndr[k], op2_ndr[k]);
					}
					break;
				case 3:
					{
						auto &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
						if(i.d.disc_in)
						{
							concurrency::parallel_for(0u, op1.ndr.size()-1, [&](int k)
							{
								auto &condition=ex.discontinuities[k];
								condition=condition||i.d.td_i(op1.ndr[k], op2.ndr[k], op3.ndr[k], op1.ndr[k+1], op2.ndr[k+1], op3.ndr[k+1]);
							});
						}
						concurrency::parallel_for(0u, op1.ndr.size(), [&](int k){result.ndr[k]=i.tf(op1.ndr[k], op2.ndr[k], op3.ndr[k]);});
					}
					break;
				}
				if(i.d.disc_out)
				{
					for(unsigned k=0;k<result.ndr.size()-1;++k)
					{
						auto &condition=ex.discontinuities[k];
						condition=condition||i.d.d_o(result.ndr[k], result.ndr[k+1]);
					}
					//concurrency::parallel_for(0u, result.ndr.size()-1, [&](int k)
					//{
					//	auto &condition=ex.discontinuities[k];
					//	condition=condition||i.d.d_o(result.ndr[k], result.ndr[k+1]);
					//	if(!condition)
					//		int LOL_1=0;//sometimes misses
					//});
				}
			}
		}
	private:
		void shift_		(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			int &XSstart=sa[0], &XSend=sa[1], &XDstart=sa[2];
			{
				auto begin=ndr.begin();
				std::copy(begin+XSstart, begin+XSend, begin+XDstart);
			}
			if(XSstart<Xplaces-1)
			{
				auto begin=discontinuities.begin();
				std::copy(begin+XSstart, begin+XSend-1, begin+XDstart);
			}
		}
		void shift_r	(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2];
			{
				auto rbegin=ndr.rbegin();
				std::copy(rbegin+Xplaces-1-XSstart, rbegin+Xplaces-1-XSend, rbegin+Xplaces-1-XDstart);
			}
			if(XSstart>0)
			{
				auto rbegin=discontinuities.rbegin();
				std::copy(rbegin+Xplaces-2-(XSstart-1), rbegin+Xplaces-2-XSend, rbegin+Xplaces-2-(XDstart-1));
			}
		}
		decltype(&Solve_1D_Disc::shift_) shift;
	public:
		void partial_bounds	(double VX, double DX, int Xoffset)
		{
			this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces;
				 if(Xoffset>0)					shift=&Solve_1D_Disc::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,				++Xoffset,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces;
			else if(Xoffset<0)Xoffset=-Xoffset,	shift=&Solve_1D_Disc::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,		++Xoffset,	ra[0]=0,				ra[1]=Xoffset;
		}
		void partial(Expression &ex)
		{
			(this->*shift)(ex.n[0].ndr, ex.discontinuities);
			int x1=ra[0], x2=ra[1];
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_1D_Disc::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_1D_Disc::fx, LOL_1_const=0;break;
				case 'c':f=&Solve_1D_Disc::fc, p=&variables.val.r;break;
				case 't':f=&Solve_1D_Disc::fc, p=&T;break;
				}
			};
			auto initialize_const=[&](std::vector<Value> &ndr, Value &value){std::fill(ndr.begin()+x1, ndr.begin()+x2, value);};
			auto initialize_const_r=[&](std::vector<Value> &ndr, double value){std::fill(ndr.begin()+x1, ndr.begin()+x2, value);};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					initialize_const(n.ndr, ex.data[kn]);
				//	initialize_const(n.ndr, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_1D_Disc::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								initialize_const_r(n.ndr, (this->*r)());
							else
							{
								auto ndrIT=ndr.begin()+x1;
								for(x=x1;x<x2;++x, ++ndrIT)
									*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_1D_Disc::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)()));
							else
							{
								auto ndrIT=ndr.begin()+x1;
								for(x=x1;x<x2;++x, ++ndrIT)
									*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_1D_Disc::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								auto ndrIT=ndr.begin()+x1;
								for(x=x1;x<x2;++x, ++ndrIT)
									*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
		//	std::fill(ex.discontinuities.begin()+x1, ex.discontinuities.begin()+x2-1, false);
			for(int v=x1;v<x2-1;++v)
				ex.discontinuities[v]=false;
			for(auto &i:ex.i)
			{
				auto &result=ex.n[i.result];
				switch(i.type)
			//	switch(i.nArgs)
				{
				case 'c'://user function call
					concurrency::parallel_for(unsigned(x1), unsigned(x2), Solve_UserFunction(ex, i));
					break;
				case 1:
					{
						auto &op1=ex.n[i.op1];
						if(i.d.disc_in)
						{
							for(int v=x1;v<x2-1;++v)
							{
								auto &condition=ex.discontinuities[v];
								condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+1]);
							}
						}
						std::transform(op1.ndr.begin()+x1, op1.ndr.begin()+x2, result.ndr.begin()+x1, i.uf);
					//	for(auto it=o1->begin()+x1, itEnd=o1->begin()+x2;it!=itEnd;++it)*it=i.uf(*it);
					}
					break;
				case 2:
					{
						auto &op1=ex.n[i.op1], &op2=ex.n[i.op2];
						if(i.d.disc_in)
						{
							for(int v=x1;v<x2-1;++v)
							{
								auto &condition=ex.discontinuities[v];
								condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+1], op2.ndr[v+1]);
							}
						}
						std::transform(op1.ndr.begin()+x1, op1.ndr.begin()+x2, op2.ndr.begin()+x1, result.ndr.begin()+x1, i.bf);
					//	for(auto it=o1->begin()+x1, itEnd=o1->begin()+x2, it2=ex.n[i.op2].ndr.begin()+x1, &res=i.result==i.op1?it:it2;it!=itEnd;++it, ++it2)*res=i.bf(*it, *it2);
					}
					break;
				case 3:
					{
						auto &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
						if(i.d.disc_in)
						{
							for(int v=x1;v<x2;++v)
							{
								auto &condition=ex.discontinuities[v];
								condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+1], op2.ndr[v+1], op3.ndr[v+1]);
							}
						}
						for(int v=x1;v<x2;++v)
							result.ndr[v]=i.tf(op1.ndr[v], op2.ndr[v], op3.ndr[v]);
					//	for(auto it=o1->begin()+x1, itEnd=o1->begin()+x2, it2=ex.n[i.op2].ndr.begin()+x1, it3=ex.n[i.op3].ndr.begin()+x1, &res=i.result==i.op1?it:i.result==i.op2?it2:it3;it!=itEnd;++it, ++it2, ++it3)*res=i.tf(*it, *it2, *it3);
					}
					break;
				}
				if(i.d.disc_out)
				{
					for(int v=x1;v<x2-1;++v)
					{
						auto &condition=ex.discontinuities[v];
						condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+1]);
					}
				}
			}
		}
	};
	class		Solve_1D:public Solve
	{
	public:
		double Xstart, Xsample;
		int Xplaces;
	private:
		int x;
		double *p;
		double fx(){return Xstart+x*Xsample;}
		double fc(){return *p;}
		int sa[3], ra[2];
	public:
		void full_resize(double VX, double DX, int Xplaces){this->Xplaces=Xplaces, this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces;}
		void full(Expression &ex)
		{
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_1D::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_1D::fx, LOL_1_const=0;break;
				case 'c':f=&Solve_1D::fc, p=&variables.val.r;break;
				case 't':f=&Solve_1D::fc, p=&T;break;
				}
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					n.ndr.assign(Xplaces, ex.data[kn]);
				//	n.ndr.assign(Xplaces, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(variables.mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_1D::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								ndr.assign(Xplaces, (this->*r)());
							else
							{
								ndr.resize(Xplaces);
								auto ndrIT=ndr.begin();
								for(x=0;x<Xplaces;++x, ++ndrIT)
									*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_1D::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								ndr.assign(Xplaces, Value((this->*r)(), (this->*i)()));
							else
							{
								ndr.resize(Xplaces);
								auto ndrIT=ndr.begin();
								for(x=0;x<Xplaces;++x, ++ndrIT)
									*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_1D::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								ndr.assign(Xplaces, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								ndr.resize(Xplaces);
								auto ndrIT=ndr.begin();
								for(x=0;x<Xplaces;++x, ++ndrIT)
									*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			::solve(ex);
		}
	private:
		void shift_		(std::vector<Value> &ndr)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2];
			auto begin=ndr.begin();
			std::copy(begin+XSstart, begin+XSend, begin+XDstart);
		}
		void shift_r	(std::vector<Value> &ndr)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2];
			auto rbegin=ndr.rbegin();
			std::copy(rbegin+Xplaces-1-XSstart, rbegin+Xplaces-1-XSend, rbegin+Xplaces-1-XDstart);
		}
		decltype(&Solve_1D::shift_) shift;
	public:
		void partial_bounds	(double VX, double DX, int Xoffset)
		{
			this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces;
				 if(Xoffset>0)					shift=&Solve_1D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,				ra[0]=Xplaces-Xoffset-1,	ra[1]=Xplaces;
			else if(Xoffset<0)Xoffset=-Xoffset,	shift=&Solve_1D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,		ra[0]=0,					ra[1]=Xoffset+1;
		}
		void partial(Expression &ex)
		{
			(this->*shift)(ex.n[0].ndr);
			int x1=ra[0], x2=ra[1];
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_1D::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_1D::fx, LOL_1_const=0;break;
				case 'c':f=&Solve_1D::fc, p=&variables.val.r;break;
				case 't':f=&Solve_1D::fc, p=&T;break;
				}
			};
			auto initialize_const=[&](std::vector<Value> &ndr, Value &value){std::fill(ndr.begin()+x1, ndr.begin()+x2, value);};
			auto initialize_const_r=[&](std::vector<Value> &ndr, double value){std::fill(ndr.begin()+x1, ndr.begin()+x2, value);};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					initialize_const(n.ndr, ex.data[kn]);
				//	initialize_const(n.ndr, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_1D::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								initialize_const_r(n.ndr, (this->*r)());
							else
							{
								auto ndrIT=ndr.begin()+x1;
								for(x=x1;x<x2;++x, ++ndrIT)
									*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_1D::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)()));
							else
							{
								auto ndrIT=ndr.begin()+x1;
								for(x=x1;x<x2;++x, ++ndrIT)
									*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_1D::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								auto ndrIT=ndr.begin()+x1;
								for(x=x1;x<x2;++x, ++ndrIT)
									*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			for(auto &i:ex.i)
			{
				switch(i.type)
			//	switch(i.nArgs)
				{
				case 'c'://user function call
					concurrency::parallel_for(unsigned(x1), unsigned(x2), Solve_UserFunction(ex, i));
					break;
				case 1:
					{
						auto &result=ex.n[i.result], &op1=ex.n[i.op1];
						std::transform(op1.ndr.begin()+x1, op1.ndr.begin()+x2, result.ndr.begin()+x1, i.uf);
					//	for(auto it=o1->begin()+x1, itEnd=o1->begin()+x2;it!=itEnd;++it)*it=i.uf(*it);
					}
					break;
				case 2:
					{
						auto &result=ex.n[i.result], &op1=ex.n[i.op1], &op2=ex.n[i.op2];
						std::transform(op1.ndr.begin()+x1, op1.ndr.begin()+x2, op2.ndr.begin()+x1, result.ndr.begin()+x1, i.bf);
					//	for(auto it=o1->begin()+x1, itEnd=o1->begin()+x2, it2=ex.n[i.op2].ndr.begin()+x1, &res=i.result==i.op1?it:it2;it!=itEnd;++it, ++it2)*res=i.bf(*it, *it2);
					}
					break;
				case 3:
					{
						auto &result=ex.n[i.result], &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
						for(int v=x1;v<x2;++v)
							result.ndr[v]=i.tf(op1.ndr[v], op2.ndr[v], op3.ndr[v]);
					//	for(auto it=o1->begin()+x1, itEnd=o1->begin()+x2, it2=ex.n[i.op2].ndr.begin()+x1, it3=ex.n[i.op3].ndr.begin()+x1, &res=i.result==i.op1?it:i.result==i.op2?it2:it3;it!=itEnd;++it, ++it2, ++it3)*res=i.tf(*it, *it2, *it3);
					}
					break;
				}
			}
		}
	};
	class		Solve_2D_Implicit:public Solve
	{
	public:
		HBITMAP hBitmap;
		int *rgb, **prgb;
		Solve_2D_Implicit():rgb(0){}
		double
			Xsample, Xstart, Xstart_s, *aXstart,
			Ysample, Yend, Yend_s, *aYend;
		int ndrSize, Xplaces, Yplaces;
	private:
		int y, x;
		double *p;
		double fx(){return *aXstart	+x*Xsample;}
		double fy(){return *aYend	-y*Ysample;}
		double fc(){return *p;}
		int sa[12], ra[16];

	//	unsigned char exColorRA, exColorRB, exColorGA, exColorGB, exColorBA, exColorBB;
		double exColorRA, exColorRB, exColorGA, exColorGB, exColorBA, exColorBB;
		void DimDIBPixelUnchecked_mono				(int x, int y, double a)
		{
		//	auto p=(unsigned char*)&prgb[0][(y-1)*w+x-1];
			auto p=(unsigned char*)&(*prgb)[(y-1)*w+x-1];
			p[0]=unsigned char(p[0]*a), p[1]=unsigned char(p[1]*a), p[2]=unsigned char(p[2]*a);
		}
		void DimDIBPixelUnchecked_mono_complement	(int x, int y, double a)
		{
			auto p=(unsigned char*)&(*prgb)[(y-1)*w+x-1];
			p[0]-=unsigned char(a*p[0])/2, p[1]-=unsigned char(a*p[1])/2, p[2]-=unsigned char(a*p[2])/2;
		}
		void DimDIBPixelUnchecked_color				(int x, int y, double a)
		{
			auto p=(unsigned char*)&(*prgb)[(y-1)*w+x-1];
			
		//	p[0]=(unsigned char(exColorBA*a)+exColorBB)*p[0]>>8;
		//	p[1]=(unsigned char(exColorGA*a)+exColorGB)*p[1]>>8;
		//	p[2]=(unsigned char(exColorRA*a)+exColorRB)*p[2]>>8;
			p[0]=unsigned char((exColorBA*a+exColorBB)*p[0]);
			p[1]=unsigned char((exColorGA*a+exColorGB)*p[1]);
			p[2]=unsigned char((exColorRA*a+exColorRB)*p[2]);
		}
		void DimDIBPixelUnchecked_color_complement	(int x, int y, double a)
		{
			a=1-a;
			auto p=(unsigned char*)&(*prgb)[(y-1)*w+x-1];
			
		//	p[0]=(unsigned char(exColorBA*a)+exColorBB)*p[0]>>8;
		//	p[1]=(unsigned char(exColorGA*a)+exColorGB)*p[1]>>8;
		//	p[2]=(unsigned char(exColorRA*a)+exColorRB)*p[2]>>8;
			p[0]=unsigned char((exColorBA*a+exColorBB)*p[0]);
			p[1]=unsigned char((exColorGA*a+exColorGB)*p[1]);
			p[2]=unsigned char((exColorRA*a+exColorRB)*p[2]);
		}
	public:
		void full_resize(double VX, double DX, double VY, double DY, int Xplaces, int Yplaces)
		{
			this->Xplaces=Xplaces, this->Yplaces=Yplaces, ndrSize=Xplaces*Yplaces;
			Xsample=DX/Xplaces;
			Xstart_s=VX-DX/2, Xstart=Xstart_s+Xsample;
		//	Xstart=VX-DX/2, Xstart_s=Xstart-Xsample;
			Ysample=DY/Yplaces, Yend=VY+DY/2, Yend_s=Yend+Ysample;
			
			DeleteObject(hBitmap);
			BITMAPINFO bmpInfo={{sizeof(BITMAPINFOHEADER), w, -h, 1, 32, BI_RGB, 0, 0, 0, 0, 0}};
			hBitmap=CreateDIBSection(0, &bmpInfo, DIB_RGB_COLORS, (void**)&rgb, 0, 0);
		}
		void full(Expression &ex)
		{
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_2D_Implicit::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_2D_Implicit::fx, LOL_1_const=0;break;
				case 'y':f=&Solve_2D_Implicit::fy, LOL_1_const=0;break;
				case 'c':f=&Solve_2D_Implicit::fc, p=&variables.val.r;break;
				case 't':f=&Solve_2D_Implicit::fc, p=&T;break;
				}
			};
			int aXplaces, aYplaces;
			if(ex.resultLogicType>=2)
				aXstart=&Xstart_s, aYend=&Yend_s, aXplaces=Xplaces+2, aYplaces=Yplaces+2;
			else
				aXstart=&Xstart, aYend=&Yend, aXplaces=Xplaces, aYplaces=Yplaces;
			int aNDRsize=aXplaces*aYplaces;
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					n.ndr.assign(aNDRsize, ex.data[kn]);
				//	n.ndr.assign(aNDRsize, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(variables.mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_2D_Implicit::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								ndr.assign(aNDRsize, (this->*r)());
							else
							{
								ndr.resize(aNDRsize);
								auto ndrIT=ndr.begin();
								for(y=0;y<aYplaces;++y)
									for(x=0;x<aXplaces;++x, ++ndrIT)
										*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_2D_Implicit::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								ndr.assign(aNDRsize, Value((this->*r)(), (this->*i)()));
							else
							{
								ndr.resize(aNDRsize);
								auto ndrIT=ndr.begin();
								for(y=0;y<aYplaces;++y)
									for(x=0;x<aXplaces;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_2D_Implicit::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								ndr.assign(aNDRsize, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								ndr.resize(aNDRsize);
								auto ndrIT=ndr.begin();
								for(y=0;y<aYplaces;++y)
									for(x=0;x<aXplaces;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			switch(ex.resultLogicType)
			{
			case 1://&& || ## < > <= >=		logic expresion / inequality		logic
			/*	{
					std::vector<bool> capture(ex.i.size());
					int nCaptured=0;
					{
						std::vector<bool> visited(ex.i.size());
						std::stack<int> s;
						s.push(ex.i.size()-1);
						for(;s.size();)
						{
							int i=s.top();
							s.pop();
							if(!visited[i])
							{
								visited[i]=true;
								auto &instr=ex.i[i];
								if(instr.bf==G2::rr_logic_and||instr.bf==G2::rr_logic_xor||instr.bf==G2::rr_logic_or)
								{
									for(int arg=0;arg<instr.nArgs;++arg)
									{
										auto argN=(&instr.op1)[arg];
										for(int i2=i-1;i2>=0;--i2)
										{
											if(ex.i[i2].result==argN)
											{
												s.push(i2);
												break;
											}
										}
									}
								}
								else
									++nCaptured, capture[i]=true;
							}
						}
					}
					std::vector<int> bitmaps(nCaptured*ndrSize);
					
					int Xplaces1=Xplaces+1, Yplaces1=Yplaces+1,
						Xplaces2=Xplaces+2, Yplaces2=Yplaces+2;
					unsigned yDiscOffset=Yplaces2*Xplaces1;
					ex.discontinuities.assign(yDiscOffset+Yplaces1*Xplaces2, false);
					for(int ki=0, kiEnd=ex.i.size();ki<kiEnd;++ki)
				//	for(auto &i:ex.i)
					{
						auto &i=ex.i[ki];
						auto &op1=ex.n[i.op1], &result=ex.n[i.result];
						switch(i.nArgs)
						{
						case 1:
							result.mathSet=i.umts(op1.ndrMathType);
							if(i.d.disc_in)
							{
								for(int y=0;y<Yplaces2;++y)
								{
									for(int x=0;x<Xplaces1;++x)
									{
										unsigned v=Xplaces2*y+x;
										auto &condition=ex.discontinuities[Xplaces1*y+x];
										condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+1]);
									}
								}
								for(int y=0;y<Yplaces1;++y)
								{
									for(int x=0;x<Xplaces2;++x)
									{
										unsigned v=Xplaces2*y+x;
										auto &condition=ex.discontinuities[yDiscOffset+v];
										condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+Xplaces2]);
									}
								}
							}
							concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), i.uf);
							break;
						case 2:
							{
								auto &op2=ex.n[i.op2];
								result.ndrMathType=i.bmts(op1.ndrMathType, op2.ndrMathType);
								if(i.d.disc_in)
								{
									for(int y=0;y<Yplaces2;++y)
									{
										for(int x=0;x<Xplaces1;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[Xplaces1*y+x];
											condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+1], op2.ndr[v+1]);
										}
									}
									for(int y=0;y<Yplaces1;++y)
									{
										for(int x=0;x<Xplaces2;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[yDiscOffset+v];
											condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+Xplaces2], op2.ndr[v+Xplaces2]);
										}
									}
								}
								concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), op2.ndr.begin(), result.ndr.begin(), i.bf);
							}
							break;
						case 3:
							{
								auto &op2=ex.n[i.op2], &op3=ex.n[i.op3];
								result.ndrMathType=i.tmts(op1.ndrMathType, op2.ndrMathType, op3.ndrMathType);
								if(i.d.disc_in)
								{
									for(int y=0;y<Yplaces2;++y)
									{
										for(int x=0;x<Xplaces1;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[Xplaces1*y+x];
											condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+1], op2.ndr[v+1], op3.ndr[v+1]);
										}
									}
									for(int y=0;y<Yplaces1;++y)
									{
										for(int x=0;x<Xplaces2;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[yDiscOffset+v];
											condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+Xplaces2], op2.ndr[v+Xplaces2], op3.ndr[v+Xplaces2]);
										}
									}
								}
								concurrency::parallel_for(0u, op1.ndr.size(), [&](int k){result.ndr[k]=i.tf(op1.ndr[k], op2.ndr[k], op3.ndr[k]);});
							}
							break;
						}
						if(i.d.disc_out)
						{
							for(int y=0;y<Yplaces2;++y)
							{
								for(int x=0;x<Xplaces1;++x)
								{
									unsigned v=Xplaces2*y+x;
									auto &condition=ex.discontinuities[Xplaces1*y+x];
									condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+1]);
								}
							}
							for(int y=0;y<Yplaces1;++y)
							{
								for(int x=0;x<Xplaces2;++x)
								{
									unsigned v=Xplaces2*y+x;
									auto &condition=ex.discontinuities[yDiscOffset+v];
									condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+Xplaces2]);
								}
							}
						}
						if(capture[ki])
						{
						}
					}
					//for(int i=ex.i.size()-1;i>=0;--i)
					//{
					//	auto &inst=ex.i[i];
					//	if(inst.bf==G2::rr_logic_and||inst.bf==G2::rr_logic_xor||inst.bf==G2::rr_logic_or)
					//	{
					//	}
					//	else
					//	{
					//	}
					//}
				}//*/
			//	for(auto &i:boost::adaptors::reverse(ex.i))
			//	{
			//	}
				::solve(ex);
				break;

				//= !=		equation	ex.resultLogicType>=2		zero cross curve, anti-aliasing
			case 2:
				//zero cross	_/\_
			case 3:
				//				_  _
				//zero cross	 \/
				{
					int Xplaces1=Xplaces+1, Yplaces1=Yplaces+1,
						Xplaces2=Xplaces+2, Yplaces2=Yplaces+2;

					unsigned yDiscOffset=Yplaces2*Xplaces1;
					ex.discontinuities.assign(yDiscOffset+Yplaces1*Xplaces2, false);
					unsigned ndrSize=ex.n[0].ndr.size();
					for(auto iIT=ex.i.begin(), iITend=ex.i.end()-1;iIT!=iITend;++iIT)
					{
						auto &i=*iIT;
						auto &result=ex.n[i.result];
						switch(i.type)
					//	switch(i.nArgs)
						{
						case 'c'://user function call
							concurrency::parallel_for(0u, ndrSize, Solve_UserFunction(ex, i));
							break;
						case 1:
							{
								auto &op1=ex.n[i.op1];
								if(i.d.disc_in)
								{
									for(int y=0;y<Yplaces2;++y)
									{
										for(int x=0;x<Xplaces1;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[Xplaces1*y+x];
											condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+1]);
										}
									}
									for(int y=0;y<Yplaces1;++y)
									{
										for(int x=0;x<Xplaces2;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[yDiscOffset+v];
											condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+Xplaces2]);
										}
									}
								}
								concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), i.uf);
							}
							break;
						case 2:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2];
								if(i.d.disc_in)
								{
									for(int y=0;y<Yplaces2;++y)
									{
										for(int x=0;x<Xplaces1;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[Xplaces1*y+x];
											condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+1], op2.ndr[v+1]);
										}
									}
									for(int y=0;y<Yplaces1;++y)
									{
										for(int x=0;x<Xplaces2;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[yDiscOffset+v];
											condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+Xplaces2], op2.ndr[v+Xplaces2]);
										}
									}
								}
								concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), op2.ndr.begin(), result.ndr.begin(), i.bf);
							}
							break;
						case 3:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
								if(i.d.disc_in)
								{
									for(int y=0;y<Yplaces2;++y)
									{
										for(int x=0;x<Xplaces1;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[Xplaces1*y+x];
											condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+1], op2.ndr[v+1], op3.ndr[v+1]);
										}
									}
									for(int y=0;y<Yplaces1;++y)
									{
										for(int x=0;x<Xplaces2;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[yDiscOffset+v];
											condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+Xplaces2], op2.ndr[v+Xplaces2], op3.ndr[v+Xplaces2]);
										}
									}
								}
								concurrency::parallel_for(0u, op1.ndr.size(), [&](int k){result.ndr[k]=i.tf(op1.ndr[k], op2.ndr[k], op3.ndr[k]);});
							}
							break;
						}
						if(i.d.disc_out)
						{
							for(int y=0;y<Yplaces2;++y)
							{
								for(int x=0;x<Xplaces1;++x)
								{
									unsigned v=Xplaces2*y+x;
									auto &condition=ex.discontinuities[Xplaces1*y+x];
									condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+1]);
								}
							}
							for(int y=0;y<Yplaces1;++y)
							{
								for(int x=0;x<Xplaces2;++x)
								{
									unsigned v=Xplaces2*y+x;
									auto &condition=ex.discontinuities[yDiscOffset+v];
									condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+Xplaces2]);
								}
							}
						}
					}
					{
						auto &i=*ex.i.rbegin();
						auto &op1=ex.n[i.op1], &result=ex.n[i.result];
						switch(i.type)
					//	switch(i.nArgs)
						{
						case 1:
							concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), G2::q_minus);
							break;
						case 2:
							{
								auto &op2=ex.n[i.op2];
								concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), op2.ndr.begin(), result.ndr.begin(), G2::qq_minus);
							}
							break;
						}
					}
				}
				break;
			}
		}
		void draw(Expression &ex)
		{
			switch(ex.resultLogicType)
			{
			case 1://&& || ## < > <= >=		logic expresion / inequality		logic
				{
					auto &ndr=ex.n[0].ndr;
					double A0, A1, A2;
					if(nExpr[11]==1)
						A0=A1=A2=.5;
					else
					{
						auto pp=(unsigned char*)&ex.color;
						A0=(0xFF-pp[0])/510., A1=(0xFF-pp[1])/510., A2=(0xFF-pp[2])/510.;
					//	A0=.5-pp[0]/510., A1=.5-pp[1]/510., A2=.5-pp[2]/510.;
					}
					for(int p=0;p<ndrSize;++p)
					{
						auto pp=(unsigned char*)&(*prgb)[p];
						auto &a=ndr[p].r;
						pp[0]-=unsigned char(A0*a*pp[0]);
						pp[1]-=unsigned char(A1*a*pp[1]);
						pp[2]-=unsigned char(A2*a*pp[2]);//warning C4244
					}
				}
				break;

				//= !=		equation	ex.resultLogicType>=2		zero cross curve, anti-aliasing
			case 2:
				//zero cross	_/\_
			case 3:
				//				_  _
				//zero cross	 \/
				{
					int Xplaces1=Xplaces+1, Yplaces1=Yplaces+1,
						Xplaces2=Xplaces+2, Yplaces2=Yplaces+2;

					unsigned yDiscOffset=Yplaces2*Xplaces1;
					unsigned ndrSize=ex.n[0].ndr.size();

					switch(ex.resultMathSet)
				//	switch(ex.n[0].mathSet)
					{
					case 'r':
				//	case 'R':
						if(Xplaces>=1&&Yplaces>=1)
						{
							auto &ndr=ex.n[0].ndr;

							const double aa_thickness=1,
				
								_1_aa_thickness=1/aa_thickness;
							const int aa_bound=int(std::round(aa_thickness));

							//crossings
							int XCsize=Xplaces1*Yplaces2, YCsize=Xplaces2*Yplaces1,
								Xplaces3=Xplaces2+aa_bound;
							std::vector<double>
								Xcross(XCsize, -1),//._
								Ycross(YCsize, -1);//!
							std::vector<bool> shade(Xplaces3*(Yplaces2+aa_bound));
							{
								// _	top left
								//|_!
								auto&v00=ndr[				0].r, &v01=ndr[				1].r,
									&v10=ndr[Xplaces2*1+	0].r, &v11=ndr[Xplaces2*1+	1].r;
								auto&corner=shade[Xplaces3*1+1];
								if(std::signbit(v00)!=std::signbit(v01)&&!ex.discontinuities[Xplaces1*0+0])
									corner=true, Xcross[Xplaces1*0+0]=(0-v00)/(v01-v00);
								if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[Xplaces1*1+0])
									corner=true, Xcross[Xplaces1*1+0]=(0-v10)/(v11-v10);
								if(std::signbit(v00)!=std::signbit(v10)&&!ex.discontinuities[yDiscOffset+Xplaces2*0+0])
									corner=true, Ycross[Xplaces2*0+0]=(0-v00)/(v10-v00);
								if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+Xplaces2*0+1])
									corner=true, Ycross[Xplaces2*0+1]=(0-v01)/(v11-v01);
							}
							{
								// _	top right
								//._|
								auto&v00=ndr[				Xplaces1-1].r, &v01=ndr[			Xplaces1].r,
									&v10=ndr[Xplaces2*1+	Xplaces1-1].r, &v11=ndr[Xplaces2*1+	Xplaces1].r;
								auto&corner=shade[Xplaces3*1+Xplaces1-1];
								if(std::signbit(v00)!=std::signbit(v01)&&!ex.discontinuities[Xplaces1*0	+Xplaces1-1])
									corner=true, Xcross[Xplaces1*0	+Xplaces1-1]=(0-v00)/(v01-v00);
								if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[Xplaces1*1	+Xplaces1-1])
									corner=true, Xcross[Xplaces1*1	+Xplaces1-1]=(0-v10)/(v11-v10);
								if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+Xplaces2*1	+Xplaces1])
									corner=true, Ycross[Xplaces2*1+	Xplaces1]=(0-v01)/(v11-v01);
							}
							{
								//  .	bottom left
								//|_|
								auto&v00=ndr[Xplaces2*(Yplaces1-1)	+0].r, &v01=ndr[Xplaces2*(Yplaces1-1)	+1].r,
									&v10=ndr[Xplaces2* Yplaces1		+0].r, &v11=ndr[Xplaces2* Yplaces1		+1].r;
								auto&corner=shade[Xplaces3*(Yplaces1-1)+1];
								if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[Xplaces1*Yplaces1	+0])
									corner=true, Xcross[Xplaces1*Yplaces1		+0]=(0-v10)/(v11-v10);
								if(std::signbit(v00)!=std::signbit(v10)&&!ex.discontinuities[yDiscOffset+Xplaces2*(Yplaces1-1)	+0])
									corner=true, Ycross[Xplaces2*(Yplaces1-1)	+0]=(0-v00)/(v10-v00);
								if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+Xplaces2*(Yplaces1-1)	+1])
									corner=true, Ycross[Xplaces2*(Yplaces1-1)	+1]=(0-v01)/(v11-v01);
							}
							for(int x=1, xEnd=Xplaces;x<xEnd;++x)
							{
								// _	upper row
								//._!
								auto&v00=ndr[Xplaces2*0	+x].r, &v01=ndr[Xplaces2*0	+x+1].r,
									&v10=ndr[Xplaces2*1	+x].r, &v11=ndr[Xplaces2*1	+x+1].r;
								auto&p0=shade[Xplaces3*1+x], &p1=shade[Xplaces3*1+x+1];
								if(std::signbit(v00)!=std::signbit(v01)&&!ex.discontinuities[Xplaces1*0	+x])
									p0=p1=true, Xcross[Xplaces1*0	+x]=(0-v00)/(v01-v00);
								if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[Xplaces1*1	+x])
									p0=p1=true, Xcross[Xplaces1*1	+x]=(0-v10)/(v11-v10);
								if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+Xplaces2*0	+x+1])
									p0=p1=true, Ycross[Xplaces2*0	+x+1]=(0-v01)/(v11-v01);
							}
							for(int y=1, yEnd=Yplaces;y<yEnd;++y)
							{
								//  .	left column
								//|_!
								auto&v00=ndr[Xplaces2* y   +0].r, &v01=ndr[Xplaces2* y   +1].r,
									&v10=ndr[Xplaces2*(y+1)+0].r, &v11=ndr[Xplaces2*(y+1)+1].r;
								auto&p0=shade[Xplaces3*y+1], &p1=shade[Xplaces3*(y+1)+1];
								if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[Xplaces1*(y+1)	+0])
									p0=p1=true, Xcross[Xplaces1*(y+1)	+0]=(0-v10)/(v11-v10);
								if(std::signbit(v00)!=std::signbit(v10)&&!ex.discontinuities[yDiscOffset+Xplaces2*y	+0])
									p0=p1=true, Ycross[Xplaces2*y	+0]=(0-v00)/(v10-v00);
								if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+Xplaces2*y	+1])
									p0=p1=true, Ycross[Xplaces2*y	+1]=(0-v01)/(v11-v01);
							}

							auto aa_straight=[&](double d){return d>aa_thickness?1:d*_1_aa_thickness;};
							auto aa_close=[&](double x, double y)
							{
								double d=x*y*inv_sqrt(x*x+y*y);
							//	double d=std::abs(x*y)*inv_sqrt(x*x+y*y);
								return d>aa_thickness?1:d*_1_aa_thickness;
							};
							auto aa_middle=[&](double a, double b)//|. |
							{
								double b_a=b-a, d=a*inv_sqrt(1+b_a*b_a);
								return d>aa_thickness?1:d*_1_aa_thickness;
							};
							auto aa_far=[&](double x, double y)
							{
								if(x==1.||y==1.)
									return 1.;
								double x_1=x-1, y_1=y-1;
								double d=std::abs(x*y-1)*inv_sqrt(x_1*x_1+y_1*y_1);
								return d>aa_thickness?1:d*_1_aa_thickness;
							};

							//if(nExpr[11]==1)
							//{
							//	exColorBA=1, exColorBB=0;
							//	exColorGA=1, exColorGB=0;
							//	exColorRA=1, exColorRB=0;
							//}
							//else
							//{
							//	auto p=(unsigned char*)&ex.color;
							//	double a=p[0]/255.;
							//	exColorBA=1-a, exColorBB=a;
							//	a=p[1]/255.;
							//	exColorGA=1-a, exColorGB=a;
							//	a=p[2]/255.;
							//	exColorRA=1-a, exColorRB=a;
							//}
							//auto DimDIBPixelUnchecked=[&](int x, int y, double a)
							//{
							//	auto p=(unsigned char*)&(*prgb)[(y-1)*w+x-1];
							//	p[0]=unsigned char((exColorBA*a+exColorBB)*p[0]);
							//	p[1]=unsigned char((exColorGA*a+exColorGB)*p[1]);
							//	p[2]=unsigned char((exColorRA*a+exColorRB)*p[2]);
							//};
							//{
							//	auto p=(unsigned char*)&ex.color;
							//	exColorBA=1-p[0], exColorBB=p[0];
							//	exColorGA=1-p[1], exColorGB=p[1];
							//	exColorRA=1-p[2], exColorRB=p[2];
							//}
							{
								auto p=(unsigned char*)&ex.color;
								double a=p[0]/255.;
								exColorBA=1-a, exColorBB=a;
								a=p[1]/255.;
								exColorGA=1-a, exColorGB=a;
								a=p[2]/255.;
								exColorRA=1-a, exColorRB=a;
							}
							auto DimDIBPixelUnchecked=ex.resultLogicType==2?
									nExpr[11]==1?&Solve_2D_Implicit::DimDIBPixelUnchecked_mono				:&Solve_2D_Implicit::DimDIBPixelUnchecked_color
								:	nExpr[11]==1?&Solve_2D_Implicit::DimDIBPixelUnchecked_mono_complement	:&Solve_2D_Implicit::DimDIBPixelUnchecked_color_complement;
							for(int y=aa_bound, yEnd=Yplaces1;y<yEnd;++y)
							{
								for(int x=aa_bound, xEnd=Xplaces1;x<xEnd;++x)
								{
								//	double a=.5+.5*tanh(ndr[Xplaces2*y+x]);
								////	auto p=(unsigned char*)&(*prgb)[w*(y-2)+x-2];
								//	auto p=(unsigned char*)&(*prgb)[w*(y-1)+x-1];
								////	p[0]=p[1]=p[2]=0xFF*a;
								//	p[0]*=a, p[1]*=a, p[2]*=a;
									int ndrP=Xplaces2*y+x;
									int sp=Xplaces3*y+x;
									{
										auto							&v01=ndr[ndrP			+1].r,
											&v10=ndr[ndrP+Xplaces2].r,	&v11=ndr[ndrP+Xplaces2	+1].r;
										if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[Xplaces1*(y+1)	+x])
										{
											Xcross[Xplaces1*(y+1)+x]=(0-v10)/(v11-v10);
											shade[sp			]=true, shade[sp			+1]=true;
											shade[sp+Xplaces3	]=true, shade[sp+Xplaces3	+1]=true;
											shade[sp+Xplaces3*2	]=true, shade[sp+Xplaces3*2	+1]=true;
										}
										if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+ndrP+1])
										{
											Ycross[ndrP+1]=(0-v01)/(v11-v01);
											shade[sp			]=true, shade[sp			+1]=true, shade[sp			+2]=true;
											shade[sp+Xplaces3	]=true, shade[sp+Xplaces3	+1]=true, shade[sp+Xplaces3	+2]=true;
										}
									}
									if(shade[sp])
									{
										//	 	Dx
										//	Lx	+	Rx
										//		Ux  '
										auto		&Dx=Ycross[Xplaces2*(y-1)+x],
											&Lx=Xcross[Xplaces1*y+x-1],		&Rx=Xcross[Xplaces1*y+x],
													&Ux=Ycross[Xplaces2* y   +x];
										if(Ux!=-1)
										{
											if(Dx!=-1)
											{
												if(Lx!=-1)
												{
													if(Rx!=-1)	//udlr	>=2 lines	\+\	/+/
													{
														double d, d_min=aa_close(Rx, Ux);
														if(d_min>(d=aa_close(Rx, 1-Dx)))
															d_min=d;
														if(d_min>(d=aa_close(1-Lx, 1-Dx)))
															d_min=d;
														if(d_min>(d=aa_close(1-Lx, Ux)))
															d_min=d;
														(this->*DimDIBPixelUnchecked)(x, y, d_min);
													}
													else		//udl	>=2 lines	<+
													{
														double d, d_min=aa_close(1-Lx, 1-Dx);
														if(d_min>(d=aa_close(1-Lx, Ux)))
															d_min=d;
														(this->*DimDIBPixelUnchecked)(x, y, d_min);
													}
												}
												else
												{
													if(Rx!=-1)	//ud r	>=2 lines	+>
													{
														double d, d_min=aa_close(Rx, Ux);
														if(d_min>(d=aa_close(Rx, 1-Dx)))
															d_min=d;
														(this->*DimDIBPixelUnchecked)(x, y, d_min);
													}
													else		//ud				_F_
													{
														double d, d_min=Ux;
														if(d_min>(d=1-Dx))
															d_min=d;
														(this->*DimDIBPixelUnchecked)(x, y, d_min);
													}
												}
											}
											else
											{
												if(Lx!=-1)
												{
													if(Rx!=-1)	//u lr	>=2 lines	\+/
													{
														double d, d_min=aa_close(Rx, 1-Dx);
														if(d_min>(d=aa_close(1-Lx, 1-Dx)))
															d_min=d;
														(this->*DimDIBPixelUnchecked)(x, y, d_min);
													}
													else		//u l	>=1 line	\+
														(this->*DimDIBPixelUnchecked)(x, y, aa_close(1-Lx, Ux));
												}
												else
												{
													if(Rx!=-1)	//u  r	>=1 line	+/
														(this->*DimDIBPixelUnchecked)(x, y, aa_close(Rx, Ux));
													else		//u		>=1 line	_+_
													{
														auto &LUx=Ycross[Xplaces2* y   +x-1], &RUx=Ycross[Xplaces2* y   +x+1];
														double d, d_min=Ux;
														if(LUx!=-1&&LUx<Ux&&d_min>(d=aa_middle(Ux, LUx)))
															d_min=d;
														if(RUx!=-1&&RUx<Ux&&d_min>(d=aa_middle(Ux, RUx)))
															d_min=d;
														(this->*DimDIBPixelUnchecked)(x, y, d_min);
													}
												}
											}
										}
										else
										{
											if(Dx!=-1)
											{
												if(Lx!=-1)
												{
													if(Rx!=-1)	// dlr	>=2 lines	/+\ 
													{
														double d, d_min=aa_close(Rx, Ux);
														if(d_min>(d=aa_close(1-Lx, Ux)))
															d_min=d;
														(this->*DimDIBPixelUnchecked)(x, y, d_min);
													}
													else		// dl	>=1 line	/+
														(this->*DimDIBPixelUnchecked)(x, y, aa_close(1-Lx, 1-Dx));
												}
												else
												{
													if(Rx!=-1)	// d r	>=1 line	+\ 
														(this->*DimDIBPixelUnchecked)(x, y, aa_close(Rx, 1-Dx));
													else		// d	>=1 line	F
													{
														auto &LDx=Ycross[Xplaces2*(y-1)+x-1], &RDx=Ycross[Xplaces2*(y-1)+x+1];
														double d, d_min=1-Dx;
														if(LDx!=-1&&LDx>Dx&&d_min>(d=aa_middle(1-Dx, 1-LDx)))
															d_min=d;
														if(RDx!=-1&&RDx>Dx&&d_min>(d=aa_middle(1-Dx, 1-RDx)))
															d_min=d;
														(this->*DimDIBPixelUnchecked)(x, y, d_min);
													}
												}
											}
											else
											{
												if(Lx!=-1)
												{
													if(Rx!=-1)	//  lr	>=1 line	|+|
													{
														double d, d_min=Rx;
														if(d_min>(d=1-Lx))
															d_min=d;
														(this->*DimDIBPixelUnchecked)(x, y, d_min);
													}
													else		//  l	>=1 line	|+
													{
														auto &DLx=Xcross[Xplaces1*(y-1)+x-1], &ULx=Xcross[Xplaces1*(y+1)+x-1];
														double d, d_min=1-Lx;
														if(DLx!=-1&&DLx>Lx&&d_min>(d=aa_middle(1-Lx, 1-DLx)))
															d_min=d;
														if(ULx!=-1&&ULx>Lx&&d_min>(d=aa_middle(1-Lx, 1-ULx)))
															d_min=d;
														(this->*DimDIBPixelUnchecked)(x, y, d_min);
													}
												}
												else
												{
													if(Rx!=-1)	//   r	>=1 line	+|
													{
														auto &DRx=Xcross[Xplaces1*(y-1)+x  ], &URx=Xcross[Xplaces1*(y+1)+x  ];
														double d, d_min=Rx;
														if(DRx!=-1&&DRx<Rx&&d_min>(d=aa_middle(Rx, DRx)))
															d_min=d;
														if(URx!=-1&&URx<Rx&&d_min>(d=aa_middle(Rx, URx)))
															d_min=d;
														(this->*DimDIBPixelUnchecked)(x, y, d_min);
													}
													else		//		>=0 lines
													{
														auto
															&DLx=Xcross[Xplaces1*(y-1)+x-1],	&LDx=Ycross[Xplaces2*(y-1)+x-1],//	 _    _
															&DRx=Xcross[Xplaces1*(y-1)+x  ],	&RDx=Ycross[Xplaces2*(y-1)+x+1],//	| 1  2 | D
															&ULx=Xcross[Xplaces1*(y+1)+x-1],	&LUx=Ycross[Xplaces2* y   +x-1],//	    .
															&URx=Xcross[Xplaces1*(y+1)+x  ],	&RUx=Ycross[Xplaces2* y   +x+1];//	|_3  4_| U
														double d, d_min=_HUGE;
														if(DLx!=-1&&LDx!=-1&&d_min>(d=aa_far(1-DLx, 1-LDx)))//1
															d_min=d;
														if(DRx!=-1&&RDx!=-1&&d_min>(d=aa_far(  DRx, 1-RDx)))//2
															d_min=d;
														if(ULx!=-1&&LUx!=-1&&d_min>(d=aa_far(1-ULx,   LUx)))//3
															d_min=d;
														if(URx!=-1&&RUx!=-1&&d_min>(d=aa_far(  URx,   RUx)))//4
															d_min=d;
														if(d_min!=_HUGE)
															(this->*DimDIBPixelUnchecked)(x, y, d_min>aa_thickness?1:d_min*_1_aa_thickness);
													}
												}
											}
										}
									}
									else (this->*DimDIBPixelUnchecked)(x, y, 1);
								}
							}
						}
						break;
					case 'c':
				//	case 'C':
						break;
					case 'H':
						break;
					}
				}
				break;
			}//*/
		}
	private:
		void drawCheckboard_range(HPEN hPen, HBRUSH hBrush, double VX, double DX, double VY, double DY, double Xstep, double Ystep, int *rDims, int clearScreen)
		{
			int x1=rDims[0], x2=rDims[1], y1=rDims[2], y2=rDims[3];

			HRGN hRgn=CreateRectRgn(x1, y1, x2, y2);
			SelectClipRgn(ghMemDC, hRgn);

		/*	HGDIOBJ obj1, obj2, obj3, obj4;
			HPEN hWpen=CreatePen(PS_SOLID, 1, 0xFFFFFF);
			HBRUSH hWbrush=CreateSolidBrush(0xFFFFFF);
			obj1=SelectObject(ghMemDC, hWpen);
			obj2=SelectObject(ghMemDC, hWbrush);
			Rectangle(ghMemDC, x1, y1, x2, y2);
			obj4=SelectObject(ghMemDC, obj2);//returns brush
			obj3=SelectObject(ghMemDC, obj1);//returns pen		//order not necessary
			DeleteObject(SelectObject(ghMemDC, obj3));
			DeleteObject(SelectObject(ghMemDC, obj4));//*/
			HPEN hWpen=(HPEN)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, 0xFFFFFF));//bgr
			HBRUSH hWbrush=(HBRUSH)SelectObject(ghMemDC, CreateSolidBrush(0xFFFFFF));
			Rectangle(ghMemDC, x1, y1, x2, y2);
			DeleteObject(SelectObject(ghMemDC, hWpen));
			DeleteObject(SelectObject(ghMemDC, hWbrush));

		//	if(!clearScreen)
		//	{
				hPen=(HPEN)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH)SelectObject(ghMemDC, hBrush);
				double Ystart=VY-DY/2, Yend=VY+DY/2, Ystepx2=Ystep*2, Xstart=VX-DX/2, Xend=VX+DX/2, Xstepx2=Xstep*2;
				for(double y=ceil((Yend-y1*DY/h)/Ystepx2)*Ystepx2, yEnd=floor((Yend-y2*DY/h)/Ystep)*Ystep;y>yEnd;y-=Ystepx2)
				{
					for(double x=floor((Xstart+x1*DX/w)/Xstepx2)*Xstepx2, xEnd=ceil((Xstart+x2*DX/w)/Xstep)*Xstep;x<xEnd;x+=Xstepx2)
					{
						double
							ax1=(x+Xstep-Xstart)/DX*w, ay1=(Yend-y		)/DY*h, ax2=(x+Xstepx2	-Xstart)/DX*w, ay2=(Yend-y+Ystep	)/DY*h,
							bx1=(x		-Xstart)/DX*w, by1=(Yend-y+Ystep)/DY*h, bx2=(x+Xstep	-Xstart)/DX*w, by2=(Yend-y+Ystepx2	)/DY*h;
						Rectangle(ghMemDC, int(ax1)-(ax1<0), int(ay1)-(ay1<0)+1, int(ax2)-(ax2<0), int(ay2)-(ay2<0)+1);
						Rectangle(ghMemDC, int(bx1)-(bx1<0), int(by1)-(by1<0)+1, int(bx2)-(bx2<0), int(by2)-(by2<0)+1);
					}
				}
				hPen=(HPEN)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH)SelectObject(ghMemDC, hBrush);
		//	}

			SelectClipRgn(ghMemDC, 0);
			DeleteObject(hRgn);
		}
	public:
		void shiftAndCheckboard(HPEN hPen, HBRUSH hBrush, double VX, double DX, double VY, double DY, double Xstep, double Ystep, int clearScreen)
		{
			if(shift==&Solve_2D_Implicit::shift_)
			{
				int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
				auto _First=rgb+XSstart, _Last=rgb+XSend, _Dest=rgb+XDstart;
				for(int ky=Xplaces*YSstart, kyEnd=Xplaces*YSend, kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*YDstart;ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
					std::copy(_First+ky, _Last+ky, _Dest+ky2);
			}
			else if(shift==&Solve_2D_Implicit::shift_r)
			{
				int ndrSize=Xplaces*Yplaces;
				int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
				auto _First=std::reverse_iterator<int*>(rgb+ndrSize)+Xplaces-1-XSstart, _Last=std::reverse_iterator<int*>(rgb+ndrSize)+Xplaces-1-XSend, _Dest=std::reverse_iterator<int*>(rgb+ndrSize)+Xplaces-1-XDstart;
				for(int ky=Xplaces*(Yplaces-1-YSstart), kyEnd=Xplaces*(Yplaces-1-YSend), kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*(Yplaces-1-YDstart);ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
					std::copy(_First+ky,_Last+ky, _Dest+ky2);
			}
			drawCheckboard_range(hPen, hBrush, VX, DX, VY, DY, Xstep, Ystep, ra, clearScreen);
			if(partial==&Solve_2D_Implicit::partial_2)
				drawCheckboard_range(hPen, hBrush, VX, DX, VY, DY, Xstep, Ystep, ra+4, clearScreen);
		}
	private:
		void shift_		(std::vector<Value> &ndr, int *a, int aXplaces, int Yplaces)
		{
			int XSstart=a[0], XSend=a[1], XDstart=a[2], YSstart=a[3], YSend=a[4], YDstart=a[5];
		//	int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
			auto _First=ndr.begin()+XSstart, _Last=ndr.begin()+XSend, _Dest=ndr.begin()+XDstart;
			for(int ky=aXplaces*YSstart, kyEnd=aXplaces*YSend, kyStep=(ky<kyEnd?1:-1)*aXplaces, ky2=aXplaces*YDstart;ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
				std::copy(_First+ky, _Last+ky, _Dest+ky2);
		}
		void shift_r	(std::vector<Value> &ndr, int *a, int aXplaces, int aYplaces)
		{
			int XSstart=a[0], XSend=a[1], XDstart=a[2], YSstart=a[3], YSend=a[4], YDstart=a[5];
		//	int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
			int ndrSize=aXplaces*aYplaces;
			auto _First=ndr.rbegin()+aXplaces-1-XSstart, _Last=ndr.rbegin()+aXplaces-1-XSend, _Dest=ndr.rbegin()+aXplaces-1-XDstart;
			for(int ky=aXplaces*(aYplaces-1-YSstart), kyEnd=aXplaces*(aYplaces-1-YSend), kyStep=(ky<kyEnd?1:-1)*aXplaces, ky2=aXplaces*(aYplaces-1-YDstart);ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
				std::copy(_First+ky,_Last+ky, _Dest+ky2);
		}
		decltype(&Solve_2D_Implicit::shift_) shift;
		void solve_range	(Expression &ex, int *a)
		{
			int aXplaces, aYplaces;
			int x1, x2, y1, y2;
			if(ex.resultLogicType==1)
				aXstart=&Xstart,	aYend=&Yend,	aXplaces=Xplaces,	aYplaces=Yplaces,		x1=a[0], x2=a[1], y1=a[2], y2=a[3];
			else
				aXstart=&Xstart_s,	aYend=&Yend_s,	aXplaces=Xplaces+2,	aYplaces=Yplaces+2,		x1=a[8], x2=a[9], y1=a[10], y2=a[11];//x1=a[16], x2=a[17], y1=a[18], y2=a[19];//x1=a[8], x2=a[9], y1=a[10], y2=a[11];
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_2D_Implicit::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_2D_Implicit::fx, LOL_1_const=0;break;
				case 'y':f=&Solve_2D_Implicit::fy, LOL_1_const=0;break;
				case 'c':f=&Solve_2D_Implicit::fc, p=&variables.val.r;break;
				case 't':f=&Solve_2D_Implicit::fc, p=&T;break;
				}
			};
			auto initialize_const=[&](std::vector<Value> &ndr, Value &value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int ky=aXplaces*y1, kyEnd=aXplaces*y2;ky<kyEnd;ky+=aXplaces)
					std::fill(_First+ky, _Last+ky, value);
			};
			auto initialize_const_r=[&](std::vector<Value> &ndr, double value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int ky=aXplaces*y1, kyEnd=aXplaces*y2;ky<kyEnd;ky+=aXplaces)
					std::fill(_First+ky, _Last+ky, value);
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					initialize_const(n.ndr, ex.data[kn]);
				//	initialize_const(n.ndr, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(variables.mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_2D_Implicit::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								initialize_const_r(n.ndr, (this->*r)());
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=aXplaces*y1;y<y2;++y, ky+=aXplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_2D_Implicit::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=aXplaces*y1;y<y2;++y, ky+=aXplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_2D_Implicit::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=aXplaces*y1;y<y2;++y, ky+=aXplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			switch(ex.resultLogicType)
			{
			case 1://logic/inequality	just evaluate
				{
					for(auto &i:ex.i)
					{
						switch(i.type)
					//	switch(i.nArgs)
						{
						case 'c'://user function call
							{
								auto &result=ex.n[i.result];
								Solve_UserFunction uf(ex, i);
								for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
									concurrency::parallel_for(ky+x1, ky+x2, uf);
							}
							break;
						case 1:
							{
								auto &result=ex.n[i.result], &op1=ex.n[i.op1];
								auto _First=op1.ndr.begin()+x1, _Last=op1.ndr.begin()+x2;
								for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
									std::transform(_First+ky, _Last+ky, _First+ky, i.uf);
							}
							break;
						case 2:
							{
								auto &result=ex.n[i.result], &op1=ex.n[i.op1], &op2=ex.n[i.op2];
								auto _First1=op1.ndr.begin()+x1, _Last1=op1.ndr.begin()+x2, _First2=op2.ndr.begin()+x1, _Dest=result.ndr.begin()+x1;
								for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
									std::transform(_First1+ky, _Last1+ky, _First2+ky, _Dest+ky, i.bf);
							}
							break;
						case 3:
							{
								auto &result=ex.n[i.result], &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
								auto _First1=op1.ndr.begin()+x1, _Last1=op1.ndr.begin()+x2, _First2=op2.ndr.begin()+x1, _First3=op3.ndr.begin()+x1;
								for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
									for(auto it=_First1+ky, itEnd=_Last1+ky, it2=_First2+ky, it3=_First3+ky, &res=i.result==i.op1?it:i.result==i.op2?it2:it3;it!=itEnd;++it, ++it2, ++it3)
										*res=i.tf(*it, *it2, *it3);
							}
							break;
						}
					}
					auto &ndr=ex.n[0].ndr;
					double A0, A1, A2;
					if(nExpr[11]==1)
						A0=A1=A2=.5;
					else
					{
						auto pp=(unsigned char*)&ex.color;
						A0=(0xFF-pp[0])/510., A1=(0xFF-pp[1])/510., A2=(0xFF-pp[2])/510.;
					//	A0=.5-pp[0]/510., A1=.5-pp[1]/510., A2=.5-pp[2]/510.;
					}
					for(int y=y1;y<y2;++y)
					{
						for(int p=w*y+x1, pEnd=w*y+x2;p<pEnd;++p)
						{
							auto pp=(unsigned char*)&(*prgb)[p];
							auto &a=ndr[p].r;
							pp[0]-=unsigned char(A0*a*pp[0]);
							pp[1]-=unsigned char(A1*a*pp[1]);
							pp[2]-=unsigned char(A2*a*pp[2]);//warning C4244
						}
					}
				}
				break;
			//ex.resultLogicType>=2		zero cross curve, anti-aliasing
			case 2:
				//zero cross	_/\_		= equation
			case 3:
				//				_  _
				//zero cross	 \/			!= anti-equation?
				{
					int Xplaces1=Xplaces+1, Yplaces1=Yplaces+1,
						Xplaces2=Xplaces+2, Yplaces2=Yplaces+2;

					unsigned yDiscOffset=Xplaces1*Yplaces2;
					for(int y=y1;y<y2;++y)
					//	for(auto it=ex.discontinuities.begin()+Xplaces1*y+x1, itEnd=ex.discontinuities.begin()+Xplaces1*y+x2-1;it!=itEnd;++it)
					//		*it=false;
						for(int x=x1;x<x2-1;++x)
							ex.discontinuities[Xplaces1*y+x]=false;
					for(int y=y1;y<y2-1;++y)
					//	for(auto it=ex.discontinuities.begin()+yDiscOffset+Xplaces2*y+x1, itEnd=ex.discontinuities.begin()+Xplaces2*y+x2;it!=itEnd;++it)
					//		*it=false;
						for(int x=x1;x<x2;++x)
							ex.discontinuities[yDiscOffset+Xplaces2*y+x]=false;
					for(auto iIT=ex.i.begin(), iITend=ex.i.end()-1;iIT!=iITend;++iIT)
					{
						auto &i=*iIT;
						auto &result=ex.n[i.result];
						switch(i.type)
					//	switch(i.nArgs)
						{
						case 'c'://user function call
							{
								Solve_UserFunction uf(ex, i);
								for(int ky=Xplaces2*y1, kyEnd=Xplaces2*y2;ky<kyEnd;ky+=Xplaces2)
									//for(int kx=ky+x1;kx<ky+x2;++kx)
									//	uf(kx);	
									concurrency::parallel_for(ky+x1, ky+x2, uf);
							}
							break;
						case 1:
							{
								auto &op1=ex.n[i.op1];
								if(i.d.disc_in)
								{
									for(int y=y1;y<y2;++y)
									{
										for(int x=x1;x<x2-1;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[Xplaces1*y+x];
											condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+1]);
										}
									}
									for(int y=y1;y<y2-1;++y)
									{
										for(int x=x1;x<x2;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[yDiscOffset+v];
											condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+Xplaces2]);
										}
									}
								}
								auto _First=op1.ndr.begin()+x1, _Last=op1.ndr.begin()+x2;
								for(int ky=Xplaces2*y1, kyEnd=Xplaces2*y2;ky<kyEnd;ky+=Xplaces2)
									std::transform(_First+ky, _Last+ky, _First+ky, i.uf);
							}
							break;
						case 2:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2];
								if(i.d.disc_in)
								{
									for(int y=y1;y<y2;++y)
									{
										for(int x=x1;x<x2-1;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[Xplaces1*y+x];
											condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+1], op2.ndr[v+1]);
										}
									}
									for(int y=y1;y<y2-1;++y)
									{
										for(int x=x1;x<x2;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[yDiscOffset+v];
											condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+Xplaces2], op2.ndr[v+Xplaces2]);
										}
									}
								}
								auto _First1=op1.ndr.begin()+x1, _Last1=op1.ndr.begin()+x2, _First2=op2.ndr.begin()+x1, _Dest=result.ndr.begin()+x1;
								for(int ky=Xplaces2*y1, kyEnd=Xplaces2*y2;ky<kyEnd;ky+=Xplaces2)
									std::transform(_First1+ky, _Last1+ky, _First2+ky, _Dest+ky, i.bf);
							}
							break;
						case 3:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
								if(i.d.disc_in)
								{
									for(int y=y1;y<y2;++y)
									{
										for(int x=x1;x<x2-1;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[Xplaces1*y+x];
											condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+1], op2.ndr[v+1], op3.ndr[v+1]);
										}
									}
									for(int y=y1;y<y2-1;++y)
									{
										for(int x=x1;x<x2;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[yDiscOffset+v];
											condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+Xplaces2], op2.ndr[v+Xplaces2], op3.ndr[v+Xplaces2]);
										}
									}
								}
								auto _First1=op1.ndr.begin()+x1, _Last1=op1.ndr.begin()+x2, _First2=op2.ndr.begin()+x1, _First3=op3.ndr.begin()+x1;
								for(int ky=Xplaces2*y1, kyEnd=Xplaces2*y2;ky<kyEnd;ky+=Xplaces2)
									for(auto it=_First1+ky, itEnd=_Last1+ky, it2=_First2+ky, it3=_First3+ky, &res=i.result==i.op1?it:i.result==i.op2?it2:it3;it!=itEnd;++it, ++it2, ++it3)
										*res=i.tf(*it, *it2, *it3);
							}
							break;
						}
						if(i.d.disc_out)
						{
							for(int y=y1;y<y2;++y)
							{
								for(int x=x1;x<x2-1;++x)
								{
									unsigned v=Xplaces2*y+x;
									auto &condition=ex.discontinuities[Xplaces1*y+x];
									condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+1]);
								}
							}
							for(int y=y1;y<y2-1;++y)
							{
								for(int x=x1;x<x2;++x)
								{
									unsigned v=Xplaces2*y+x;
									auto &condition=ex.discontinuities[yDiscOffset+v];
									condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+Xplaces2]);
								}
							}
						}
					}
					{
						auto &i=*ex.i.rbegin();
						auto &op1=ex.n[i.op1], &result=ex.n[i.result];
						switch(i.type)
					//	switch(i.nArgs)
						{
						case 1:
							{
								auto _First=op1.ndr.begin()+x1, _Last=op1.ndr.begin()+x2;
								for(int ky=Xplaces2*y1, kyEnd=Xplaces2*y2;ky<kyEnd;ky+=Xplaces2)
									std::transform(_First+ky, _Last+ky, _First+ky, G2::q_minus);
							}
							break;
						case 2:
							{
								auto &op2=ex.n[i.op2];
								auto _First1=op1.ndr.begin()+x1, _Last1=op1.ndr.begin()+x2, _First2=op2.ndr.begin()+x1, _Dest=result.ndr.begin()+x1;
								for(int ky=Xplaces2*y1, kyEnd=Xplaces2*y2;ky<kyEnd;ky+=Xplaces2)
									std::transform(_First1+ky, _Last1+ky, _First2+ky, _Dest+ky, G2::qq_minus);
							}
							break;
						}
					}

					//auto &ndr=ex.n[0].ndr;//
					//for(int ky=1;ky<Yplaces1;++ky)//
					//	for(int kx=1;kx<Xplaces1;++kx)//
					//		DimDIBPixelUnchecked_mono(kx, ky, ex.n[0].ndr[Xplaces2*ky+kx]);//

					switch(ex.resultMathSet)
				//	switch(ex.n[0].mathSet)
					{
					case 'r':
				//	case 'R':
						{
						//	int dx=x2-x1, dy=y2-y1;
						//	if(dx>=3&&dy>=3)
							if(x2-x1>=3&&y2-y1>=3)//redundant check		Xoffset>0||Yoffset>0	x2-x1>2&&y2-y1>2
							{
								int x11=x1+1, y11=y1+1, x2_1=x2-1, y2_1=y2-1;

								auto &ndr=ex.n[0].ndr;

								const double aa_thickness=1,//
				
									_1_aa_thickness=1/aa_thickness;
								const int aa_bound=int(std::round(aa_thickness));

								//crossings
								int XCsize=Xplaces1*Yplaces2, YCsize=Xplaces2*Yplaces1,
									Xplaces3=Xplaces2+aa_bound;
								std::vector<double>
									Xcross(XCsize, -1),//._
									Ycross(YCsize, -1);//!
								std::vector<bool> shade(Xplaces3*(Yplaces2+aa_bound));
								{
									// _	top left
									//|_!
									auto&v00=ndr[Xplaces2*y1	+x1].r, &v01=ndr[Xplaces2*y1	+x11].r,
										&v10=ndr[Xplaces2*y11	+x1].r, &v11=ndr[Xplaces2*y11	+x11].r;
									auto&corner=shade[Xplaces3*y11+x11];
									if(std::signbit(v00)!=std::signbit(v01)&&!ex.discontinuities[				Xplaces1*y1	+x1])
										corner=true, Xcross[Xplaces1*y1		+x1]=(0-v00)/(v01-v00);
									if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[				Xplaces1*y11+x1])
										corner=true, Xcross[Xplaces1*y11	+x1]=(0-v10)/(v11-v10);
									if(std::signbit(v00)!=std::signbit(v10)&&!ex.discontinuities[yDiscOffset+	Xplaces2*y1	+x1])
										corner=true, Ycross[Xplaces2*y1		+x1]=(0-v00)/(v10-v00);
									if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+	Xplaces2*y1+x11])
										corner=true, Ycross[Xplaces2*y1		+x11]=(0-v01)/(v11-v01);
								}
								{
									// _	top right
									//._|
									auto&v00=ndr[Xplaces2*y1	+x2_1-1].r, &v01=ndr[Xplaces2*y1	+x2_1].r,
										&v10=ndr[Xplaces2*y11	+x2_1-1].r, &v11=ndr[Xplaces2*y11	+x2_1].r;
									auto&corner=shade[Xplaces3*y11+x2_1-1];
									if(std::signbit(v00)!=std::signbit(v01)&&!ex.discontinuities[				Xplaces1*y1		+x2_1-1])
										corner=true, Xcross[Xplaces1*y1		+x2_1-1]=(0-v00)/(v01-v00);
									if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[				Xplaces1*y11	+x2_1-1])
										corner=true, Xcross[Xplaces1*y11	+x2_1-1]=(0-v10)/(v11-v10);
									if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+	Xplaces2*y11	+x2_1])
										corner=true, Ycross[Xplaces2*y11	+x2_1]=(0-v01)/(v11-v01);
								}
								{
									//  .	bottom left
									//|_|
									auto&v00=ndr[Xplaces2*(y2_1-1)	+x1].r, &v01=ndr[Xplaces2*(y2_1-1)	+x11].r,
										&v10=ndr[Xplaces2* y2_1		+x1].r, &v11=ndr[Xplaces2* y2_1		+x11].r;
									auto&corner=shade[Xplaces3*(y2_1-1)+x11];
									if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[				Xplaces1* y2_1		+x1])
										corner=true, Xcross[Xplaces1*y2_1		+x1]=(0-v10)/(v11-v10);
									if(std::signbit(v00)!=std::signbit(v10)&&!ex.discontinuities[yDiscOffset+	Xplaces2*(y2_1-1)	+x1])
										corner=true, Ycross[Xplaces2*(y2_1-1)	+x1]=(0-v00)/(v10-v00);
									if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+	Xplaces2*(y2_1-1)	+x11])
										corner=true, Ycross[Xplaces2*(y2_1-1)	+x11]=(0-v01)/(v11-v01);
								}
								for(int x=x11, xEnd=x2_1-1;x<xEnd;++x)
								{
									// _	upper row
									//._!
									auto&v00=ndr[Xplaces2*y1	+x].r, &v01=ndr[Xplaces2*y1		+x+1].r,
										&v10=ndr[Xplaces2*y11	+x].r, &v11=ndr[Xplaces2*y11	+x+1].r;
									auto&p0=shade[Xplaces3*y11+x], &p1=shade[Xplaces3*y11+x+1];
									if(std::signbit(v00)!=std::signbit(v01)&&!ex.discontinuities[				Xplaces1*y1		+x])
										p0=p1=true, Xcross[Xplaces1*y1	+x]=(0-v00)/(v01-v00);
									if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[				Xplaces1*y11	+x])
										p0=p1=true, Xcross[Xplaces1*y11	+x]=(0-v10)/(v11-v10);
									if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+	Xplaces2*y1		+x+1])
										p0=p1=true, Ycross[Xplaces2*y1	+x+1]=(0-v01)/(v11-v01);
								}
								for(int y=y11, yEnd=y2_1-1;y<yEnd;++y)
								{
									//  .	left column
									//|_!
									auto&v00=ndr[Xplaces2* y   +x1].r, &v01=ndr[Xplaces2* y   +x11].r,
										&v10=ndr[Xplaces2*(y+1)+x1].r, &v11=ndr[Xplaces2*(y+1)+x11].r;
									auto&p0=shade[Xplaces3* y   +x11],
										&p1=shade[Xplaces3*(y+1)+x11];
									if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[				Xplaces1*(y+1)	+x1])
										p0=p1=true, Xcross[Xplaces1*(y+1)	+x1]=(0-v10)/(v11-v10);
									if(std::signbit(v00)!=std::signbit(v10)&&!ex.discontinuities[yDiscOffset	+Xplaces2*y		+x1])
										p0=p1=true, Ycross[Xplaces2*y	+x1]=(0-v00)/(v10-v00);
									if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset	+Xplaces2*y		+x11])
										p0=p1=true, Ycross[Xplaces2*y	+x11]=(0-v01)/(v11-v01);
								}
			
								auto aa_straight=[&](double d){return d>aa_thickness?1:d*_1_aa_thickness;};
								auto aa_close=[&](double x, double y)//	!_
								{
									double d=x*y*inv_sqrt(x*x+y*y);
								//	double d=std::abs(x*y)*inv_sqrt(x*x+y*y);
									return d>aa_thickness?1:d*_1_aa_thickness;
								};
								auto aa_middle=[&](double a, double b)//	|. |
								{
									double b_a=b-a, d=a*inv_sqrt(1+b_a*b_a);
									return d>aa_thickness?1:d*_1_aa_thickness;
								};
								auto aa_far=[&](double x, double y)//	.7
								{
									if(x==1.||y==1.)
										return 1.;
									double x_1=x-1, y_1=y-1;
									double d=std::abs(x*y-1)*inv_sqrt(x_1*x_1+y_1*y_1);
									return d>aa_thickness?1:d*_1_aa_thickness;
								};

								//{
								//	auto p=(unsigned char*)&ex.color;
								//	exColorBA=1-p[0], exColorBB=p[0];
								//	exColorGA=1-p[1], exColorGB=p[1];
								//	exColorRA=1-p[2], exColorRB=p[2];
								//}
								{
									auto p=(unsigned char*)&ex.color;
									double a=p[0]/255.;
									exColorBA=1-a, exColorBB=a;
									a=p[1]/255.;
									exColorGA=1-a, exColorGB=a;
									a=p[2]/255.;
									exColorRA=1-a, exColorRB=a;
								}
								auto DimDIBPixelUnchecked=ex.resultLogicType==2?
										nExpr[11]==1?&Solve_2D_Implicit::DimDIBPixelUnchecked_mono				:&Solve_2D_Implicit::DimDIBPixelUnchecked_color
									:	nExpr[11]==1?&Solve_2D_Implicit::DimDIBPixelUnchecked_mono_complement	:&Solve_2D_Implicit::DimDIBPixelUnchecked_color_complement;
								for(int y=y1+aa_bound, yEnd=y2_1;y<yEnd;++y)
								{
									for(int x=x1+aa_bound, xEnd=x2_1;x<xEnd;++x)
									{
									//	double a=.5+.5*tanh(ndr[Xplaces2*y+x]);
									////	auto a=.5+.5*tanh(Xcross[Xplaces1*y+x]);
									////	auto a=.5+.5*tanh(Ycross[Xplaces2*y+x]);
									////	auto a=shade[sp];
									//	auto p=(unsigned char*)&(*prgb)[w*(y-1)+x-1];
									////	p[0]=p[1]=p[2]=0xFF*a;
									//	p[0]*=a, p[1]*=a, p[2]*=a;

										int ndrP=Xplaces2*y+x;
										int sp=Xplaces3*y+x;
										{
											auto							&v01=ndr[ndrP			+1].r,
												&v10=ndr[ndrP+Xplaces2].r,	&v11=ndr[ndrP+Xplaces2	+1].r;
											if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[Xplaces1*(y+1)+x])
											{
												Xcross[Xplaces1*(y+1)+x]=(0-v10)/(v11-v10);
												shade[sp			]=true, shade[sp			+1]=true;
												shade[sp+Xplaces3	]=true, shade[sp+Xplaces3	+1]=true;
												shade[sp+Xplaces3*2	]=true, shade[sp+Xplaces3*2	+1]=true;
											}
											if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+ndrP+1])
											{
												Ycross[ndrP+1]=(0-v01)/(v11-v01);
												shade[sp			]=true, shade[sp			+1]=true, shade[sp			+2]=true;
												shade[sp+Xplaces3	]=true, shade[sp+Xplaces3	+1]=true, shade[sp+Xplaces3	+2]=true;
											}
										}
										if(shade[sp])
										{
											//	 	Dx
											//	Lx	+	Rx
											//		Ux  '
											auto		&Dx=Ycross[Xplaces2*(y-1)+x],
												&Lx=Xcross[Xplaces1*y+x-1],		&Rx=Xcross[Xplaces1*y+x],
														&Ux=Ycross[Xplaces2* y   +x];
											if(Ux!=-1)
											{
												if(Dx!=-1)
												{
													if(Lx!=-1)
													{
														if(Rx!=-1)	//udlr	>=2 lines	\+\	/+/
														{
															double d, d_min=aa_close(Rx, Ux);
															if(d_min>(d=aa_close(Rx, 1-Dx)))
																d_min=d;
															if(d_min>(d=aa_close(1-Lx, 1-Dx)))
																d_min=d;
															if(d_min>(d=aa_close(1-Lx, Ux)))
																d_min=d;
															(this->*DimDIBPixelUnchecked)(x, y, d_min);
														}
														else		//udl	>=2 lines	<+
														{
															double d, d_min=aa_close(1-Lx, 1-Dx);
															if(d_min>(d=aa_close(1-Lx, Ux)))
																d_min=d;
															(this->*DimDIBPixelUnchecked)(x, y, d_min);
														}
													}
													else
													{
														if(Rx!=-1)	//ud r	>=2 lines	+>
														{
															double d, d_min=aa_close(Rx, Ux);
															if(d_min>(d=aa_close(Rx, 1-Dx)))
																d_min=d;
															(this->*DimDIBPixelUnchecked)(x, y, d_min);
														}
														else		//ud				_F_
														{
															double d, d_min=Ux;
															if(d_min>(d=1-Dx))
																d_min=d;
															(this->*DimDIBPixelUnchecked)(x, y, d_min);
														}
													}
												}
												else
												{
													if(Lx!=-1)
													{
														if(Rx!=-1)	//u lr	>=2 lines	\+/
														{
															double d, d_min=aa_close(Rx, 1-Dx);
															if(d_min>(d=aa_close(1-Lx, 1-Dx)))
																d_min=d;
															(this->*DimDIBPixelUnchecked)(x, y, d_min);
														}
														else		//u l	>=1 line	\+
															(this->*DimDIBPixelUnchecked)(x, y, aa_close(1-Lx, Ux));
													}
													else
													{
														if(Rx!=-1)	//u  r	>=1 line	+/
															(this->*DimDIBPixelUnchecked)(x, y, aa_close(Rx, Ux));
														else		//u		>=1 line	_+_
														{
															auto &LUx=Ycross[Xplaces2* y   +x-1], &RUx=Ycross[Xplaces2* y   +x+1];
															double d, d_min=Ux;
															if(LUx!=-1&&LUx<Ux&&d_min>(d=aa_middle(Ux, LUx)))
																d_min=d;
															if(RUx!=-1&&RUx<Ux&&d_min>(d=aa_middle(Ux, RUx)))
																d_min=d;
															(this->*DimDIBPixelUnchecked)(x, y, d_min);
														}
													}
												}
											}
											else
											{
												if(Dx!=-1)
												{
													if(Lx!=-1)
													{
														if(Rx!=-1)	// dlr	>=2 lines	/+\ 
														{
															double d, d_min=aa_close(Rx, Ux);
															if(d_min>(d=aa_close(1-Lx, Ux)))
																d_min=d;
															(this->*DimDIBPixelUnchecked)(x, y, d_min);
														}
														else		// dl	>=1 line	/+
															(this->*DimDIBPixelUnchecked)(x, y, aa_close(1-Lx, 1-Dx));
													}
													else
													{
														if(Rx!=-1)	// d r	>=1 line	+\ 
															(this->*DimDIBPixelUnchecked)(x, y, aa_close(Rx, 1-Dx));
														else		// d	>=1 line	F
														{
															auto &LDx=Ycross[Xplaces2*(y-1)+x-1], &RDx=Ycross[Xplaces2*(y-1)+x+1];
															double d, d_min=1-Dx;
															if(LDx!=-1&&LDx>Dx&&d_min>(d=aa_middle(1-Dx, 1-LDx)))
																d_min=d;
															if(RDx!=-1&&RDx>Dx&&d_min>(d=aa_middle(1-Dx, 1-RDx)))
																d_min=d;
															(this->*DimDIBPixelUnchecked)(x, y, d_min);
														}
													}
												}
												else
												{
													if(Lx!=-1)
													{
														if(Rx!=-1)	//  lr	>=1 line	|+|		//>=1 line	[-]
														{
															double d, d_min=Rx;
															if(d_min>(d=1-Lx))
																d_min=d;
															(this->*DimDIBPixelUnchecked)(x, y, d_min);
														}
														else		//  l	>=1 line	|+
														{
															auto &DLx=Xcross[Xplaces1*(y-1)+x-1], &ULx=Xcross[Xplaces1*(y+1)+x-1];
															double d, d_min=1-Lx;
															if(DLx!=-1&&DLx>Lx&&d_min>(d=aa_middle(1-Lx, 1-DLx)))
																d_min=d;
															if(ULx!=-1&&ULx>Lx&&d_min>(d=aa_middle(1-Lx, 1-ULx)))
																d_min=d;
															(this->*DimDIBPixelUnchecked)(x, y, d_min);
														}
													}
													else
													{
														if(Rx!=-1)	//   r	>=1 line	+|
														{
															auto &DRx=Xcross[Xplaces1*(y-1)+x  ], &URx=Xcross[Xplaces1*(y+1)+x  ];
															double d, d_min=Rx;
															if(DRx!=-1&&DRx<Rx&&d_min>(d=aa_middle(Rx, DRx)))
																d_min=d;
															if(URx!=-1&&URx<Rx&&d_min>(d=aa_middle(Rx, URx)))
																d_min=d;
															(this->*DimDIBPixelUnchecked)(x, y, d_min);
														}
														else		//		>=0 lines
														{
															auto
																&DLx=Xcross[Xplaces1*(y-1)+x-1],	&LDx=Ycross[Xplaces2*(y-1)+x-1],//	 _    _
																&DRx=Xcross[Xplaces1*(y-1)+x  ],	&RDx=Ycross[Xplaces2*(y-1)+x+1],//	| 1  2 | D
																&ULx=Xcross[Xplaces1*(y+1)+x-1],	&LUx=Ycross[Xplaces2* y   +x-1],//	    .
																&URx=Xcross[Xplaces1*(y+1)+x  ],	&RUx=Ycross[Xplaces2* y   +x+1];//	|_3  4_| U
															double d, d_min=_HUGE;
															if(DLx!=-1&&LDx!=-1&&d_min>(d=aa_far(1-DLx, 1-LDx)))//1
																d_min=d;
															if(DRx!=-1&&RDx!=-1&&d_min>(d=aa_far(  DRx, 1-RDx)))//2
																d_min=d;
															if(ULx!=-1&&LUx!=-1&&d_min>(d=aa_far(1-ULx,   LUx)))//3
																d_min=d;
															if(URx!=-1&&RUx!=-1&&d_min>(d=aa_far(  URx,   RUx)))//4
																d_min=d;
															if(d_min!=_HUGE)
																(this->*DimDIBPixelUnchecked)(x, y, d_min>aa_thickness?1:d_min*_1_aa_thickness);
														}
													}
												}
											}
										}
										else
											(this->*DimDIBPixelUnchecked)(x, y, 1);
									}
								}
							}
						}
						break;
					case 'c':
				//	case 'C':
						break;
					case 'H':
						break;
					}//*/
					break;
				}
			}
		}
		void partial_		(Expression &ex){}
		void partial_1		(Expression &ex)
		{
			int saOffset, aXplaces, aYplaces;
			if(ex.resultLogicType==1)
				saOffset=0, aXplaces=Xplaces, aYplaces=Yplaces;
			else
				saOffset=6, aXplaces=Xplaces+2, aYplaces=Yplaces+2;
			(this->*shift)(ex.n[0].ndr, sa+saOffset, aXplaces, aYplaces);
			solve_range(ex, ra);
		}
		void partial_2		(Expression &ex)
		{
			int saOffset, aXplaces, aYplaces;
			if(ex.resultLogicType==1)
				saOffset=0, aXplaces=Xplaces, aYplaces=Yplaces;
			else
				saOffset=6, aXplaces=Xplaces+2, aYplaces=Yplaces+2;
			(this->*shift)(ex.n[0].ndr, sa+saOffset, aXplaces, aYplaces);
			solve_range(ex, ra), solve_range(ex, ra+4);
		}
	public:
		void partial_bounds(double VX, double DX, double VY, double DY, int Xoffset, int Yoffset)
		{
			Xsample=DX/Xplaces;
			Xstart_s=VX-DX/2, Xstart=Xstart_s+Xsample;
		//	Xstart=VX-DX/2, Xstart_s=Xstart-Xsample;
			Ysample=DY/Yplaces, Yend=VY+DY/2, Yend_s=Yend+Ysample;
			partial=&Solve_2D_Implicit::partial_;
			int Xoffset2=std::abs(Xoffset)+2, Yoffset2=std::abs(Yoffset)+2;
			int Xplaces2=Xplaces+2, Yplaces2=Yplaces+2;
				 if(Xoffset>0){							 if(Yoffset>0)					shift=&Solve_2D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,			sa[5]=Yplaces-1,			partial=&Solve_2D_Implicit::partial_2,	ra[0]=0,					ra[1]=Xplaces,		ra[ 2]=0,					ra[ 3]=Yoffset,							ra[ 4]=Xplaces-Xoffset,		ra[ 5]=Xplaces,		ra[ 6]=Yoffset,				ra[ 7]=Yplaces,
																															sa[6]=Xoffset,				sa[7]=Xplaces2,	sa[8]=0,			sa[9]=Yplaces2-1-Yoffset,	sa[10]=-1,			sa[11]=Yplaces2-1,													ra[8]=0,					ra[9]=Xplaces2,		ra[10]=0,					ra[11]=Yoffset2,						ra[12]=Xplaces2-Xoffset2,	ra[13]=Xplaces2,	ra[14]=Yoffset,				ra[15]=Yplaces2;

													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_2D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,		sa[5]=0,					partial=&Solve_2D_Implicit::partial_2,	ra[0]=Xplaces-Xoffset,		ra[1]=Xplaces,		ra[ 2]=0,					ra[ 3]=Yplaces-Yoffset,					ra[ 4]=0,					ra[ 5]=Xplaces,		ra[ 6]=Yplaces-Yoffset,		ra[ 7]=Yplaces,
																															sa[6]=Xoffset,				sa[7]=Xplaces2,	sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces2,	sa[11]=0,															ra[8]=Xplaces2-Xoffset2,	ra[9]=Xplaces2,		ra[10]=0,					ra[11]=Yplaces2-Yoffset,				ra[12]=0,					ra[13]=Xplaces2,	ra[14]=Yplaces2-Yoffset2,	ra[15]=Yplaces2;

													else								shift=&Solve_2D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,		sa[5]=0,					partial=&Solve_2D_Implicit::partial_1,	ra[0]=Xplaces-Xoffset,		ra[1]=Xplaces,		ra[ 2]=0,					ra[ 3]=Yplaces,
																															sa[6]=Xoffset,				sa[7]=Xplaces2,	sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces2,	sa[11]=0,															ra[8]=Xplaces2-Xoffset2,	ra[9]=Xplaces2,		ra[10]=0,					ra[11]=Yplaces2;}

			else if(Xoffset<0){Xoffset=-Xoffset;		 if(Yoffset>0)					shift=&Solve_2D_Implicit::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,			sa[5]=Yplaces-1,			partial=&Solve_2D_Implicit::partial_2,	ra[0]=0,					ra[1]=Xplaces,		ra[ 2]=0,					ra[ 3]=Yoffset,							ra[ 4]=0,					ra[ 5]=Xoffset,		ra[ 6]=Yoffset,				ra[ 7]=Yplaces,
																															sa[6]=Xplaces2-1-Xoffset,	sa[7]=-1,		sa[8]=Xplaces2-1,	sa[9]=Yplaces2-1-Yoffset,	sa[10]=-1,			sa[11]=Yplaces2-1,													ra[8]=0,					ra[9]=Xplaces2,		ra[10]=0,					ra[11]=Yoffset2,						ra[12]=0,					ra[13]=Xoffset2,	ra[14]=Yoffset,				ra[15]=Yplaces2;

													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_2D_Implicit::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,		sa[5]=0,					partial=&Solve_2D_Implicit::partial_2,	ra[0]=0,					ra[1]=Xoffset,		ra[ 2]=0,					ra[ 3]=Yplaces-Yoffset,					ra[ 4]=0,					ra[ 5]=Xplaces,		ra[ 6]=Yplaces-Yoffset,		ra[ 7]=Yplaces,
																															sa[6]=Xplaces2-1-Xoffset,	sa[7]=-1,		sa[8]=Xplaces2-1,	sa[9]=Yoffset,				sa[10]=Yplaces2,	sa[11]=0,															ra[8]=0,					ra[9]=Xoffset2,		ra[10]=0,					ra[11]=Yplaces2-Yoffset,				ra[12]=0,					ra[13]=Xplaces2,	ra[14]=Yplaces2-Yoffset2,	ra[15]=Yplaces2;

													else								shift=&Solve_2D_Implicit::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,		sa[5]=0,					partial=&Solve_2D_Implicit::partial_1,	ra[0]=0,					ra[1]=Xoffset,		ra[ 2]=0,					ra[ 3]=Yplaces,
																															sa[6]=Xplaces2-1-Xoffset,	sa[7]=-1,		sa[8]=Xplaces2-1,	sa[9]=Yoffset,				sa[10]=Yplaces2,	sa[11]=0,															ra[8]=0,					ra[9]=Xoffset2,		ra[10]=0,					ra[11]=Yplaces2;}

			else{										 if(Yoffset>0)					shift=&Solve_2D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,			sa[5]=Yplaces-1,			partial=&Solve_2D_Implicit::partial_1,	ra[0]=0,					ra[1]=Xplaces,		ra[ 2]=0,					ra[ 3]=Yoffset,
																															sa[6]=Xoffset,				sa[7]=Xplaces2,	sa[8]=0,			sa[9]=Yplaces2-1-Yoffset,	sa[10]=-1,			sa[11]=Yplaces2-1,													ra[8]=0,					ra[9]=Xplaces2,		ra[10]=0,					ra[11]=Yoffset2;

													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_2D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,		sa[5]=0,					partial=&Solve_2D_Implicit::partial_1,	ra[0]=0,					ra[1]=Xplaces,		ra[ 2]=Yplaces-Yoffset,		ra[ 3]=Yplaces,
																															sa[6]=Xoffset,				sa[7]=Xplaces2,	sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces2,	sa[11]=0,															ra[8]=0,					ra[9]=Xplaces2,		ra[10]=Yplaces2-Yoffset2,	ra[11]=Yplaces2;
													else;}
		}
		decltype(&Solve_2D_Implicit::partial_) partial;
	};
	class		Solve_2D_Disc:public Solve
	{
	public:
		double Xstart, Xsample, Ystart, Ysample;
		int ndrSize, Xplaces, Yplaces;
	private:
		int y, x;
		double *p;
		double fx(){return Xstart+x*Xsample;}
		double fy(){return Ystart+y*Ysample;}
		double fc(){return *p;}
		int sa[6], ra[8];
	public:
		void full_resize(double VX, double DX, double VY, double DY, int Xplaces, int Yplaces)
		{
			this->Xplaces=Xplaces, this->Yplaces=Yplaces, ndrSize=Xplaces*Yplaces, this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces, this->Ystart=VY-DY/2, this->Ysample=DY/Yplaces;
		}
		void full(Expression &ex)
		{
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_2D_Disc::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_2D_Disc::fx, LOL_1_const=0;break;
				case 'y':f=&Solve_2D_Disc::fy, LOL_1_const=0;break;
				case 'c':f=&Solve_2D_Disc::fc, p=&variables.val.r;break;
				case 't':f=&Solve_2D_Disc::fc, p=&T;break;
				}
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					n.ndr.assign(ndrSize, ex.data[kn]);
				//	n.ndr.assign(ndrSize, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_2D_Disc::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								ndr.assign(ndrSize, (this->*r)());
							else
							{
								ndr.resize(ndrSize);
								auto ndrIT=ndr.begin();
								for(y=0;y<Yplaces;++y)
									for(x=0;x<Xplaces;++x, ++ndrIT)
										*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_2D_Disc::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								ndr.assign(ndrSize, Value((this->*r)(), (this->*i)()));
							else
							{
								ndr.resize(ndrSize);
								auto ndrIT=ndr.begin();
								for(y=0;y<Yplaces;++y)
									for(x=0;x<Xplaces;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_2D_Disc::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								ndr.assign(ndrSize, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								ndr.resize(ndrSize);
								auto ndrIT=ndr.begin();
								for(y=0;y<Yplaces;++y)
									for(x=0;x<Xplaces;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			//Xdiscs:	(Xplaces-1) * Yplaces
			//Ydiscs:	(Yplaces-1) * Xplaces
			unsigned yDiscOffset=(Xplaces-1)*Yplaces;
			ex.discontinuities.assign(yDiscOffset+(Yplaces-1)*Xplaces, false);
			unsigned ndrSize=ex.n[0].ndr.size();
			for(auto &i:ex.i)
			{
				auto &result=ex.n[i.result];
				switch(i.type)
			//	switch(i.nArgs)
				{
				case 'c'://user function call
					concurrency::parallel_for(0u, ndrSize, Solve_UserFunction(ex, i));
					break;
				case 1:
					{
						auto &op1=ex.n[i.op1];
						if(i.d.disc_in)
						{
							for(int y=0;y<Yplaces;++y)
								for(int x=0;x<Xplaces-1;++x)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
									condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+1]);
								}
							for(int x=0;x<Xplaces;++x)
								for(int y=0;y<Yplaces-1;++y)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y];
									condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+Xplaces]);
								}
						}
						concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), i.uf);
					}
					break;
				case 2:
					{
						auto &op1=ex.n[i.op1], &op2=ex.n[i.op2];
						if(i.d.disc_in)
						{
							for(int y=0;y<Yplaces;++y)
							{
								for(int x=0;x<Xplaces-1;++x)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
									condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+1], op2.ndr[v+1]);
								}
							}
							for(int x=0;x<Xplaces;++x)
							{
								for(int y=0;y<Yplaces-1;++y)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y];
									condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+Xplaces], op2.ndr[v+Xplaces]);
								}
							}
						}
						concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), op2.ndr.begin(), result.ndr.begin(), i.bf);
					}
					break;
				case 3:
					{
						auto &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
						if(i.d.disc_in)
						{
							for(int y=0;y<Yplaces;++y)
							{
								for(int x=0;x<Xplaces-1;++x)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
									condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+1], op2.ndr[v+1], op3.ndr[v+1]);
								}
							}
							for(int x=0;x<Xplaces;++x)
							{
								for(int y=0;y<Yplaces-1;++y)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y];
									condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+Xplaces], op2.ndr[v+Xplaces], op3.ndr[v+Xplaces]);
								}
							}
						}
						concurrency::parallel_for(0u, op1.ndr.size(), [&](int k){result.ndr[k]=i.tf(op1.ndr[k], op2.ndr[k], op3.ndr[k]);});
					}
					break;
				}
				if(i.d.disc_out)
				{
					for(int y=0;y<Yplaces;++y)
					{
						for(int x=0;x<Xplaces-1;++x)
						{
							unsigned v=Xplaces*y+x;
							auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
							condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+1]);
						}
					}
					for(int x=0;x<Xplaces;++x)
					{
						for(int y=0;y<Yplaces-1;++y)
						{
							unsigned v=Xplaces*y+x;
							auto &condition=ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y];
							condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+Xplaces]);
						}
					}
				}
			}
		}
	private:
		void shift_		(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			int &XSstart=sa[0], &XSend=sa[1], &XDstart=sa[2], &YSstart=sa[3], &YSend=sa[4], &YDstart=sa[5];
			{
				auto _First=ndr.begin()+XSstart, _Last=ndr.begin()+XSend, _Dest=ndr.begin()+XDstart;
				for(int ys=Xplaces*YSstart, ysEnd=Xplaces*YSend, yStep=(ys<ysEnd?1:-1)*Xplaces, yd=Xplaces*YDstart;ys!=ysEnd;ys+=yStep, yd+=yStep)
					std::copy(_First+ys, _Last+ys, _Dest+yd);
			}
			if(XSstart<Xplaces-1)
			{
				auto _First=discontinuities.begin()+XSstart, _Last=discontinuities.begin()+XSend-1, _Dest=discontinuities.begin()+XDstart;
				for(int ys=YSstart*(Xplaces-1), ysEnd=YSend*(Xplaces-1), yStep=(ys<ysEnd?1:-1)*(Xplaces-1), yd=YDstart*(Xplaces-1);ys!=ysEnd;ys+=yStep, yd+=yStep)
					std::copy(_First+ys, _Last+ys, _Dest+yd);
			}
			if(YSstart<YSend)
			{
				if(YSstart<Yplaces-1)
				{
					unsigned yDiscOffset=(Xplaces-1)*Yplaces;
					auto _First=discontinuities.begin()+yDiscOffset+YSstart, _Last=discontinuities.begin()+yDiscOffset+YSend-1, _Dest=discontinuities.begin()+yDiscOffset+YDstart;
					for(int xs=XSstart*(Yplaces-1), xsEnd=XSend*(Yplaces-1), xStep=(xs<xsEnd?1:-1)*(Yplaces-1), xd=XDstart*(Yplaces-1);xs!=xsEnd;xs+=xStep, xd+=xStep)
						std::copy(_First+xs, _Last+xs, _Dest+xd);
				}
			}
			else
			{
				if(YSstart>0)
				{
					auto _First=discontinuities.rbegin()+Yplaces-2-(YSstart-1), _Last=discontinuities.rbegin()+Yplaces-2-YSend, _Dest=discontinuities.rbegin()+Yplaces-2-(YDstart-1);
					for(int xs=(Xplaces-1-XSstart)*(Yplaces-1), xsEnd=(Xplaces-1-XSend)*(Yplaces-1), xStep=(xs<xsEnd?1:-1)*(Yplaces-1), xd=(Xplaces-1-XDstart)*(Yplaces-1);xs!=xsEnd;xs+=xStep, xd+=xStep)
						std::copy(_First+xs, _Last+xs, _Dest+xd);
				}
			}
		}
		void shift_r	(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
			{
				auto _First=ndr.rbegin()+Xplaces-1-XSstart, _Last=ndr.rbegin()+Xplaces-1-XSend, _Dest=ndr.rbegin()+Xplaces-1-XDstart;
				for(int ky=Xplaces*(Yplaces-1-YSstart), kyEnd=Xplaces*(Yplaces-1-YSend), kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*(Yplaces-1-YDstart);ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
					std::copy(_First+ky, _Last+ky, _Dest+ky2);
			}
			if(XSstart>0)
			{
				unsigned xDiscROffset=Xplaces*(Yplaces-1);
				auto _First=discontinuities.rbegin()+xDiscROffset+Xplaces-2-(XSstart-1), _Last=discontinuities.rbegin()+xDiscROffset+Xplaces-2-XSend, _Dest=discontinuities.rbegin()+xDiscROffset+Xplaces-2-(XDstart-1);
				for(int ys=(Yplaces-1-YSstart)*(Xplaces-1), ysEnd=(Yplaces-1-YSend)*(Xplaces-1), yStep=(ys<ysEnd?1:-1)*(Xplaces-1), yd=(Yplaces-1-YDstart)*(Xplaces-1);ys!=ysEnd;ys+=yStep, yd+=yStep)
					std::copy(_First+ys, _Last+ys, _Dest+yd);
			}
			if(YSstart<YSend)
			{
				if(YSstart<Yplaces-1)
				{
					unsigned yDiscOffset=(Xplaces-1)*Yplaces;
					auto _First=discontinuities.begin()+yDiscOffset+YSstart, _Last=discontinuities.begin()+yDiscOffset+YSend-1, _Dest=discontinuities.begin()+yDiscOffset+YDstart;
					for(int xs=XSstart*(Yplaces-1), xsEnd=XSend*(Yplaces-1), xStep=(xs<xsEnd?1:-1)*(Yplaces-1), xd=XDstart*(Yplaces-1);xs!=xsEnd;xs+=xStep, xd+=xStep)
						std::copy(_First+xs, _Last+xs, _Dest+xd);
				}
			}
			else
			{
				if(YSstart>0)
				{
					auto _First=discontinuities.rbegin()+Yplaces-2-(YSstart-1), _Last=discontinuities.rbegin()+Yplaces-2-YSend, _Dest=discontinuities.rbegin()+Yplaces-2-(YDstart-1);
					for(int xs=(Xplaces-1-XSstart)*(Yplaces-1), xsEnd=(Xplaces-1-XSend)*(Yplaces-1), xStep=(xs<xsEnd?1:-1)*(Yplaces-1), xd=(Xplaces-1-XDstart)*(Yplaces-1);xs!=xsEnd;xs+=xStep, xd+=xStep)
						std::copy(_First+xs, _Last+xs, _Dest+xd);
				}
			}
		}
		decltype(&Solve_2D_Disc::shift_) shift;
		void solve_range	(Expression &ex, int *a)
		{
			int &x1=a[0], &x2=a[1], &y1=a[2], &y2=a[3];
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_2D_Disc::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_2D_Disc::fx, LOL_1_const=0;break;
				case 'y':f=&Solve_2D_Disc::fy, LOL_1_const=0;break;
				case 'c':f=&Solve_2D_Disc::fc, p=&variables.val.r;break;
				case 't':f=&Solve_2D_Disc::fc, p=&T;break;
				}
			};
			auto initialize_const=[&](std::vector<Value> &ndr, Value &value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
					std::fill(_First+ky, _Last+ky, value);
			};
			auto initialize_const_r=[&](std::vector<Value> &ndr, double value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
					std::fill(_First+ky, _Last+ky, value);
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					initialize_const(n.ndr, ex.data[kn]);
				//	initialize_const(n.ndr, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_2D_Disc::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								initialize_const_r(n.ndr, (this->*r)());
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=Xplaces*y1;y<y2;++y, ky+=Xplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_2D_Disc::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=Xplaces*y1;y<y2;++y, ky+=Xplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_2D_Disc::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=Xplaces*y1;y<y2;++y, ky+=Xplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			unsigned yDiscOffset=(Xplaces-1)*Yplaces;
			for(int y=y1;y<y2;++y)
				for(int x=x1;x<x2-1;++x)
					ex.discontinuities[(Xplaces-1)*y+x]=false;
			for(int x=x1;x<x2;++x)
				for(int y=y1;y<y2-1;++y)
					ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y]=false;
			for(auto &i:ex.i)
			{
				auto &result=ex.n[i.result];
				switch(i.type)
			//	switch(i.nArgs)
				{
				case 'c'://user function call
					{
						Solve_UserFunction uf(ex, i);
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							concurrency::parallel_for(ky+x1, ky+x2, uf);
					}
					break;
				case 1:
					{
						auto &op1=ex.n[i.op1];
						if(i.d.disc_in)
						{
							for(int y=y1;y<y2;++y)
							{
								for(int x=x1;x<x2-1;++x)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
									condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+1]);
								}
							}
							for(int x=x1;x<x2;++x)
							{
								for(int y=y1;y<y2-1;++y)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y];
									condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+Xplaces]);
								}
							}
						}
						auto _First=op1.ndr.begin()+x1, _Last=op1.ndr.begin()+x2;
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							std::transform(_First+ky, _Last+ky, _First+ky, i.uf);
					}
					break;
				case 2:
					{
						auto &op1=ex.n[i.op1], &op2=ex.n[i.op2];
						if(i.d.disc_in)
						{
							for(int y=y1;y<y2;++y)
							{
								for(int x=x1;x<x2-1;++x)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
									condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+1], op2.ndr[v+1]);
								}
							}
							for(int x=x1;x<x2;++x)
							{
								for(int y=y1;y<y2-1;++y)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y];
									condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+Xplaces], op2.ndr[v+Xplaces]);
								}
							}
						}
						auto _First1=op1.ndr.begin()+x1, _Last1=op1.ndr.begin()+x2, _First2=op2.ndr.begin()+x1, _Dest=result.ndr.begin()+x1;
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							std::transform(_First1+ky, _Last1+ky, _First2+ky, _Dest+ky, i.bf);
					}
					break;
				case 3:
					{
						auto &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
						if(i.d.disc_in)
						{
							for(int y=y1;y<y2;++y)
							{
								for(int x=x1;x<x2-1;++x)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
									condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+1], op2.ndr[v+1], op3.ndr[v+1]);
								}
							}
							for(int x=x1;x<x2;++x)
							{
								for(int y=y1;y<y2-1;++y)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y];
									condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+Xplaces], op2.ndr[v+Xplaces], op3.ndr[v+Xplaces]);
								}
							}
						}
						auto _First1=op1.ndr.begin()+x1, _Last1=op1.ndr.begin()+x2, _First2=op2.ndr.begin()+x1, _First3=op3.ndr.begin()+x1;
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							for(auto it=_First1+ky, itEnd=_Last1+ky, it2=_First2+ky, it3=_First3+ky, &res=i.result==i.op1?it:i.result==i.op2?it2:it3;it!=itEnd;++it, ++it2, ++it3)
								*res=i.tf(*it, *it2, *it3);
					}
					break;
				}
				if(i.d.disc_out)
				{
					for(int y=y1;y<y2;++y)
					{
						for(int x=x1;x<x2-1;++x)
						{
							unsigned v=Xplaces*y+x;
							auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
							condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+1]);
						}
					}
					for(int x=x1;x<x2;++x)
					{
						for(int y=y1;y<y2-1;++y)
						{
							unsigned v=Xplaces*y+x;
							auto &condition=ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y];
							condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+Xplaces]);
						}
					}
				}
			}
		}
		void partial_		(Expression&){}
		void partial_1		(Expression &ex)
		{
			(this->*shift)(ex.n[0].ndr, ex.discontinuities);
			solve_range(ex, ra);
		}
		void partial_2		(Expression &ex)
		{
			(this->*shift)(ex.n[0].ndr, ex.discontinuities);
			solve_range(ex, ra);
			solve_range(ex, ra+4);
		}
	public:
		void partial_bounds	(double VX, double DX, double VY, double DY, int Xoffset, int Yoffset)
		{
			this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces, this->Ystart=VY-DY/2, this->Ysample=DY/Yplaces;
			partial=&Solve_2D_Disc::partial_;
				 if(Xoffset>0){							 if(Yoffset>0)					shift=&Solve_2D_Disc::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_2D_Disc::partial_2,	++Xoffset, ++Yoffset,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces-Yoffset,			ra[4]=0,				ra[5]=Xplaces,	ra[6]=Yplaces-Yoffset,	ra[7]=Yplaces;
													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_2D_Disc::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,			partial=&Solve_2D_Disc::partial_2,	++Xoffset, ++Yoffset,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset,					ra[4]=Xplaces-Xoffset,	ra[5]=Xplaces,	ra[6]=Yoffset,			ra[7]=Yplaces;
													else								shift=&Solve_2D_Disc::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_2D_Disc::partial_1,	++Xoffset, ++Yoffset,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces;}
			else if(Xoffset<0){Xoffset=-Xoffset;		 if(Yoffset>0)					shift=&Solve_2D_Disc::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_2D_Disc::partial_2,	++Xoffset, ++Yoffset,	ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=Yplaces-Yoffset,			ra[4]=0,				ra[5]=Xplaces,	ra[6]=Yplaces-Yoffset,	ra[7]=Yplaces;
													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_2D_Disc::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,			partial=&Solve_2D_Disc::partial_2,	++Xoffset, ++Yoffset,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset,					ra[4]=0,				ra[5]=Xoffset,	ra[6]=Yoffset,			ra[7]=Yplaces;
													else								shift=&Solve_2D_Disc::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_2D_Disc::partial_1,	++Xoffset, ++Yoffset,	ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=Yplaces;}
			else{										 if(Yoffset>0)					shift=&Solve_2D_Disc::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_2D_Disc::partial_1,	++Xoffset, ++Yoffset,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=Yplaces-Yoffset,	ra[3]=Yplaces;
													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_2D_Disc::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,			partial=&Solve_2D_Disc::partial_1,	++Xoffset, ++Yoffset,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset;
													else;}
		}
		decltype(&Solve_2D_Disc::partial_) partial;
	};
	class		Solve_2D:public Solve
	{
	public:
		double Xstart, Xsample, Ystart, Ysample;
		int ndrSize, Xplaces, Yplaces;
	private:
		int y, x;
		double *p;
		double fx(){return Xstart+x*Xsample;}
		double fy(){return Ystart+y*Ysample;}
		double fc(){return *p;}
		int sa[6], ra[8];
	public:
		void full_resize(double VX, double DX, double VY, double DY, int Xplaces, int Yplaces)
		{
			this->Xplaces=Xplaces, this->Yplaces=Yplaces, ndrSize=Xplaces*Yplaces, this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces, this->Ystart=VY-DY/2, this->Ysample=DY/Yplaces;
		}
		void full(Expression &ex)
		{
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_2D::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_2D::fx, LOL_1_const=0;break;
				case 'y':f=&Solve_2D::fy, LOL_1_const=0;break;
				case 'c':f=&Solve_2D::fc, p=&variables.val.r;break;
				case 't':f=&Solve_2D::fc, p=&T;break;
				}
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					n.ndr.assign(ndrSize, ex.data[kn]);
				//	n.ndr.assign(ndrSize, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_2D::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								ndr.assign(ndrSize, (this->*r)());
							else
							{
								ndr.resize(ndrSize);
								auto ndrIT=ndr.begin();
								for(y=0;y<Yplaces;++y)
									for(x=0;x<Xplaces;++x, ++ndrIT)
										*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_2D::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								ndr.assign(ndrSize, Value((this->*r)(), (this->*i)()));
							else
							{
								ndr.resize(ndrSize);
								auto ndrIT=ndr.begin();
								for(y=0;y<Yplaces;++y)
									for(x=0;x<Xplaces;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_2D::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								ndr.assign(ndrSize, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								ndr.resize(ndrSize);
								auto ndrIT=ndr.begin();
								for(y=0;y<Yplaces;++y)
									for(x=0;x<Xplaces;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			::solve(ex);
		}
	private:
		void shift_		(std::vector<Value> &ndr)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
			auto _First=ndr.begin()+XSstart, _Last=ndr.begin()+XSend, _Dest=ndr.begin()+XDstart;
			for(int ky=Xplaces*YSstart, kyEnd=Xplaces*YSend, kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*YDstart;ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
				std::copy(_First+ky, _Last+ky, _Dest+ky2);
		}
		void shift_r	(std::vector<Value> &ndr)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
			auto _First=ndr.rbegin()+Xplaces-1-XSstart, _Last=ndr.rbegin()+Xplaces-1-XSend, _Dest=ndr.rbegin()+Xplaces-1-XDstart;
			for(int ky=Xplaces*(Yplaces-1-YSstart), kyEnd=Xplaces*(Yplaces-1-YSend), kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*(Yplaces-1-YDstart);ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
				std::copy(_First+ky,_Last+ky, _Dest+ky2);
		}
		decltype(&Solve_2D::shift_) shift;
		void solve_range	(Expression &ex, int*a)
		{
			int x1=a[0], x2=a[1], y1=a[2], y2=a[3];
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_2D::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_2D::fx, LOL_1_const=0;break;
				case 'y':f=&Solve_2D::fy, LOL_1_const=0;break;
				case 'c':f=&Solve_2D::fc, p=&variables.val.r;break;
				case 't':f=&Solve_2D::fc, p=&T;break;
				}
			};
			auto initialize_const=[&](std::vector<Value> &ndr, Value &value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
					std::fill(_First+ky, _Last+ky, value);
			};
			auto initialize_const_r=[&](std::vector<Value> &ndr, double value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
					std::fill(_First+ky, _Last+ky, value);
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					initialize_const(n.ndr, ex.data[kn]);
				//	initialize_const(n.ndr, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_2D::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								initialize_const_r(n.ndr, (this->*r)());
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=Xplaces*y1;y<y2;++y, ky+=Xplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_2D::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=Xplaces*y1;y<y2;++y, ky+=Xplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_2D::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=Xplaces*y1;y<y2;++y, ky+=Xplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			for(auto &i:ex.i)
			{
				switch(i.type)
			//	switch(i.nArgs)
				{
				case 'c'://user function call
					{
						Solve_UserFunction uf(ex, i);
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							concurrency::parallel_for(ky+x1, ky+x2, uf);
					}
					break;
				case 1:
					{
						auto function=i.uf;
						auto o1=&ex.n[i.op1].ndr;
						auto _First=o1->begin()+x1, _Last=o1->begin()+x2;
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							std::transform(_First+ky, _Last+ky, _First+ky, function);
					}
					break;
				case 2:
					{
						auto function=i.bf;
						auto o1=&ex.n[i.op1].ndr;
						auto _First1=o1->begin()+x1, _Last1=o1->begin()+x2, _First2=ex.n[i.op2].ndr.begin()+x1, _Dest=ex.n[i.result].ndr.begin()+x1;
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							std::transform(_First1+ky, _Last1+ky, _First2+ky, _Dest+ky, function);
					}
					break;
				case 3:
					{
						auto function=i.tf;
						auto o1=&ex.n[i.op1].ndr;
						auto _First1=o1->begin()+x1, _Last1=o1->begin()+x2, _First2=ex.n[i.op2].ndr.begin()+x1, _First3=ex.n[i.op3].ndr.begin()+x1;
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							for(auto it=_First1+ky, itEnd=_Last1+ky, it2=_First2+ky, it3=_First3+ky, &res=i.result==i.op1?it:i.result==i.op2?it2:it3;it!=itEnd;++it, ++it2, ++it3)
								*res=function(*it, *it2, *it3);
					}
					break;
				}
			}
		}
		void partial_		(Expression &ex){}
		void partial_1		(Expression &ex)
		{
			(this->*shift)(ex.n[0].ndr);
			solve_range(ex, ra);
		}
		void partial_2		(Expression &ex)
		{
			(this->*shift)(ex.n[0].ndr);
			solve_range(ex, ra), solve_range(ex, ra+4);
		}
	public:
		void partial_bounds	(double VX, double DX, double VY, double DY, int Xoffset, int Yoffset)
		{
			this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces, this->Ystart=VY-DY/2, this->Ysample=DY/Yplaces;
			partial=&Solve_2D::partial_;
				 if(Xoffset>0){							 if(Yoffset>0)					shift=&Solve_2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_2D::partial_2,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces-Yoffset,			ra[4]=0,				ra[5]=Xplaces,	ra[6]=Yplaces-Yoffset,	ra[7]=Yplaces;
													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,			partial=&Solve_2D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset,					ra[4]=Xplaces-Xoffset,	ra[5]=Xplaces,	ra[6]=Yoffset,			ra[7]=Yplaces;
													else								shift=&Solve_2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_2D::partial_1,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces;}
			else if(Xoffset<0){Xoffset=-Xoffset;		 if(Yoffset>0)					shift=&Solve_2D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_2D::partial_2,	ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=Yplaces-Yoffset,			ra[4]=0,				ra[5]=Xplaces,	ra[6]=Yplaces-Yoffset,	ra[7]=Yplaces;
													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_2D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,			partial=&Solve_2D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset,					ra[4]=0,				ra[5]=Xoffset,	ra[6]=Yoffset,			ra[7]=Yplaces;
													else								shift=&Solve_2D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_2D::partial_1,	ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=Yplaces;}
			else{										 if(Yoffset>0)					shift=&Solve_2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_2D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=Yplaces-Yoffset,	ra[3]=Yplaces;
													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,			partial=&Solve_2D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset;
													else;}
		}
		decltype(&Solve_2D::partial_) partial;
	};
	class		Solve_C2D:public Solve
	{
	public:
		int *rgb;
		Solve_C2D():rgb(0){}
		double Xstart, Xsample, Yend, Ysample;
		int ndrSize, Xplaces, Yplaces;
	private:
		int y, x;
		double *p;
		double fx(){return Xstart	+x*Xsample;}
		double fy(){return Yend		-y*Ysample;}
		double fc(){return *p;}
		int sa[6], ra[8];
	public:
		void full_resize(double VX, double DX, double VY, double DY, int Xplaces, int Yplaces)
		{
			this->Xplaces=Xplaces, this->Yplaces=Yplaces, ndrSize=Xplaces*Yplaces, this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces, this->Yend=VY+DY/2, this->Ysample=DY/Yplaces;
			rgb=(int*)realloc(rgb, Xplaces*Yplaces*sizeof(int));
		}
		void full(Expression &ex)
		{
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_C2D::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_C2D::fx, LOL_1_const=0;break;
				case 'y':f=&Solve_C2D::fy, LOL_1_const=0;break;
				case 'c':f=&Solve_C2D::fc, p=&variables.val.r;break;
				case 't':f=&Solve_C2D::fc, p=&T;break;
				}
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					n.ndr.assign(ndrSize, ex.data[kn]);
				//	n.ndr.assign(ndrSize, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(variables.mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_C2D::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								ndr.assign(ndrSize, (this->*r)());
							else
							{
								ndr.resize(ndrSize);
								auto ndrIT=ndr.begin();
								for(y=0;y<Yplaces;++y)
									for(x=0;x<Xplaces;++x, ++ndrIT)
										*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_C2D::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								ndr.assign(ndrSize, Value((this->*r)(), (this->*i)()));
							else
							{
								ndr.resize(ndrSize);
								auto ndrIT=ndr.begin();
								for(y=0;y<Yplaces;++y)
									for(x=0;x<Xplaces;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_C2D::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								ndr.assign(ndrSize, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								ndr.resize(ndrSize);
								auto ndrIT=ndr.begin();
								for(y=0;y<Yplaces;++y)
									for(x=0;x<Xplaces;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			::solve(ex);
			/*	int k=0;
				for(auto &v:ex.n[0].ndr)
				{
					if(v.r==_HUGE)
					{
						if(v.i==_HUGE||v.i==-_HUGE)
							v.r=0x00FFFFFF;
						else
						{
							double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(0);
							v.r=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
						}
					}
					else if(v.r==-_HUGE)
					{
						if(v.i==_HUGE||v.i==-_HUGE)
							v.r=0x00FFFFFF;
						else
						{
							double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(G2::_pi);
							v.r=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
						}
					}
					else if(v.i==_HUGE)
					{
						double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(G2::_pi/2);
						v.r=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
					}
					else if(v.i==-_HUGE)
					{
						double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(-G2::_pi/2);
						v.r=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
					}
					else
					{
						double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=atan2(v.i, v.r);
						v.r=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
					}
					++k;
				}//*/
		}
		void updateRGB(std::vector<Value> &ndr)
		{
			concurrency::parallel_transform(ndr.begin(), ndr.end(), rgb, (int(*)(Value&))colorFunction);
		//	std::transform(ndr.begin(), ndr.end(), rgb, (int(*)(Value&))colorFunction);
		}
	//	{
		//	for(unsigned k=0;k<ndr.size();++k)
		//		rgb[k]=colorFunction(ndr[k]);
	//	}
	private:
		void shift_		(std::vector<Value> &ndr)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
			auto _First=ndr.begin()+XSstart, _Last=ndr.begin()+XSend, _Dest=ndr.begin()+XDstart;
			auto _First2=rgb+XSstart, _Last2=rgb+XSend, _Dest2=rgb+XDstart;
			for(int ky=Xplaces*YSstart, kyEnd=Xplaces*YSend, kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*YDstart;ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
			{
				std::copy(_First+ky, _Last+ky, _Dest+ky2);
				std::copy(_First2+ky, _Last2+ky, _Dest2+ky2);
			}
		}
		void shift_r	(std::vector<Value> &ndr)
		{
			int ndrSize=Xplaces*Yplaces;
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
			auto _First=ndr.rbegin()+Xplaces-1-XSstart, _Last=ndr.rbegin()+Xplaces-1-XSend, _Dest=ndr.rbegin()+Xplaces-1-XDstart;
			auto _First2=std::reverse_iterator<int*>(rgb+ndrSize)+Xplaces-1-XSstart, _Last2=std::reverse_iterator<int*>(rgb+ndrSize)+Xplaces-1-XSend, _Dest2=std::reverse_iterator<int*>(rgb+ndrSize)+Xplaces-1-XDstart;
			for(int ky=Xplaces*(Yplaces-1-YSstart), kyEnd=Xplaces*(Yplaces-1-YSend), kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*(Yplaces-1-YDstart);ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
			{
				std::copy(_First+ky,_Last+ky, _Dest+ky2);
				std::copy(_First2+ky,_Last2+ky, _Dest2+ky2);
			}
		}
		decltype(&Solve_C2D::shift_) shift;
		void solve_range	(Expression &ex, int *a, bool contourOnly)
		{
			int x1=a[0], x2=a[1], y1=a[2], y2=a[3];
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_C2D::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_C2D::fx, LOL_1_const=0;break;
				case 'y':f=&Solve_C2D::fy, LOL_1_const=0;break;
				case 'c':f=&Solve_C2D::fc, p=&variables.val.r;break;
				case 't':f=&Solve_C2D::fc, p=&T;break;
				}
			};
			auto initialize_const=[&](std::vector<Value> &ndr, Value &value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
					std::fill(_First+ky, _Last+ky, value);
			};
			auto initialize_const_r=[&](std::vector<Value> &ndr, double value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
					std::fill(_First+ky, _Last+ky, value);
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					initialize_const(n.ndr, ex.data[kn]);
				//	initialize_const(n.ndr, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_C2D::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								initialize_const_r(n.ndr, (this->*r)());
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=Xplaces*y1;y<y2;++y, ky+=Xplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_C2D::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=Xplaces*y1;y<y2;++y, ky+=Xplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_C2D::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=Xplaces*y1;y<y2;++y, ky+=Xplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			for(auto &i:ex.i)
			{
				switch(i.type)
			//	switch(i.nArgs)
				{
				case 'c'://user function call
					{
						Solve_UserFunction uf(ex, i);
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							concurrency::parallel_for(ky+x1, ky+x2, uf);
					}
					break;
				case 1:
					{
						auto o1=&ex.n[i.op1].ndr;
						auto _First=o1->begin()+x1, _Last=o1->begin()+x2;
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							std::transform(_First+ky, _Last+ky, _First+ky, i.uf);
					}
					break;
				case 2:
					{
						auto o1=&ex.n[i.op1].ndr;
						auto _First1=o1->begin()+x1, _Last1=o1->begin()+x2, _First2=ex.n[i.op2].ndr.begin()+x1, _Dest=ex.n[i.result].ndr.begin()+x1;
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							std::transform(_First1+ky, _Last1+ky, _First2+ky, _Dest+ky, i.bf);
					}
					break;
				case 3:
					{
						auto o1=&ex.n[i.op1].ndr;
						auto _First1=o1->begin()+x1, _Last1=o1->begin()+x2, _First2=ex.n[i.op2].ndr.begin()+x1, _First3=ex.n[i.op3].ndr.begin()+x1;
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							for(auto it=_First1+ky, itEnd=_Last1+ky, it2=_First2+ky, it3=_First3+ky, &res=i.result==i.op1?it:i.result==i.op2?it2:it3;it!=itEnd;++it, ++it2, ++it3)
								*res=i.tf(*it, *it2, *it3);
					}
					break;
				}
			}
		//	auto _First=ex.n[0].ndr.begin()+x1, _Last=ex.n[0].ndr.begin()+x2;
				auto &ndr=ex.n[0].ndr;
			if(contourOnly)
			{
				for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
					for(int kx=ky+x1, kxEnd=ky+x2;kx<kxEnd;++kx)
						rgb[kx]=0xFFFFFF;
			}
			else
			{
				for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
					for(int kx=ky+x1, kxEnd=ky+x2;kx<kxEnd;++kx)
						rgb[kx]=colorFunction(ndr[kx]);
			}
			/*	{
					auto &v=ndr[kx];
					if(v.r==_HUGE)
					{
						if(v.i==_HUGE||v.i==-_HUGE)
							rgb[kx]=0x00FFFFFF;
						else
						{
							double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(0);
							rgb[kx]=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
						}
					}
					else if(v.r==-_HUGE)
					{
						if(v.i==_HUGE||v.i==-_HUGE)
							rgb[kx]=0x00FFFFFF;
						else
						{
							double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(G2::_pi);
							rgb[kx]=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
						}
					}
					else if(v.i==_HUGE)
					{
						double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(G2::_pi/2);
						rgb[kx]=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
					}
					else if(v.i==-_HUGE)
					{
						double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(-G2::_pi/2);
						rgb[kx]=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
					}
					double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=atan2(v.i, v.r);
					rgb[kx]=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
				}//*/
			/*	std::transform(_First+ky, _Last+ky, _First+ky, [&](Value &v)->Value
				{
					if(v.r==_HUGE)
					{
						if(v.i==_HUGE||v.i==-_HUGE)
							return 0x00FFFFFF;
						else
						{
							double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(0);
							return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
						}
					}
					else if(v.r==-_HUGE)
					{
						if(v.i==_HUGE||v.i==-_HUGE)
							return 0x00FFFFFF;
						else
						{
							double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(G2::_pi);
							return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
						}
					}
					else if(v.i==_HUGE)
					{
						double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(G2::_pi/2);
						return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
					}
					else if(v.i==-_HUGE)
					{
						double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(-G2::_pi/2);
						return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
					}
					double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=atan2(v.i, v.r);
					return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
				});//*/
		}
		void partial_		(Expression &ex, bool contourOnly){}
		void partial_1		(Expression &ex, bool contourOnly)
		{
			sa[3]=Yplaces-1-sa[3], sa[4]=Yplaces-1-sa[4], sa[5]=Yplaces-1-sa[5];
			(this->*shift)(ex.n[0].ndr);
			int	temp=ra[2];	ra[2]=Yplaces-ra[3], ra[3]=Yplaces-temp;
			solve_range(ex, ra, contourOnly);
		}
		void partial_2		(Expression &ex, bool contourOnly)
		{
			sa[3]=Yplaces-1-sa[3], sa[4]=Yplaces-1-sa[4], sa[5]=Yplaces-1-sa[5];
			(this->*shift)(ex.n[0].ndr);
			int	temp=ra[2];	ra[2]=Yplaces-ra[3], ra[3]=Yplaces-temp;
				temp=ra[6], ra[6]=Yplaces-ra[7], ra[7]=Yplaces-temp;
			solve_range(ex, ra, contourOnly), solve_range(ex, ra+4, contourOnly);
		}
	public:
		void partial_bounds(double VX, double DX, double VY, double DY, int Xoffset, int Yoffset)
		{
			this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces, this->Yend=VY+DY/2, this->Ysample=DY/Yplaces;
			partial=&Solve_C2D::partial_;
				 if(Xoffset>0){							 if(Yoffset>0)					shift=&Solve_C2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_C2D::partial_2,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces-Yoffset,			ra[4]=0,				ra[5]=Xplaces,	ra[6]=Yplaces-Yoffset,	ra[7]=Yplaces;
													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_C2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,			partial=&Solve_C2D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset,					ra[4]=Xplaces-Xoffset,	ra[5]=Xplaces,	ra[6]=Yoffset,			ra[7]=Yplaces;
													else								shift=&Solve_C2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_C2D::partial_1,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces;}
			else if(Xoffset<0){Xoffset=-Xoffset;		 if(Yoffset>0)					shift=&Solve_C2D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_C2D::partial_2,	ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=Yplaces-Yoffset,			ra[4]=0,				ra[5]=Xplaces,	ra[6]=Yplaces-Yoffset,	ra[7]=Yplaces;
													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_C2D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,			partial=&Solve_C2D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset,					ra[4]=0,				ra[5]=Xoffset,	ra[6]=Yoffset,			ra[7]=Yplaces;
													else								shift=&Solve_C2D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_C2D::partial_1,	ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=Yplaces;}
			else{										 if(Yoffset>0)					shift=&Solve_C2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_C2D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=Yplaces-Yoffset,	ra[3]=Yplaces;
													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_C2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,			partial=&Solve_C2D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset;
													else;}
		}
		decltype(&Solve_C2D::partial_) partial;
	};
	class		Solve_L2D_Disc:public Solve
	{
	public:
		double XXstart, XXstep, XYstart, XYstep, YXstart, YXstep, YYstart, YYstep;
		int Xplaces, Yplaces, nX, nY, old_nX, old_nY, ndrSize;
	private:
		int x, y;
		double *p;
		double fxx(){return XXstart+x*XXstep;}
		double fxy(){return XYstart+y*XYstep;}
		double fyx(){return YXstart+x*YXstep;}
		double fyy(){return YYstart+y*YYstep;}
		double fc(){return *p;}
		int sa[12], ra[16];
	public:
		void full_resize(double VX, double DX, double VY, double DY, double Xsample, double Ysample, int Xplaces, int Yplaces)
		{
		/*	XYstep=YXstep=step;
			XXstart=VX-DX/2, XXend=VX+DX/2, XYstart=ceil((VY-DY/2)/XYstep)*XYstep, XYend=floor((VY+DY/2)/XYstep)*XYstep;
			YYstart=VY-DY/2, YYend=VY+DY/2, YXstart=ceil((VX-DX/2)/YXstep)*YXstep, YXend=floor((VX+DX/2)/YXstep)*YXstep;
			nX=int(floor(YYend/XYstep)-floor(YYstart/XYstep)), nY=int(floor(XXend/YXstep)-floor(XXstart/YXstep));//*/
			this->Xplaces=Xplaces, this->Yplaces=Yplaces;
			XYstep=Ysample, YXstep=Xsample;
			XXstart=VX-DX/2, XXstep=DX/Xplaces;
			YYstart=VY-DY/2, YYstep=DY/Yplaces;
			int Xstart=int(ceil(YYstart/XYstep)), Ystart=int(ceil(XXstart/YXstep));
			XYstart=Xstart*XYstep;
			YXstart=Ystart*YXstep;
			nX=int(ceil((VY+DY/2)/XYstep))-Xstart, nY=int(ceil((VX+DX/2)/YXstep))-Ystart, ndrSize=Xplaces*nX+Yplaces*nY;//*/
		/*	XYstep=YXstep=step;
			XXstart=VX-DX/2, XXstep=DX/Xplaces;
			YYstart=VY-DY/2, YYstep=DY/Yplaces;
			XYstart=ceil(YYstart/XYstep)*XYstep;
			YXstart=ceil(XXstart/YXstep)*YXstep;
			nX=int(ceil((VY+DY/2)/XYstep)-ceil(YYstart/XYstep)), nY=int(ceil((VX+DX/2)/YXstep)-ceil(XXstart/YXstep)), ndrSize=Xplaces*nX+Yplaces*nY;*/
		//	Xdiscs.clear(), Ydiscs.clear();
		}
		void full(Expression &ex)
		{
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, std::remove_reference<decltype(&Solve_L2D_Disc::fxx)>::type &f, std::remove_reference<decltype(&Solve_L2D_Disc::fxx)>::type &fb, int varType)
			{
				switch(varType)
				{
				case 'x':	f=&Solve_L2D_Disc::fxx, fb=&Solve_L2D_Disc::fyx, LOL_1_const=0;break;
				case 'y':	f=&Solve_L2D_Disc::fxy, fb=&Solve_L2D_Disc::fyy, LOL_1_const=0;break;
				case 'c':fb=f=&Solve_L2D_Disc::fc, p=&variables.val.r;break;
				case 't':fb=f=&Solve_L2D_Disc::fc, p=&T;break;
				}
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					n.ndr.assign(ndrSize, ex.data[kn]);
				//	n.ndr.assign(ndrSize, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					ndr.resize(ndrSize);
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_L2D_Disc::fxx) r, rb;
							LOL_1(variables, r, rb, variables.varTypeR);
							if(LOL_1_const)
								std::fill_n(ndr.begin(), Xplaces*nX, (this->*r)()),
								std::fill_n(ndr.begin()+Xplaces*nX, Yplaces*nY, (this->*rb)());
							else
							{
								auto ndrIT=ndr.begin();
								for(y=0;y<nX;++y)
									for(x=0;x<Xplaces;++x, ++ndrIT)
										*ndrIT=(this->*r)();
									//	*ndrIT=(*r)();
								for(x=0;x<nY;++x)
									for(y=0;y<Yplaces;++y, ++ndrIT)
										*ndrIT=(this->*rb)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_L2D_Disc::fxx) r, i, rb, ib;
							LOL_1(variables, r, rb, variables.varTypeR);
							LOL_1(variables, i, ib, variables.varTypeI);
							if(LOL_1_const)
								std::fill_n(ndr.begin(), Xplaces*nX, Value((this->*r)(), (this->*i)())),
								std::fill_n(ndr.begin()+Xplaces*nX, Yplaces*nY, Value((this->*rb)(), (this->*ib)()));
							else
							{
								auto ndrIT=ndr.begin();
								if(ndr.size()!=Xplaces*nX+Yplaces*nY)
								{
									int LOL=0;
									LOL=1;
								}
								for(y=0;y<nX;++y)
									for(x=0;x<Xplaces;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
								for(x=0;x<nY;++x)
									for(y=0;y<Yplaces;++y, ++ndrIT)
										*ndrIT=Value((this->*rb)(), (this->*ib)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_L2D_Disc::fxx) r, i, j, k, rb, ib, jb, kb;
							LOL_1(variables, r, rb, variables.varTypeR);
							LOL_1(variables, i, ib, variables.varTypeI);
							LOL_1(variables, j, jb, variables.varTypeJ);
							LOL_1(variables, k, kb, variables.varTypeK);
							if(LOL_1_const)
								std::fill_n(ndr.begin(), Xplaces*nX, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)())),
								std::fill_n(ndr.begin()+Xplaces*nX, Yplaces*nY, Value((this->*rb)(), (this->*ib)(), (this->*jb)(), (this->*kb)()));
							else
							{
								auto ndrIT=ndr.begin();
								for(y=0;y<nX;++y)
									for(x=0;x<Xplaces;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
								for(x=0;x<nY;++x)
									for(y=0;y<Yplaces;++y, ++ndrIT)
										*ndrIT=Value((this->*rb)(), (this->*ib)(), (this->*jb)(), (this->*kb)());
							}
						}
						break;
					}
				}
			}
			//Xdiscs:	(Xplaces-1) * nX
			//Ydiscs:	(Yplaces-1) * nY
			unsigned yDiscOffset=(Xplaces-1)*nX;
			ex.discontinuities.assign(yDiscOffset+(Yplaces-1)*nY, false);
			unsigned yPos=Xplaces*nX;
			unsigned ndrSize=ex.n[0].ndr.size();
			for(auto &i:ex.i)
			{
				auto &result=ex.n[i.result];
				switch(i.type)
			//	switch(i.nArgs)
				{
				case 'c'://user function call
					concurrency::parallel_for(0u, ndrSize, Solve_UserFunction(ex, i));
					break;
				case 1:
					{
						auto &op1=ex.n[i.op1];
						if(i.d.disc_in)
						{
							for(int y=0;y<nX;++y)
							{
								for(int x=0;x<Xplaces-1;++x)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
									condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+1]);
								}
							}
							for(int x=0;x<nY;++x)
							{
								for(int y=0;y<Yplaces-1;++y)
								{
									unsigned v=yPos+Yplaces*x+y;
									auto &condition=ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y];
									condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+1]);
								}
							}
						}
						concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), i.uf);
					}
					break;
				case 2:
					{
						auto &op1=ex.n[i.op1], &op2=ex.n[i.op2];
						if(i.d.disc_in)
						{
							for(int y=0;y<nX;++y)
							{
								for(int x=0;x<Xplaces-1;++x)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
									condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+1], op2.ndr[v+1]);
								}
							}
							for(int x=0;x<nY;++x)
							{
								for(int y=0;y<Yplaces-1;++y)
								{
									unsigned v=yPos+Yplaces*x+y;
									auto &condition=ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y];
									condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+1], op2.ndr[v+1]);
								}
							}
						}
						concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), op2.ndr.begin(), result.ndr.begin(), i.bf);
					}
					break;
				case 3:
					{
						auto &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
						if(i.d.disc_in)
						{
							for(int y=0;y<nX;++y)
							{
								for(int x=0;x<Xplaces-1;++x)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
									condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+1], op2.ndr[v+1], op3.ndr[v+1]);
								}
							}
							for(int x=0;x<nY;++x)
							{
								for(int y=0;y<Yplaces-1;++y)
								{
									unsigned v=yPos+Yplaces*x+y;
									auto &condition=ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y];
									condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+1], op2.ndr[v+1], op3.ndr[v+1]);
								}
							}
						}
						concurrency::parallel_for(0u, op1.ndr.size(), [&](int k){result.ndr[k]=i.tf(op1.ndr[k], op2.ndr[k], op3.ndr[k]);});
					}
					break;
				}
				if(i.d.disc_out)
				{
					for(int y=0;y<nX;++y)
					{
						for(int x=0;x<Xplaces-1;++x)
						{
							unsigned v=Xplaces*y+x;
							auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
							condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+1]);
						}
					}
					for(int x=0;x<nY;++x)
					{
						for(int y=0;y<Yplaces-1;++y)
						{
							unsigned v=yPos+Yplaces*x+y;
							auto &condition=ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y];
							condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+1]);
						}
					}
				}
			}
		}
	private:
		void shift_		(std::vector<Value>&, std::vector<bool>&){}
		void shift_x	(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			int &XSstart=sa[0], &XSend=sa[1], &XDstart=sa[2], &YSstart=sa[3], &YSend=sa[4], &YDstart=sa[5];
			{
				auto _First=ndr.begin()+XSstart, _Last=ndr.begin()+XSend, _Dest=ndr.begin()+XDstart;
				for(int ys=Xplaces*YSstart, ysEnd=Xplaces*YSend, yStep=(ys<ysEnd?1:-1)*Xplaces, yd=Xplaces*YDstart;ys!=ysEnd;ys+=yStep, yd+=yStep)
					std::copy(_First+ys, _Last+ys, _Dest+yd);
			}
			if(XSstart<Xplaces-1)
			{
				auto _First=discontinuities.begin()+XSstart, _Last=discontinuities.begin()+XSend-1, _Dest=discontinuities.begin()+XDstart;
				for(int ys=YSstart*(Xplaces-1), ysEnd=YSend*(Xplaces-1), yStep=(ys<ysEnd?1:-1)*(Xplaces-1), yd=YDstart*(Xplaces-1);ys!=ysEnd;ys+=yStep, yd+=yStep)
					std::copy(_First+ys, _Last+ys, _Dest+yd);
			}
		}
		void shift_xr	(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			int &XSstart=sa[0], &XSend=sa[1], &XDstart=sa[2], &YSstart=sa[3], &YSend=sa[4], &YDstart=sa[5];
			{
				auto _First=ndr.rbegin()+Yplaces*nY+Xplaces-1-XSstart, _Last=ndr.rbegin()+Yplaces*nY+Xplaces-1-XSend, _Dest=ndr.rbegin()+Yplaces*nY+Xplaces-1-XDstart;
				for(int ys=Xplaces*(nX-1-YSstart), ysEnd=Xplaces*(nX-1-YSend), yStep=Xplaces*(ys<ysEnd?1:-1), yd=Xplaces*(nX-1-YDstart);ys!=ysEnd;ys+=yStep, yd+=yStep)
					std::copy(_First+ys,_Last+ys, _Dest+yd);
			}
			if(XSstart>0)
			{
				unsigned xDiscROffset=(Yplaces-1)*nY;
				auto _First=discontinuities.rbegin()+Xplaces-2-(XSstart-1), _Last=discontinuities.rbegin()+Xplaces-2-XSend, _Dest=discontinuities.rbegin()+Xplaces-2-(XDstart-1);
				for(int ys=(nX-1-YSstart)*(Xplaces-1), ysEnd=(nX-1-YSend)*(Xplaces-1), yStep=(ys<ysEnd?1:-1)*(Xplaces-1), yd=(nX-1-YDstart)*(Xplaces-1);ys!=ysEnd;ys+=yStep, yd+=yStep)
					std::copy(_First+ys, _Last+ys, _Dest+yd);
			}
		}
		void shift_y	(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			int &XSstart=sa[6], &XSend=sa[7], &XDstart=sa[8], &YSstart=sa[9], &YSend=sa[10], &YDstart=sa[11];
			{
				auto _First=ndr.begin()+Xplaces*nX+YSstart, _Last=ndr.begin()+Xplaces*nX+YSend, _Dest=ndr.begin()+Xplaces*nX+YDstart;
				for(int xs=Yplaces*XSstart, xsEnd=Yplaces*XSend, xStep=(xs<xsEnd?1:-1)*Yplaces, xd=Yplaces*XDstart;xs!=xsEnd;xs+=xStep, xd+=xStep)
					std::copy(_First+xs, _Last+xs, _Dest+xd);
			}
			if(YSstart<Yplaces-1)
			{
				unsigned yDiscOffset=(Xplaces-1)*nX;
				auto _First=discontinuities.begin()+yDiscOffset+YSstart, _Last=discontinuities.begin()+yDiscOffset+YSend-1, _Dest=discontinuities.begin()+yDiscOffset+YDstart;
				for(int xs=(Yplaces-1)*XSstart, xsEnd=(Yplaces-1)*XSend, xStep=(xs<xsEnd?1:-1)*(Yplaces-1), xd=(Yplaces-1)*XDstart;xs!=xsEnd;xs+=xStep, xd+=xStep)
					std::copy(_First+xs, _Last+xs, _Dest+xd);
			}
		}
		void shift_yr	(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			int &XSstart=sa[6], &XSend=sa[7], &XDstart=sa[8], &YSstart=sa[9], &YSend=sa[10], &YDstart=sa[11];
			{
				auto _First=ndr.rbegin()+Yplaces-1-YSstart, _Last=ndr.rbegin()+Yplaces-1-YSend, _Dest=ndr.rbegin()+Yplaces-1-YDstart;
				for(int xs=Yplaces*(nY-1-XSstart), xsEnd=Yplaces*(nY-1-XSend), xStep=(xs<xsEnd?1:-1)*Yplaces, xd=Yplaces*(nY-1-XDstart);xs!=xsEnd;xs+=xStep, xd+=xStep)
					std::copy(_First+xs, _Last+xs, _Dest+xd);
			}
			if(YSstart>0)
			{
				auto _First=discontinuities.rbegin()+Yplaces-2-(YSstart-1), _Last=discontinuities.rbegin()+Yplaces-2-YSend, _Dest=discontinuities.rbegin()+Yplaces-2-(YDstart-1);
				for(int xs=(Yplaces-1)*(nY-1-XSstart), xsEnd=(Yplaces-1)*(nY-1-XSend), xStep=(xs<xsEnd?1:-1)*(Yplaces-1), xd=(Yplaces-1)*(nY-1-XDstart);xs!=xsEnd;xs+=xStep, xd+=xStep)
					std::copy(_First+xs, _Last+xs, _Dest+xd);
			}
		}
		decltype(&Solve_L2D_Disc::shift_) shift_X, shift_Y;
		void modify_	(std::vector<Value>&, std::vector<bool>&){}
		void modify_Yi	(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			ndr.erase(
				ndr.begin()+Xplaces*old_nX,
				ndr.begin()+Xplaces*old_nX+Yplaces);

			unsigned yDiscOffset=(Xplaces-1)*old_nX;
			discontinuities.erase(
				discontinuities.begin()+yDiscOffset,
				discontinuities.begin()+yDiscOffset+Yplaces-1);
		}
		void modify_YI	(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			ndr.insert(ndr.begin()+Xplaces*old_nX, Yplaces, Value());

			unsigned yDiscOffset=(Xplaces-1)*old_nX;
			discontinuities.insert(discontinuities.begin()+yDiscOffset, Yplaces-1, false);
		}
		void modify_Yf	(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			ndr.erase(
				ndr.begin()+Xplaces*old_nX+Yplaces*(old_nY-1),
				ndr.begin()+Xplaces*old_nX+Yplaces*old_nY);

			unsigned yDiscOffset=(Xplaces-1)*old_nX;
			discontinuities.erase(
				discontinuities.begin()+yDiscOffset+(Yplaces-1)*(old_nY-1),
				discontinuities.begin()+yDiscOffset+(Yplaces-1)*old_nY);
		}
		void modify_YF	(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			ndr.insert(ndr.begin()+Xplaces*old_nX+Yplaces*old_nY, Yplaces, Value());
			discontinuities.insert(discontinuities.end(), Yplaces-1, false);
		}
		void modify_Xi	(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			ndr.erase(
				ndr.begin(),
				ndr.begin()+Xplaces);
			discontinuities.erase(
				discontinuities.begin(),
				discontinuities.begin()+Xplaces-1);
		}
		void modify_XI	(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			ndr.insert(ndr.begin(), Xplaces, Value());
			discontinuities.insert(discontinuities.begin(), Xplaces-1, false);
		}
		void modify_Xf	(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			ndr.erase(
				ndr.begin()+Xplaces*(old_nX-1),
				ndr.begin()+Xplaces*old_nX);
			discontinuities.erase(
				discontinuities.begin()+(Xplaces-1)*(old_nX-1),
				discontinuities.begin()+(Xplaces-1)*old_nX);
		}
		void modify_XF	(std::vector<Value> &ndr, std::vector<bool> &discontinuities)
		{
			ndr.insert(ndr.begin()+Xplaces*old_nX, Xplaces, Value());
			discontinuities.insert(discontinuities.begin()+(Xplaces-1)*old_nX, Xplaces-1, false);
		}
		decltype(&Solve_L2D_Disc::modify_) modify_X, modify_Y;
		void solve_range_X(Expression &ex, int *a)
		{
			int &x1=a[0], &x2=a[1], &y1=a[2], &y2=a[3];
			auto initialize_const=[&](std::vector<Value> &ndr, Value &value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
					std::fill(_First+ky, _Last+ky, value);
			};
			auto initialize_const_r=[&](std::vector<Value> &ndr, double value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
					std::fill(_First+ky, _Last+ky, value);
			};
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, std::remove_reference<decltype(&Solve_L2D_Disc::fxx)>::type &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_L2D_Disc::fxx, LOL_1_const=0;break;
				case 'y':f=&Solve_L2D_Disc::fxy, LOL_1_const=0;break;
				case 'c':f=&Solve_L2D_Disc::fc, p=&variables.val.r;break;
				case 't':f=&Solve_L2D_Disc::fc, p=&T;break;
				}
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					initialize_const(n.ndr, ex.data[kn]);
				//	initialize_const(n.ndr, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_L2D_Disc::fxx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								initialize_const_r(n.ndr, (this->*r)());
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=Xplaces*y1;y<y2;++y, ky+=Xplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_L2D_Disc::fxx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=Xplaces*y1;y<y2;++y, ky+=Xplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_L2D_Disc::fxx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=Xplaces*y1;y<y2;++y, ky+=Xplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			for(int y=y1;y<y2;++y)
				for(int x=x1;x<x2-1;++x)
					ex.discontinuities[(Xplaces-1)*y+x]=false;
			for(auto &i:ex.i)
			{
				auto &result=ex.n[i.result];
				switch(i.type)
			//	switch(i.nArgs)
				{
				case 'c'://user function call
					{
						Solve_UserFunction uf(ex, i);
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							concurrency::parallel_for(ky+x1, ky+x2, uf);
					}
					break;
				case 1:
					{
						auto &op1=ex.n[i.op1];
						if(i.d.disc_in)
						{
							for(int y=y1;y<y2;++y)
							{
								for(int x=x1;x<x2-1;++x)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
									condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+1]);
								}
							}
						}
						auto _First=op1.ndr.begin()+x1, _Last=op1.ndr.begin()+x2;
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							std::transform(_First+ky, _Last+ky, _First+ky, i.uf);
					}
					break;
				case 2:
					{
						auto &op1=ex.n[i.op1], &op2=ex.n[i.op2];
						if(i.d.disc_in)
						{
							for(int y=y1;y<y2;++y)
							{
								for(int x=x1;x<x2-1;++x)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
									condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+1], op2.ndr[v+1]);
								}
							}
						}
						auto _First1=op1.ndr.begin()+x1, _Last1=op1.ndr.begin()+x2, _First2=op2.ndr.begin()+x1, _Dest=result.ndr.begin()+x1;
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							std::transform(_First1+ky, _Last1+ky, _First2+ky, _Dest+ky, i.bf);
					}
					break;
				case 3:
					{
						auto &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
						if(i.d.disc_in)
						{
							for(int y=y1;y<y2;++y)
							{
								for(int x=x1;x<x2-1;++x)
								{
									unsigned v=Xplaces*y+x;
									auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
									condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+1], op2.ndr[v+1], op3.ndr[v+1]);
								}
							}
						}
						auto _First1=op1.ndr.begin()+x1, _Last1=op1.ndr.begin()+x2, _First2=op2.ndr.begin()+x1, _First3=op3.ndr.begin()+x1;
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							for(auto it=_First1+ky, itEnd=_Last1+ky, it2=_First2+ky, it3=_First3+ky, &res=i.result==i.op1?it:i.result==i.op2?it2:it3;it!=itEnd;++it, ++it2, ++it3)
								*res=i.tf(*it, *it2, *it3);
					}
					break;
				}
				if(i.d.disc_out)
				{
					for(int y=y1;y<y2;++y)
					{
						for(int x=x1;x<x2-1;++x)
						{
							unsigned v=Xplaces*y+x;
							auto &condition=ex.discontinuities[(Xplaces-1)*y+x];
							condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+1]);
						}
					}
				}
			}
		}
		void solve_range_Y(Expression &ex, int *a)
		{
			int &x1=a[0], &x2=a[1], &y1=a[2], &y2=a[3];
			auto initialize_const=[&](std::vector<Value> &ndr, Value &value)
			{
				auto _First=ndr.begin()+Xplaces*nX+y1, _Last=ndr.begin()+Xplaces*nX+y2;
				for(int kx=Yplaces*x1, kxEnd=Yplaces*x2;kx<kxEnd;kx+=Yplaces)
					std::fill(_First+kx, _Last+kx, value);
			};
			auto initialize_const_r=[&](std::vector<Value> &ndr, double value)
			{
				auto _First=ndr.begin()+Xplaces*nX+y1, _Last=ndr.begin()+Xplaces*nX+y2;
				for(int kx=Yplaces*x1, kxEnd=Yplaces*x2;kx<kxEnd;kx+=Yplaces)
					std::fill(_First+kx, _Last+kx, value);
			};
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, std::remove_reference<decltype(&Solve_L2D_Disc::fxx)>::type &fb, int varType)
			{
				switch(varType)
				{
				case 'x':fb=&Solve_L2D_Disc::fyx, LOL_1_const=0;break;
				case 'y':fb=&Solve_L2D_Disc::fyy, LOL_1_const=0;break;
				case 'c':fb=&Solve_L2D_Disc::fc, p=&variables.val.r;break;
				case 't':fb=&Solve_L2D_Disc::fc, p=&T;break;
				}
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					initialize_const(n.ndr, ex.data[kn]);
				//	initialize_const(n.ndr, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_L2D_Disc::fxx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								initialize_const_r(n.ndr, (this->*r)());
							else
							{
								decltype(ndr.begin()) ndrIT;
								x=x1;
								for(int kx=Xplaces*nX+Yplaces*x1;x<x2;++x, kx+=Yplaces)
									for(ndrIT=ndr.begin()+kx+y1, y=y1;y<y2;++y, ++ndrIT)
										*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_L2D_Disc::fxx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								x=x1;
								for(int kx=Xplaces*nX+Yplaces*x1;x<x2;++x, kx+=Yplaces)
									for(ndrIT=ndr.begin()+kx+y1, y=y1;y<y2;++y, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_L2D_Disc::fxx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								x=x1;
								for(int kx=Xplaces*nX+Yplaces*x1;x<x2;++x, kx+=Yplaces)
									for(ndrIT=ndr.begin()+kx+y1, y=y1;y<y2;++y, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			int yPos=Xplaces*nX, yDiscPos=(Xplaces-1)*nX;
			for(int x=x1;x<x2;++x)
				for(int y=y1;y<y2-1;++y)
					ex.discontinuities[yDiscPos+(Yplaces-1)*x+y]=false;
			for(auto &i:ex.i)
			{
				auto &result=ex.n[i.result];
				switch(i.type)
			//	switch(i.nArgs)
				{
				case 'c'://user function call
					{
						Solve_UserFunction uf(ex, i);
						int yOffset=Xplaces*nX, y1p=yOffset+y1, y2p=yOffset+y2;
						for(int kx=Yplaces*x1, kxEnd=Yplaces*x2;kx<kxEnd;kx+=Yplaces)
							concurrency::parallel_for(kx+y1p, kx+y2p, uf);
					}
					break;
				case 1:
					{
						auto &op1=ex.n[i.op1];
						if(i.d.disc_in)
						{
							for(int x=x1;x<x2;++x)
							{
								for(int y=y1;y<y2-1;++y)
								{
									unsigned v=yPos+Yplaces*x+y;
									auto &condition=ex.discontinuities[yDiscPos+(Yplaces-1)*x+y];
									condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+1]);
								}
							}
						}
						auto _First=op1.ndr.begin()+Xplaces*nX+y1, _Last=op1.ndr.begin()+Xplaces*nX+y2;
						for(int kx=Yplaces*x1, kxEnd=Yplaces*x2;kx<kxEnd;kx+=Yplaces)
							std::transform(_First+kx, _Last+kx, _First+kx, i.uf);
					}
					break;
				case 2:
					{
						auto &op1=ex.n[i.op1], &op2=ex.n[i.op2];
						if(i.d.disc_in)
						{
							for(int x=x1;x<x2;++x)
							{
								for(int y=y1;y<y2-1;++y)
								{
									unsigned v=yPos+Yplaces*x+y;
									auto &condition=ex.discontinuities[yDiscPos+(Yplaces-1)*x+y];
									condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+1], op2.ndr[v+1]);
								}
							}
						}
						auto _First1=op1.ndr.begin()+Xplaces*nX+y1, _Last1=op1.ndr.begin()+Xplaces*nX+y2, _First2=op2.ndr.begin()+Xplaces*nX+y1, _Dest=result.ndr.begin()+Xplaces*nX+y1;
						for(int kx=Yplaces*x1, kxEnd=Yplaces*x2;kx<kxEnd;kx+=Yplaces)
							std::transform(_First1+kx, _Last1+kx, _First2+kx, _Dest+kx, i.bf);
					}
					break;
				case 3:
					{
						auto &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
						if(i.d.disc_in)
						{
							for(int x=x1;x<x2;++x)
							{
								for(int y=y1;y<y2-1;++y)
								{
									unsigned v=yPos+Yplaces*x+y;
									auto &condition=ex.discontinuities[yDiscPos+(Yplaces-1)*x+y];
									condition=i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+1], op2.ndr[v+1], op3.ndr[v+1]);
								}
							}
						}
						auto _First1=op1.ndr.begin()+Xplaces*nX+y1, _Last1=op1.ndr.begin()+Xplaces*nX+y2, _First2=op2.ndr.begin()+Xplaces*nX+y1, _First3=op3.ndr.begin()+Xplaces*nX+y1;
						for(int kx=Yplaces*x1, kxEnd=Yplaces*x2;kx<kxEnd;kx+=Yplaces)
							for(auto it=_First1+kx, itEnd=_Last1+kx, it2=_First2+kx, it3=_First3+kx, &res=i.result==i.op1?it:i.result==i.op2?it2:it3;it!=itEnd;++it, ++it2, ++it3)
								*res=i.tf(*it, *it2, *it3);
					}
					break;
				}
				if(i.d.disc_out)
				{
					for(int x=x1;x<x2;++x)
					{
						for(int y=y1;y<y2-1;++y)
						{
							unsigned v=yPos+Yplaces*x+y;
							auto &condition=ex.discontinuities[yDiscPos+(Yplaces-1)*x+y];
							condition=i.d.d_o(result.ndr[v], result.ndr[v+1]);
						}
					}
				}
			}
		}
		void range_		(Expression&){}
		void range_xx	(Expression &ex){solve_range_X(ex, ra), solve_range_X(ex, ra+4);}
		void range_x	(Expression &ex){solve_range_X(ex, ra);}
		void range_yy	(Expression &ex){solve_range_Y(ex, ra+8), solve_range_Y(ex, ra+12);}
		void range_y	(Expression &ex){solve_range_Y(ex, ra+8);}
		decltype(&Solve_L2D_Disc::range_) range_X, range_Y;
	public:
		void partial_bounds(double VX, double DX, double VY, double DY, int Xoffset, int Yoffset)
		{
			int XDstart, XDend, YDstart, YDend;
			{
				old_nX=nX, old_nY=nY;
				int old_Xstart=int(ceil(YYstart/XYstep)), old_Ystart=int(ceil(XXstart/YXstep));

				XXstart=VX-DX/2, XXstep=DX/Xplaces;
				YYstart=VY-DY/2, YYstep=DY/Yplaces;
				int Xstart=int(ceil(YYstart/XYstep)), Ystart=int(ceil(XXstart/YXstep));
				XYstart=Xstart*XYstep;
				YXstart=Ystart*YXstep;
				nX=int(ceil((VY+DY/2)/XYstep))-Xstart, nY=int(ceil((VX+DX/2)/YXstep))-Ystart;

				XDstart=abs(Xstart-old_Xstart), XDend=abs(Xstart+nX-(old_Xstart+old_nX)), YDstart=abs(Ystart-old_Ystart), YDend=abs(Ystart+nY-(old_Ystart+old_nY));//*/
			}

		/*	shift_Y
				shift_																	!nY
				shift_y																	nY	Yoffset>0
				shift_yr																nY	Yoffset<0

			shift_X
				shift_																	!nX
				shift_x																	nX	Xoffset>0
				shift_xr																nX	Xoffset<0

			modify_Y
				modify_																	YDstart==	YDend		||	Xoffset==0
				modify_Yi																YDstart>	YDend		&&	Xoffset>0
				modify_YF																YDstart<	YDend		&&	Xoffset>0
				modify_YI																YDstart>	YDend		&&	Xoffset<0
				modify_Yf																YDstart<	YDend		&&	Xoffset<0

			modify_X
				modify_																	XDstart==	XDend		||	Yoffset==0
				modify_Xi																XDstart>	XDend		&&	Yoffset>0
				modify_XF																XDstart<	XDend		&&	Yoffset>0
				modify_XI																XDstart>	XDend		&&	Yoffset<0
				modify_Xf																XDstart<	XDend		&&	Yoffset<0

			sa[0], sa[1], sa[2]
				Xoffset,			Xplaces,	0										Xoffset>0	&&	nX
				Xplaces-1-Xoffset,	-1,			Xplaces-1								Xoffset<0	&&	nX
				0,					Xplaces,	0										Xoffset==0	&&	nX	&&	(Yoffset>0	&&	(XDstart>	XDend	&&	XDstart-1	||	XDstart)	||	Yoffset<0	&&	(XDstart<	XDend	&&	XDend-1	||	XDend))

			sa[3], sa[4], sa[5]
				XDstart,			nX,			0										Xoffset!=0	&&	Yoffset>0	&&	nX	&&	XDstart==	XDend	||	Yoffset>0	&&	XDstart==	XDend	&&	XDstart
				XDstart-1,			nX,			0										Xoffset!=0	&&	Yoffset>0	&&	nX	&&	XDstart>	XDend	||	Yoffset>0	&&	XDstart>	XDend	&&	XDstart-1
				XDstart,			nX-1,		0										Xoffset!=0	&&	Yoffset>0	&&	nX	&&	XDstart<	XDend	||	Yoffset>0	&&	XDstart<	XDend	&&	XDstart
				nX-1-XDend,			-1,			nX-1									Xoffset!=0	&&	Yoffset<0	&&	nX	&&	XDstart==	XDend	||	Yoffset<0	&&	XDstart==	XDend	&&	XDend
				nX-1-XDend,			0,			nX-1									Xoffset!=0	&&	Yoffset<0	&&	nX	&&	XDstart>	XDend	||	Yoffset<0	&&	XDstart>	XDend	&&	XDend
				nX-1-(XDend-1),		-1,			nX-1									Xoffset!=0	&&	Yoffset<0	&&	nX	&&	XDstart<	XDend	||	Yoffset<0	&&	XDstart<	XDend	&&	XDend-1

			sa[6], sa[7], sa[8]
				YDstart,			nY,			0										Yoffset!=0	&&	Xoffset>0	&&	nY	&&	YDstart==	YDend	||	Xoffset>0	&&	YDstart==	YDend	&&	YDstart
				YDstart-1,			nY,			0										Yoffset!=0	&&	Xoffset>0	&&	nY	&&	YDstart>	YDend	||	Xoffset>0	&&	YDstart>	YDend	&&	YDstart-1
				YDstart,			nY-1,		0										Yoffset!=0	&&	Xoffset>0	&&	nY	&&	YDstart<	YDend	||	Xoffset>0	&&	YDstart<	YDend	&&	YDstart
				nY-1-YDend,			-1,			nY-1									Yoffset!=0	&&	Xoffset<0	&&	nY	&&	YDstart==	YDend	||	Xoffset<0	&&	YDstart==	YDend	&&	YDend
				nY-1-YDend,			0,			nY-1									Yoffset!=0	&&	Xoffset<0	&&	nY	&&	YDstart>	YDend	||	Xoffset<0	&&	YDstart>	YDend	&&	YDend
				nY-1-(YDend-1),		-1,			nY-1									Yoffset!=0	&&	Xoffset<0	&&	nY	&&	YDstart<	YDend	||	Xoffset<0	&&	YDstart<	YDend	&&	YDend-1

			sa[9], sa[10], sa[11]
				Yoffset,			Yplaces,	0										Yoffset>0	&&	nY
				Yplaces-1-Yoffset,	-1,			Yplaces-1								Yoffset<0	&&	nY
				0,					Yplaces,	0										Yoffset==0	&&	nY	&&	(Xoffset>0	&&	(YDstart>	YDend	&&	YDstart-1	||	YDstart)	||	Xoffset<0	&&	(YDstart<	YDend	&&	YDend-1	||	YDend))

			ra[0], ra[1], ra[2], ra[3], ra[4], ra[5], ra[6], ra[7]
				Xplaces-Xoffset,	Xplaces,	0,					nX-XDend		0,					Xplaces,	nX-XDend,			nX					nX	&&	Xoffset>0	&&	Yoffset>0	&&	XDend
				0,					Xplaces,	0,					XDstart			Xplaces-Xoffset,	Xplaces,	XDstart,			nX					nX	&&	Xoffset>0	&&	Yoffset<0	&&	XDstart
				Xplaces-Xoffset,	Xplaces,	0,					nX																						nX	&&	Xoffset>0	&&	(Yoffset>0	&&	!XDend	||	Yoffset<0	&&	!XDstart	||	!Yoffset)
				0,					Xoffset,	0,					nX-XDend		0,					Xplaces,	nX-XDend,			nX					nX	&&	Xoffset<0	&&	Yoffset>0	&&	XDend
				0,					Xplaces,	0,					XDstart			0,					Xoffset,	XDstart,			nX					nX	&&	Xoffset<0	&&	Yoffset<0	&&	XDstart
				0,					Xoffset,	0,					nX																						nX	&&	Xoffset<0	&&	(Yoffset>0	&&	!XDend	||	Yoffset<0	&&	!XDstart	||	!Yoffset)
				0,					Xplaces,	nX-XDend,			nX																								!Xoffset	&&	Yoffset>0	&&	XDend
				0,					Xplaces,	0,					XDstart																							!Xoffset	&&	Yoffset<0	&&	XDstart

			ra[8], ra[9], ra[10], ra[11], ra[12], ra[13], ra[14], ra[15]
				0,					nY-YDend,	Yplaces-Yoffset,	Yplaces			nY-YDend,			nY,			0,					Yplaces				nY	&&	Xoffset>0	&&	Yoffset>0	&&	YDend
				0,					nY,			Yplaces-Yoffset,	Yplaces																					nY	&&	Xoffset>0	&&	Yoffset>0	&&	!YDend
				0,					nY-YDend,	0,					Yoffset			nY-YDend,			nY,			0,					Yplaces				nY	&&	Xoffset>0	&&	Yoffset<0	&&	YDend
				0,					nY,			0,					Yoffset																					nY	&&	Xoffset>0	&&	Yoffset<0	&&	!YDend
				nY-YDend,			nY,			0,					Yplaces																							Xoffset>0	&&	!Yoffset	&&	YDend
				0,					YDstart,	0,					Yplaces			YDstart,			nY,			Yplaces-Yoffset,	Yplaces				nY	&&	Xoffset<0	&&	Yoffset>0	&&	YDstart
				0,					nY,			Yplaces-Yoffset,	Yplaces																					nY	&&	Xoffset<0	&&	Yoffset>0	&&	!YDstart
				0,					YDstart,	0,					Yplaces			YDstart,			nY,			0,					Yoffset				nY	&&	Xoffset<0	&&	Yoffset<0	&&	YDstart
				0,					nY,			0,					Yplaces																					nY	&&	Xoffset<0	&&	Yoffset<0	&&	!YDstart
				0,					YDstart,	0,					Yplaces																							Xoffset<0	&&	!Yoffset	&&	YDstart
				0,					nY,			Yplaces-Yoffset,	Yplaces																					nY	&&	!Xoffset	&&	Yoffset>0
				0,					nY,			0,					Yoffset																					nY	&&	!Xoffset	&&	Yoffset<0
			*/
				 if(Xoffset>0)	{						 if(Yoffset>0)	{						 if(nY)	{	shift_Y=&Solve_L2D_Disc::shift_y;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D_Disc::modify_,																sa[6]=YDstart,				sa[7]=nY,			sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D_Disc::modify_Yi,															sa[6]=YDstart-1,			sa[7]=nY,			sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D_Disc::modify_YF,															sa[6]=YDstart,				sa[7]=nY-1,			sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;
																																																																																																							if(YDend)	range_Y=&Solve_L2D_Disc::range_yy,		++Yoffset,	ra[8]=0,				ra[9]=nY-YDend,	ra[10]=Yplaces-Yoffset,	ra[11]=Yplaces,		ra[12]=nY-YDend,		ra[13]=nY,		ra[14]=0,				ra[15]=Yplaces;
																																																																																																						else			range_Y=&Solve_L2D_Disc::range_y,		++Yoffset,	ra[8]=0,				ra[9]=nY,		ra[10]=Yplaces-Yoffset,	ra[11]=Yplaces;																							}
																							else		{	shift_Y=&Solve_L2D_Disc::shift_;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D_Disc::modify_;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D_Disc::modify_Yi;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D_Disc::modify_YF;																																																			range_Y=&Solve_L2D_Disc::range_;																																												}
																								 if(nX)	{	shift_X=&Solve_L2D_Disc::shift_x;		 if(XDstart==	XDend)		modify_X=&Solve_L2D_Disc::modify_,																		sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart,				sa[4]=nX,		sa[5]=0;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D_Disc::modify_Xi,																	sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart-1,			sa[4]=nX,		sa[5]=0;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D_Disc::modify_XF,																	sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart,				sa[4]=nX-1,		sa[5]=0;
																																																																																																							if(XDend)	range_X=&Solve_L2D_Disc::range_xx,		++Xoffset,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=nX-XDend,		ra[4]=0,				ra[5]=Xplaces,	ra[6]=nX-XDend,			ra[7]=nX;
																																																																																																						else			range_X=&Solve_L2D_Disc::range_x,		++Xoffset,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=nX;																								}
																							else		{	shift_X=&Solve_L2D_Disc::shift_;		 if(XDstart==	XDend)		modify_X=&Solve_L2D_Disc::modify_;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D_Disc::modify_Xi;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D_Disc::modify_XF;																																																					range_X=&Solve_L2D_Disc::range_;																																												}}
													else if(Yoffset<0)	{Yoffset=-Yoffset;		 if(nY)	{	shift_Y=&Solve_L2D_Disc::shift_yr;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D_Disc::modify_,																sa[6]=YDstart,				sa[7]=nY,			sa[8]=0,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D_Disc::modify_Yi,															sa[6]=YDstart-1,			sa[7]=nY,			sa[8]=0,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D_Disc::modify_YF,															sa[6]=YDstart,				sa[7]=nY-1,			sa[8]=0,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;
																																																																																																							if(YDend)	range_Y=&Solve_L2D_Disc::range_yy,		++Yoffset,	ra[8]=0,				ra[9]=nY-YDend,	ra[10]=0,				ra[11]=Yoffset,		ra[12]=nY-YDend,		ra[13]=nY,		ra[14]=0,				ra[15]=Yplaces;
																																																																																																						else			range_Y=&Solve_L2D_Disc::range_y,		++Yoffset,	ra[8]=0,				ra[9]=nY,		ra[10]=0,				ra[11]=Yoffset;																							}
																							else		{	shift_Y=&Solve_L2D_Disc::shift_;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D_Disc::modify_;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D_Disc::modify_Yi;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D_Disc::modify_YF;																																																			range_Y=&Solve_L2D_Disc::range_;																																												}
																								 if(nX)	{	shift_X=&Solve_L2D_Disc::shift_x;		 if(XDstart==	XDend)		modify_X=&Solve_L2D_Disc::modify_,																		sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-XDend,			sa[4]=-1,		sa[5]=nX-1;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D_Disc::modify_XI,																	sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-XDend,			sa[4]=0,		sa[5]=nX-1;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D_Disc::modify_Xf,																	sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-(XDend-1),		sa[4]=-1,		sa[5]=nX-1;
																																																																																																							if(XDstart)	range_X=&Solve_L2D_Disc::range_xx,		++Xoffset,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=XDstart,		ra[4]=Xplaces-Xoffset,	ra[5]=Xplaces,	ra[6]=XDstart,			ra[7]=nX;
																																																																																																						else			range_X=&Solve_L2D_Disc::range_x,		++Xoffset,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=nX;																								}
																							else		{	shift_X=&Solve_L2D_Disc::shift_;		 if(XDstart==	XDend)		modify_X=&Solve_L2D_Disc::modify_;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D_Disc::modify_XI;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D_Disc::modify_Xf;																																																					range_X=&Solve_L2D_Disc::range_;																																												}}
													else				{																										modify_X=&Solve_L2D_Disc::modify_;					 if(nX)			shift_X=&Solve_L2D_Disc::shift_x,	sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=0,					sa[4]=nX,		sa[5]=0,						range_X=&Solve_L2D_Disc::range_x,		++Xoffset,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=nX;
																																																								else				shift_X=&Solve_L2D_Disc::shift_,																																					range_X=&Solve_L2D_Disc::range_;
																																					if(YDstart==	YDend)	{			modify_Y=&Solve_L2D_Disc::modify_;			 if(YDstart)	shift_Y=&Solve_L2D_Disc::shift_y,	sa[6]=YDstart,				sa[7]=nY,			sa[8]=0,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																								else				shift_Y=&Solve_L2D_Disc::shift_;																																																																																									}
																																				else if(YDstart>	YDend)	{			modify_Y=&Solve_L2D_Disc::modify_Yi;		 if(YDstart-1)	shift_Y=&Solve_L2D_Disc::shift_y,	sa[6]=YDstart-1,			sa[7]=nY,			sa[8]=0,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																								else				shift_Y=&Solve_L2D_Disc::shift_;																																																																																									}
																																				else if(YDstart<	YDend)	{			modify_Y=&Solve_L2D_Disc::modify_YF;		 if(YDstart)	shift_Y=&Solve_L2D_Disc::shift_y,	sa[6]=YDstart,				sa[7]=nY-1,			sa[8]=0,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																								else				shift_Y=&Solve_L2D_Disc::shift_;																																																																																									}
																																																																																																							 if(YDend)	range_Y=&Solve_L2D_Disc::range_y,					ra[8]=nY-YDend,			ra[9]=nY,		ra[10]=0,				ra[11]=Yplaces;
																																																																																																						else			range_Y=&Solve_L2D_Disc::range_;																																												}}
			else if(Xoffset<0)	{Xoffset=-Xoffset;		 if(Yoffset>0)	{						 if(nY)	{	shift_Y=&Solve_L2D_Disc::shift_y;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D_Disc::modify_,																sa[6]=nY-1-YDend,			sa[7]=-1,			sa[8]=nY-1,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D_Disc::modify_YI,															sa[6]=nY-1-YDend,			sa[7]=0,			sa[8]=nY-1,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D_Disc::modify_Yf,															sa[6]=nY-1-(YDend-1),		sa[7]=-1,			sa[8]=nY-1,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;																																																									
																																																																																																							 if(YDstart)range_Y=&Solve_L2D_Disc::range_yy,		++Yoffset,	ra[8]=0,				ra[9]=YDstart,	ra[10]=0,				ra[11]=Yplaces,		ra[12]=YDstart,			ra[13]=nY,		ra[14]=Yplaces-Yoffset,	ra[15]=Yplaces;
																																																																																																						else			range_Y=&Solve_L2D_Disc::range_y,		++Yoffset,	ra[8]=0,				ra[9]=nY,		ra[10]=Yplaces-Yoffset,	ra[11]=Yplaces;																							}
																							else		{	shift_Y=&Solve_L2D_Disc::shift_;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D_Disc::modify_;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D_Disc::modify_YI;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D_Disc::modify_Yf;																																																			range_Y=&Solve_L2D_Disc::range_;																																												}
																								 if(nX)	{	shift_X=&Solve_L2D_Disc::shift_xr;		 if(XDstart==	XDend)		modify_X=&Solve_L2D_Disc::modify_,																		sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=XDstart,				sa[4]=nX,		sa[5]=0;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D_Disc::modify_Xi,																	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=XDstart-1,			sa[4]=nX,		sa[5]=0;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D_Disc::modify_XF,																	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=XDstart,				sa[4]=nX-1,		sa[5]=0;																																																									
																																																																																																							 if(XDend)	range_X=&Solve_L2D_Disc::range_xx,		++Xoffset,	ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=nX-XDend,		ra[4]=0,				ra[5]=Xplaces,	ra[6]=nX-XDend,			ra[7]=nX;
																																																																																																						else			range_X=&Solve_L2D_Disc::range_x,		++Xoffset,	ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=nX;																								}
																							else		{	shift_X=&Solve_L2D_Disc::shift_;		 if(XDstart==	XDend)		modify_X=&Solve_L2D_Disc::modify_;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D_Disc::modify_Xi;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D_Disc::modify_XF;																																																					range_X=&Solve_L2D_Disc::range_;																																												}}
													else if(Yoffset<0)	{Yoffset=-Yoffset;		 if(nY)	{	shift_Y=&Solve_L2D_Disc::shift_yr;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D_Disc::modify_,																sa[6]=nY-1-YDend,			sa[7]=-1,			sa[8]=nY-1,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D_Disc::modify_YI,															sa[6]=nY-1-YDend,			sa[7]=0,			sa[8]=nY-1,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D_Disc::modify_Yf,															sa[6]=nY-1-(YDend-1),		sa[7]=-1,			sa[8]=nY-1,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;																																																							
																																																																																																							 if(YDstart)range_Y=&Solve_L2D_Disc::range_yy,		++Yoffset,	ra[8]=0,				ra[9]=YDstart,	ra[10]=0,				ra[11]=Yplaces,		ra[12]=YDstart,			ra[13]=nY,		ra[14]=0,				ra[15]=Yoffset;
																																																																																																						else			range_Y=&Solve_L2D_Disc::range_y,					ra[8]=0,				ra[9]=nY,		ra[10]=0,				ra[11]=Yplaces;																							}
																							else		{	shift_Y=&Solve_L2D_Disc::shift_;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D_Disc::modify_;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D_Disc::modify_YI;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D_Disc::modify_Yf;																																																			range_Y=&Solve_L2D_Disc::range_;																																												}
																								 if(nX)	{	shift_X=&Solve_L2D_Disc::shift_xr;		 if(XDstart==	XDend)		modify_X=&Solve_L2D_Disc::modify_,																		sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=nX-1-XDend,			sa[4]=-1,		sa[5]=nX-1;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D_Disc::modify_XI,																	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=nX-1-XDend,			sa[4]=0,		sa[5]=nX-1;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D_Disc::modify_Xf,																	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=nX-1-(XDend-1),		sa[4]=-1,		sa[5]=nX-1;																																																									
																																																																																																							 if(XDstart)range_X=&Solve_L2D_Disc::range_xx,		++Xoffset,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=XDstart,		ra[4]=0,				ra[5]=Xoffset,	ra[6]=XDstart,			ra[7]=nX;
																																																																																																						else			range_X=&Solve_L2D_Disc::range_x,		++Xoffset,	ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=nX;																								}
																							else		{	shift_X=&Solve_L2D_Disc::shift_;		 if(XDstart==	XDend)		modify_X=&Solve_L2D_Disc::modify_;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D_Disc::modify_XI;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D_Disc::modify_Xf;																																																					range_X=&Solve_L2D_Disc::range_;																																												}}
													else				{																										modify_X=&Solve_L2D_Disc::modify_;					 if(nX)			shift_X=&Solve_L2D_Disc::shift_xr,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=0,					sa[4]=nX,		sa[5]=0,						range_X=&Solve_L2D_Disc::range_x,		++Xoffset,	ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=nX;
																																																								else				shift_X=&Solve_L2D_Disc::shift_,																																					range_X=&Solve_L2D_Disc::range_;
																																					if(YDstart==	YDend)	{			modify_Y=&Solve_L2D_Disc::modify_;			 if(YDend)		shift_Y=&Solve_L2D_Disc::shift_y,	sa[6]=nY-1-YDend,			sa[7]=-1,			sa[8]=nY-1,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																								else				shift_Y=&Solve_L2D_Disc::shift_;																																																																																									}
																																				else if(YDstart>	YDend)	{			modify_Y=&Solve_L2D_Disc::modify_YI;		 if(YDend)		shift_Y=&Solve_L2D_Disc::shift_y,	sa[6]=nY-1-YDend,			sa[7]=0,			sa[8]=nY-1,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																								else				shift_Y=&Solve_L2D_Disc::shift_;																																																																																									}
																																				else if(YDstart<	YDend)	{			modify_Y=&Solve_L2D_Disc::modify_Yf;		 if(YDend-1)	shift_Y=&Solve_L2D_Disc::shift_y,	sa[6]=nY-1-(YDend-1),		sa[7]=-1,			sa[8]=nY-1,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																								else				shift_Y=&Solve_L2D_Disc::shift_;																																																																																									}
																																																																																																							 if(YDstart)range_Y=&Solve_L2D_Disc::range_y,					ra[8]=0,				ra[9]=YDstart,	ra[10]=0,				ra[11]=Yplaces;
																																																																																																						else			range_Y=&Solve_L2D_Disc::range_;																																												}}
			else				{																																						modify_Y=&Solve_L2D_Disc::modify_;
															if(Yoffset>0)	{																																						 if(nY)			shift_Y=&Solve_L2D_Disc::shift_y,	sa[6]=0,					sa[7]=nY,			sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0,						range_Y=&Solve_L2D_Disc::range_y,		++Yoffset,	ra[8]=0,				ra[9]=nY,		ra[10]=Yplaces-Yoffset,	ra[11]=Yplaces;
																																																								else				shift_Y=&Solve_L2D_Disc::shift_,																																					range_Y=&Solve_L2D_Disc::range_;
																																					if( XDstart==	XDend)	{	modify_X=&Solve_L2D_Disc::modify_;					 if(XDstart)	shift_X=&Solve_L2D_Disc::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart,				sa[4]=nX,		sa[5]=0;
																																																								else				shift_X=&Solve_L2D_Disc::shift_;																																																																																									}
																																				else if( XDstart>	XDend)	{	modify_X=&Solve_L2D_Disc::modify_Xi;				 if(XDstart-1)	shift_X=&Solve_L2D_Disc::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart-1,			sa[4]=nX,		sa[5]=0;
																																																								else				shift_X=&Solve_L2D_Disc::shift_;																																																																																									}
																																				else if( XDstart<	XDend)	{	modify_X=&Solve_L2D_Disc::modify_XF;				 if(XDstart)	shift_X=&Solve_L2D_Disc::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart,				sa[4]=nX-1,		sa[5]=0;
																																																								else				shift_X=&Solve_L2D_Disc::shift_;																																																																																									}
																																																																																																							 if(XDend)	range_X=&Solve_L2D_Disc::range_x,					ra[0]=0,				ra[1]=Xplaces,	ra[2]=nX-XDend,			ra[3]=nX;
																																																																																																						else			range_X=&Solve_L2D_Disc::range_;																																												}
													else if(Yoffset<0)	{Yoffset=-Yoffset;																																			 if(nY)			shift_Y=&Solve_L2D_Disc::shift_yr,	sa[6]=0,					sa[7]=nY,			sa[8]=0,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1,				range_Y=&Solve_L2D_Disc::range_y,		++Yoffset,	ra[8]=0,				ra[9]=nY,		ra[10]=0,				ra[11]=Yoffset;
																																																								else				shift_Y=&Solve_L2D_Disc::shift_,																																					range_Y=&Solve_L2D_Disc::range_;
																																					if( XDstart==	XDend)	{	modify_X=&Solve_L2D_Disc::modify_;					 if(XDend)		shift_X=&Solve_L2D_Disc::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-XDend,			sa[4]=-1,		sa[5]=nX-1;
																																																								else				shift_X=&Solve_L2D_Disc::shift_;																																																																																									}
																																				else if( XDstart>	XDend)	{	modify_X=&Solve_L2D_Disc::modify_XI;				 if(XDend)		shift_X=&Solve_L2D_Disc::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-XDend,			sa[4]=0,		sa[5]=nX-1;
																																																								else				shift_X=&Solve_L2D_Disc::shift_;																																																																																									}
																																				else if( XDstart<	XDend)	{	modify_X=&Solve_L2D_Disc::modify_Xf;				 if(XDend-1)	shift_X=&Solve_L2D_Disc::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-(XDend-1),		sa[4]=-1,		sa[5]=nX-1;
																																																								else				shift_X=&Solve_L2D_Disc::shift_;																																																																																									}
																																																																																																							 if(XDstart)range_X=&Solve_L2D_Disc::range_x,					ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=XDstart;
																																																																																																						else			range_X=&Solve_L2D_Disc::range_;																																												}}
			
			partial=modify_X==&Solve_L2D_Disc::modify_&&modify_Y==&Solve_L2D_Disc::modify_?&Solve_L2D_Disc::partial_:&Solve_L2D_Disc::partial_m;
		}
	private:
		void partial_(Expression &ex)
		{
			(this->*shift_X)(ex.n[0].ndr, ex.discontinuities);
			(this->*shift_Y)(ex.n[0].ndr, ex.discontinuities);

			(this->*range_X)(ex);
			(this->*range_Y)(ex);
		}
		void partial_m(Expression &ex)
		{
			(this->*modify_Y)(ex.n[0].ndr, ex.discontinuities);
			(this->*modify_X)(ex.n[0].ndr, ex.discontinuities);
			for(auto nIT=ex.n.begin()+1;nIT!=ex.n.end();++nIT)
				nIT->ndr.resize(ndrSize);
							
			(this->*shift_X)(ex.n[0].ndr, ex.discontinuities);
			(this->*shift_Y)(ex.n[0].ndr, ex.discontinuities);

			(this->*range_X)(ex);
			(this->*range_Y)(ex);
		}
	public:
		decltype(&Solve_L2D_Disc::partial_) partial;
	};
	class		Solve_L2D:public Solve
	{
	public:
		double XXstart, XXstep, XYstart, XYstep, YXstart, YXstep, YYstart, YYstep;
		int Xplaces, Yplaces, nX, nY, old_nX, old_nY, ndrSize;
	private:
		int x, y;
		double *p;
		double fxx(){return XXstart+x*XXstep;}
		double fxy(){return XYstart+y*XYstep;}
		double fyx(){return YXstart+x*YXstep;}
		double fyy(){return YYstart+y*YYstep;}
		double fc(){return *p;}
		int sa[12], ra[16];
	public:
		void full_resize(double VX, double DX, double VY, double DY, double step, int Xplaces, int Yplaces)
		{
		/*	XYstep=YXstep=step;
			XXstart=VX-DX/2, XXend=VX+DX/2, XYstart=ceil((VY-DY/2)/XYstep)*XYstep, XYend=floor((VY+DY/2)/XYstep)*XYstep;
			YYstart=VY-DY/2, YYend=VY+DY/2, YXstart=ceil((VX-DX/2)/YXstep)*YXstep, YXend=floor((VX+DX/2)/YXstep)*YXstep;
			nX=int(floor(YYend/XYstep)-floor(YYstart/XYstep)), nY=int(floor(XXend/YXstep)-floor(XXstart/YXstep));//*/
			this->Xplaces=Xplaces, this->Yplaces=Yplaces;
			XYstep=YXstep=step;
			XXstart=VX-DX/2, XXstep=DX/Xplaces;
			YYstart=VY-DY/2, YYstep=DY/Yplaces;
			int Xstart=int(ceil(YYstart/XYstep)), Ystart=int(ceil(XXstart/YXstep));
			XYstart=Xstart*XYstep;
			YXstart=Ystart*YXstep;
			nX=int(ceil((VY+DY/2)/XYstep))-Xstart, nY=int(ceil((VX+DX/2)/YXstep))-Ystart, ndrSize=Xplaces*nX+Yplaces*nY;//*/
		/*	XYstep=YXstep=step;
			XXstart=VX-DX/2, XXstep=DX/Xplaces;
			YYstart=VY-DY/2, YYstep=DY/Yplaces;
			XYstart=ceil(YYstart/XYstep)*XYstep;
			YXstart=ceil(XXstart/YXstep)*YXstep;
			nX=int(ceil((VY+DY/2)/XYstep)-ceil(YYstart/XYstep)), nY=int(ceil((VX+DX/2)/YXstep)-ceil(XXstart/YXstep)), ndrSize=Xplaces*nX+Yplaces*nY;*/
		}
		void full(Expression &ex)
		{
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, std::remove_reference<decltype(&Solve_L2D::fxx)>::type &f, std::remove_reference<decltype(&Solve_L2D::fxx)>::type &fb, int varType)
			{
				switch(varType)
				{
				case 'x':	f=&Solve_L2D::fxx, fb=&Solve_L2D::fyx, LOL_1_const=0;break;
				case 'y':	f=&Solve_L2D::fxy, fb=&Solve_L2D::fyy, LOL_1_const=0;break;
				case 'c':fb=f=&Solve_L2D::fc, p=&variables.val.r;break;
				case 't':fb=f=&Solve_L2D::fc, p=&T;break;
				}
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					n.ndr.assign(ndrSize, ex.data[kn]);
				//	n.ndr.assign(ndrSize, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					ndr.resize(ndrSize);
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_L2D::fxx) r, rb;
							LOL_1(variables, r, rb, variables.varTypeR);
							if(LOL_1_const)
								std::fill_n(ndr.begin(), Xplaces*nX, (this->*r)()),
								std::fill_n(ndr.begin()+Xplaces*nX, Yplaces*nY, (this->*rb)());
							else
							{
								auto ndrIT=ndr.begin();
								for(y=0;y<nX;++y)
									for(x=0;x<Xplaces;++x, ++ndrIT)
										*ndrIT=(this->*r)();
									//	*ndrIT=(*r)();
								for(x=0;x<nY;++x)
									for(y=0;y<Yplaces;++y, ++ndrIT)
										*ndrIT=(this->*rb)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_L2D::fxx) r, i, rb, ib;
							LOL_1(variables, r, rb, variables.varTypeR);
							LOL_1(variables, i, ib, variables.varTypeI);
							if(LOL_1_const)
								std::fill_n(ndr.begin(), Xplaces*nX, Value((this->*r)(), (this->*i)())),
								std::fill_n(ndr.begin()+Xplaces*nX, Yplaces*nY, Value((this->*rb)(), (this->*ib)()));
							else
							{
								auto ndrIT=ndr.begin();
								if(ndr.size()!=Xplaces*nX+Yplaces*nY)
								{
									int LOL=0;
									LOL=1;
								}
								for(y=0;y<nX;++y)
									for(x=0;x<Xplaces;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
								for(x=0;x<nY;++x)
									for(y=0;y<Yplaces;++y, ++ndrIT)
										*ndrIT=Value((this->*rb)(), (this->*ib)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_L2D::fxx) r, i, j, k, rb, ib, jb, kb;
							LOL_1(variables, r, rb, variables.varTypeR);
							LOL_1(variables, i, ib, variables.varTypeI);
							LOL_1(variables, j, jb, variables.varTypeJ);
							LOL_1(variables, k, kb, variables.varTypeK);
							if(LOL_1_const)
								std::fill_n(ndr.begin(), Xplaces*nX, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)())),
								std::fill_n(ndr.begin()+Xplaces*nX, Yplaces*nY, Value((this->*rb)(), (this->*ib)(), (this->*jb)(), (this->*kb)()));
							else
							{
								auto ndrIT=ndr.begin();
								for(y=0;y<nX;++y)
									for(x=0;x<Xplaces;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
								for(x=0;x<nY;++x)
									for(y=0;y<Yplaces;++y, ++ndrIT)
										*ndrIT=Value((this->*rb)(), (this->*ib)(), (this->*jb)(), (this->*kb)());
							}
						}
						break;
					}
				}
			}
			::solve(ex);
		}
	private:
		void shift_		(std::vector<Value> &ndr){}
		void shift_x	(std::vector<Value> &ndr)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
			auto _First=ndr.begin()+XSstart, _Last=ndr.begin()+XSend, _Dest=ndr.begin()+XDstart;
			for(int ky=Xplaces*YSstart, kyEnd=Xplaces*YSend, kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*YDstart;ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
				std::copy(_First+ky, _Last+ky, _Dest+ky2);
		}
		void shift_xr	(std::vector<Value> &ndr)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
			auto _First=ndr.rbegin()+Yplaces*nY+Xplaces-1-XSstart, _Last=ndr.rbegin()+Yplaces*nY+Xplaces-1-XSend, _Dest=ndr.rbegin()+Yplaces*nY+Xplaces-1-XDstart;
			for(int ky=Xplaces*(nX-1-YSstart), kyEnd=Xplaces*(nX-1-YSend), kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*(nX-1-YDstart);ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
				std::copy(_First+ky,_Last+ky, _Dest+ky2);
		}
		void shift_y	(std::vector<Value> &ndr)
		{
			int XSstart=sa[6], XSend=sa[7], XDstart=sa[8], YSstart=sa[9], YSend=sa[10], YDstart=sa[11];
			auto _First=ndr.begin()+Xplaces*nX+YSstart, _Last=ndr.begin()+Xplaces*nX+YSend, _Dest=ndr.begin()+Xplaces*nX+YDstart;
			for(int kx=Yplaces*XSstart, kxEnd=Yplaces*XSend, kxStep=(kx<kxEnd?1:-1)*Yplaces, kx2=Yplaces*XDstart;kx!=kxEnd;kx+=kxStep, kx2+=kxStep)
				std::copy(_First+kx, _Last+kx, _Dest+kx2);
		}
		void shift_yr	(std::vector<Value> &ndr)
		{
			int XSstart=sa[6], XSend=sa[7], XDstart=sa[8], YSstart=sa[9], YSend=sa[10], YDstart=sa[11];
			auto _First=ndr.rbegin()+Yplaces-1-YSstart, _Last=ndr.rbegin()+Yplaces-1-YSend, _Dest=ndr.rbegin()+Yplaces-1-YDstart;
			for(int kx=Yplaces*(nY-1-XSstart), kxEnd=Yplaces*(nY-1-XSend), kxStep=(kx<kxEnd?1:-1)*Yplaces, kx2=Yplaces*(nY-1-XDstart);kx!=kxEnd;kx+=kxStep, kx2+=kxStep)
				std::copy(_First+kx, _Last+kx, _Dest+kx2);
		}
		decltype(&Solve_L2D::shift_) shift_X, shift_Y;
		void modify_	(std::vector<Value> &ndr){}
		void modify_Yi	(std::vector<Value> &ndr){ndr.erase	(ndr.begin()+Xplaces*old_nX						, ndr.begin()+Xplaces*old_nX+Yplaces);}
		void modify_YI	(std::vector<Value> &ndr){ndr.insert(ndr.begin()+Xplaces*old_nX					, Yplaces, Value());}
		void modify_Yf	(std::vector<Value> &ndr){ndr.erase	(ndr.begin()+Xplaces*old_nX+Yplaces*(old_nY-1)	, ndr.begin()+Xplaces*old_nX+Yplaces*old_nY);}
		void modify_YF	(std::vector<Value> &ndr){ndr.insert(ndr.begin()+Xplaces*old_nX+Yplaces*old_nY	, Yplaces, Value());}
		void modify_Xi	(std::vector<Value> &ndr){ndr.erase	(ndr.begin()									, ndr.begin()+Xplaces);}
		void modify_XI	(std::vector<Value> &ndr){ndr.insert(ndr.begin()								, Xplaces, Value());}
		void modify_Xf	(std::vector<Value> &ndr){ndr.erase	(ndr.begin()+Xplaces*(old_nX-1)					, ndr.begin()+Xplaces*old_nX);}
		void modify_XF	(std::vector<Value> &ndr){ndr.insert(ndr.begin()+Xplaces*old_nX					, Xplaces, Value());}
		decltype(&Solve_L2D::modify_) modify_X, modify_Y;
		void solve_range_X(Expression &ex, int *a)
		{
			int x1=a[0], x2=a[1], y1=a[2], y2=a[3];
			auto initialize_const=[&](std::vector<Value> &ndr, Value &value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
					std::fill(_First+ky, _Last+ky, value);
			};
			auto initialize_const_r=[&](std::vector<Value> &ndr, double value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
					std::fill(_First+ky, _Last+ky, value);
			};
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, std::remove_reference<decltype(&Solve_L2D::fxx)>::type &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_L2D::fxx, LOL_1_const=0;break;
				case 'y':f=&Solve_L2D::fxy, LOL_1_const=0;break;
				case 'c':f=&Solve_L2D::fc, p=&variables.val.r;break;
				case 't':f=&Solve_L2D::fc, p=&T;break;
				}
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					initialize_const(n.ndr, ex.data[kn]);
				//	initialize_const(n.ndr, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_L2D::fxx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								initialize_const_r(n.ndr, (this->*r)());
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=Xplaces*y1;y<y2;++y, ky+=Xplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_L2D::fxx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=Xplaces*y1;y<y2;++y, ky+=Xplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_L2D::fxx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=Xplaces*y1;y<y2;++y, ky+=Xplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			for(auto &i:ex.i)
			{
				switch(i.type)
			//	switch(i.nArgs)
				{
				case 'c'://user function call
					{
						Solve_UserFunction uf(ex, i);
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							concurrency::parallel_for(ky+x1, ky+x2, uf);
					}
					break;
				case 1:
					{
						auto function=i.uf;
						auto o1=&ex.n[i.op1].ndr;
						auto _First=o1->begin()+x1, _Last=o1->begin()+x2;
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							std::transform(_First+ky, _Last+ky, _First+ky, function);
					}
					break;
				case 2:
					{
						auto function=i.bf;
						auto o1=&ex.n[i.op1].ndr;
						auto _First1=o1->begin()+x1, _Last1=o1->begin()+x2, _First2=ex.n[i.op2].ndr.begin()+x1, _Dest=ex.n[i.result].ndr.begin()+x1;
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							std::transform(_First1+ky, _Last1+ky, _First2+ky, _Dest+ky, function);
					}
					break;
				case 3:
					{
						auto function=i.tf;
						auto o1=&ex.n[i.op1].ndr;
						auto _First1=o1->begin()+x1, _Last1=o1->begin()+x2, _First2=ex.n[i.op2].ndr.begin()+x1, _First3=ex.n[i.op3].ndr.begin()+x1;
						for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
							for(auto it=_First1+ky, itEnd=_Last1+ky, it2=_First2+ky, it3=_First3+ky, &res=i.result==i.op1?it:i.result==i.op2?it2:it3;it!=itEnd;++it, ++it2, ++it3)
								*res=function(*it, *it2, *it3);
					}
					break;
				}
			}
		}
		void solve_range_Y(Expression &ex, int *a)
		{
			int x1=a[0], x2=a[1], y1=a[2], y2=a[3];
			auto initialize_const=[&](std::vector<Value> &ndr, Value &value)
			{
				auto _First=ndr.begin()+Xplaces*nX+y1, _Last=ndr.begin()+Xplaces*nX+y2;
				for(int kx=Yplaces*x1, kxEnd=Yplaces*x2;kx<kxEnd;kx+=Yplaces)
					std::fill(_First+kx, _Last+kx, value);
			};
			auto initialize_const_r=[&](std::vector<Value> &ndr, double value)
			{
				auto _First=ndr.begin()+Xplaces*nX+y1, _Last=ndr.begin()+Xplaces*nX+y2;
				for(int kx=Yplaces*x1, kxEnd=Yplaces*x2;kx<kxEnd;kx+=Yplaces)
					std::fill(_First+kx, _Last+kx, value);
			};
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, std::remove_reference<decltype(&Solve_L2D::fxx)>::type &fb, int varType)
			{
				switch(varType)
				{
				case 'x':fb=&Solve_L2D::fyx, LOL_1_const=0;break;
				case 'y':fb=&Solve_L2D::fyy, LOL_1_const=0;break;
				case 'c':fb=&Solve_L2D::fc, p=&variables.val.r;break;
				case 't':fb=&Solve_L2D::fc, p=&T;break;
				}
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					initialize_const(n.ndr, ex.data[kn]);
				//	initialize_const(n.ndr, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_L2D::fxx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								initialize_const_r(n.ndr, (this->*r)());
							else
							{
								decltype(ndr.begin()) ndrIT;
								x=x1;
								for(int kx=Xplaces*nX+Yplaces*x1;x<x2;++x, kx+=Yplaces)
									for(ndrIT=ndr.begin()+kx+y1, y=y1;y<y2;++y, ++ndrIT)
										*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_L2D::fxx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								x=x1;
								for(int kx=Xplaces*nX+Yplaces*x1;x<x2;++x, kx+=Yplaces)
									for(ndrIT=ndr.begin()+kx+y1, y=y1;y<y2;++y, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_L2D::fxx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								x=x1;
								for(int kx=Xplaces*nX+Yplaces*x1;x<x2;++x, kx+=Yplaces)
									for(ndrIT=ndr.begin()+kx+y1, y=y1;y<y2;++y, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			for(auto &i:ex.i)
			{
				switch(i.type)
			//	switch(i.nArgs)
				{
				case 'c'://user function call
					{
						Solve_UserFunction uf(ex, i);
						int yOffset=Xplaces*nX, y1p=yOffset+y1, y2p=yOffset+y2;
						for(int kx=Yplaces*x1, kxEnd=Yplaces*x2;kx<kxEnd;kx+=Yplaces)
							concurrency::parallel_for(kx+y1p, kx+y2p, uf);
					}
					break;
				case 1:
					{
						auto function=i.uf;
						auto o1=&ex.n[i.op1].ndr;
						auto _First=o1->begin()+Xplaces*nX+y1, _Last=o1->begin()+Xplaces*nX+y2;
						for(int kx=Yplaces*x1, kxEnd=Yplaces*x2;kx<kxEnd;kx+=Yplaces)
							std::transform(_First+kx, _Last+kx, _First+kx, function);
					}
					break;
				case 2:
					{
						auto function=i.bf;
						auto o1=&ex.n[i.op1].ndr;
						auto _First1=o1->begin()+Xplaces*nX+y1, _Last1=o1->begin()+Xplaces*nX+y2, _First2=ex.n[i.op2].ndr.begin()+Xplaces*nX+y1, _Dest=ex.n[i.result].ndr.begin()+Xplaces*nX+y1;
						for(int kx=Yplaces*x1, kxEnd=Yplaces*x2;kx<kxEnd;kx+=Yplaces)
							std::transform(_First1+kx, _Last1+kx, _First2+kx, _Dest+kx, function);
					}
					break;
				case 3:
					{
						auto function=i.tf;
						auto o1=&ex.n[i.op1].ndr;
						auto _First1=o1->begin()+Xplaces*nX+y1, _Last1=o1->begin()+Xplaces*nX+y2, _First2=ex.n[i.op2].ndr.begin()+Xplaces*nX+y1, _First3=ex.n[i.op3].ndr.begin()+Xplaces*nX+y1;
						for(int kx=Yplaces*x1, kxEnd=Yplaces*x2;kx<kxEnd;kx+=Yplaces)
							for(auto it=_First1+kx, itEnd=_Last1+kx, it2=_First2+kx, it3=_First3+kx, &res=i.result==i.op1?it:i.result==i.op2?it2:it3;it!=itEnd;++it, ++it2, ++it3)
								*res=function(*it, *it2, *it3);
					}
					break;
				}
			}
		}
		void range_		(Expression &ex){}
		void range_xx	(Expression &ex){solve_range_X(ex, ra), solve_range_X(ex, ra+4);}
		void range_x	(Expression &ex){solve_range_X(ex, ra);}
		void range_yy	(Expression &ex){solve_range_Y(ex, ra+8), solve_range_Y(ex, ra+12);}
		void range_y	(Expression &ex){solve_range_Y(ex, ra+8);}
		decltype(&Solve_L2D::range_) range_X, range_Y;
	public:
		void partial_bounds(double VX, double DX, double VY, double DY, int Xoffset, int Yoffset)
		{
			int XDstart, XDend, YDstart, YDend;
			{
				old_nX=nX, old_nY=nY;
				int old_Xstart=int(ceil(YYstart/XYstep)), old_Ystart=int(ceil(XXstart/YXstep));

				XXstart=VX-DX/2, XXstep=DX/Xplaces;
				YYstart=VY-DY/2, YYstep=DY/Yplaces;
				int Xstart=int(ceil(YYstart/XYstep)), Ystart=int(ceil(XXstart/YXstep));
				XYstart=Xstart*XYstep;
				YXstart=Ystart*YXstep;
				nX=int(ceil((VY+DY/2)/XYstep))-Xstart, nY=int(ceil((VX+DX/2)/YXstep))-Ystart;

				XDstart=abs(Xstart-old_Xstart), XDend=abs(Xstart+nX-(old_Xstart+old_nX)), YDstart=abs(Ystart-old_Ystart), YDend=abs(Ystart+nY-(old_Ystart+old_nY));//*/
			}

		/*	shift_Y
				shift_																	!nY
				shift_y																	nY	Yoffset>0
				shift_yr																nY	Yoffset<0

			shift_X
				shift_																	!nX
				shift_x																	nX	Xoffset>0
				shift_xr																nX	Xoffset<0

			modify_Y
				modify_																	YDstart==	YDend		||	Xoffset==0
				modify_Yi																YDstart>	YDend		&&	Xoffset>0
				modify_YF																YDstart<	YDend		&&	Xoffset>0
				modify_YI																YDstart>	YDend		&&	Xoffset<0
				modify_Yf																YDstart<	YDend		&&	Xoffset<0

			modify_X
				modify_																	XDstart==	XDend		||	Yoffset==0
				modify_Xi																XDstart>	XDend		&&	Yoffset>0
				modify_XF																XDstart<	XDend		&&	Yoffset>0
				modify_XI																XDstart>	XDend		&&	Yoffset<0
				modify_Xf																XDstart<	XDend		&&	Yoffset<0

			sa[0], sa[1], sa[2]
				Xoffset,			Xplaces,	0										Xoffset>0	&&	nX
				Xplaces-1-Xoffset,	-1,			Xplaces-1								Xoffset<0	&&	nX
				0,					Xplaces,	0										Xoffset==0	&&	nX	&&	(Yoffset>0	&&	(XDstart>	XDend	&&	XDstart-1	||	XDstart)	||	Yoffset<0	&&	(XDstart<	XDend	&&	XDend-1	||	XDend))

			sa[3], sa[4], sa[5]
				XDstart,			nX,			0										Xoffset!=0	&&	Yoffset>0	&&	nX	&&	XDstart==	XDend	||	Yoffset>0	&&	XDstart==	XDend	&&	XDstart
				XDstart-1,			nX,			0										Xoffset!=0	&&	Yoffset>0	&&	nX	&&	XDstart>	XDend	||	Yoffset>0	&&	XDstart>	XDend	&&	XDstart-1
				XDstart,			nX-1,		0										Xoffset!=0	&&	Yoffset>0	&&	nX	&&	XDstart<	XDend	||	Yoffset>0	&&	XDstart<	XDend	&&	XDstart
				nX-1-XDend,			-1,			nX-1									Xoffset!=0	&&	Yoffset<0	&&	nX	&&	XDstart==	XDend	||	Yoffset<0	&&	XDstart==	XDend	&&	XDend
				nX-1-XDend,			0,			nX-1									Xoffset!=0	&&	Yoffset<0	&&	nX	&&	XDstart>	XDend	||	Yoffset<0	&&	XDstart>	XDend	&&	XDend
				nX-1-(XDend-1),		-1,			nX-1									Xoffset!=0	&&	Yoffset<0	&&	nX	&&	XDstart<	XDend	||	Yoffset<0	&&	XDstart<	XDend	&&	XDend-1

			sa[6], sa[7], sa[8]
				YDstart,			nY,			0										Yoffset!=0	&&	Xoffset>0	&&	nY	&&	YDstart==	YDend	||	Xoffset>0	&&	YDstart==	YDend	&&	YDstart
				YDstart-1,			nY,			0										Yoffset!=0	&&	Xoffset>0	&&	nY	&&	YDstart>	YDend	||	Xoffset>0	&&	YDstart>	YDend	&&	YDstart-1
				YDstart,			nY-1,		0										Yoffset!=0	&&	Xoffset>0	&&	nY	&&	YDstart<	YDend	||	Xoffset>0	&&	YDstart<	YDend	&&	YDstart
				nY-1-YDend,			-1,			nY-1									Yoffset!=0	&&	Xoffset<0	&&	nY	&&	YDstart==	YDend	||	Xoffset<0	&&	YDstart==	YDend	&&	YDend
				nY-1-YDend,			0,			nY-1									Yoffset!=0	&&	Xoffset<0	&&	nY	&&	YDstart>	YDend	||	Xoffset<0	&&	YDstart>	YDend	&&	YDend
				nY-1-(YDend-1),		-1,			nY-1									Yoffset!=0	&&	Xoffset<0	&&	nY	&&	YDstart<	YDend	||	Xoffset<0	&&	YDstart<	YDend	&&	YDend-1

			sa[9], sa[10], sa[11]
				Yoffset,			Yplaces,	0										Yoffset>0	&&	nY
				Yplaces-1-Yoffset,	-1,			Yplaces-1								Yoffset<0	&&	nY
				0,					Yplaces,	0										Yoffset==0	&&	nY	&&	(Xoffset>0	&&	(YDstart>	YDend	&&	YDstart-1	||	YDstart)	||	Xoffset<0	&&	(YDstart<	YDend	&&	YDend-1	||	YDend))

			ra[0], ra[1], ra[2], ra[3], ra[4], ra[5], ra[6], ra[7]
				Xplaces-Xoffset,	Xplaces,	0,					nX-XDend		0,					Xplaces,	nX-XDend,			nX					nX	&&	Xoffset>0	&&	Yoffset>0	&&	XDend
				0,					Xplaces,	0,					XDstart			Xplaces-Xoffset,	Xplaces,	XDstart,			nX					nX	&&	Xoffset>0	&&	Yoffset<0	&&	XDstart
				Xplaces-Xoffset,	Xplaces,	0,					nX																						nX	&&	Xoffset>0	&&	(Yoffset>0	&&	!XDend	||	Yoffset<0	&&	!XDstart	||	!Yoffset)
				0,					Xoffset,	0,					nX-XDend		0,					Xplaces,	nX-XDend,			nX					nX	&&	Xoffset<0	&&	Yoffset>0	&&	XDend
				0,					Xplaces,	0,					XDstart			0,					Xoffset,	XDstart,			nX					nX	&&	Xoffset<0	&&	Yoffset<0	&&	XDstart
				0,					Xoffset,	0,					nX																						nX	&&	Xoffset<0	&&	(Yoffset>0	&&	!XDend	||	Yoffset<0	&&	!XDstart	||	!Yoffset)
				0,					Xplaces,	nX-XDend,			nX																								!Xoffset	&&	Yoffset>0	&&	XDend
				0,					Xplaces,	0,					XDstart																							!Xoffset	&&	Yoffset<0	&&	XDstart

			ra[8], ra[9], ra[10], ra[11], ra[12], ra[13], ra[14], ra[15]
				0,					nY-YDend,	Yplaces-Yoffset,	Yplaces			nY-YDend,			nY,			0,					Yplaces				nY	&&	Xoffset>0	&&	Yoffset>0	&&	YDend
				0,					nY,			Yplaces-Yoffset,	Yplaces																					nY	&&	Xoffset>0	&&	Yoffset>0	&&	!YDend
				0,					nY-YDend,	0,					Yoffset			nY-YDend,			nY,			0,					Yplaces				nY	&&	Xoffset>0	&&	Yoffset<0	&&	YDend
				0,					nY,			0,					Yoffset																					nY	&&	Xoffset>0	&&	Yoffset<0	&&	!YDend
				nY-YDend,			nY,			0,					Yplaces																							Xoffset>0	&&	!Yoffset	&&	YDend
				0,					YDstart,	0,					Yplaces			YDstart,			nY,			Yplaces-Yoffset,	Yplaces				nY	&&	Xoffset<0	&&	Yoffset>0	&&	YDstart
				0,					nY,			Yplaces-Yoffset,	Yplaces																					nY	&&	Xoffset<0	&&	Yoffset>0	&&	!YDstart
				0,					YDstart,	0,					Yplaces			YDstart,			nY,			0,					Yoffset				nY	&&	Xoffset<0	&&	Yoffset<0	&&	YDstart
				0,					nY,			0,					Yplaces																					nY	&&	Xoffset<0	&&	Yoffset<0	&&	!YDstart
				0,					YDstart,	0,					Yplaces																							Xoffset<0	&&	!Yoffset	&&	YDstart
				0,					nY,			Yplaces-Yoffset,	Yplaces																					nY	&&	!Xoffset	&&	Yoffset>0
				0,					nY,			0,					Yoffset																					nY	&&	!Xoffset	&&	Yoffset<0
			*/
					if(Xoffset>0)	{					 if(Yoffset>0)	{						 if(nY)	{	shift_Y=&Solve_L2D::shift_y;			 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_,														sa[6]=YDstart,				sa[7]=nY,			sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_Yi,														sa[6]=YDstart-1,			sa[7]=nY,			sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_YF,														sa[6]=YDstart,				sa[7]=nY-1,			sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;
																																																																																																					if(YDend)	range_Y=&Solve_L2D::range_yy,		ra[8]=0,				ra[9]=nY-YDend,	ra[10]=Yplaces-Yoffset,	ra[11]=Yplaces,		ra[12]=nY-YDend,		ra[13]=nY,		ra[14]=0,				ra[15]=Yplaces;
																																																																																																				else			range_Y=&Solve_L2D::range_y,		ra[8]=0,				ra[9]=nY,		ra[10]=Yplaces-Yoffset,	ra[11]=Yplaces;																							}
																							else		{	shift_Y=&Solve_L2D::shift_;				 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_Yi;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_YF;																																																			range_Y=&Solve_L2D::range_;																																													}
																								if(nX)	{	shift_X=&Solve_L2D::shift_x;			 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_,																sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart,				sa[4]=nX,		sa[5]=0;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_Xi,																sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart-1,			sa[4]=nX,		sa[5]=0;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_XF,																sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart,				sa[4]=nX-1,		sa[5]=0;
																																																																																																					if(XDend)	range_X=&Solve_L2D::range_xx,		ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=nX-XDend,		ra[4]=0,				ra[5]=Xplaces,	ra[6]=nX-XDend,			ra[7]=nX;
																																																																																																				else			range_X=&Solve_L2D::range_x,		ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=nX;																								}
																							else		{	shift_X=&Solve_L2D::shift_;				 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_Xi;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_XF;																																																					range_X=&Solve_L2D::range_;																																													}}
													else if(Yoffset<0)	{Yoffset=-Yoffset;		 if(nY)	{	shift_Y=&Solve_L2D::shift_yr;			 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_,														sa[6]=YDstart,				sa[7]=nY,			sa[8]=0,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_Yi,														sa[6]=YDstart-1,			sa[7]=nY,			sa[8]=0,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_YF,														sa[6]=YDstart,				sa[7]=nY-1,			sa[8]=0,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;
																																																																																																					if(YDend)	range_Y=&Solve_L2D::range_yy,		ra[8]=0,				ra[9]=nY-YDend,	ra[10]=0,				ra[11]=Yoffset,		ra[12]=nY-YDend,		ra[13]=nY,		ra[14]=0,				ra[15]=Yplaces;
																																																																																																				else			range_Y=&Solve_L2D::range_y,		ra[8]=0,				ra[9]=nY,		ra[10]=0,				ra[11]=Yoffset;																							}
																							else		{	shift_Y=&Solve_L2D::shift_;				 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_Yi;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_YF;																																																			range_Y=&Solve_L2D::range_;																																													}
																								if(nX)	{	shift_X=&Solve_L2D::shift_x;			 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_,																sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-XDend,			sa[4]=-1,		sa[5]=nX-1;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_XI,																sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-XDend,			sa[4]=0,		sa[5]=nX-1;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_Xf,																sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-(XDend-1),		sa[4]=-1,		sa[5]=nX-1;
																																																																																																					if(XDstart)	range_X=&Solve_L2D::range_xx,		ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=XDstart,		ra[4]=Xplaces-Xoffset,	ra[5]=Xplaces,	ra[6]=XDstart,			ra[7]=nX;
																																																																																																				else			range_X=&Solve_L2D::range_x,		ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=nX;																								}
																							else		{	shift_X=&Solve_L2D::shift_;				 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_XI;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_Xf;																																																					range_X=&Solve_L2D::range_;																																													}}
													else				{																										modify_X=&Solve_L2D::modify_;				 if(nX)			shift_X=&Solve_L2D::shift_x,	sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=0,					sa[4]=nX,		sa[5]=0,							range_X=&Solve_L2D::range_x,		ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=nX;
																																																						else				shift_X=&Solve_L2D::shift_,																																							range_X=&Solve_L2D::range_;
																																			if(YDstart==	YDend)	{					modify_Y=&Solve_L2D::modify_;		 if(YDstart)	shift_Y=&Solve_L2D::shift_y,	sa[6]=YDstart,				sa[7]=nY,			sa[8]=0,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																						else				shift_Y=&Solve_L2D::shift_;																																																																																										}
																																		else if(YDstart>	YDend)	{					modify_Y=&Solve_L2D::modify_Yi;		 if(YDstart-1)	shift_Y=&Solve_L2D::shift_y,	sa[6]=YDstart-1,			sa[7]=nY,			sa[8]=0,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																						else				shift_Y=&Solve_L2D::shift_;																																																																																										}
																																		else if(YDstart<	YDend)	{					modify_Y=&Solve_L2D::modify_YF;		 if(YDstart)	shift_Y=&Solve_L2D::shift_y,	sa[6]=YDstart,				sa[7]=nY-1,			sa[8]=0,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																						else				shift_Y=&Solve_L2D::shift_;																																																																																										}
																																																																																																					 if(YDend)	range_Y=&Solve_L2D::range_y,		ra[8]=nY-YDend,			ra[9]=nY,		ra[10]=0,				ra[11]=Yplaces;
																																																																																																				else			range_Y=&Solve_L2D::range_;																																													}}
			else if(Xoffset<0)	{Xoffset=-Xoffset;		 if(Yoffset>0)	{						 if(nY)	{	shift_Y=&Solve_L2D::shift_y;			 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_,														sa[6]=nY-1-YDend,			sa[7]=-1,			sa[8]=nY-1,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_YI,														sa[6]=nY-1-YDend,			sa[7]=0,			sa[8]=nY-1,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_Yf,														sa[6]=nY-1-(YDend-1),		sa[7]=-1,			sa[8]=nY-1,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;																																																									
																																																																																																					 if(YDstart)range_Y=&Solve_L2D::range_yy,		ra[8]=0,				ra[9]=YDstart,	ra[10]=0,				ra[11]=Yplaces,		ra[12]=YDstart,			ra[13]=nY,		ra[14]=Yplaces-Yoffset,	ra[15]=Yplaces;
																																																																																																				else			range_Y=&Solve_L2D::range_y,		ra[8]=0,				ra[9]=nY,		ra[10]=Yplaces-Yoffset,	ra[11]=Yplaces;																							}
																							else		{	shift_Y=&Solve_L2D::shift_;				 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_YI;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_Yf;																																																			range_Y=&Solve_L2D::range_;																																													}
																								if(nX)	{	shift_X=&Solve_L2D::shift_xr;			 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_,																sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=XDstart,				sa[4]=nX,		sa[5]=0;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_Xi,																sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=XDstart-1,			sa[4]=nX,		sa[5]=0;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_XF,																sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=XDstart,				sa[4]=nX-1,		sa[5]=0;																																																									
																																																																																																					 if(XDend)	range_X=&Solve_L2D::range_xx,		ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=nX-XDend,		ra[4]=0,				ra[5]=Xplaces,	ra[6]=nX-XDend,			ra[7]=nX;
																																																																																																				else			range_X=&Solve_L2D::range_x,		ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=nX;																								}
																							else		{	shift_X=&Solve_L2D::shift_;				 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_Xi;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_XF;																																																					range_X=&Solve_L2D::range_;																																													}}
													else if(Yoffset<0)	{Yoffset=-Yoffset;		 if(nY)	{	shift_Y=&Solve_L2D::shift_yr;			 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_,														sa[6]=nY-1-YDend,			sa[7]=-1,			sa[8]=nY-1,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_YI,														sa[6]=nY-1-YDend,			sa[7]=0,			sa[8]=nY-1,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_Yf,														sa[6]=nY-1-(YDend-1),		sa[7]=-1,			sa[8]=nY-1,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;																																																							
																																																																																																					 if(YDstart)range_Y=&Solve_L2D::range_yy,		ra[8]=0,				ra[9]=YDstart,	ra[10]=0,				ra[11]=Yplaces,		ra[12]=YDstart,			ra[13]=nY,		ra[14]=0,				ra[15]=Yoffset;
																																																																																																				else			range_Y=&Solve_L2D::range_y,		ra[8]=0,				ra[9]=nY,		ra[10]=0,				ra[11]=Yplaces;																							}
																							else		{	shift_Y=&Solve_L2D::shift_;				 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_;
																																				else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_YI;
																																				else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_Yf;																																																			range_Y=&Solve_L2D::range_;																																													}
																								if(nX)	{	shift_X=&Solve_L2D::shift_xr;			 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_,																sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=nX-1-XDend,			sa[4]=-1,		sa[5]=nX-1;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_XI,																sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=nX-1-XDend,			sa[4]=0,		sa[5]=nX-1;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_Xf,																sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=nX-1-(XDend-1),		sa[4]=-1,		sa[5]=nX-1;																																																									
																																																																																																					 if(XDstart)range_X=&Solve_L2D::range_xx,		ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=XDstart,		ra[4]=0,				ra[5]=Xoffset,	ra[6]=XDstart,			ra[7]=nX;
																																																																																																				else			range_X=&Solve_L2D::range_x,		ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=nX;																								}
																							else		{	shift_X=&Solve_L2D::shift_;				 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_;
																																				else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_XI;
																																				else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_Xf;																																																					range_X=&Solve_L2D::range_;																																													}}
													else				{																										modify_X=&Solve_L2D::modify_;				 if(nX)			shift_X=&Solve_L2D::shift_xr,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=0,					sa[4]=nX,		sa[5]=0,							range_X=&Solve_L2D::range_x,		ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=nX;
																																																						else				shift_X=&Solve_L2D::shift_,																																							range_X=&Solve_L2D::range_;
																																					if(YDstart==	YDend)	{			modify_Y=&Solve_L2D::modify_;		 if(YDend)		shift_Y=&Solve_L2D::shift_y,	sa[6]=nY-1-YDend,			sa[7]=-1,			sa[8]=nY-1,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																						else				shift_Y=&Solve_L2D::shift_;																																																																																										}
																																				else if(YDstart>	YDend)	{			modify_Y=&Solve_L2D::modify_YI;		 if(YDend)		shift_Y=&Solve_L2D::shift_y,	sa[6]=nY-1-YDend,			sa[7]=0,			sa[8]=nY-1,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																						else				shift_Y=&Solve_L2D::shift_;																																																																																										}
																																				else if(YDstart<	YDend)	{			modify_Y=&Solve_L2D::modify_Yf;		 if(YDend-1)	shift_Y=&Solve_L2D::shift_y,	sa[6]=nY-1-(YDend-1),		sa[7]=-1,			sa[8]=nY-1,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																						else				shift_Y=&Solve_L2D::shift_;																																																																																										}
																																																																																																					 if(YDstart)range_Y=&Solve_L2D::range_y,		ra[8]=0,				ra[9]=YDstart,	ra[10]=0,				ra[11]=Yplaces;
																																																																																																				else			range_Y=&Solve_L2D::range_;																																													}}
			else				{																																						modify_Y=&Solve_L2D::modify_;
															if(Yoffset>0)	{																																				 if(nY)			shift_Y=&Solve_L2D::shift_y,	sa[6]=0,					sa[7]=nY,			sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0,							range_Y=&Solve_L2D::range_y,		ra[8]=0,				ra[9]=nY,		ra[10]=Yplaces-Yoffset,	ra[11]=Yplaces;
																																																						else				shift_Y=&Solve_L2D::shift_,																																							range_Y=&Solve_L2D::range_;
																																					if( XDstart==	XDend)	{	modify_X=&Solve_L2D::modify_;				 if(XDstart)	shift_X=&Solve_L2D::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart,				sa[4]=nX,		sa[5]=0;
																																																						else				shift_X=&Solve_L2D::shift_;																																																																																										}
																																				else if( XDstart>	XDend)	{	modify_X=&Solve_L2D::modify_Xi;				 if(XDstart-1)	shift_X=&Solve_L2D::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart-1,			sa[4]=nX,		sa[5]=0;
																																																						else				shift_X=&Solve_L2D::shift_;																																																																																										}
																																				else if( XDstart<	XDend)	{	modify_X=&Solve_L2D::modify_XF;				 if(XDstart)	shift_X=&Solve_L2D::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart,				sa[4]=nX-1,		sa[5]=0;
																																																						else				shift_X=&Solve_L2D::shift_;																																																																																										}
																																																																																																					 if(XDend)	range_X=&Solve_L2D::range_x,		ra[0]=0,				ra[1]=Xplaces,	ra[2]=nX-XDend,			ra[3]=nX;
																																																																																																				else			range_X=&Solve_L2D::range_;																																													}
													else if(Yoffset<0)	{Yoffset=-Yoffset;																																	 if(nY)			shift_Y=&Solve_L2D::shift_yr,	sa[6]=0,					sa[7]=nY,			sa[8]=0,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1,					range_Y=&Solve_L2D::range_y,		ra[8]=0,				ra[9]=nY,		ra[10]=0,				ra[11]=Yoffset;
																																																						else				shift_Y=&Solve_L2D::shift_,																																							range_Y=&Solve_L2D::range_;
																																					if( XDstart==	XDend)	{	modify_X=&Solve_L2D::modify_;				 if(XDend)		shift_X=&Solve_L2D::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-XDend,			sa[4]=-1,		sa[5]=nX-1;
																																																						else				shift_X=&Solve_L2D::shift_;																																																																																										}
																																				else if( XDstart>	XDend)	{	modify_X=&Solve_L2D::modify_XI;				 if(XDend)		shift_X=&Solve_L2D::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-XDend,			sa[4]=0,		sa[5]=nX-1;
																																																						else				shift_X=&Solve_L2D::shift_;																																																																																												}
																																				else if( XDstart<	XDend)	{	modify_X=&Solve_L2D::modify_Xf;				 if(XDend-1)	shift_X=&Solve_L2D::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-(XDend-1),		sa[4]=-1,		sa[5]=nX-1;
																																																						else				shift_X=&Solve_L2D::shift_;																																																																																												}
																																																																																																					 if(XDstart)range_X=&Solve_L2D::range_x,		ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=XDstart;
																																																																																																				else			range_X=&Solve_L2D::range_;																																													}}
			
			partial=modify_X==&Solve_L2D::modify_&&modify_Y==&Solve_L2D::modify_?&Solve_L2D::partial_:&Solve_L2D::partial_m;
		}
	private:
		void partial_(Expression &ex)
		{
			(this->*shift_X)(ex.n[0].ndr);
			(this->*shift_Y)(ex.n[0].ndr);

			(this->*range_X)(ex);
			(this->*range_Y)(ex);
		}
		void partial_m(Expression &ex)
		{
			(this->*modify_Y)(ex.n[0].ndr);
			(this->*modify_X)(ex.n[0].ndr);
			for(auto nIT=ex.n.begin()+1;nIT!=ex.n.end();++nIT)
				nIT->ndr.resize(ndrSize);
							
			(this->*shift_X)(ex.n[0].ndr);
			(this->*shift_Y)(ex.n[0].ndr);

			(this->*range_X)(ex);
			(this->*range_Y)(ex);
		}
	public:
		decltype(&Solve_L2D::partial_) partial;
	};
#if 0
	class		Solve_3D_Implicit:public Solve
	{
	public:
		double
			Xsample, Xstart, Xstart_s, *aXstart,
			Ysample, Yend, Yend_s, *aYend;
		int ndrSize, Xplaces, Yplaces;
	private:
		int y, x;
		double *p;
		double fx(){return *aXstart	+x*Xsample;}
		double fy(){return *aYend	-y*Ysample;}
		double fc(){return *p;}
		int sa[12], ra[16];
	public:
		void full_resize(double VX, double DX, double VY, double DY, int Xplaces, int Yplaces)
		{
			this->Xplaces=Xplaces, this->Yplaces=Yplaces, ndrSize=Xplaces*Yplaces;
			Xsample=DX/Xplaces, Xstart=VX-DX/2, Xstart_s=Xstart-Xsample;
			Ysample=DY/Yplaces, Yend=VY+DY/2, Yend_s=Yend+Ysample;
		}
		void full(Expression &ex)
		{
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_3D_Implicit::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_3D_Implicit::fx, LOL_1_const=0;break;
				case 'y':f=&Solve_3D_Implicit::fy, LOL_1_const=0;break;
				case 'c':f=&Solve_3D_Implicit::fc, p=&variables.val.r;break;
				case 't':f=&Solve_3D_Implicit::fc, p=&T;break;
				}
			};
			int aXplaces, aYplaces;
			if(ex.resultLogicType>=2)
				aXstart=&Xstart_s, aYend=&Yend_s, aXplaces=Xplaces+2, aYplaces=Yplaces+2;
			else
				aXstart=&Xstart, aYend=&Yend, aXplaces=Xplaces, aYplaces=Yplaces;
			int aNDRsize=aXplaces*aYplaces;
			for(auto &n:ex.n)
			{
				if(n.constant)
					n.ndr.assign(aNDRsize, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(variables.mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_3D_Implicit::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								ndr.assign(aNDRsize, (this->*r)());
							else
							{
								ndr.resize(aNDRsize);
								auto ndrIT=ndr.begin();
								for(y=0;y<aYplaces;++y)
									for(x=0;x<aXplaces;++x, ++ndrIT)
										*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_3D_Implicit::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								ndr.assign(aNDRsize, Value((this->*r)(), (this->*i)()));
							else
							{
								ndr.resize(aNDRsize);
								auto ndrIT=ndr.begin();
								for(y=0;y<aYplaces;++y)
									for(x=0;x<aXplaces;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_3D_Implicit::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								ndr.assign(aNDRsize, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								ndr.resize(aNDRsize);
								auto ndrIT=ndr.begin();
								for(y=0;y<aYplaces;++y)
									for(x=0;x<aXplaces;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			switch(ex.resultLogicType)
			{
			case 1://logic/inequality	just evaluate
				{
					unsigned ndrSize=ex.n[0].ndr.size();
					for(auto &i:ex.i)
					{
						auto &result=ex.n[i.result];
						switch(i.nArgs)
						{
						case 'c'://user function call
							concurrency::parallel_for(0u, ndrSize, Solve_UserFunction(ex, i));
							break;
						case 1:
							{
								auto &op1=ex.n[i.op1];
								concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), i.uf);
							}
							break;
						case 2:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2];
								concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), op2.ndr.begin(), result.ndr.begin(), i.bf);
							}
							break;
						case 3:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
								concurrency::parallel_for(0u, op1.ndr.size(), [&](int k){result.ndr[k]=i.tf(op1.ndr[k], op2.ndr[k], op3.ndr[k]);});
							}
							break;
						}
					}
				}
				break;

				//= !=		equation	ex.resultLogicType>=2		zero cross curve, anti-aliasing
			case 2:
				//zero cross	_/\_
			case 3:
				//				_  _
				//zero cross	 \/
				{
					int Xplaces1=Xplaces+1, Yplaces1=Yplaces+1,
						Xplaces2=Xplaces+2, Yplaces2=Yplaces+2;

					unsigned yDiscOffset=Yplaces2*Xplaces1;
					ex.discontinuities.assign(yDiscOffset+Yplaces1*Xplaces2, false);
					unsigned ndrSize=ex.n[0].ndr.size();
					for(auto iIT=ex.i.begin(), iITend=ex.i.end()-1;iIT!=iITend;++iIT)
					{
						auto &i=*iIT;
						auto &result=ex.n[i.result];
						switch(i.nArgs)
						{
						case 'c'://user function call
							concurrency::parallel_for(0u, ndrSize, Solve_UserFunction(ex, i));
							break;
						case 1:
							{
								auto &op1=ex.n[i.op1];
								if(i.d.disc_in)
								{
									for(int y=0;y<Yplaces2;++y)
									{
										for(int x=0;x<Xplaces1;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[Xplaces1*y+x];
											condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+1]);
										}
									}
									for(int y=0;y<Yplaces1;++y)
									{
										for(int x=0;x<Xplaces2;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[yDiscOffset+v];
											condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+Xplaces2]);
										}
									}
								}
								concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), i.uf);
							}
							break;
						case 2:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2];
								if(i.d.disc_in)
								{
									for(int y=0;y<Yplaces2;++y)
									{
										for(int x=0;x<Xplaces1;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[Xplaces1*y+x];
											condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+1], op2.ndr[v+1]);
										}
									}
									for(int y=0;y<Yplaces1;++y)
									{
										for(int x=0;x<Xplaces2;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[yDiscOffset+v];
											condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+Xplaces2], op2.ndr[v+Xplaces2]);
										}
									}
								}
								concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), op2.ndr.begin(), result.ndr.begin(), i.bf);
							}
							break;
						case 3:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
								if(i.d.disc_in)
								{
									for(int y=0;y<Yplaces2;++y)
									{
										for(int x=0;x<Xplaces1;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[Xplaces1*y+x];
											condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+1], op2.ndr[v+1], op3.ndr[v+1]);
										}
									}
									for(int y=0;y<Yplaces1;++y)
									{
										for(int x=0;x<Xplaces2;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[yDiscOffset+v];
											condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+Xplaces2], op2.ndr[v+Xplaces2], op3.ndr[v+Xplaces2]);
										}
									}
								}
								concurrency::parallel_for(0u, op1.ndr.size(), [&](int k){result.ndr[k]=i.tf(op1.ndr[k], op2.ndr[k], op3.ndr[k]);});
							}
							break;
						}
						if(i.d.disc_out)
						{
							for(int y=0;y<Yplaces2;++y)
							{
								for(int x=0;x<Xplaces1;++x)
								{
									unsigned v=Xplaces2*y+x;
									auto &condition=ex.discontinuities[Xplaces1*y+x];
									condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+1]);
								}
							}
							for(int y=0;y<Yplaces1;++y)
							{
								for(int x=0;x<Xplaces2;++x)
								{
									unsigned v=Xplaces2*y+x;
									auto &condition=ex.discontinuities[yDiscOffset+v];
									condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+Xplaces2]);
								}
							}
						}
					}
					{
						auto &i=*ex.i.rbegin();
						auto &result=ex.n[i.result], &op1=ex.n[i.op1];
						switch(i.nArgs)
						{
						case 1:
							concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), result.ndr.begin(), G2::q_minus);
							break;
						case 2:
							{
								auto &op2=ex.n[i.op2];
								concurrency::parallel_transform(op1.ndr.begin(), op1.ndr.end(), op2.ndr.begin(), result.ndr.begin(), G2::qq_minus);
							}
							break;
						}
					}
					switch(ex.resultMathSet)
				//	switch(ex.n[0].mathSet)
					{
					case 'r':
				//	case 'R':
						break;
					case 'c':
				//	case 'C':
						break;
					case 'H':
						break;
					}
				}
				break;
			}
		}
	private:
		void drawCheckboard_range(HPEN hPen, HBRUSH hBrush, double VX, double DX, double VY, double DY, double Xstep, double Ystep, int *rDims)
		{
			int x1=rDims[0], x2=rDims[1], y1=rDims[2], y2=rDims[3];

			HRGN hRgn=CreateRectRgn(x1, y1, x2, y2);
			SelectClipRgn(ghMemDC, hRgn);
			HPEN hWpen=(HPEN)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, 0xFFFFFF));
			HBRUSH hWbrush=(HBRUSH)SelectObject(ghMemDC, CreateSolidBrush(0xFFFFFF));
			Rectangle(ghMemDC, x1, y1, x2, y2);
			DeleteObject(SelectObject(ghMemDC, hWpen));
			DeleteObject(SelectObject(ghMemDC, hWbrush));

			hPen=(HPEN)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH)SelectObject(ghMemDC, hBrush);
			double Ystart=VY-DY/2, Yend=VY+DY/2, Ystepx2=Ystep*2, Xstart=VX-DX/2, Xend=VX+DX/2, Xstepx2=Xstep*2;
			for(double y=ceil((Yend-y1*DY/h)/Ystepx2)*Ystepx2, yEnd=floor((Yend-y2*DY/h)/Ystep)*Ystep;y>yEnd;y-=Ystepx2)
			{
				for(double x=floor((Xstart+x1*DX/w)/Xstepx2)*Xstepx2, xEnd=ceil((Xstart+x2*DX/w)/Xstep)*Xstep;x<xEnd;x+=Xstepx2)
				{
					Rectangle(ghMemDC, int((x+Xstep	-Xstart)/DX*w), int((Yend-y			)/DY*h), int((x+Xstepx2	-Xstart)/DX*w), int((Yend-y+Ystep	)/DY*h));
					Rectangle(ghMemDC, int((x		-Xstart)/DX*w), int((Yend-y+Ystep	)/DY*h), int((x+Xstep	-Xstart)/DX*w), int((Yend-y+Ystepx2	)/DY*h));
				}
			}
			hPen=(HPEN)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH)SelectObject(ghMemDC, hBrush);

			SelectClipRgn(ghMemDC, 0);
			DeleteObject(hRgn);
		}
	public:
		void shiftAndCheckboard(HPEN hPen, HBRUSH hBrush, double VX, double DX, double VY, double DY, double Xstep, double Ystep)
		{
			if(shift==&Solve_3D_Implicit::shift_)
			{
				int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
				auto _First=rgb+XSstart, _Last=rgb+XSend, _Dest=rgb+XDstart;
				for(int ky=Xplaces*YSstart, kyEnd=Xplaces*YSend, kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*YDstart;ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
					std::copy(_First+ky, _Last+ky, _Dest+ky2);
			}
			else if(shift==&Solve_3D_Implicit::shift_r)
			{
				int ndrSize=Xplaces*Yplaces;
				int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
				auto _First=std::reverse_iterator<int*>(rgb+ndrSize)+Xplaces-1-XSstart, _Last=std::reverse_iterator<int*>(rgb+ndrSize)+Xplaces-1-XSend, _Dest=std::reverse_iterator<int*>(rgb+ndrSize)+Xplaces-1-XDstart;
				for(int ky=Xplaces*(Yplaces-1-YSstart), kyEnd=Xplaces*(Yplaces-1-YSend), kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*(Yplaces-1-YDstart);ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
					std::copy(_First+ky,_Last+ky, _Dest+ky2);
			}
			drawCheckboard_range(hPen, hBrush, VX, DX, VY, DY, Xstep, Ystep, ra);
			if(partial==&Solve_3D_Implicit::partial_2)
				drawCheckboard_range(hPen, hBrush, VX, DX, VY, DY, Xstep, Ystep, ra+4);
		}
	private:
		void shift_		(std::vector<Value> &ndr, int *a, int aXplaces, int Yplaces)
		{
			int XSstart=a[0], XSend=a[1], XDstart=a[2], YSstart=a[3], YSend=a[4], YDstart=a[5];
			auto _First=ndr.begin()+XSstart, _Last=ndr.begin()+XSend, _Dest=ndr.begin()+XDstart;
			for(int ky=aXplaces*YSstart, kyEnd=aXplaces*YSend, kyStep=(ky<kyEnd?1:-1)*aXplaces, ky2=aXplaces*YDstart;ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
				std::copy(_First+ky, _Last+ky, _Dest+ky2);
		}
		void shift_r	(std::vector<Value> &ndr, int *a, int aXplaces, int aYplaces)
		{
			int XSstart=a[0], XSend=a[1], XDstart=a[2], YSstart=a[3], YSend=a[4], YDstart=a[5];
			int ndrSize=aXplaces*aYplaces;
			auto _First=ndr.rbegin()+aXplaces-1-XSstart, _Last=ndr.rbegin()+aXplaces-1-XSend, _Dest=ndr.rbegin()+aXplaces-1-XDstart;
			for(int ky=aXplaces*(aYplaces-1-YSstart), kyEnd=aXplaces*(aYplaces-1-YSend), kyStep=(ky<kyEnd?1:-1)*aXplaces, ky2=aXplaces*(aYplaces-1-YDstart);ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
				std::copy(_First+ky,_Last+ky, _Dest+ky2);
		}
		decltype(&Solve_3D_Implicit::shift_) shift;
		void solve_range	(Expression &ex, int *a)
		{
			int aXplaces, aYplaces;
			int x1, x2, y1, y2;
			if(ex.resultLogicType==1)
				aXstart=&Xstart,	aYend=&Yend,	aXplaces=Xplaces,	aYplaces=Yplaces,		x1=a[0], x2=a[1], y1=a[2], y2=a[3];
			else
				aXstart=&Xstart_s,	aYend=&Yend_s,	aXplaces=Xplaces+2,	aYplaces=Yplaces+2,		x1=a[8], x2=a[9], y1=a[10], y2=a[11];//x1=a[16], x2=a[17], y1=a[18], y2=a[19];//x1=a[8], x2=a[9], y1=a[10], y2=a[11];
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, decltype(&Solve_3D_Implicit::fx) &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_3D_Implicit::fx, LOL_1_const=0;break;
				case 'y':f=&Solve_3D_Implicit::fy, LOL_1_const=0;break;
				case 'c':f=&Solve_3D_Implicit::fc, p=&variables.val.r;break;
				case 't':f=&Solve_3D_Implicit::fc, p=&T;break;
				}
			};
			auto initialize_const=[&](std::vector<Value> &ndr, Value &value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int ky=aXplaces*y1, kyEnd=aXplaces*y2;ky<kyEnd;ky+=aXplaces)
					std::fill(_First+ky, _Last+ky, value);
			};
			auto initialize_const_r=[&](std::vector<Value> &ndr, double value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int ky=aXplaces*y1, kyEnd=aXplaces*y2;ky<kyEnd;ky+=aXplaces)
					std::fill(_First+ky, _Last+ky, value);
			};
			for(auto &n:ex.n)
			{
				if(n.constant)
					initialize_const(n.ndr, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_3D_Implicit::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								initialize_const_r(n.ndr, (this->*r)());
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=aXplaces*y1;y<y2;++y, ky+=aXplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_3D_Implicit::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=aXplaces*y1;y<y2;++y, ky+=aXplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_3D_Implicit::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								decltype(ndr.begin()) ndrIT;
								y=y1;
								for(int ky=aXplaces*y1;y<y2;++y, ky+=aXplaces)
									for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
										*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			switch(ex.resultLogicType)
			{
			case 1://logic/inequality	just evaluate
				{
					for(auto &i:ex.i)
					{
						auto &result=ex.n[i.result];
						switch(i.nArgs)
						{
						case 'c'://user function call
							{
								Solve_UserFunction uf(ex, i);
								for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
									concurrency::parallel_for(ky+x1, ky+x2, uf);
							}
							break;
						case 1:
							{
								auto &op1=ex.n[i.op1];
								auto _First=op1.ndr.begin()+x1, _Last=op1.ndr.begin()+x2;
								for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
									std::transform(_First+ky, _Last+ky, _First+ky, i.uf);
							}
							break;
						case 2:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2];
								auto _First1=op1.ndr.begin()+x1, _Last1=op1.ndr.begin()+x2, _First2=op2.ndr.begin()+x1, _Dest=result.ndr.begin()+x1;
								for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
									std::transform(_First1+ky, _Last1+ky, _First2+ky, _Dest+ky, i.bf);
							}
							break;
						case 3:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
								auto _First1=op1.ndr.begin()+x1, _Last1=op1.ndr.begin()+x2, _First2=op2.ndr.begin()+x1, _First3=op3.ndr.begin()+x1;
								for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
									for(auto it=_First1+ky, itEnd=_Last1+ky, it2=_First2+ky, it3=_First3+ky, &res=i.result==i.op1?it:i.result==i.op2?it2:it3;it!=itEnd;++it, ++it2, ++it3)
										*res=i.tf(*it, *it2, *it3);
							}
							break;
						}
					}
				}
				break;
				//= !=		equation	ex.resultLogicType>=2		zero cross curve, anti-aliasing
			case 2:
				//zero cross	_/\_
			case 3:
				//				_  _
				//zero cross	 \/
				{
					int Xplaces1=Xplaces+1, Yplaces1=Yplaces+1,
						Xplaces2=Xplaces+2, Yplaces2=Yplaces+2;

					unsigned yDiscOffset=Xplaces1*Yplaces2;
					for(int y=y1;y<y2;++y)
					//	for(auto it=ex.discontinuities.begin()+Xplaces1*y+x1, itEnd=ex.discontinuities.begin()+Xplaces1*y+x2-1;it!=itEnd;++it)
					//		*it=false;
						for(int x=x1;x<x2-1;++x)
							ex.discontinuities[Xplaces1*y+x]=false;
					for(int y=y1;y<y2-1;++y)
					//	for(auto it=ex.discontinuities.begin()+yDiscOffset+Xplaces2*y+x1, itEnd=ex.discontinuities.begin()+Xplaces2*y+x2;it!=itEnd;++it)
					//		*it=false;
						for(int x=x1;x<x2;++x)
							ex.discontinuities[yDiscOffset+Xplaces2*y+x]=false;
					for(auto iIT=ex.i.begin(), iITend=ex.i.end()-1;iIT!=iITend;++iIT)
					{
						auto &i=*iIT;
						auto &result=ex.n[i.result];
						switch(i.nArgs)
						{
						case 'c'://user function call
							{
								Solve_UserFunction uf(ex, i);
								for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
									concurrency::parallel_for(ky+x1, ky+x2, uf);
							}
							break;
						case 1:
							{
								auto &op1=ex.n[i.op1];
								if(i.d.disc_in)
								{
									for(int y=y1;y<y2;++y)
									{
										for(int x=x1;x<x2-1;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[Xplaces1*y+x];
											condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+1]);
										}
									}
									for(int y=y1;y<y2-1;++y)
									{
										for(int x=x1;x<x2;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[yDiscOffset+v];
											condition=condition||i.d.ud_i(op1.ndr[v], op1.ndr[v+Xplaces2]);
										}
									}
								}
								auto _First=op1.ndr.begin()+x1, _Last=op1.ndr.begin()+x2;
								for(int ky=Xplaces2*y1, kyEnd=Xplaces2*y2;ky<kyEnd;ky+=Xplaces2)
									std::transform(_First+ky, _Last+ky, _First+ky, i.uf);
							}
							break;
						case 2:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2];
								if(i.d.disc_in)
								{
									for(int y=y1;y<y2;++y)
									{
										for(int x=x1;x<x2-1;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[Xplaces1*y+x];
											condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+1], op2.ndr[v+1]);
										}
									}
									for(int y=y1;y<y2-1;++y)
									{
										for(int x=x1;x<x2;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[yDiscOffset+v];
											condition=condition||i.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+Xplaces2], op2.ndr[v+Xplaces2]);
										}
									}
								}
								auto _First1=op1.ndr.begin()+x1, _Last1=op1.ndr.begin()+x2, _First2=op2.ndr.begin()+x1, _Dest=result.ndr.begin()+x1;
								for(int ky=Xplaces2*y1, kyEnd=Xplaces2*y2;ky<kyEnd;ky+=Xplaces2)
									std::transform(_First1+ky, _Last1+ky, _First2+ky, _Dest+ky, i.bf);
							}
							break;
						case 3:
							{
								auto &op1=ex.n[i.op1], &op2=ex.n[i.op2], &op3=ex.n[i.op3];
								if(i.d.disc_in)
								{
									for(int y=y1;y<y2;++y)
									{
										for(int x=x1;x<x2-1;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[Xplaces1*y+x];
											condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+1], op2.ndr[v+1], op3.ndr[v+1]);
										}
									}
									for(int y=y1;y<y2-1;++y)
									{
										for(int x=x1;x<x2;++x)
										{
											unsigned v=Xplaces2*y+x;
											auto &condition=ex.discontinuities[yDiscOffset+v];
											condition=condition||i.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+Xplaces2], op2.ndr[v+Xplaces2], op3.ndr[v+Xplaces2]);
										}
									}
								}
								auto _First1=op1.ndr.begin()+x1, _Last1=op1.ndr.begin()+x2, _First2=op2.ndr.begin()+x1, _First3=op3.ndr.begin()+x1;
								for(int ky=Xplaces2*y1, kyEnd=Xplaces2*y2;ky<kyEnd;ky+=Xplaces2)
									for(auto it=_First1+ky, itEnd=_Last1+ky, it2=_First2+ky, it3=_First3+ky, &res=i.result==i.op1?it:i.result==i.op2?it2:it3;it!=itEnd;++it, ++it2, ++it3)
										*res=i.tf(*it, *it2, *it3);
							}
							break;
						}
						if(i.d.disc_out)
						{
							for(int y=y1;y<y2;++y)
							{
								for(int x=x1;x<x2-1;++x)
								{
									unsigned v=Xplaces2*y+x;
									auto &condition=ex.discontinuities[Xplaces1*y+x];
									condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+1]);
								}
							}
							for(int y=y1;y<y2-1;++y)
							{
								for(int x=x1;x<x2;++x)
								{
									unsigned v=Xplaces2*y+x;
									auto &condition=ex.discontinuities[yDiscOffset+v];
									condition=condition||i.d.d_o(result.ndr[v], result.ndr[v+Xplaces2]);
								}
							}
						}
					}
					{
						auto &i=*ex.i.rbegin();
						auto &result=ex.n[i.result], &op1=ex.n[i.op1];
						switch(i.nArgs)
						{
						case 1:
							{
								auto _First=op1.ndr.begin()+x1, _Last=op1.ndr.begin()+x2;
								for(int ky=Xplaces2*y1, kyEnd=Xplaces2*y2;ky<kyEnd;ky+=Xplaces2)
									std::transform(_First+ky, _Last+ky, _First+ky, G2::q_minus);
							}
							break;
						case 2:
							{
								auto &op2=ex.n[i.op2];
								auto _First1=op1.ndr.begin()+x1, _Last1=op1.ndr.begin()+x2, _First2=op2.ndr.begin()+x1, _Dest=result.ndr.begin()+x1;
								for(int ky=Xplaces2*y1, kyEnd=Xplaces2*y2;ky<kyEnd;ky+=Xplaces2)
									std::transform(_First1+ky, _Last1+ky, _First2+ky, _Dest+ky, G2::qq_minus);
							}
							break;
						}
					}
					switch(ex.resultMathSet)
				//	switch(ex.n[0].mathSet)
					{
					case 'r':
				//	case 'R':
						break;
					case 'c':
				//	case 'C':
						break;
					case 'H':
						break;
					}
					break;
				}
			}
		}
		void partial_		(Expression &ex){}
		void partial_1		(Expression &ex)
		{
			int saOffset, aXplaces, aYplaces;
			if(ex.resultLogicType==1)
				saOffset=0, aXplaces=Xplaces, aYplaces=Yplaces;
			else
				saOffset=6, aXplaces=Xplaces+2, aYplaces=Yplaces+2;
			(this->*shift)(ex.n[0].ndr, sa+saOffset, aXplaces, aYplaces);
			solve_range(ex, ra);
		}
		void partial_2		(Expression &ex)
		{
			int saOffset, aXplaces, aYplaces;
			if(ex.resultLogicType==1)
				saOffset=0, aXplaces=Xplaces, aYplaces=Yplaces;
			else
				saOffset=6, aXplaces=Xplaces+2, aYplaces=Yplaces+2;
			(this->*shift)(ex.n[0].ndr, sa+saOffset, aXplaces, aYplaces);
			solve_range(ex, ra), solve_range(ex, ra+4);
		}
	public:
		void partial_bounds(double VX, double DX, double VY, double DY, int Xoffset, int Yoffset)
		{
			Xsample=DX/Xplaces, Xstart=VX-DX/2, Xstart_s=Xstart-Xsample;
			Ysample=DY/Yplaces, Yend=VY+DY/2, Yend_s=Yend+Ysample;
			partial=&Solve_3D_Implicit::partial_;
			int Xoffset2=std::abs(Xoffset)+2, Yoffset2=std::abs(Yoffset)+2;
			int Xplaces2=Xplaces+2, Yplaces2=Yplaces+2;
				 if(Xoffset>0){							 if(Yoffset>0)					shift=&Solve_3D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,			sa[5]=Yplaces-1,			partial=&Solve_3D_Implicit::partial_2,	ra[0]=0,					ra[1]=Xplaces,		ra[ 2]=0,					ra[ 3]=Yoffset,							ra[ 4]=Xplaces-Xoffset,		ra[ 5]=Xplaces,		ra[ 6]=Yoffset,				ra[ 7]=Yplaces,
																															sa[6]=Xoffset,				sa[7]=Xplaces2,	sa[8]=0,			sa[9]=Yplaces2-1-Yoffset,	sa[10]=-1,			sa[11]=Yplaces2-1,													ra[8]=0,					ra[9]=Xplaces2,		ra[10]=0,					ra[11]=Yoffset2,						ra[12]=Xplaces2-Xoffset2,	ra[13]=Xplaces2,	ra[14]=Yoffset,				ra[15]=Yplaces2;

													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_3D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,		sa[5]=0,					partial=&Solve_3D_Implicit::partial_2,	ra[0]=Xplaces-Xoffset,		ra[1]=Xplaces,		ra[ 2]=0,					ra[ 3]=Yplaces-Yoffset,					ra[ 4]=0,					ra[ 5]=Xplaces,		ra[ 6]=Yplaces-Yoffset,		ra[ 7]=Yplaces,
																															sa[6]=Xoffset,				sa[7]=Xplaces2,	sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces2,	sa[11]=0,															ra[8]=Xplaces2-Xoffset2,	ra[9]=Xplaces2,		ra[10]=0,					ra[11]=Yplaces2-Yoffset,				ra[12]=0,					ra[13]=Xplaces2,	ra[14]=Yplaces2-Yoffset2,	ra[15]=Yplaces2;

													else								shift=&Solve_3D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,		sa[5]=0,					partial=&Solve_3D_Implicit::partial_1,	ra[0]=Xplaces-Xoffset,		ra[1]=Xplaces,		ra[ 2]=0,					ra[ 3]=Yplaces,
																															sa[6]=Xoffset,				sa[7]=Xplaces2,	sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces2,	sa[11]=0,															ra[8]=Xplaces2-Xoffset2,	ra[9]=Xplaces2,		ra[10]=0,					ra[11]=Yplaces2;}

			else if(Xoffset<0){Xoffset=-Xoffset;		 if(Yoffset>0)					shift=&Solve_3D_Implicit::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,			sa[5]=Yplaces-1,			partial=&Solve_3D_Implicit::partial_2,	ra[0]=0,					ra[1]=Xplaces,		ra[ 2]=0,					ra[ 3]=Yoffset,							ra[ 4]=0,					ra[ 5]=Xoffset,		ra[ 6]=Yoffset,				ra[ 7]=Yplaces,
																															sa[6]=Xplaces2-1-Xoffset,	sa[7]=-1,		sa[8]=Xplaces2-1,	sa[9]=Yplaces2-1-Yoffset,	sa[10]=-1,			sa[11]=Yplaces2-1,													ra[8]=0,					ra[9]=Xplaces2,		ra[10]=0,					ra[11]=Yoffset2,						ra[12]=0,					ra[13]=Xoffset2,	ra[14]=Yoffset,				ra[15]=Yplaces2;

													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_3D_Implicit::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,		sa[5]=0,					partial=&Solve_3D_Implicit::partial_2,	ra[0]=0,					ra[1]=Xoffset,		ra[ 2]=0,					ra[ 3]=Yplaces-Yoffset,					ra[ 4]=0,					ra[ 5]=Xplaces,		ra[ 6]=Yplaces-Yoffset,		ra[ 7]=Yplaces,
																															sa[6]=Xplaces2-1-Xoffset,	sa[7]=-1,		sa[8]=Xplaces2-1,	sa[9]=Yoffset,				sa[10]=Yplaces2,	sa[11]=0,															ra[8]=0,					ra[9]=Xoffset2,		ra[10]=0,					ra[11]=Yplaces2-Yoffset,				ra[12]=0,					ra[13]=Xplaces2,	ra[14]=Yplaces2-Yoffset2,	ra[15]=Yplaces2;

													else								shift=&Solve_3D_Implicit::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,		sa[5]=0,					partial=&Solve_3D_Implicit::partial_1,	ra[0]=0,					ra[1]=Xoffset,		ra[ 2]=0,					ra[ 3]=Yplaces,
																															sa[6]=Xplaces2-1-Xoffset,	sa[7]=-1,		sa[8]=Xplaces2-1,	sa[9]=Yoffset,				sa[10]=Yplaces2,	sa[11]=0,															ra[8]=0,					ra[9]=Xoffset2,		ra[10]=0,					ra[11]=Yplaces2;}

			else{										 if(Yoffset>0)					shift=&Solve_3D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,			sa[5]=Yplaces-1,			partial=&Solve_3D_Implicit::partial_1,	ra[0]=0,					ra[1]=Xplaces,		ra[ 2]=0,					ra[ 3]=Yoffset,
																															sa[6]=Xoffset,				sa[7]=Xplaces2,	sa[8]=0,			sa[9]=Yplaces2-1-Yoffset,	sa[10]=-1,			sa[11]=Yplaces2-1,													ra[8]=0,					ra[9]=Xplaces2,		ra[10]=0,					ra[11]=Yoffset2;

													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_3D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,		sa[5]=0,					partial=&Solve_3D_Implicit::partial_1,	ra[0]=0,					ra[1]=Xplaces,		ra[ 2]=Yplaces-Yoffset,		ra[ 3]=Yplaces,
																															sa[6]=Xoffset,				sa[7]=Xplaces2,	sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces2,	sa[11]=0,															ra[8]=0,					ra[9]=Xplaces2,		ra[10]=Yplaces2-Yoffset2,	ra[11]=Yplaces2;
													else;}
		}
		decltype(&Solve_3D_Implicit::partial_) partial;
	};
#endif
	class		Solve_3D:public Solve
	{
	public:
		int *ndr_rgb,
			*ndr_rgb_i, *ndr_rgb_j, *ndr_rgb_k;
		Solve_3D():ndr_rgb(0), ndr_rgb_i(0), ndr_rgb_j(0), ndr_rgb_k(0){}
		double Xstart, Xsample, Ystart, Ysample, Zstart, Zsample;
		int Xplaces, Yplaces, Zplaces, ndrSize;
	private:
		int x, y, z;
		double *p;
	//	double x(){return Xstart+(.5+x)*Xsample;}
	//	double y(){return Ystart+(.5+y)*Ysample;}
	//	double z(){return Zstart+(.5+z)*Zsample;}
		double fx(){return Xstart+x*Xsample;}
		double fy(){return Ystart+y*Ysample;}
		double fz(){return Zstart+z*Zsample;}
		double fc(){return *p;}
		int sa[9], ra[12];
	public:
		void full_resize(double VX, double DX, double VY, double DY, double VZ, double DZ, int Xplaces, int Yplaces, int Zplaces)
		{
			this->Xplaces=Xplaces, this->Yplaces=Yplaces, this->Zplaces=Zplaces, ndrSize=Xplaces*Yplaces*Zplaces, kzStep=Yplaces*Xplaces;
			Xstart=VX-DX/2, Xsample=DX/Xplaces, Ystart=VY-DY/2, Ysample=DY/Yplaces, Zstart=VZ-DZ/2, Zsample=DZ/Zplaces;
			ndr_rgb=(int*)realloc(ndr_rgb, ndrSize*sizeof(int));
			ndr_rgb_i=(int*)realloc(ndr_rgb_i, ndrSize*sizeof(int));
			ndr_rgb_j=(int*)realloc(ndr_rgb_j, ndrSize*sizeof(int));
			ndr_rgb_k=(int*)realloc(ndr_rgb_k, ndrSize*sizeof(int));
		}
		void full(Expression &ex)
		{
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, std::remove_reference<decltype(&Solve_3D::fx)>::type &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_3D::fx, LOL_1_const=0;break;
				case 'y':f=&Solve_3D::fy, LOL_1_const=0;break;
				case 'z':f=&Solve_3D::fz, LOL_1_const=0;break;
				case 'c':f=&Solve_3D::fc, p=&variables.val.r;break;
				case 't':f=&Solve_3D::fc, p=&T;break;
				}
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					n.ndr.assign(ndrSize, ex.data[kn]);
				//	n.ndr.assign(ndrSize, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_3D::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								ndr.assign(ndrSize, (this->*r)());
							else
							{
								ndr.resize(ndrSize);
								auto ndrIT=ndr.begin();
								for(z=0;z<Zplaces;++z)
									for(y=0;y<Yplaces;++y)
										for(x=0;x<Xplaces;++x, ++ndrIT)
											*ndrIT=(this->*r)();
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_3D::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								ndr.assign(ndrSize, Value((this->*r)(), (this->*i)()));
							else
							{
								ndr.resize(ndrSize);
								auto ndrIT=ndr.begin();
								for(z=0;z<Zplaces;++z)
									for(y=0;y<Yplaces;++y)
										for(x=0;x<Xplaces;++x, ++ndrIT)
											*ndrIT=Value((this->*r)(), (this->*i)());
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_3D::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								ndr.assign(ndrSize, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
							{
								ndr.resize(ndrSize);
								auto ndrIT=ndr.begin();
								for(z=0;z<Zplaces;++z)
									for(y=0;y<Yplaces;++y)
										for(x=0;x<Xplaces;++x, ++ndrIT)
											*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
							}
						}
						break;
					}
				}
			}
			::solve(ex);
		/*	switch(ex.resultMathSet)
		//	switch(ex.n[0].mathSet)
			{
			case 'R':
				for(auto &v:ex.n[0].ndr)
				{
					double mag=255/G2::_pi*atan(abs(v.r)), arg=v.r<0?G2::_pi:0;
					v.r=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
				}
				//	v.r=v.r>=0?unsigned char(255*atan(v.r)*2/G2::_pi):unsigned char(255*atan(-v.r)*2/G2::_pi)<<16;
				break;
			case 'C':
				for(auto &v:ex.n[0].ndr)
				{
					if(v.r==_HUGE)
					{
						if(v.i==_HUGE||v.i==-_HUGE)
							v.r=0x00FFFFFF;
						else
						{
							double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(0);
							v.r=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
						}
					}
					else if(v.r==-_HUGE)
					{
						if(v.i==_HUGE||v.i==-_HUGE)
							v.r=0x00FFFFFF;
						else
						{
							double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(G2::_pi);
							v.r=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
						}
					}
					else if(v.i==_HUGE)
					{
						double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(G2::_pi/2);
						v.r=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
					}
					else if(v.i==-_HUGE)
					{
						double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(-G2::_pi/2);
						v.r=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
					}
					else
					{
						double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=atan2(v.i, v.r);
						v.r=unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
					}
				}
				break;
			case 'H':
				for(auto &v:ex.n[0].ndr)
				{
					v.r=v.r>=0?unsigned char(255*atan(v.r)*2/G2::_pi):unsigned char(255*atan(-v.r)*2/G2::_pi)<<16;
					v.i=v.i>=0?unsigned char(255*atan(v.i)*2/G2::_pi):unsigned char(255*atan(-v.i)*2/G2::_pi)<<16;
					v.j=v.j>=0?unsigned char(255*atan(v.j)*2/G2::_pi):unsigned char(255*atan(-v.j)*2/G2::_pi)<<16;
					v.k=v.k>=0?unsigned char(255*atan(v.k)*2/G2::_pi):unsigned char(255*atan(-v.k)*2/G2::_pi)<<16;
				}
				break;
			}//*/
		}
		void updateRGB(Expression &ex)
	//	void updateRGB(Expression::Term &n)
		{
			auto &ndr=ex.n[0].ndr;
			switch(ex.resultMathSet)
		//	switch(n.mathSet)
			{
			case 'r':case 'c':
		//	case 'R':case 'C':
				std::transform(ndr.begin(), ndr.end(), ndr_rgb, [&](Value &x){return colorFunction(x);});
				break;
			case 'H':
				for(unsigned v=0, vEnd=Xplaces*Yplaces*Zplaces;v<vEnd;++v)
					colorFunction_q(ndr[v], ndr_rgb[v], ndr_rgb_i[v], ndr_rgb_j[v], ndr_rgb_k[v]);
				break;
			}
		}
	private:
		int kzStep;
		void shift_		(std::vector<Value> &ndr)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5], ZSstart=sa[6], ZSend=sa[7], ZDstart=sa[8];
			auto _First=ndr.begin()+XSstart, _Last=ndr.begin()+XSend, _Dest=ndr.begin()+XDstart;
			for(int kz=Xplaces*Yplaces*ZSstart, kzEnd=Xplaces*Yplaces*ZSend, kzStep=(kz<kzEnd?1:-1)*Xplaces*Yplaces, kz2=Xplaces*Yplaces*ZDstart;kz!=kzEnd;kz+=kzStep, kz2+=kzStep)
				for(int ky=kz+Xplaces*YSstart, kyEnd=kz+Xplaces*YSend, kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=kz2+Xplaces*YDstart;ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
					std::copy(_First+ky, _Last+ky, _Dest+ky2);
		}
		void shift_r	(std::vector<Value> &ndr)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5], ZSstart=sa[6], ZSend=sa[7], ZDstart=sa[8];
			auto _First=ndr.rbegin()+Xplaces-1-XSstart, _Last=ndr.rbegin()+Xplaces-1-XSend, _Dest=ndr.rbegin()+Xplaces-1-XDstart;
			for(int kz=Xplaces*Yplaces*(Zplaces-1-ZSstart), kzEnd=Xplaces*Yplaces*(Zplaces-1-ZSend), kzStep=(kz<kzEnd?1:-1)*Xplaces*Yplaces, kz2=Xplaces*Yplaces*(Zplaces-1-ZDstart);kz!=kzEnd;kz+=kzStep, kz2+=kzStep)
				for(int ky=kz+Xplaces*(Yplaces-1-YSstart), kyEnd=kz+Xplaces*(Yplaces-1-YSend), kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=kz2+Xplaces*(Yplaces-1-YDstart);ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
					std::copy(_First+ky, _Last+ky, _Dest+ky2);
		}
		decltype(&Solve_3D::shift_) shift;
		void solve_range	(Expression &ex, int *a)
		{
			int x1=a[0], x2=a[1], y1=a[2], y2=a[3], z1=a[4], z2=a[5];
			auto initialize_const=[&](std::vector<Value> &ndr, Value &value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int kz=Xplaces*Yplaces*z1, kzEnd=Xplaces*Yplaces*z2;kz<kzEnd;kz+=kzStep)
					for(int ky=kz+Xplaces*y1, kyEnd=kz+Xplaces*y2;ky<kyEnd;ky+=Xplaces)
						std::fill(_First+ky, _Last+ky, value);
			};
			auto initialize_const_r=[&](std::vector<Value> &ndr, double value)
			{
				auto _First=ndr.begin()+x1, _Last=ndr.begin()+x2;
				for(int kz=Xplaces*Yplaces*z1, kzEnd=Xplaces*Yplaces*z2;kz<kzEnd;kz+=kzStep)
					for(int ky=kz+Xplaces*y1, kyEnd=kz+Xplaces*y2;ky<kyEnd;ky+=Xplaces)
						std::fill(_First+ky, _Last+ky, value);
			};
		/*	auto initialize_var=[&](std::vector<Value> &ndr, Value f())
			{
				decltype(ndr.begin()) ndrIT;
				z=z1;
				for(int kz=z1*kzStep;z<z2;++z, kz+=kzStep)
				{
					y=y1;
					for(int ky=kz+Xplaces*y1;y<y2;++y, ky+=Xplaces)
						for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
							*ndrIT=f();
				}
			};
			auto initialize_var_r=[&](std::vector<Value> &ndr, double (Solve_3D::*f)())
			{
				decltype(ndr.begin()) ndrIT;
				z=z1;
				for(int kz=z1*kzStep;z<z2;++z, kz+=kzStep)
				{
					y=y1;
					for(int ky=kz+Xplaces*y1;y<y2;++y, ky+=Xplaces)
						for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
							*ndrIT=(this->*f)();
				}
			};*/
			int LOL_1_const;
			auto LOL_1=[&](Variable &variables, std::remove_reference<decltype(&Solve_3D::fx)>::type &f, int varType)
			{
				switch(varType)
				{
				case 'x':f=&Solve_3D::fx, LOL_1_const=0;break;
				case 'y':f=&Solve_3D::fy, LOL_1_const=0;break;
				case 'z':f=&Solve_3D::fz, LOL_1_const=0;break;
				case 'c':f=&Solve_3D::fc, p=&variables.val.r;break;
				case 't':f=&Solve_3D::fc, p=&T;break;
				}
			};
			for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		//	for(auto &n:ex.n)
			{
				auto &n=ex.n[kn];
				if(n.constant)
					initialize_const(n.ndr, ex.data[kn]);
				//	initialize_const(n.ndr, n.val);
				else
				{
					auto &variables=ex.variables[n.varNo];
					auto &ndr=n.ndr;
					LOL_1_const=1;
					switch(ex.variables[n.varNo].mathSet)
					{
					case 'r':
				//	case 'R':
						{
							decltype(&Solve_3D::fx) r;
							LOL_1(variables, r, variables.varTypeR);
							if(LOL_1_const)
								initialize_const_r(n.ndr, (this->*r)());
							else
						//		initialize_var_r(n.ndr, r);
							{
								decltype(ndr.begin()) ndrIT;
								z=z1;
								for(int kz=z1*kzStep;z<z2;++z, kz+=kzStep)
								{
									y=y1;
									for(int ky=kz+Xplaces*y1;y<y2;++y, ky+=Xplaces)
										for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
											*ndrIT=(this->*r)();
								}
							}
						}
						break;
					case 'c':
				//	case 'C':
						{
							decltype(&Solve_3D::fx) r, i;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)()));
							else
						//		initialize_var(n.ndr, [&]{return Value((this->*r)(), (this->*i)());});
							{
								decltype(ndr.begin()) ndrIT;
								z=z1;
								for(int kz=z1*kzStep;z<z2;++z, kz+=kzStep)
								{
									y=y1;
									for(int ky=kz+Xplaces*y1;y<y2;++y, ky+=Xplaces)
										for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
											*ndrIT=Value((this->*r)(), (this->*i)());
								}
							}
						}
						break;
					case 'H':
						{
							decltype(&Solve_3D::fx) r, i, j, k;
							LOL_1(variables, r, variables.varTypeR);
							LOL_1(variables, i, variables.varTypeI);
							LOL_1(variables, j, variables.varTypeJ);
							LOL_1(variables, k, variables.varTypeK);
							if(LOL_1_const)
								initialize_const(n.ndr, Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)()));
							else
						//		initialize_var(n.ndr, [&]{return Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());});
							{
								decltype(ndr.begin()) ndrIT;
								z=z1;
								for(int kz=z1*kzStep;z<z2;++z, kz+=kzStep)
								{
									y=y1;
									for(int ky=kz+Xplaces*y1;y<y2;++y, ky+=Xplaces)
										for(ndrIT=ndr.begin()+ky+x1, x=x1;x<x2;++x, ++ndrIT)
											*ndrIT=Value((this->*r)(), (this->*i)(), (this->*j)(), (this->*k)());
								}
							}
						}
						break;
					}
				}
			}
			for(auto &i:ex.i)
			{
				switch(i.type)
			//	switch(i.nArgs)
				{
				case 'c'://user function call
					{
						Solve_UserFunction uf(ex, i);
						for(int kz=Xplaces*Yplaces*z1, kzEnd=Xplaces*Yplaces*z2;kz<kzEnd;kz+=kzStep)
							for(int ky=kz+Xplaces*y1, kyEnd=kz+Xplaces*y2;ky<kyEnd;ky+=Xplaces)
								concurrency::parallel_for(ky+x1, ky+x2, uf);
					}
					break;
				case 1:
					{
						auto function=i.uf;
						auto o1=&ex.n[i.op1].ndr;
						auto _First=o1->begin()+x1, _Last=o1->begin()+x2;
						for(int kz=Xplaces*Yplaces*z1, kzEnd=Xplaces*Yplaces*z2;kz<kzEnd;kz+=kzStep)
							for(int ky=kz+Xplaces*y1, kyEnd=kz+Xplaces*y2;ky<kyEnd;ky+=Xplaces)
								std::transform(_First+ky, _Last+ky, _First+ky, function);
					}
					break;
				case 2:
					{
						auto function=i.bf;
						auto o1=&ex.n[i.op1].ndr;
						auto _First1=o1->begin()+x1, _Last1=o1->begin()+x2, _First2=ex.n[i.op2].ndr.begin()+x1, _Dest=ex.n[i.result].ndr.begin()+x1;
						for(int kz=Xplaces*Yplaces*z1, kzEnd=Xplaces*Yplaces*z2;kz<kzEnd;kz+=kzStep)
							for(int ky=kz+Xplaces*y1, kyEnd=kz+Xplaces*y2;ky<kyEnd;ky+=Xplaces)
								std::transform(_First1+ky, _Last1+ky, _First2+ky, _Dest+ky, function);
					}
					break;
				case 3:
					{
						auto function=i.tf;
						auto o1=&ex.n[i.op1].ndr;
						auto _First1=o1->begin()+x1, _Last1=o1->begin()+x2, _First2=ex.n[i.op2].ndr.begin()+x1, _First3=ex.n[i.op3].ndr.begin()+x1;
						for(int kz=Xplaces*Yplaces*z1, kzEnd=Xplaces*Yplaces*z2;kz<kzEnd;kz+=kzStep)
							for(int ky=kz+Xplaces*y1, kyEnd=kz+Xplaces*y2;ky<kyEnd;ky+=Xplaces)
								for(auto it=_First1+ky, itEnd=_Last1+ky, it2=_First2+ky, it3=_First3+ky, &res=i.result==i.op1?it:i.result==i.op2?it2:it3;it!=itEnd;++it, ++it2, ++it3)
									*res=function(*it, *it2, *it3);
					}
					break;
				}
			}
		/*	auto _First=ex.n[0].ndr.begin()+x1, _Last=ex.n[0].ndr.begin()+x2;
			switch(ex.resultMathSet)
		//	switch(ex.n[0].mathSet)
			{
			case 'R':
				for(int kz=Xplaces*Yplaces*z1, kzEnd=Xplaces*Yplaces*z2;kz<kzEnd;kz+=kzStep)
					for(int ky=kz+Xplaces*y1, kyEnd=kz+Xplaces*y2;ky<kyEnd;ky+=Xplaces)
						std::transform(_First+ky, _Last+ky, _First+ky, [&](Value &v)->Value
							{
								double mag=255/G2::_pi*atan(abs(v.r)), arg=v.r<0?G2::_pi:0;
								return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
							});
				break;
			case 'C':
				for(int kz=Xplaces*Yplaces*z1, kzEnd=Xplaces*Yplaces*z2;kz<kzEnd;kz+=kzStep)
					for(int ky=kz+Xplaces*y1, kyEnd=kz+Xplaces*y2;ky<kyEnd;ky+=Xplaces)
						std::transform(_First+ky, _Last+ky, _First+ky, [&](Value &v)->Value
							{
								if(v.r==_HUGE)
								{
									if(v.i==_HUGE||v.i==-_HUGE)
										return 0x00FFFFFF;
									else
									{
										double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(0);
										return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
									}
								}
								else if(v.r==-_HUGE)
								{
									if(v.i==_HUGE||v.i==-_HUGE)
										return 0x00FFFFFF;
									else
									{
										double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(G2::_pi);
										return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
									}
								}
								else if(v.i==_HUGE)
								{
									double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(G2::_pi/2);
									return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
								}
								else if(v.i==-_HUGE)
								{
									double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=(-G2::_pi/2);
									return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
								}
								double mag=255/G2::_pi*atan(sqrt(v.r*v.r+v.i*v.i)), arg=atan2(v.i, v.r);
								return unsigned char(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
							});
				break;
			case 'H':
				for(int kz=Xplaces*Yplaces*z1, kzEnd=Xplaces*Yplaces*z2;kz<kzEnd;kz+=kzStep)
					for(int ky=kz+Xplaces*y1, kyEnd=kz+Xplaces*y2;ky<kyEnd;ky+=Xplaces)
						std::transform(_First+ky, _Last+ky, _First+ky, [&](Value &v)->Value
							{
								return Value(	v.r>=0?unsigned char(255*atan(v.r)*2/G2::_pi):unsigned char(255*atan(-v.r)*2/G2::_pi)<<16,
												v.i>=0?unsigned char(255*atan(v.i)*2/G2::_pi):unsigned char(255*atan(-v.i)*2/G2::_pi)<<16,
												v.j>=0?unsigned char(255*atan(v.j)*2/G2::_pi):unsigned char(255*atan(-v.j)*2/G2::_pi)<<16,
												v.k>=0?unsigned char(255*atan(v.k)*2/G2::_pi):unsigned char(255*atan(-v.k)*2/G2::_pi)<<16);
							});
				break;
			}//*/
		}
	public:
		void partial_bounds	(double VX, double DX, double VY, double DY, double VZ, double DZ, int Xoffset, int Yoffset, int Zoffset)
		{
			partial=&Solve_3D::partial_;
			Xstart=VX-DX/2, Xsample=DX/Xplaces, Ystart=VY-DY/2, Xsample=DY/Yplaces, Zstart=VZ-DZ/2, Xsample=DZ/Zplaces;
				 if(Xoffset>0){							 if(Yoffset>0){							 if(Zoffset>0);
																							else if(Zoffset<0);
																							else								shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=Yplaces-Yoffset,	ra[3]=Yplaces, ra[4]=0,					ra[5]=Zplaces,				ra[6]=Xplaces-Xoffset,	ra[7]=Xplaces, ra[8]=0,					ra[9]=Yplaces-Yoffset,	ra[10]=0,				ra[11]=Zplaces;			}
													else if(Yoffset<0){Yoffset=-Yoffset;		 if(Zoffset>0);
																							else if(Zoffset<0);
																							else								shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,	sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset, ra[4]=0,					ra[5]=Zplaces,				ra[6]=Xplaces-Xoffset,	ra[7]=Xplaces, ra[8]=Yoffset,			ra[9]=Yplaces,			ra[10]=0,				ra[11]=Zplaces;			}
													else{										 if(Zoffset>0)					shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=Zplaces-Zoffset,	ra[5]=Zplaces,				ra[6]=Xplaces-Xoffset,	ra[7]=Xplaces, ra[8]=0,					ra[9]=Yplaces,			ra[10]=0,				ra[11]=Zplaces-Zoffset;
																							else if(Zoffset<0)Zoffset=-Zoffset,	shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zplaces-1-Zoffset,	sa[7]=-1,		sa[8]=Zplaces-1,			partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=0,					ra[5]=Zoffset,				ra[6]=Xplaces-Xoffset,	ra[7]=Xplaces, ra[8]=0,					ra[9]=Yplaces,			ra[10]=Zoffset,			ra[11]=Zplaces;
																							else								shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_1,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=0,					ra[5]=Zplaces;																																						}}
			else if(Xoffset<0){Xoffset=-Xoffset;		 if(Yoffset>0){							 if(Zoffset>0);
																							else if(Zoffset<0);
																							else								shift=&Solve_3D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=Yplaces-Yoffset,	ra[3]=Yplaces, ra[4]=0,					ra[5]=Zplaces,				ra[6]=0,				ra[7]=Xoffset, ra[8]=0,					ra[9]=Yplaces-Yoffset,	ra[10]=0,				ra[11]=Zplaces;			}
													else if(Yoffset<0){Yoffset=-Yoffset;		 if(Zoffset>0);
																							else if(Zoffset<0);
																							else								shift=&Solve_3D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,	sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset, ra[4]=0,					ra[5]=Zplaces,				ra[6]=0,				ra[7]=Xoffset, ra[8]=Yoffset,			ra[9]=Yplaces,			ra[10]=0,				ra[11]=Zplaces;			}
													else{										 if(Zoffset>0)					shift=&Solve_3D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=Zplaces-Zoffset,	ra[5]=Zplaces,				ra[6]=0,				ra[7]=Xoffset, ra[8]=0,					ra[9]=Yplaces,			ra[10]=0,				ra[11]=Zplaces-Zoffset;
																							else if(Zoffset<0)Zoffset=-Zoffset,	shift=&Solve_3D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zplaces-Zoffset-1,	sa[7]=-1,		sa[8]=Zplaces-1,			partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=0,					ra[5]=Zoffset,				ra[6]=0,				ra[7]=Xoffset, ra[8]=0,					ra[9]=Yplaces,			ra[10]=Zoffset,			ra[11]=Zplaces;
																							else								shift=&Solve_3D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_1,	ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=Yplaces, ra[4]=0,					ra[5]=Zplaces;																																						}}
			else{										if(Yoffset>0){							 if(Zoffset>0)					shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=Zplaces-Zoffset,	ra[5]=Zplaces,				ra[6]=0,				ra[7]=Xplaces, ra[8]=Yplaces-Yoffset,	ra[9]=Yplaces,			ra[10]=0,				ra[11]=Zplaces-Zoffset;
																							else if(Zoffset<0)Zoffset=-Zoffset,	shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zplaces-Zoffset-1,	sa[7]=-1,		sa[8]=Zplaces-1,			partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=0,					ra[5]=Zoffset,				ra[6]=0,				ra[7]=Xplaces, ra[8]=Yplaces-Yoffset,	ra[9]=Yplaces,			ra[10]=Zoffset,			ra[11]=Zplaces;
																							else								shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=Yplaces-Yoffset,	ra[3]=Yplaces, ra[4]=0,					ra[5]=Zplaces;																																						}
													else if(Yoffset<0){Yoffset=-Yoffset;		 if(Zoffset>0)					shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,	sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=Zplaces-Zoffset,	ra[5]=Zplaces,				ra[6]=0,				ra[7]=Xplaces, ra[8]=0,					ra[9]=Yplaces,			ra[10]=Zplaces-Zoffset,	ra[11]=Zplaces;
																							else if(Zoffset<0)Zoffset=-Zoffset,	shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,	sa[6]=Zplaces-Zoffset-1,	sa[7]=-1,		sa[8]=Zplaces-1,			partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=0,					ra[5]=Zoffset,				ra[6]=0,				ra[7]=Xplaces, ra[8]=0,					ra[9]=Yoffset,			ra[10]=Zplaces-Zoffset,	ra[11]=Zplaces;
																							else								shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,	sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset, ra[4]=0,					ra[5]=Zplaces;																																						}
													else{										 if(Zoffset>0)					shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=Zplaces-Zoffset,	ra[5]=Zplaces;
																							else if(Zoffset<0)Zoffset=-Zoffset,	shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zplaces-Zoffset-1,	sa[7]=-1,		sa[8]=Zplaces-1,			partial=&Solve_3D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=0,					ra[5]=Zoffset;
																							else;}}
		}
	private:
		void partial_		(Expression &ex){}
		void partial_1		(Expression &ex)
		{
			(this->*shift)(ex.n[0].ndr);
			solve_range(ex, ra);
		}
		void partial_2		(Expression &ex)
		{
			(this->*shift)(ex.n[0].ndr);
			solve_range(ex, ra), solve_range(ex, ra+6);
		}
	public:
		decltype(&Solve_3D::partial_) partial;
	};
	
	void derive_step(double DV, int v, double &Vstep, int &prec)
	{
		const double ln_10=log(10);
		double t=100*DV/v, t2=floor(log10(t));
		Vstep=exp(t2*ln_10), prec=t2<0?int(-t2):0;
		switch(int(t/Vstep))
		{
		case 1:Vstep*=1;break;
		case 2:Vstep*=2;break;
		case 3:Vstep*=2;break;
		case 4:Vstep*=2;break;
		case 5:Vstep*=5;break;
		case 6:Vstep*=5;break;
		case 7:Vstep*=5;break;
		case 8:Vstep*=5;break;
		case 9:Vstep*=5;break;
		default:Vstep*=6;break;
	//	default:Vstep*=1;break;
		}
	}
	void derive_step_noprec(double DV, int v, double &Vstep)
	{
		const double ln_10=log(10);
		double t=100*DV/v;
		Vstep=exp(floor(log10(t))*ln_10);
		switch(int(t/Vstep))
		{
		case 1:Vstep*=1;break;
		case 2:Vstep*=2;break;
		case 3:Vstep*=2;break;
		case 4:Vstep*=2;break;
		case 5:Vstep*=5;break;
		case 6:Vstep*=5;break;
		case 7:Vstep*=5;break;
		case 8:Vstep*=5;break;
		case 9:Vstep*=5;break;
		default:Vstep*=6;break;
	//	default:Vstep*=1;break;
		}
	}
	void derive_step_2D(double const &DX, double const &AR_Y, int w, double &Xstep, double &Ystep, int &Xprec, int &Yprec)
	{
		derive_step(DX, w, Xstep, Xprec);
		if(AR_Y==1)
			Ystep=Xstep;
		else
			derive_step(DX/AR_Y, w, Ystep, Yprec);
	}
	void derive_step_3D(double const &DX, double const &AR_Y, double const &AR_Z, int w, double &Xstep, double &Ystep, double &Zstep)
	{
		int prec=0;
		derive_step_noprec(DX, w, Xstep);
		if(AR_Y==1)
			Ystep=Xstep;
		else
			derive_step_noprec(DX/AR_Y, w, Ystep);
		if(AR_Z==1)
			Zstep=Xstep;
		else
			derive_step_noprec(DX/AR_Z, w, Zstep);
	}
	void _3dMode_DrawGridNAxes(_3D &_3d, double &VX, double &VY, double &VZ, double &DX, double Xstep, double Ystep, double Zstep, double AR_Y, double AR_Z)
	{
		_3d.lineColor=_3dGridColor;
		double
			Xstart=VX-DX/2, Xend=VX+DX/2,
			Ystart=VY-DX/2, Yend=VY+DX/2,
			Zstart=VZ-DX/2, Zend=VZ+DX/2,
			Yst_r=AR_Y*Ystep, Zst_r=AR_Z*Zstep;
		for(double x=(floor(Xstart/Xstep)+1)*Xstep, xEnd=floor(Xend/Xstep)*Xstep;x<xEnd;x+=Xstep)//floor+1: xo grid, ceil: L grid at reset
			_3d.line(x, Ystart, VZ, x, Yend, VZ), _3d.line(x, VY, Zstart, x, VY, Zend);
		for(double y=(floor(Ystart/Yst_r)+1)*Yst_r, yEnd=floor(Yend/Yst_r)*Yst_r;y<yEnd;y+=Yst_r)
			_3d.line(Xstart, y, VZ, Xend, y, VZ), _3d.line(VX, y, Zstart, VX, y, Zend);
		for(double z=(floor(Zstart/Zst_r)+1)*Zst_r, zEnd=floor(Zend/Zst_r)*Zst_r;z<zEnd;z+=Zst_r)
			_3d.line(Xstart, VY, z, Xend, VY, z), _3d.line(VX, Ystart, z, VX, Yend, z);//*/
	/*	double
			Xstart=VX-DX/2, Xend=VX+DX/2,
			Ystart=VY-DX/2, Yend=VY+DX/2,
			Zstart=VZ-DX/2, Zend=VZ+DX/2,
			Yst_r=AR_Y*Ystep, Zst_r=AR_Z*Zstep;
		for(double x=(floor(Xstart/Xstep)+1)*Xstep, xEnd=ceil(Xend/Xstep)*Xstep;x<xEnd;x+=Xstep)//original: grid goes out of cube when scaling y, z
			_3d.line(x, Ystart, VZ, x, Yend, VZ), _3d.line(x, VY, Zstart, x, VY, Zend);
		for(double y=(floor(Ystart/Yst_r)+1)*Yst_r, yEnd=ceil(Yend/Yst_r)*Yst_r;y<yEnd;y+=Yst_r)
			_3d.line(Xstart, y, VZ, Xend, y, VZ), _3d.line(VX, y, Zstart, VX, y, Zend);
		for(double z=(floor(Zstart/Zst_r)+1)*Zst_r, zEnd=ceil(Zend/Zst_r)*Zst_r;z<zEnd;z+=Zst_r)
			_3d.line(Xstart, VY, z, Xend, VY, z), _3d.line(VX, Ystart, z, VX, Yend, z);//*/
	/*	for(double x=floor((VX-DX/2)/Xstep)*Xstep+Xstep;x<ceil((VX+DX/2)/Xstep)*Xstep;x+=Xstep)
			_3d.line(x, VY-DX/2, VZ, x, VY+DX/2, VZ), _3d.line(x, VY, VZ-DX/2, x, VY, VZ+DX/2);
		for(double y=floor((VY-DX/2)/Ystep)*Ystep+Ystep;y<ceil((VY+DX/2)/Ystep)*Ystep;y+=Ystep)
			_3d.line(VX-DX/2, y, VZ, VX+DX/2, y, VZ), _3d.line(VX, y, VZ-DX/2, VX, y, VZ+DX/2);
		for(double z=floor((VZ-DX/2)/Zstep)*Zstep+Zstep;z<ceil((VZ+DX/2)/Zstep)*Zstep;z+=Zstep)
			_3d.line(VX-DX/2, VY, z, VX+DX/2, VY, z), _3d.line(VX, VY-DX/2, z, VX, VY+DX/2, z);//*/
		_3d.lineColor=0;
		_3d.line(0, 0, 0, 10,	0,			0);
		_3d.line(0, 0, 0, 0,	AR_Y*10,	0);
		_3d.line(0, 0, 0, 0,	0,			AR_Z*10);
	}
	void _3dMode_FrameStart(_3D &_3d, double &VX, double &VY, double &VZ, double &DX, double Xstep, double Ystep, double Zstep, double AR_Y, double AR_Z)
	{_3d.newFrame(), _3dMode_DrawGridNAxes(_3d, VX, VY, VZ, DX, Xstep, Ystep, Zstep, AR_Y, AR_Z);}
	void _2dMode_DrawCheckboard(HPEN__ *hPen, HBRUSH__ *hBrush, double const &VX, double const &VY, double const &DX, double const &DY, double const &Xstep, double const &Ystep)
	{
		hPen=(HPEN__*)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH__*)SelectObject(ghMemDC, hBrush);
		{
			double Ystart=VY-DY/2, Yend=VY+DY/2, Ystepx2=Ystep*2, Xstart=VX-DX/2, Xend=VX+DX/2, Xstepx2=Xstep*2;
			for(double y=ceil(Yend/Ystepx2)*Ystepx2, yEnd=floor(Ystart/Ystep)*Ystep-Ystepx2;y>yEnd;y-=Ystepx2)
			{
				for(double x=floor(Xstart/Xstepx2)*Xstepx2, xEnd=ceil (Xend/Xstep)*Xstep;x<xEnd;x+=Xstepx2)
				{
					double
						ax1=(x		-Xstart)/DX*w, ay1=(Yend-y		)/DY*h, ax2=(x+Xstep	-Xstart)/DX*w, ay2=(Yend-y-Ystep	)/DY*h,
						bx1=(x+Xstep-Xstart)/DX*w, by1=(Yend-y-Ystep)/DY*h, bx2=(x+Xstepx2	-Xstart)/DX*w, by2=(Yend-y-Ystepx2	)/DY*h;
					Rectangle(ghMemDC, int(ax1)-(ax1<0), int(ay1)-(ay1<0)+1, int(ax2)-(ax2<0), int(ay2)-(ay2<0)+1);
					Rectangle(ghMemDC, int(bx1)-(bx1<0), int(by1)-(by1<0)+1, int(bx2)-(bx2<0), int(by2)-(by2<0)+1);
				//	Rectangle(ghMemDC, int((x		-Xstart)/DX*w)+1, int((Yend-y		)/DY*h)+1, int((x+Xstep		-Xstart)/DX*w)+1, int((Yend-y-Ystep		)/DY*h)+1);
				//	Rectangle(ghMemDC, int((x+Xstep	-Xstart)/DX*w)+1, int((Yend-y-Ystep	)/DY*h)+1, int((x+Xstepx2	-Xstart)/DX*w)+1, int((Yend-y-Ystepx2	)/DY*h)+1);
				//	Rectangle(ghMemDC, int((x		-Xstart)/DX*w), int((Yend-y			)/DY*h), int((x+Xstep	-Xstart)/DX*w), int((Yend-y-Ystep	)/DY*h));
				//	Rectangle(ghMemDC, int((x+Xstep	-Xstart)/DX*w), int((Yend-y-Ystep	)/DY*h), int((x+Xstepx2	-Xstart)/DX*w), int((Yend-y-Ystepx2	)/DY*h));
				}
			}
		}
	/*	for(double y=ceil ((VY+DY/2)/(2*Ystep))*(2*Ystep);y>floor((VY-DY/2)/Ystep)*Ystep-2*Ystep;y-=2*Ystep)
		{
			for(double x=floor((VX-DX/2)/(2*Xstep))*(2*Xstep);x<ceil ((VX+DX/2)/Xstep)*Xstep;x+=2*Xstep)
			{
				Rectangle(ghMemDC, int(w*(x			-(VX-DX/2))/DX), int(h*((VY+DY/2)-y			)/DY), int(w*(x+	Xstep-(VX-DX/2))/DX), int(h*((VY+DY/2)-y-	Ystep)/DY));
				Rectangle(ghMemDC, int(w*(x+Xstep	-(VX-DX/2))/DX), int(h*((VY+DY/2)-y-Ystep	)/DY), int(w*(x+2*	Xstep-(VX-DX/2))/DX), int(h*((VY+DY/2)-y-2*	Ystep)/DY));
			}
		}//*/
		hPen=(HPEN__*)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH__*)SelectObject(ghMemDC, hBrush);
	}
	void _2dMode_NumberAxes(double const &VX, double const &VY, double const &DX, double const &DY, double const &Xstep, double const &Ystep, int prec, int &H, int &V, int &VT)
	{
		H=int(VY-DY/2>0?h:VY+DY/2<0?-1:h*(VY/DY+.5)); int HT=H+(H>h-30?-18:2); V=int(VX-DX/2>0?-1:VX+DX/2<0?w:w*(-VX+DX/2)/DX), VT=V+int(V>w-24-prec*8?-24-prec*8:2);
		SetBkMode(ghMemDC, TRANSPARENT);
		for(double x=floor((VX-DX/2)/Xstep)*Xstep, xEnd=ceil((VX+DX/2)/Xstep)*Xstep, Xstep_2=Xstep/2;x<xEnd;x+=Xstep)
		{
			if(x>-Xstep_2&&x<Xstep_2)
				continue;
			int linelen=sprintf_s(g_buf, 128, "%g", x);
		//	linelen=sprintf_s(line, 128, "%g", x);
			double X=w*(x-(VX-DX/2))/DX;
			TextOutA(ghMemDC, int(X)-(X<0)+2, HT, g_buf, linelen);
		//	TextOutA(ghMemDC, int(X)-(X<0)+2, HT, line, linelen);
		}
		for(double y=ceil((VY+DY/2)/Ystep)*Ystep, yEnd=floor((VY-DY/2)/Ystep)*Ystep, Ystep_2=Ystep/2;y>yEnd;y-=Ystep)
		{
			if(y>-Ystep_2&&y<Ystep_2)
				continue;
			int linelen=sprintf_s(g_buf, 128, "%g", y);
		//	linelen=sprintf_s(line, 128, "%g", y);
			double Y=h*((VY+DY/2)-y)/DY;
			TextOutA(ghMemDC, VT, int(Y)-(Y<0)+2, g_buf, linelen);
		//	TextOutA(ghMemDC, VT, int(Y)-(Y<0)+2, line, linelen);
		}
	}

	class		Mode
	{
	public:
		static const int arrow_label_offset_X=50, const_label_offset_X=150;
		bool ready;
		bool toSolve;
		int bpx, bpy, bw, bh;
		bool time_variance, paused;
		Mode():ready(false), toSolve(false), bpx(0), bpy(0), bw(0), bh(0), time_variance(false), paused(false){}

		virtual void enter()=0;//mode becomes active or inactive
		virtual void exit()=0;
		virtual void pause()=0;//mode goes away
		virtual void resume()=0;
		virtual void appDeactivate()=0;//application deactivated
		virtual void appActivate()=0;

		virtual void setDimentions(int x, int y, int w, int h)=0;
		virtual void messagePaint(int x, int y, int w, int h)=0;
		virtual void messageTimer()=0;
		virtual int inputLButtonDown(int lParam)=0;
		virtual int inputMouseMove(int lParam)=0;
		virtual void inputLButtonUp(int lParam)=0;
		virtual int inputMouseWheel(int wParam)=0;
		virtual int inputKeyDown(int wParam, int lParam)=0;
		virtual int inputKeyUp(int wParam)=0;
		virtual void a_draw()=0;
		virtual void i_draw()=0;
	} *mode, *old_mode=nullptr;
#if 1
	class		_2D_Mode:public Mode//ti2d
	{
	public:
	//	int toSolve;
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		int bpx, bpy, bw, bh;
		
		double VX, VY, DX, AR_Y, Xstep, Ystep;
		int prec;
		Solve &solver;

		bool timer, drag;
		int kp;
		_2D_Mode(Solve &solver):solver(solver), timer(false), drag(false), kp(0){}
		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
				drag=1;
			}
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
		//	kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]+kb[VK_ADD]+kb[VK_OEM_PLUS]+kb[VK_SUBTRACT]+kb[VK_OEM_MINUS];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag)
			{
				drag=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		
		void setDimentions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h;
			function1();
			toSolve=true, shiftOnly=0;
			ready=true;

		/*	//l2d
#if 0
			bpx=x, bpy=y, bw=w, bh=h;

			Xplaces=bw, Yplaces=bh;
			function1();
		//	DY=DX*h/w;
			toSolve=true, shiftOnly=0;
			ready=true;
#endif//*/
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimentions(x, y, w, h);
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
		}
		//timer
#if 0
		void messageTimer()
		{
			//t1d
			//t1d_h
#if 0
			if(_2d_drag_graph_not_window)
			{
				if(kb[VK_LEFT		]){	VX+=10*DX/w, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_RIGHT		]){	VX-=10*DX/w, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_UP			])	VY-=10*DX/(w*AR_Y);
				if(kb[VK_DOWN		])	VY+=10*DX/(w*AR_Y);
			}
			else
			{
				if(kb[VK_LEFT		]){	VX-=10*DX/w, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_RIGHT		]){	VX+=10*DX/w, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_UP			])	VY+=10*DX/(w*AR_Y);
				if(kb[VK_DOWN		])	VY-=10*DX/(w*AR_Y);
			}
			if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])
			{
				if(kb['X'])
					DX/=1.05, AR_Y/=1.05;
				else if(kb['Y'])
					AR_Y*=1.05;
				else
					DX/=1.05;
				function1(), toSolve=true, shiftOnly=0;
			}
			if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])
			{
				if(kb['X'])
					DX*=1.05, AR_Y*=1.05;
				else if(kb['Y'])
					AR_Y/=1.05;
				else
					DX*=1.05;
				function1(), toSolve=true, shiftOnly=0;
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
#endif
			//ti2d
#if 0
			if(_2d_drag_graph_not_window)
			{
				if(kb[VK_LEFT		]){	VX+=DX/w*10, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_RIGHT		]){	VX-=DX/w*10, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_UP			]){	itb.tpy+=10;	if(itb.tpy>itb.th-h	)itb.tpy=itb.th-h;}//VY-=DX/w*10;
				if(kb[VK_DOWN		]){	itb.tpy-=10;	if(itb.tpy<0		)itb.tpy=0;}//VY+=DX/w*10;
			}
			else
			{
				if(kb[VK_LEFT		]){	VX-=DX*10/w, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_RIGHT		]){	VX+=DX*10/w, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_UP			]){	itb.tpy-=10;	if(itb.tpy<0		)itb.tpy=0;}//VY+=DX*10/w;
				if(kb[VK_DOWN		]){	itb.tpy+=10;	if(itb.tpy>itb.th-h	)itb.tpy=itb.th-h;}//VY-=DX*10/w;
			}
			if(kb[VK_ADD		]||kb[VK_OEM_PLUS	]||kb[VK_RETURN	])	DX/=1.05, function1(), toSolve=true, shiftOnly=0;
			if(kb[VK_SUBTRACT	]||kb[VK_OEM_MINUS	]||kb[VK_BACK	])	DX*=1.05, function1(), toSolve=true, shiftOnly=0;
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
#endif
			//c2d
#if 0
			if(_2d_drag_graph_not_window)
			{
				if(kb[VK_LEFT		]){	VX+=10*DX/ Xplaces		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_RIGHT		]){	VX-=10*DX/ Xplaces		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_UP			]){	VY-=10*DX/(Xplaces*AR_Y), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset-=10;}
				if(kb[VK_DOWN		]){	VY+=10*DX/(Xplaces*AR_Y), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset+=10;}
			}
			else
			{
				if(kb[VK_LEFT		]){	VX-=10*DX/ Xplaces		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_RIGHT		]){	VX+=10*DX/ Xplaces		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_UP			]){	VY+=10*DX/(Xplaces*AR_Y), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset+=10;}
				if(kb[VK_DOWN		]){	VY-=10*DX/(Xplaces*AR_Y), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset-=10;}
			}
			if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])
			{
				if(kb['X'])
					DX/=1.1, AR_Y/=1.1;
				else if(kb['Y'])
					AR_Y*=1.1;
				else
					DX/=1.1;
				function1(), toSolve=true, shiftOnly=0;
			}
			if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])
			{
				if(kb['X'])
					DX*=1.1, AR_Y*=1.1;
				else if(kb['Y'])
					AR_Y/=1.1;
				else
					DX*=1.1;
				function1(), toSolve=true, shiftOnly=0;
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
#endif
			//l2d
#if 0
			if(_2d_drag_graph_not_window)
			{
				if(kb[VK_LEFT		]){	VX+=10*DX/ w		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_RIGHT		]){	VX-=10*DX/ w		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_UP			]){	VY-=10*DX/(w*AR_Y)	, toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset-=10;}
				if(kb[VK_DOWN		]){	VY+=10*DX/(w*AR_Y)	, toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset+=10;}
			}
			else
			{
				if(kb[VK_LEFT		]){	VX-=10*DX/ w		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_RIGHT		]){	VX+=10*DX/ w		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_UP			]){	VY+=10*DX/(w*AR_Y)	, toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset+=10;}
				if(kb[VK_DOWN		]){	VY-=10*DX/(w*AR_Y)	, toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset-=10;}
			}
			if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])
			{
				if(kb['X'])
					DX/=1.05, AR_Y/=1.05;
				else if(kb['Y'])
					AR_Y*=1.05;
				else
					DX/=1.05;
				//	DX/=1.1, DY=DX*h/w;
				function1(), toSolve=true, shiftOnly=0;
			}
			if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])
			{
				if(kb['X'])
					DX*=1.05, AR_Y*=1.05;
				else if(kb['Y'])
					AR_Y/=1.05;
				else
					DX*=1.05;
				function1(), toSolve=true, shiftOnly=0;
			//	DX*=1.1, DY=DX*h/w, function1(), toSolve=true, shiftOnly=0;
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
#endif
		}
#endif
		//lbuttondown
#if 0
		int inputLButtonDown(int lParam)
		{
			//t1d
			//t1d_h
#if 0
			if(!drag)
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
				SetCapture(ghWnd);
				drag=1;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=centerP;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=short(p.x), ((short*)&oldMouse)[1]=short(p.y);
					a_draw();
				}
			}
			return 0;
#endif
			//ti2d
#if 0
#endif
			//c2d
			//l2d
#if 0
			if(!drag)
			{
				drag=1;
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
				SetCapture(ghWnd);
			}
			return 0;
#endif
		}
#endif
		//mousemove
#if 0
		int inputMouseMove(int lParam)
		{
			//t1d
			//t1d_h
#if 0
			bool draw=false;
			if(drag)
			{
				if(!m_bypass)
				{
					int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
					int dx=mx-w/2, dy=h/2-my;
					if(_2d_drag_graph_not_window)
						dx=-dx, dy=-dy;
					VX+=dx*DX/w, VY+=dy*DX/(w*AR_Y);
					toSolve=true;
					if(shiftOnly)
						shiftOnly=1, Xoffset+=dx;
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						draw=true;
				}
				m_bypass=!m_bypass;
			}
			if(contourOn&&!time_variance&&!timer)
				oldMouse=lParam, draw=true;
			if(draw)
				a_draw();
			return 0;
#endif
			//ti2d
#if 0
#endif
			//c2d
			//l2d
#if 0
			if(drag)
			{
				if(!m_bypass)
				{
					int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
					int dx=mx-w/2, dy=h/2-my;
					if(_2d_drag_graph_not_window)
						dx=-dx, dy=-dy;
					VX+=dx*DX/w, VY+=dy*DX/(w*AR_Y);
					toSolve=true;
					if(shiftOnly)
						shiftOnly=1, Xoffset+=dx, Yoffset+=dy;
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
				m_bypass=!m_bypass;
			}
			return 0;
#endif
		}
#endif
		//lbuttonup
#if 0
		void inputLButtonUp(int lParam)
		{
			//t1d
			//t1d_h
#if 0
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=mouseP0;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=(short)p.x, ((short*)&oldMouse)[1]=(short)p.y;
					a_draw();
				}
			}
#endif
			//ti2d
#if 0
#endif
			//c2d
			//l2d
#if 0
			if(drag)
			{
				drag=0;
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
#endif
		}
#endif
		int inputMouseWheel(int wParam)
		{
			//t1d
			//t1d_h
			//c2d
			//l2d
#if 0
			int mx=((short*)&oldMouse)[0], my=(h/2-((short*)&oldMouse)[1];
			double dx=(mx-w/2)*DX/w, dy=(h/2-my)*DX/(w*AR_Y);
			if(kb['X'])
			{
					 if(((short*)&wParam)[1]>0)	DX/=1.1, AR_Y/=1.1, VX=VX+dx-dx/1.1;
				else							DX*=1.1, AR_Y*=1.1, VX=VX+dx-dx*1.1;
			}
			else if(kb['Y'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Y*=1.1, VY=VY+dy-dy/1.1;
				else							AR_Y/=1.1, VY=VY+dy-dy*1.1;
			}
			else
			{
					 if(((short*)&wParam)[1]>0)	DX/=1.1, VX=VX+dx-dx/1.1, VY=VY+dy-dy/1.1;
				else							DX*=1.1, VX=VX+dx-dx*1.1, VY=VY+dy-dy*1.1;
			}
		/*	double dx=DX*(short(oldMouse)-w/2)/w, dy=DX*(h/2-short(oldMouse>>16))/w;
				 if(short(wParam>>16)>0)	VX=VX+dx-dx/1.1, DX/=1.1, VY=VY+dy-dy/1.1;
			else							VX=VX+dx-dx*1.1, DX*=1.1, VY=VY+dy-dy*1.1;//*/
			function1();
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
			return 0;
#endif
			//ti2d
#if 0
#endif
		}
		//keydown
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				--kp;
				break;
			}
			return 0;
		}
		void function1()
		{
			double t=100*DX/w, t2=floor(log10(t));
			Xstep=exp(t2*log(10)), prec=t2<0?int(-t2):0;
			switch(int(t/Xstep))
			{
			case 1:Xstep*=1;break;
			case 2:Xstep*=2;break;
			case 3:Xstep*=2;break;
			case 4:Xstep*=2;break;
			case 5:Xstep*=5;break;
			case 6:Xstep*=5;break;
			case 7:Xstep*=5;break;
			case 8:Xstep*=5;break;
			case 9:Xstep*=5;break;
			default:Xstep*=6;break;
			}
			if(AR_Y==1)
				Ystep=Xstep;
			else
			{
				double DY=DX*h/(w*AR_Y);
				double t=100*DY/h, t2=floor(log10(t));
				Ystep=exp(t2*log(10)), prec=t2<0?int(-t2):0;
				switch(int(t/Ystep))
				{
				case 1:Ystep*=1;break;
				case 2:Ystep*=2;break;
				case 3:Ystep*=2;break;
				case 4:Ystep*=2;break;
				case 5:Ystep*=5;break;
				case 6:Ystep*=5;break;
				case 7:Ystep*=5;break;
				case 8:Ystep*=5;break;
				case 9:Ystep*=5;break;
				default:Ystep*=6;break;
				}
			}
		}
		//draw
	};
	class		_3D_Mode:public Mode
	{
	public:
	//	int toSolve;
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		
		double VX, VY, VZ, DX, AR_Y, AR_Z, Xstep, Ystep, Zstep;
		Solve &solver;

		bool timer, drag, shift;
		int kp;

		_3D_Mode(Solve &solver):solver(solver), drag(false), kp(0){}

		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
				drag=1;
			}
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
		//	kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]+kb[VK_ADD]+kb[VK_OEM_PLUS]+kb[VK_SUBTRACT]+kb[VK_OEM_MINUS];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag||shift)
			{
				drag=0, shift=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}

		//setdimensions		->	paint
#if 0
		void setDimentions(int x, int y, int w, int h)
		{
			//t1d_c
#if 0
			bpx=x, bpy=y, bw=w, bh=h, X0=bpx+bw/2, Y0=bpy+bh/2;
			_3d.setDimentions(x, y, w, h);
			double old_Ystep=Ystep, old_Zstep=Zstep;
			function1();
			if(!toSolve&&contourOn&&(old_Ystep!=Ystep||old_Zstep!=Zstep))
			{
				Rcontours.clear(), Icontours.clear();
				double Xs=DX/Xplaces, DY=DX/AR_Y, DZ=DX/AR_Z;
				for(unsigned e=0;e<expr.size();++e)
					if(expr[e].rmode[0]==2||expr[e].rmode[0]==3)
						doContour(e, Xs, VY-DY/2, VY+DY/2, Ystep, 10, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
			}
			ready=true;
#endif
			//t2d
#if 0
			bpx=x, bpy=y, bw=w, bh=h, X0=bpx+bw/2, Y0=bpy+bh/2;
			_3d.setDimentions(x, y, w, h);
			double old_Zstep=Zstep;
			function1();
			if(!toSolve&&contourOn&&old_Zstep!=Zstep)
			{
				contours.clear();
				double Xs=DX/Xplaces, DZ=DX/AR_Z;
				for(unsigned e=0;e<expr.size();++e)
					if(expr[e].rmode[0]==5)
						doContour(e, Xs, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
			}
			ready=true;
#endif
			//t2d_h
#if 0
			bpx=x, bpy=y, bw=w, bh=h, X0=bpx+bw/2, Y0=bpy+bh/2;
			_3d.setDimentions(x, y, w, h);
			double old_Zstep=Zstep;
			function1();
			if(!toSolve&&contourOn&&old_Zstep!=Zstep)
			{
				Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
				double Xs=DX/Xplaces, DZ=DX/AR_Z;
				doContour(cursorEx, Xs, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
			}
			ready=true;
#endif
			//c3d
#if 0
			bpx=x, bpy=y, bw=w, bh=h, X0=bpx+bw/2, Y0=bpy+bh/2;
			_3d.setDimentions(x, y, w, h);
			double old_Xstep=Xstep;
			function1();
			if(!toSolve&&contourOn&&old_Xstep!=Xstep)
			{
				Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
				Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
				doContour(cursorEx, DX/Xplaces, -DX/2, +DX/2, Xstep, 2);
			}
			ready=true;
#endif
		}
#endif
		//paint
#if 0
		void messagePaint(int x, int y, int w, int h)
		{
			//t1d_c
#if 0
			setDimentions(x, y, w, h);
			if(!time_variance&&!timer)
				a_draw();
#endif
			//t2d
#if 0
			setDimentions(x, y, w, h);
			if(!time_variance&&!timer)
				a_draw();
#endif
			//t2d_h
#if 0
			setDimentions(x, y, w, h);
			if(!time_variance&&!timer)
				a_draw();
#endif
			//c3d
#if 0
			setDimentions(x, y, w, h);
			if(!time_variance&&!timer)
				a_draw();
#endif
		}
#endif
		//shiftNDR		->	timer	mousemove
#if 0
		void shiftNDR(double &DshiftPoint, double &Dsample, double &DsamplePos, int &Doffset, double &VD, double ammount)
		{
			double newDsamplePos=std::floor((DshiftPoint+=ammount)/Dsample);
			if(newDsamplePos!=DsamplePos)
			{
				toSolve=true;
				if(shiftOnly)
					shiftOnly=1, Doffset+=int(newDsamplePos-DsamplePos);
				DsamplePos=newDsamplePos, VD=newDsamplePos*Dsample;
			}
			DsamplePos=newDsamplePos;
		}
#endif
		//timer
#if 0
		void messageTimer()
		{
			//t1d_c
#if 0
				 if(kb[VK_SHIFT	]){	 if(kb['W'])	_3d.moveForwardFast();
									 if(kb['A'])	_3d.moveLeftFast();
									 if(kb['S'])	_3d.moveBackFast();
									 if(kb['D'])	_3d.moveRightFast();}
			else				  {	 if(kb['W'])	_3d.moveForward();
									 if(kb['A'])	_3d.moveLeft();
									 if(kb['S'])	_3d.moveBack();
									 if(kb['D'])	_3d.moveRight();}
			if(kb['X'])
			{
				if(kb['Y'])
				{
					if(kb['Z'])
					{
					}
					else		//xy
					{
						if(kb[VK_UP])		VY+=KXplaces*DX/Xplaces;
						if(kb[VK_DOWN])		VY-=KXplaces*DX/Xplaces;
						if(kb[VK_RIGHT]){	VX+=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
						if(kb[VK_LEFT]){	VX-=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
				}
				else
				{
					if(kb['Z'])	//xz
					{
						if(kb[VK_UP])		VZ+=KXplaces*DX/Xplaces;
						if(kb[VK_DOWN])		VZ-=KXplaces*DX/Xplaces;
						if(kb[VK_RIGHT]){	VX+=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
						if(kb[VK_LEFT]){	VX-=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
					else		//x
					{
						if(kb[VK_UP]||kb[VK_RIGHT]){	VX+=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
						if(kb[VK_DOWN]||kb[VK_LEFT]){	VX-=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
				}
			}
			else
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//yz
					{
						if(kb[VK_UP])		VZ+=KXplaces*DX/Xplaces;
						if(kb[VK_DOWN])		VZ-=KXplaces*DX/Xplaces;
						if(kb[VK_RIGHT])	VY+=KXplaces*DX/Xplaces;
						if(kb[VK_LEFT])		VY-=KXplaces*DX/Xplaces;
					}
					else		//y
					{
						if(kb[VK_UP]||kb[VK_RIGHT])		VY+=KXplaces*DX/Xplaces;
						if(kb[VK_DOWN]||kb[VK_LEFT])	VY-=KXplaces*DX/Xplaces;
					}
				}
				else
				{
					if(kb['Z'])	//z
					{
						if(kb[VK_UP]||kb[VK_RIGHT])		VZ+=KXplaces*DX/Xplaces;
						if(kb[VK_DOWN]||kb[VK_LEFT])	VZ-=KXplaces*DX/Xplaces;
					}
					else
					{
						if(kb[VK_UP])	_3d.rotateUp();
						if(kb[VK_DOWN])	_3d.rotateDown();
						if(kb[VK_RIGHT])_3d.rotateRight();
						if(kb[VK_LEFT])	_3d.rotateLeft();
					}
				}
			}
			if(kb[VK_ADD]||kb[VK_RETURN]||kb[VK_OEM_PLUS])
			{
				if(kb[VK_MENU])
					DX*=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['X'])
				{
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])
					AR_Y*=1.1, function1();
				else if(kb['Z'])
					AR_Z*=1.1, function1();
				else if(!kb[VK_CONTROL])
					_3d.zoomIn();
			}
			if(kb[VK_SUBTRACT]||kb[VK_BACK]||kb[VK_OEM_MINUS])
			{
				if(kb[VK_MENU])
					DX/=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['X'])
				{
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])
					AR_Y/=1.1, function1();
				else if(kb['Z'])
					AR_Z/=1.1, function1();
				else if(!kb[VK_CONTROL])
					_3d.zoomOut();
			}
		//		 if(kb[VK_MENU	]){		if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	DX*=1.1, function1(), toSolve=true, shiftOnly=0;
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	DX/=1.1, function1(), toSolve=true, shiftOnly=0;}
		//	else if(!kb[VK_CONTROL]){	if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	_3d.zoomIn();
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	_3d.zoomOut();}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
#endif
			//t2d
#if 0
				 if(kb[VK_SHIFT	]){	 if(kb['W'])	_3d.moveForwardFast();
									 if(kb['A'])	_3d.moveLeftFast();
									 if(kb['S'])	_3d.moveBackFast();
									 if(kb['D'])	_3d.moveRightFast();}
			else				  {	 if(kb['W'])	_3d.moveForward();
									 if(kb['A'])	_3d.moveLeft();
									 if(kb['S'])	_3d.moveBack();
									 if(kb['D'])	_3d.moveRight();}
			if(kb['X'])
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//xyz
					{
					}
					else		//xy
					{
						if(kb[VK_UP])	shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, DX/100);
						if(kb[VK_DOWN])	shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, -DX/100);
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, DX/100);
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, -DX/100);
					//	if(kb[VK_UP]){		VY+=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset+=KYplaces;}
					//	if(kb[VK_DOWN]){	VY-=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset-=KYplaces;}
					//	if(kb[VK_RIGHT]){	VX+=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
					//	if(kb[VK_LEFT]){	VX-=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
				}
				else
				{
					if(kb['Z'])	//xz
					{
						if(kb[VK_UP])	VZ+=DX/100;
						if(kb[VK_DOWN])	VZ-=DX/100;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, DX/100);
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, -DX/100);
					//	if(kb[VK_UP])		VZ+=KXplaces*DX/Xplaces;
					//	if(kb[VK_DOWN])		VZ-=KXplaces*DX/Xplaces;
					//	if(kb[VK_RIGHT]){	VX+=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
					//	if(kb[VK_LEFT]){	VX-=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
					else		//x
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, DX/100);
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, -DX/100);
					//	if(kb[VK_UP]||kb[VK_RIGHT]){	VX+=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
					//	if(kb[VK_DOWN]||kb[VK_LEFT]){	VX-=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
				}
			}
			else
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//yz
					{
						if(kb[VK_UP])	VZ+=DX/100;
						if(kb[VK_DOWN])	VZ-=DX/100;
						if(kb[VK_RIGHT])shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, DX/100);
						if(kb[VK_LEFT])	shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, -DX/100);
					//	if(kb[VK_UP])		VZ+=KXplaces*DX/Xplaces;
					//	if(kb[VK_DOWN])		VZ-=KXplaces*DX/Xplaces;
					//	if(kb[VK_RIGHT]){	VY+=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset+=KYplaces;}
					//	if(kb[VK_LEFT]){	VY-=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset-=KYplaces;}
					}
					else		//y
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, DX/100);
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, -DX/100);
					//	if(kb[VK_UP]||kb[VK_RIGHT]){	VY+=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset+=KYplaces;}
					//	if(kb[VK_DOWN]||kb[VK_LEFT]){	VY-=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset-=KYplaces;}
					}
				}
				else
				{
					if(kb['Z'])	//z
					{
						if(kb[VK_UP]||kb[VK_RIGHT])		VZ+=DX/100;
						if(kb[VK_DOWN]||kb[VK_LEFT])	VZ-=DX/100;
					//	if(kb[VK_UP]||kb[VK_RIGHT])		VZ+=KXplaces*DX/Xplaces;
					//	if(kb[VK_DOWN]||kb[VK_LEFT])	VZ-=KXplaces*DX/Xplaces;
					}
					else
					{
						if(kb[VK_UP])	_3d.rotateUp();
						if(kb[VK_DOWN])	_3d.rotateDown();
						if(kb[VK_RIGHT])_3d.rotateRight();
						if(kb[VK_LEFT])	_3d.rotateLeft();
					}
				}
			}
			if(kb[VK_ADD]||kb[VK_RETURN]||kb[VK_OEM_PLUS])
			{
				if(kb[VK_MENU])
					DX*=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['X'])
				{
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])
					AR_Y*=1.1, function1();
				else if(kb['Z'])
					AR_Z*=1.1, function1();
				else if(!kb[VK_CONTROL])
					_3d.zoomIn();
			}
			if(kb[VK_SUBTRACT]||kb[VK_BACK]||kb[VK_OEM_MINUS])
			{
				if(kb[VK_MENU])
					DX/=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['X'])
				{
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])
					AR_Y/=1.1, function1();
				else if(kb['Z'])
					AR_Z/=1.1, function1();
				else if(!kb[VK_CONTROL])
					_3d.zoomOut();
			}
		//		 if(kb[VK_MENU]){		if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	DX*=1.1, DY*=1.1, function1(), toSolve=true, shiftOnly=0;
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	DX/=1.1, DY/=1.1, function1(), toSolve=true, shiftOnly=0;}
		//	else if(!kb[VK_CONTROL]){	if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	_3d.zoomIn();
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	_3d.zoomOut();}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
#endif
			//t2d_h
#if 0
				 if(kb[VK_SHIFT	]){	 if(kb['W'])	_3d.moveForwardFast();
									 if(kb['A'])	_3d.moveLeftFast();
									 if(kb['S'])	_3d.moveBackFast();
									 if(kb['D'])	_3d.moveRightFast();}
			else				  {	 if(kb['W'])	_3d.moveForward();
									 if(kb['A'])	_3d.moveLeft();
									 if(kb['S'])	_3d.moveBack();
									 if(kb['D'])	_3d.moveRight();}
			if(kb['X'])
			{
				if(kb['Y'])
				{
					if(kb['Z'])
					{
					}
					else		//xy
					{
						if(kb[VK_UP])	shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, DX/100);
						if(kb[VK_DOWN])	shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, -DX/100);
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, DX/100);
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, -DX/100);
					//	if(kb[VK_UP]){		VY+=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset+=KYplaces;}
					//	if(kb[VK_DOWN]){	VY-=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset-=KYplaces;}
					//	if(kb[VK_RIGHT]){	VX+=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
					//	if(kb[VK_LEFT]){	VX-=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
				}
				else
				{
					if(kb['Z'])	//xz
					{
						if(kb[VK_UP])	VZ+=DX/100;
						if(kb[VK_DOWN])	VZ-=DX/100;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, DX/100);
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, -DX/100);
					//	if(kb[VK_UP])		VZ+=KXplaces*DX/Xplaces;
					//	if(kb[VK_DOWN])		VZ-=KXplaces*DX/Xplaces;
					//	if(kb[VK_RIGHT]){	VX+=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
					//	if(kb[VK_LEFT]){	VX-=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
					else		//x
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, DX/100);
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, -DX/100);
					//	if(kb[VK_UP]||kb[VK_RIGHT]){	VX+=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
					//	if(kb[VK_DOWN]||kb[VK_LEFT]){	VX-=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
				}
			}
			else
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//yz
					{
						if(kb[VK_UP])	VZ+=DX/100;
						if(kb[VK_DOWN])	VZ-=DX/100;
						if(kb[VK_RIGHT])shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, DX/100);
						if(kb[VK_LEFT])	shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, -DX/100);
					//	if(kb[VK_UP])		VZ+=KXplaces*DX/Xplaces;
					//	if(kb[VK_DOWN])		VZ-=KXplaces*DX/Xplaces;
					//	if(kb[VK_RIGHT]){	VY+=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset+=KYplaces;}
					//	if(kb[VK_LEFT]){	VY-=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset-=KYplaces;}
					}
					else		//y
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, DX/100);
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, -DX/100);
					//	if(kb[VK_UP]||kb[VK_RIGHT]){	VY+=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset+=KYplaces;}
					//	if(kb[VK_DOWN]||kb[VK_LEFT]){	VY-=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset-=KYplaces;}
					}
				}
				else
				{
					if(kb['Z'])	//z
					{
						if(kb[VK_UP]||kb[VK_RIGHT])		VZ+=DX/100;
						if(kb[VK_DOWN]||kb[VK_LEFT])	VZ-=DX/100;
					//	if(kb[VK_UP]||kb[VK_RIGHT])		VZ+=KXplaces*DX/Xplaces;
					//	if(kb[VK_DOWN]||kb[VK_LEFT])	VZ-=KXplaces*DX/Xplaces;
					}
					else
					{
						if(kb[VK_UP])	_3d.rotateUp();
						if(kb[VK_DOWN])	_3d.rotateDown();
						if(kb[VK_RIGHT])_3d.rotateRight();
						if(kb[VK_LEFT])	_3d.rotateLeft();
					}
				}
			}
			if(kb[VK_ADD]||kb[VK_RETURN]||kb[VK_OEM_PLUS])
			{
				if(kb[VK_MENU])
					DX*=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['X'])
				{
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])
					AR_Y*=1.1, function1();
				else if(kb['Z'])
					AR_Z*=1.1, function1();
				else if(!kb[VK_CONTROL])
					_3d.zoomIn();
			}
			if(kb[VK_SUBTRACT]||kb[VK_BACK]||kb[VK_OEM_MINUS])
			{
				if(kb[VK_MENU])
					DX/=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['X'])
				{
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])
					AR_Y/=1.1, function1();
				else if(kb['Z'])
					AR_Z/=1.1, function1();
				else if(!kb[VK_CONTROL])
					_3d.zoomOut();
			}
		//		 if(kb[VK_MENU	]){		if(kb[VK_ADD		]||kb[VK_OEM_PLUS	])	DX*=1.1, DY*=1.1, function1(), toSolve=true, shiftOnly=0;
		//								if(kb[VK_SUBTRACT	]||kb[VK_OEM_MINUS	])	DX/=1.1, DY/=1.1, function1(), toSolve=true, shiftOnly=0;}
		//	else if(!kb[VK_CONTROL]){	if(kb[VK_ADD		]||kb[VK_OEM_PLUS	])	_3d.zoomIn();
		//								if(kb[VK_SUBTRACT	]||kb[VK_OEM_MINUS	])	_3d.zoomOut();}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
#endif
			//c3d
#if 0
				 if(kb[VK_SHIFT	]){	 if(kb['W'])	_3d.moveForwardFast();
									 if(kb['A'])	_3d.moveLeftFast();
									 if(kb['S'])	_3d.moveBackFast();
									 if(kb['D'])	_3d.moveRightFast();}
			else				  {	 if(kb['W'])	_3d.moveForward();
									 if(kb['A'])	_3d.moveLeft();
									 if(kb['S'])	_3d.moveBack();
									 if(kb['D'])	_3d.moveRight();}
			if(kb['X'])
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//xyz
					{
					}
					else		//xy
					{
						if(kb[VK_UP])	shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, DX/100);
						if(kb[VK_DOWN])	shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, -DX/100);
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, DX/100);
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, -DX/100);
					//	if(kb[VK_UP]){		VY+=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset+=KYplaces;}
					//	if(kb[VK_DOWN]){	VY-=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset-=KYplaces;}
					//	if(kb[VK_RIGHT]){	VX+=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
					//	if(kb[VK_LEFT]){	VX-=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
				}
				else
				{
					if(kb['Z'])	//xz
					{
						if(kb[VK_UP])	shiftNDR(ZshiftPoint, solver.Zsample, ZsamplePos, Zoffset, VZ, DX/100);
						if(kb[VK_DOWN])	shiftNDR(ZshiftPoint, solver.Zsample, ZsamplePos, Zoffset, VZ, -DX/100);
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, DX/100);
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, -DX/100);
					//	if(kb[VK_UP]){		VZ+=KZplaces*DX/Zplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Zoffset+=KZplaces;}
					//	if(kb[VK_DOWN]){	VZ-=KZplaces*DX/Zplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Zoffset-=KZplaces;}
					//	if(kb[VK_RIGHT]){	VX+=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
					//	if(kb[VK_LEFT]){	VX-=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
					else		//x
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, DX/100);
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, -DX/100);
					//	if(kb[VK_UP]||kb[VK_RIGHT]){	VX+=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
					//	if(kb[VK_DOWN]||kb[VK_LEFT]){	VX-=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
				}
			}
			else
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//yz
					{
						if(kb[VK_UP])	shiftNDR(ZshiftPoint, solver.Zsample, ZsamplePos, Zoffset, VZ, DX/100);
						if(kb[VK_DOWN])	shiftNDR(ZshiftPoint, solver.Zsample, ZsamplePos, Zoffset, VZ, -DX/100);
						if(kb[VK_RIGHT])shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, DX/100);
						if(kb[VK_LEFT])	shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, -DX/100);
					//	if(kb[VK_UP]){		VZ+=KZplaces*DX/Zplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Zoffset+=KZplaces;}
					//	if(kb[VK_DOWN]){	VZ-=KZplaces*DX/Zplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Zoffset-=KZplaces;}
					//	if(kb[VK_RIGHT]){	VY+=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset+=KYplaces;}
					//	if(kb[VK_LEFT]){	VY-=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset-=KYplaces;}
					}
					else		//y
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, DX/100);
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, -DX/100);
					//	if(kb[VK_UP]||kb[VK_RIGHT]){	VY+=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset+=KYplaces;}
					//	if(kb[VK_DOWN]||kb[VK_LEFT]){	VY-=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset-=KYplaces;}
					}
				}
				else
				{
					if(kb['Z'])	//z
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(ZshiftPoint, solver.Zsample, ZsamplePos, Zoffset, VZ, DX/100);
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(ZshiftPoint, solver.Zsample, ZsamplePos, Zoffset, VZ, -DX/100);
					//	if(kb[VK_UP]||kb[VK_RIGHT]){	VZ+=KZplaces*DX/Zplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Zoffset+=KZplaces;}
					//	if(kb[VK_DOWN]||kb[VK_LEFT]){	VZ-=KZplaces*DX/Zplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Zoffset-=KZplaces;}
					}
					else
					{
						if(kb[VK_UP])	_3d.rotateUp();
						if(kb[VK_DOWN])	_3d.rotateDown();
						if(kb[VK_RIGHT])_3d.rotateRight();
						if(kb[VK_LEFT])	_3d.rotateLeft();
					}
				}
			}
			if(kb[VK_ADD]||kb[VK_RETURN]||kb[VK_OEM_PLUS])
			{
				if(kb[VK_MENU])
					DX*=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['X'])
				{
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])
					AR_Y*=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['Z'])
					AR_Z*=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(!(kb[VK_CONTROL]||kb[VK_SHIFT]))
					_3d.zoomIn();
			}
			if(kb[VK_SUBTRACT]||kb[VK_BACK]||kb[VK_OEM_MINUS])
			{
				if(kb[VK_MENU])
					DX/=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['X'])
				{
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])
					AR_Y/=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['Z'])
					AR_Z/=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(!(kb[VK_CONTROL]||kb[VK_SHIFT]))
					_3d.zoomOut();
			}
		//		 if(kb[VK_MENU	]){		if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	DX*=1.1, DY*=1.1, DZ*=1.1, function1(), toSolve=true, shiftOnly=0;
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	DX/=1.1, DY/=1.1, DZ/=1.1, function1(), toSolve=true, shiftOnly=0;}
		//	else if(!kb[VK_CONTROL]){	if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	_3d.zoomIn();
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	_3d.zoomOut();}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
#endif
		}
#endif
		//lbuttondown
#if 0
		int inputLButtonDown(int lParam)
		{
			//t1d_c
#if 0
			if(!drag)
			{
				if(!shift)
				{
					ShowCursor(0);
					GetCursorPos(&mouseP0);
					SetCursorPos(centerP.x, centerP.y);
					SetCapture(ghWnd);
				}
				drag=1;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=centerP;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=(short)p.x, ((short*)&oldMouse)[1]=(short)p.y;
					a_draw();
				}
			}
			return 0;
#endif
			//t2d
			//t2d_h
			//c3d
#if 0
			if(!drag)
			{
				if(!shift)
				{
					ShowCursor(0);
					GetCursorPos(&mouseP0);
					SetCursorPos(centerP.x, centerP.y);
					SetCapture(ghWnd);
				}
				drag=1;
			}
			return 0;
#endif
		}
#endif
		//mousemove
#if 0
		int inputMouseMove(int lParam)
		{
			//t1d_c
#if 0
			int draw=0;
			if(!m_bypass)
			{
				if(kb['X'])
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//xyz	mx my mw
						{
							int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
							VX+=(mx-w/2)*DX/Xplaces, VY+=(h/2-my)*DX/Xplaces;
							toSolve=true;
							if(shiftOnly)
								shiftOnly=1, Xoffset+=mx-w/2;
							draw=1;
						}
						else		//xy	mx my
						{
							int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
							VX+=(mx-w/2)*DX/Xplaces, VY+=(h/2-my)*DX/Xplaces;
							toSolve=true;
							if(shiftOnly)
								shiftOnly=1, Xoffset+=mx-w/2;
							draw=1;
						}
					}
					else
					{
						if(kb['Z'])	//xz	mx my
						{
							int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
							VX+=(mx-w/2)*DX/Xplaces, VZ+=(h/2-my)*DX/Xplaces;
							toSolve=true;
							if(shiftOnly)
								shiftOnly=1, Xoffset+=mx-w/2;
						}
						else		//x		mx
						{
							int mx=((short*)&lParam)[0];
							VX+=(mx-w/2)*DX/Xplaces;
							toSolve=true;
							if(shiftOnly)
								shiftOnly=1, Xoffset+=mx-w/2;
						}
						draw=1;
					}
				}
				else
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//yz	mx my
						{
							int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
							VY+=(mx-w/2)*DX/Xplaces, VZ+=(h/2-my)*DX/Xplaces;
						}
						else		//y		mx
						{
							int mx=((short*)&lParam)[0];
							VY+=(mx-w/2)*DX/Xplaces;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//z		my
						{
							int my=((short*)&lParam)[1];
							VZ+=(h/2-my)*DX/Xplaces;
							draw=1;
						}
						else if(drag)
						{
							_3d.rotate(lParam);
							draw=1;
						}
					}
				}
			}
			if(draw)
			{
				SetCursorPos(centerP.x, centerP.y);
				if(!time_variance&&!timer)
					a_draw();
			}
			else if(contourOn&&!time_variance&&!timer)
				oldMouse=lParam, a_draw();
			m_bypass=!m_bypass;
			return 0;
#endif
			//t2d
			//t2d_h
#if 0
			if(!m_bypass)
			{
				int draw=0;
				if(kb['X'])
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//xyz	mx my mw
						{
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
							shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, (h/2-((short*)&lParam)[1])*DX/w);
							//int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
							//VX+=(mx-w/2)*DX/Xplaces, VY+=(h/2-my)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Xoffset+=mx-w/2, Yoffset+=h/2-my;
							//draw=1;
						}
						else		//xy	mx my
						{
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
							shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, (h/2-((short*)&lParam)[1])*DX/w);
							//int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
							//VX+=(mx-w/2)*DX/Xplaces, VY+=(h/2-my)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Xoffset+=mx-w/2, Yoffset+=h/2-my;
							//draw=1;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//xz	mx my
						{
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
							VZ+=(h/2-((short*)&lParam)[1])*DX/w;
							//int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
							//VX+=(mx-w/2)*DX/Xplaces, VZ+=(h/2-my)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Xoffset+=mx-w/2;
						}
						else		//x		mx
						{
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
							//int mx=((short*)&lParam)[0];
							//VX+=(mx-w/2)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Xoffset+=mx-w/2;
						}
						draw=1;
					}
				}
				else
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//yz	mx my
						{
							shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, (((short*)&lParam)[0]-w/2)*DX/w);
							VZ+=(h/2-((short*)&lParam)[1])*DX/w;
							//int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
							//VY+=(mx-w/2)*DX/Xplaces, VZ+=(h/2-my)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Yoffset+=mx-w/2;
						}
						else		//y		mx
						{
							shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, (((short*)&lParam)[0]-w/2)*DX/w);
							//int mx=((short*)&lParam)[0];
							//VY+=(mx-w/2)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Yoffset+=mx-w/2;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//z		my
						{
							int my=((short*)&lParam)[1];
							VZ+=(h/2-my)*DX/Xplaces;
							draw=1;
						}
						else if(drag)
						{
							_3d.rotate(lParam);
							draw=1;
						}
					}
				}
				if(draw)
				{
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
			}
			m_bypass=!m_bypass;
			return 0;
#endif
			//c3d
#if 0
			if(!m_bypass)
			{
				int draw=0;
				if(kb['X'])
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//xyz	mx my mw
						{
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
							shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, (h/2-((short*)&lParam)[1])*DX/w);
						//	int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
						//	VX+=(mx-w/2)*DX/Xplaces, VY+=(h/2-my)*DX/Xplaces;
						//	toSolve=true;
						//	if(shiftOnly)
						//		shiftOnly=1, Xoffset+=mx-w/2, Yoffset+=h/2-my;
						//	draw=1;
						}
						else		//xy	mx my
						{
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
							shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, (h/2-((short*)&lParam)[1])*DX/w);
							//int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
							//VX+=(mx-w/2)*DX/Xplaces, VY+=(h/2-my)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Xoffset+=mx-w/2, Yoffset+=h/2-my;
							//draw=1;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//xz	mx my
						{
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
							shiftNDR(ZshiftPoint, solver.Zsample, ZsamplePos, Zoffset, VZ, (h/2-((short*)&lParam)[1])*DX/w);
							//int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
							//VX+=(mx-w/2)*DX/Xplaces, VZ+=(h/2-my)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Xoffset+=mx-w/2, Zoffset+=h/2-my;
						}
						else		//x		mx
						{
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
							//int mx=((short*)&lParam)[0];
							//VX+=(mx-w/2)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Xoffset+=mx-w/2;
						}
						draw=1;
					}
				}
				else
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//yz	mx my
						{
							shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, (((short*)&lParam)[0]-w/2)*DX/w);
							shiftNDR(ZshiftPoint, solver.Zsample, ZsamplePos, Zoffset, VZ, (h/2-((short*)&lParam)[1])*DX/w);
							//int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
							//VY+=(mx-w/2)*DX/Xplaces, VZ+=(h/2-my)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Yoffset+=mx-w/2, Zoffset+=h/2-my;
						}
						else		//y		mx
						{
							shiftNDR(YshiftPoint, solver.Ysample, YsamplePos, Yoffset, VY, (((short*)&lParam)[0]-w/2)*DX/w);
							//int mx=((short*)&lParam)[0];
							//VY+=(mx-w/2)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Yoffset+=mx-w/2;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//z		my
						{
							shiftNDR(ZshiftPoint, solver.Zsample, ZsamplePos, Zoffset, VZ, (h/2-((short*)&lParam)[1])*DX/w);
							//int my=((short*)&lParam)[1];
							//VZ+=(h/2-my)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Zoffset+=h/2-my;
							draw=1;
						}
						else if(drag)
						{
							_3d.rotate(lParam);
							draw=1;
						}
					}
				}
				if(draw)
				{
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
			}
			m_bypass=!m_bypass;
			return 0;
#endif
		}
#endif
		//lbuttonup
#if 0
		void inputLButtonUp(int lParam)
		{
			//t1d_c
#if 0
			if(drag)
			{
				if(!shift)
				{
					ReleaseCapture();
					SetCursorPos(mouseP0.x, mouseP0.y);
					ShowCursor(1);
				}
				drag=0;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=mouseP0;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=(short)p.x, ((short*)&oldMouse)[1]=(short)p.y;
				//	oldMouse=p.y<<16|p.x;
					a_draw();
				}
			}
#endif
			//t2d
			//t2d_h
			//c3d
#if 0
			if(drag)
			{
				if(!shift)
				{
					ReleaseCapture();
					SetCursorPos(mouseP0.x, mouseP0.y);
					ShowCursor(1);
				}
				drag=0;
			}
#endif
		}
#endif
		//mousewheel
#if 0
		int inputMouseWheel(int wParam)
		{
			//t1d_c
#if 0
			if(kb['X']&&kb['Y']&&kb['Z'])
			{
					 if(((short*)&wParam)[1]>0)	VZ+=KXplaces*DX/Xplaces;
				else							VZ-=KXplaces*DX/Xplaces;
			}
			else if(kb[VK_MENU])
			{
					 if(((short*)&wParam)[1]>0)	DX*=1.1;
				else							DX/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['X'])
			{
				if(((short*)&wParam)[1]>0)
				{
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1;
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
				}
				else
				{
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1;
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
				}
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Y'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Y*=1.1;
				else							AR_Y/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Z'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Z*=1.1;
				else							AR_Z/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb[VK_CONTROL])
			{
					 if(((short*)&wParam)[1]>0)	_3d.faster();
				else							_3d.slower();
			}
			else
			{
					 if(((short*)&wParam)[1]>0)	_3d.zoomIn();
				else							_3d.zoomOut();
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
#endif
			//t2d
			//t2d_h
#if 0
			if(kb['X']&&kb['Y']&&kb['Z'])
			{
					 if(((short*)&wParam)[1]>0)	VZ+=DX/100;
				else							VZ-=DX/100;
			//		 if(((short*)&wParam)[1]>0)	VZ+=KXplaces*DX/Xplaces;
			//	else							VZ-=KXplaces*DX/Xplaces;
			}
			else if(kb[VK_MENU])
			{
					 if(((short*)&wParam)[1]>0)	DX*=1.1;//, DY*=1.1;
				else							DX/=1.1;//, DY/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['X'])
			{
				if(((short*)&wParam)[1]>0)
				{
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1;
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
				}
				else
				{
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1;
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
				}
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Y'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Y*=1.1;
				else							AR_Y/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Z'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Z*=1.1;
				else							AR_Z/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb[VK_CONTROL])
			{
					 if(((short*)&wParam)[1]>0)	_3d.faster();
				else							_3d.slower();
			}
			else if(kb[VK_SHIFT])
			{
				if(((short*)&wParam)[1]>0)
					Yplaces=++Xplaces, toSolve=true, shiftOnly=0;
				else
				{
					if(Xplaces>1)
						Yplaces=--Xplaces, toSolve=true, shiftOnly=0;
				}
			}
			else
			{
					 if(((short*)&wParam)[1]>0)	_3d.zoomIn();
				else							_3d.zoomOut();
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
#endif
			//c3d
#if 0
			if(kb['X']&&kb['Y']&&kb['Z'])
			{
				shiftNDR(ZshiftPoint, solver.Zsample, ZsamplePos, Zoffset, VZ,
					((short*)&wParam)[1]>0	?	DX/100
											:	-DX/100);
			//		 if(((short*)&wParam)[1]>0)	VZ+=KXplaces*DX/Xplaces;
			//	else							VZ-=KXplaces*DX/Xplaces;
			}
			else if(kb[VK_MENU])
			{
					 if(((short*)&wParam)[1]>0)	DX*=1.1;//, DY*=1.1, DZ*=1.1;
				else							DX/=1.1;//, DY/=1.1, DZ/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['X'])
			{
				if(((short*)&wParam)[1]>0)
				{
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1;
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
				}
				else
				{
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1;
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
				}
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Y'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Y*=1.1;
				else							AR_Y/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Z'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Z*=1.1;
				else							AR_Z/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb[VK_CONTROL])
			{
					 if(((short*)&wParam)[1]>0)	_3d.faster();
				else							_3d.slower();
			}
			else if(kb[VK_SHIFT])
			{
					 if(((short*)&wParam)[1]>0)
				{
					Zplaces=Yplaces=++Xplaces, toSolve=true, shiftOnly=0;
					//int oldXplaces=Xplaces;
					//Xplaces=int(1.5*Xplaces);
					//if(Xplaces==oldXplaces)
					//	++Xplaces;
					//Zplaces=Yplaces=Xplaces;
					//toSolve=true, shiftOnly=0;
				}
				else
				{
					if(Xplaces>1)
						Zplaces=Yplaces=--Xplaces, toSolve=true, shiftOnly=0;
					//int oldXplaces=Xplaces;
					//Xplaces=int(Xplaces/1.5);
					//if(Xplaces==oldXplaces&&Xplaces!=1)
					//	--Xplaces;
					//Zplaces=Yplaces=Xplaces;
					//toSolve=true, shiftOnly=0;
				}
			}
			else
			{
					 if(((short*)&wParam)[1]>0)	_3d.zoomIn();
				else							_3d.zoomOut();
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
#endif
		}
#endif
		//keydown
#if 0
		int inputKeyDown(int wParam, int lParam)
		{
			//t1d_c
#if 0
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
				if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
		//	case VK_CONTROL:
		//		if(!(lParam&1<<30))
		//		{
		//			kp-=kb[VK_ADD]+kb[VK_SUBTRACT]+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]+kb[VK_RETURN]+kb[VK_BACK];
		//			if(kp<0)
		//				kp=0;
		//		}
		//		return 0;
			case VK_ADD:case VK_OEM_PLUS:case VK_RETURN:
				if(kb[VK_CONTROL])
					_3d.faster();
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_SUBTRACT:case VK_OEM_MINUS:case VK_BACK:
				if(kb[VK_CONTROL])
					_3d.slower();
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case 'X':
				if(kb[VK_CONTROL])
				{
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
					break;
				}
				else if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case 'Y':
				if(kb[VK_CONTROL])
				{
					_3d.teleport_degrees(0, 20, 0, -90, 0, 1);
					break;
				}
				else if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case 'Z':
				if(kb[VK_CONTROL])
				{
					_3d.teleport_degrees(0, 0, 20, 0, -90, 1);
					break;
				}
				else if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			//case 'X':case 'Y':case 'Z':
			//	if(!(lParam&1<<30)&&!shift)
			//	{
			//		if(!drag)
			//		{
			//			GetCursorPos(&mouseP0);
			//			ShowCursor(0);
			//			SetCursorPos(centerP.x, centerP.y);
			//			SetCapture(ghWnd);
			//		}
			//		shift=1;
			//	}
			//	return 0;
			case VK_OEM_3://contour
				if(contourOn)
				{
					if(kb[VK_CONTROL])
						contourOnly=!contourOnly;//toggle contour with / without the curves
					else
						contourOn=false;
				}
				else
				{
					contourOn=true, contourOnly=false;//turn contour on
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear();
						double Xs=DX/Xplaces, DY=DX/AR_Y, DZ=DX/AR_Z;
						for(unsigned e=0;e<expr.size();++e)
							if(expr[e].rmode[0]==2||expr[e].rmode[0]==3)
								doContour(e, Xs, VY-DY/2, VY+DY/2, Ystep, 10, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
					}
				}
				break;
			case '0':case VK_NUMPAD0:
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
				Rcontours.clear(), Icontours.clear();
				{
					auto op=&Transverse_1D_C::differentiate;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:operations.push_back(1), op=&Transverse_1D_C::differentiate;					break;
					case '2':case VK_NUMPAD2:operations.push_back(2), op=&Transverse_1D_C::integrate;						break;
					case '3':case VK_NUMPAD3:operations.push_back(3), op=&Transverse_1D_C::discreteFourrierTransform;		break;
					case '4':case VK_NUMPAD4:operations.push_back(4), op=&Transverse_1D_C::inverseDiscreteFourrierTransform;break;
					case '5':case VK_NUMPAD5:operations.push_back(5), op=&Transverse_1D_C::lowPassFilter;					break;
					case '6':case VK_NUMPAD6:operations.push_back(6), op=&Transverse_1D_C::highPassFilter;					break;
					}
					if(!toSolve)//lazy solve?
					{
						for(unsigned e=0;e<expr.size();++e)
						{
							auto &ex=expr[e];
							if(ex.rmode[0]==2||ex.rmode[0]==3)
								(this->*op)(ex.n[0].ndr);
						}
						if(contourOn)
						{
							double Xs=DX/Xplaces, DY=DX/AR_Y, DZ=DX/AR_Z;
							for(unsigned e=0;e<expr.size();++e)
							{
								auto &ex=expr[e];
								if(ex.rmode[0]==2||ex.rmode[0]==3)
									doContour(e, Xs, VY-DY/2, VY+DY/2, Ystep, 10, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
							}
						}
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				{
					double r=20/DX;
					VX*=r, VY*=r, VZ*=r;
					_3d.camx*=r, _3d.camy*=r, _3d.camz*=r, _3d.dcam*=r;
					DX=20, AR_Y=1, AR_Z=1, function1();
					toSolve=true, shiftOnly=0;
				}
				break;
			case 'R':
				_3d.dcam=.04;
				if(!kb[VK_CONTROL])
					DX=20, AR_Y=1, AR_Z=1, function1();
				if(VX!=0||VY!=0||VZ!=0)
					VX=VY=VZ=0;
				toSolve=true, shiftOnly=0;
				if(kb['X'])
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
				else if(kb['Y'])
					_3d.teleport_degrees(0, 20, 0, 270, 0, 1);
				else if(kb['Z'])
					_3d.teleport_degrees(0, 0, 20, 90, 270, 1);
				else
					_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
			//	if(kb[VK_CONTROL])
			//	{
			//		_3d.dcam=.04;
			//		DX=20, AR_Y=1, AR_Z=1, function1();
			//		toSolve=true, shiftOnly=0;
			//	}
			//	if(VX!=0||VY!=0||VZ!=0)
			//	{
			//		VX=VY=VZ=0;
			//		toSolve=true, shiftOnly=0;
			//	}
			//	if(kb[VK_CONTROL])
			//		_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
			//	else
			//		_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
#endif
			//t2d
#if 0
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
				if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_ADD:case VK_OEM_PLUS:case VK_RETURN:
				if(kb[VK_CONTROL])
					_3d.faster();
				else if(kb[VK_SHIFT])
				{
					Yplaces=++Xplaces, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_SUBTRACT:case VK_OEM_MINUS:case VK_BACK:
				if(kb[VK_CONTROL])
					_3d.slower();
				else if(kb[VK_SHIFT])
				{
					if(Xplaces>1)
						Yplaces=--Xplaces, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case 'X':case 'Y':case 'Z':
				if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case VK_OEM_3:
				if(contourOn)//was on
				{
					if(kb[VK_CONTROL])
					{
						//contour+surface
						//contour only
						//flat contour
						//flat+surface
						if(contourFlat)
						{
							if(contourOnly)
								contourOnly=false;//3: surface appears
							else
								contourFlat=false;//4: pops up
						}
						else
						{
							if(contourOnly)
								contourFlat=true;//2: gets flat
							else
								contourOnly=true;//1: surface disappears
						}
					}
					else
						contourOn=false, contourOnly=false, contourFlat=false;
				}
				else//was off
				{
					contourOn=true;
					if(!toSolve)
					{
						contours.clear();
						double Xs=DX/Xplaces, DZ=DX/AR_Z;
						for(unsigned e=0;e<expr.size();++e)
							if(expr[e].rmode[0]==5)
								doContour(e, Xs, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
					}
				}
				break;
			case '0':case VK_NUMPAD0:
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
			case '7':case VK_NUMPAD7:
			case '8':case VK_NUMPAD8:
				{
					auto op=&Transverse_2D::differentiate_x;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:	operations.push_back( 1), op=&Transverse_2D::differentiate_x;					break;
					case '2':case VK_NUMPAD2:	operations.push_back( 2), op=&Transverse_2D::differentiate_y;					break;
					case '3':case VK_NUMPAD3:	operations.push_back( 3), op=&Transverse_2D::integrate_x;						break;
					case '4':case VK_NUMPAD4:	operations.push_back( 4), op=&Transverse_2D::integrate_y;						break;
					case '5':case VK_NUMPAD5:	operations.push_back( 5), op=&Transverse_2D::discreteFourrierTransform;			break;
					case '6':case VK_NUMPAD6:	operations.push_back( 6), op=&Transverse_2D::inverseDiscreteFourrierTransform;	break;
					case '7':case VK_NUMPAD7:	operations.push_back( 7), op=&Transverse_2D::lowPassFilter;						break;
					case '8':case VK_NUMPAD8:	operations.push_back( 8), op=&Transverse_2D::highPassFilter;					break;
					}
					if(!toSolve)
					{
						contours.clear();
						double Xs=DX/Xplaces, DY=DX/AR_Y, DZ=DX/AR_Z;
						for(unsigned e=0;e<expr.size();++e)
						{
							auto &ndr=expr[e].n[0].ndr;
							(this->*op)(ndr);
							if(contourOn)
								doContour(e, Xs, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
						}
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				{
					double r=20/DX;
					VX*=r, VY*=r, VZ*=r;
					_3d.camx*=r, _3d.camy*=r, _3d.camz*=r, _3d.dcam*=r;
					DX=20, AR_Y=1, AR_Z=1, function1();
					toSolve=true, shiftOnly=0;
				}
				break;
			case 'R':
				_3d.dcam=.04;
				if(!kb[VK_CONTROL])
					DX=20, AR_Y=1, AR_Z=1, function1(), Xplaces=Yplaces=100;
				if(VX!=0||VY!=0||VZ!=0)
					VX=VY=VZ=0;
				toSolve=true, shiftOnly=0;
				if(kb['X'])
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
				else if(kb['Y'])
					_3d.teleport_degrees(0, 20, 0, 270, 0, 1);
				else if(kb['Z'])
					_3d.teleport_degrees(0, 0, 20, 90, 270, 1);
				else
					_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
			/*	if(kb[VK_CONTROL])
				{
					DX=20, DY=20, function1();
					toSolve=true, shiftOnly=0;
				}
				if(VX!=0||VY!=0||VZ!=0)
				{
					VX=VY=VZ=0;
					toSolve=true, shiftOnly=0;
				}
				_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);//*/
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
		//	default:
		//		if(lParam&1<<30)
		//			return 0;
		//		break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
#endif
			//t2d_h
#if 0
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
				if(!kb[wParam])
					++kp;
				if(!time_variance&&!timer)
					SetTimer(ghWnd, 0, 10, 0), timer=true;
				return 0;
			case VK_ADD:case VK_OEM_PLUS:case VK_RETURN:
				if(kb[VK_CONTROL])
					_3d.faster();
				else if(kb[VK_SHIFT])
				{
					Yplaces=++Xplaces, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_SUBTRACT:case VK_OEM_MINUS:case VK_BACK:
				if(kb[VK_CONTROL])
					_3d.slower();
				else if(kb[VK_SHIFT])
				{
					if(Xplaces>1)
						Yplaces=--Xplaces, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case 'X':case 'Y':case 'Z':
				if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case VK_OEM_3:
				if(contourOn)//was on
				{
					if(kb[VK_CONTROL])
					{
						//contour+surface
						//contour only
						//flat contour
						//flat+surface
						if(contourFlat)
						{
							if(contourOnly)
								contourOnly=false;//3: surface appears
							else
								contourFlat=false;//4: pops up
						}
						else
						{
							if(contourOnly)
								contourFlat=true;//2: gets flat
							else
								contourOnly=true;//1: surface disappears
						}
					}
					else
						contourOn=false, contourOnly=false, contourFlat=false;
				}
				else//was off
				{
					contourOn=true;
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						double Xs=DX/Xplaces, DZ=DX/AR_Z;
						doContour(cursorEx, Xs, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				{
					double r=20/DX;
					VX*=r, VY*=r, VZ*=r;
					_3d.camx*=r, _3d.camy*=r, _3d.camz*=r, _3d.dcam*=r;
					DX=20, AR_Y=1, AR_Z=1, function1();
					toSolve=true, shiftOnly=0;
				}
				break;
			case 'R':
				_3d.dcam=.04;
				if(!kb[VK_CONTROL])
					DX=20, AR_Y=1, AR_Z=1, function1(), Xplaces=Yplaces=100;
				if(VX!=0||VY!=0||VZ!=0)
					VX=VY=VZ=0;
				toSolve=true, shiftOnly=0;
				if(kb['X'])
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
				else if(kb['Y'])
					_3d.teleport_degrees(0, 20, 0, 270, 0, 1);
				else if(kb['Z'])
					_3d.teleport_degrees(0, 0, 20, 90, 270, 1);
				else
					_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
			/*	if(kb[VK_CONTROL])
				{
					DX=20, DY=20, function1();
					toSolve=true, shiftOnly=0;
				}
				if(VX!=0||VY!=0||VZ!=0)
				{
					VX=VY=VZ=0;
					toSolve=true, shiftOnly=0;
				}
				_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);//*/
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
#endif
			//c3d
#if 0
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
				if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_ADD:case VK_OEM_PLUS:case VK_RETURN:
				if(kb[VK_CONTROL])
					_3d.faster();
				else if(kb[VK_SHIFT])//increase resolution
				{
					Zplaces=Yplaces=++Xplaces, toSolve=true, shiftOnly=0;
					//int oldXplaces=Xplaces;
					//Xplaces=int(1.5*Xplaces);
					//if(Xplaces==oldXplaces)
					//	++Xplaces;
					//Zplaces=Yplaces=Xplaces;
					//toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_SUBTRACT:case VK_OEM_MINUS:case VK_BACK:
				if(kb[VK_CONTROL])
					_3d.slower();
				else if(kb[VK_SHIFT])//decrease resolution
				{
					if(Xplaces>1)
						Zplaces=Yplaces=--Xplaces, toSolve=true, shiftOnly=0;
					//int oldXplaces=Xplaces;
					//Xplaces=int(Xplaces/1.5);
					//if(Xplaces==oldXplaces&&Xplaces!=1)
					//	--Xplaces;
					//Zplaces=Yplaces=Xplaces;
					//toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case 'X':case 'Y':case 'Z':
				if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case VK_OEM_3:
				if(contourOn)//was on
				{
					if(kb[VK_CONTROL])
					{
						//contour+surface
						//contour only
						//flat contour
						//flat+surface
						if(contourFlat)
						{
							if(contourOnly)
								contourOnly=false;//3: surface appears
							else
								contourFlat=false;//4: pops up
						}
						else
						{
							if(contourOnly)
								contourFlat=true;//2: gets flat
							else
								contourOnly=true;//1: surface disappears
						}
					}
					else
						contourOn=false, contourOnly=false, contourFlat=false;
				}
				else//was off
				{
					contourOn=true;
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
						doContour(cursorEx, DX/Xplaces, -DX/2, +DX/2, Xstep, 2);
					}
				}
				break;
			case '0':case VK_NUMPAD0:
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
			case '7':case VK_NUMPAD7:
			case '8':case VK_NUMPAD8:
				{
					auto op=&Color_3D::differentiate_xyz;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back( 1), op=&Color_3D::differentiate_xyz;
																else			operations.push_back( 5), op=&Color_3D::differentiate_xy;}
											else			{		 if(kb['Z'])operations.push_back( 7), op=&Color_3D::differentiate_xz;
																else			operations.push_back( 2), op=&Color_3D::differentiate_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back( 6), op=&Color_3D::differentiate_yz;
																else			operations.push_back( 3), op=&Color_3D::differentiate_y;}
											else			{		 if(kb['Z'])operations.push_back( 4), op=&Color_3D::differentiate_z;
																else			operations.push_back( 1), op=&Color_3D::differentiate_xyz;}}
						break;
					case '2':case VK_NUMPAD2:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back( 8), op=&Color_3D::integrate_xyz;
																else			operations.push_back(12), op=&Color_3D::integrate_xy;}
											else			{		 if(kb['Z'])operations.push_back(14), op=&Color_3D::integrate_xz;
																else			operations.push_back( 9), op=&Color_3D::integrate_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back(13), op=&Color_3D::integrate_yz;
																else			operations.push_back(10), op=&Color_3D::integrate_y;}
											else			{		 if(kb['Z'])operations.push_back(11), op=&Color_3D::integrate_z;
																else			operations.push_back( 8), op=&Color_3D::integrate_xyz;}}
						break;
					case '3':case VK_NUMPAD3:	operations.push_back(15), op=&Color_3D::discreteFourrierTransform;			break;
					case '4':case VK_NUMPAD4:	operations.push_back(16), op=&Color_3D::inverseDiscreteFourrierTransform;	break;
					case '5':case VK_NUMPAD5:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back(17), op=&Color_3D::lowPassFilter_xyz;
																else			operations.push_back(21), op=&Color_3D::lowPassFilter_xy;}
											else			{		 if(kb['Z'])operations.push_back(23), op=&Color_3D::lowPassFilter_xz;
																else			operations.push_back(18), op=&Color_3D::lowPassFilter_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back(22), op=&Color_3D::lowPassFilter_yz;
																else			operations.push_back(19), op=&Color_3D::lowPassFilter_y;}
											else			{		 if(kb['Z'])operations.push_back(20), op=&Color_3D::lowPassFilter_z;
																else			operations.push_back(17), op=&Color_3D::lowPassFilter_xyz;}}
						break;
					case '6':case VK_NUMPAD6:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back(24), op=&Color_3D::highPassFilter_xyz;
																else			operations.push_back(28), op=&Color_3D::highPassFilter_xy;}
											else			{		 if(kb['Z'])operations.push_back(30), op=&Color_3D::highPassFilter_xz;
																else			operations.push_back(25), op=&Color_3D::highPassFilter_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back(29), op=&Color_3D::highPassFilter_yz;
																else			operations.push_back(26), op=&Color_3D::highPassFilter_y;}
											else			{		 if(kb['Z'])operations.push_back(27), op=&Color_3D::highPassFilter_z;
																else			operations.push_back(24), op=&Color_3D::highPassFilter_xyz;}}
						break;
					}
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
						(this->*op)(expr[cursorEx].n[0].ndr);
						if(contourOn)
							doContour(cursorEx, DX/Xplaces, -DX/2, +DX/2, Xstep, 2);
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				{
					double r=20/DX;
					VX*=r, VY*=r, VZ*=r;
					_3d.camx*=r, _3d.camy*=r, _3d.camz*=r, _3d.dcam*=r;
					DX=20, AR_Y=1, AR_Z=1, function1();
					toSolve=true, shiftOnly=0;
				}
				break;
			case 'R':
				_3d.dcam=.04;
				if(!kb[VK_CONTROL])
					DX=20, AR_Y=1, AR_Z=1, function1(), Xplaces=Yplaces=Zplaces=10;
				if(VX!=0||VY!=0||VZ!=0)
					VX=VY=VZ=0;
				toSolve=true, shiftOnly=0;
				if(kb['X'])
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
				else if(kb['Y'])
					_3d.teleport_degrees(0, 20, 0, 270, 0, 1);
				else if(kb['Z'])
					_3d.teleport_degrees(0, 0, 20, 90, 270, 1);
				else
					_3d.teleport_degrees(20, 20, 20, 225, 324.7356103172454, 1);
				//	_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
			/*	if(kb[VK_CONTROL])
				{
					DX=20, DY=20, DZ=20, function1();
					toSolve=true, shiftOnly=0;
				}
				if(VX!=0||VY!=0||VZ!=0)
				{
					VX=VY=VZ=0;
					toSolve=true, shiftOnly=0;
				}
				_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);//*/
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
#endif
		}
#endif
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
				if(kp>0)
					--kp;
				return 0;
		//	case VK_CONTROL:
		//		kp+=kb[VK_ADD]+kb[VK_SUBTRACT]+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]+kb[VK_RETURN]+kb[VK_BACK];
		//		if(!time_variance&&!timer)
		//			SetTimer(ghWnd, 0, 10, 0), timer=true;
		//		return 0;
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[VK_CONTROL]&&kp>0)
					--kp;
				return 0;
			case 'X':
				if(!kb['Y']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Y':
				if(!kb['X']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Z':
				if(!kb['X']&&!kb['Y']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
		/*	case 'X':case 'Y':case 'Z':
				if(shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;*/
			}
			return 0;
		}
		void function1()
		{
			double t=100*DX/w;
			Xstep=exp(floor(log10(t))*log(10));
			switch(int(t/Xstep))
			{
			case 1:Xstep*=1;break;
			case 2:Xstep*=2;break;
			case 3:Xstep*=2;break;
			case 4:Xstep*=2;break;
			case 5:Xstep*=5;break;
			case 6:Xstep*=5;break;
			case 7:Xstep*=5;break;
			case 8:Xstep*=5;break;
			case 9:Xstep*=5;break;
			default:Xstep*=6;break;
			}
			if(AR_Y==1)
				Ystep=Xstep;
			else
			{
				double t=100*DX/(w*AR_Y);
				Ystep=exp(floor(log10(t))*log(10));
				switch(int(t/Ystep))
				{
				case 1:Ystep*=1;break;
				case 2:Ystep*=2;break;
				case 3:Ystep*=2;break;
				case 4:Ystep*=2;break;
				case 5:Ystep*=5;break;
				case 6:Ystep*=5;break;
				case 7:Ystep*=5;break;
				case 8:Ystep*=5;break;
				case 9:Ystep*=5;break;
				default:Ystep*=6;break;
				}
			}
			if(AR_Z==1)
				Zstep=Xstep;
			else
			{
				double t=100*DX/(w*AR_Z);
				Zstep=exp(floor(log10(t))*log(10));
				switch(int(t/Zstep))
				{
				case 1:Zstep*=1;break;
				case 2:Zstep*=2;break;
				case 3:Zstep*=2;break;
				case 4:Zstep*=2;break;
				case 5:Zstep*=5;break;
				case 6:Zstep*=5;break;
				case 7:Zstep*=5;break;
				case 8:Zstep*=5;break;
				case 9:Zstep*=5;break;
				default:Zstep*=6;break;
				}
			}
		}
		//draw
	};
#endif

	class		Numeric_0D:public Mode
	{
		TextBox tb;
	public:
	//	int toSolve;
		int toPrint;
	//	int bpx, bpy, bw, bh;
		Solve_0D solver;
		int base;
		
		Labels_0D labels;
		static const std::set<int> modes;

	//	char line[128];
	//	int linelen;
		bool drag;

		Numeric_0D():toPrint(false), drag(false), base(10){}
	//	Numeric_0D():toSolve(0), drag(0), base(10){}
		void enter()
		{
			tb.active=true;
			tb.setDimensions(bpx, bpy, bw, bh);
			if(kb[VK_LBUTTON])
			{
				if(tb.switchToWithMouseOn(oldMouse))
					a_draw();
			}
		}
		void exit()
		{
			if(kb[VK_LBUTTON])
			{
			//	ReleaseCapture();
				tb.inputLButtonUp();
			}
			tb.active=false;
			tb.setDimensions(bpx+bw/2, bpy, bw/2, bh);
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(!toSolve)//toCheck?
			{
				time_variance=0;

				labels.clear();

				tb.text=(char*)realloc(tb.text, ((tb.textlen=0)+1)*sizeof(char));
				const int aSize=1024;
				char a[aSize];
				int alen;

				solver.synchronize();
				for(unsigned k=0;k<expr.size();++k)
				{
					auto &ex=expr[k];
					if(ex.rmode[0]==1)
					{
						time_variance|=ex.nITD;
						labels.fill(k);

						alen=0;
						ex.n[0].ndr[0].print(a, alen, ex.resultMathSet);
					//	ex.n[0].ndr[0].print(a, alen, ex.n[0].mathSet);
						append(tb.text, tb.textlen, a, alen);
						for(++k;k<expr.size();++k)
						{
							auto &ex=expr[k];
							if(ex.rmode[0]==1)
							{
								time_variance|=ex.nITD;
								labels.fill(k);

								alen=sprintf_s(a, "\r\n");
								ex.n[0].ndr[0].print(a, alen, ex.resultMathSet);
							//	ex.n[0].ndr[0].print(a, (alen=0)+=sprintf_s(a+alen, aSize-alen, "\r\n"), ex.n[0].mathSet);

								append(tb.text, tb.textlen, a, alen);
							}
						}
						break;
					}
				}
			}
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				drag=0;
				ReleaseCapture();
				tb.inputLButtonUp();
			}
		}
		void appActivate(){}

		void setDimentions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h, ready=true;
			if(active)
				tb.setDimensions(bpx, bpy, bw, bh);
			else
				tb.setDimensions(bpx+bw/2, bpy, bw/2, bh);
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimentions(x, y, w, h);
			if(!time_variance)
				a_draw();
		}
		void messageTimer(){a_draw();}
		int inputLButtonDown(int lParam)
		{
			drag=1;
			SetCapture(ghWnd);
			if(tb.inputLButtonDown(lParam))
				a_draw();
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(tb.inputMouseMove(lParam))
				a_draw();
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			drag=0;
			ReleaseCapture();
			tb.inputLButtonUp();
		}
		int inputMouseWheel(int wParam)
		{
			if(tb.inputMouseWheel(wParam))
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case '1':
				if(base!=2)
				{
					base=2;
					if(!toSolve)
						print();
					a_draw();
				}
				return 0;
			case '2':
				if(base!=8)
				{
					base=8;
					if(!toSolve)
						print();
					a_draw();
				}
				return 0;
			case '3':case '0':
				if(base!=10)
				{
					base=10;
					if(!toSolve)
						print();
					a_draw();
				}
				return 0;
			case '4':
				if(base!=16)
				{
					base=16;
					if(!toSolve)
						print();
					a_draw();
				}
				return 0;
		/*	case 'D':
				if(kb[VK_CONTROL])//copy with results
				{
					if(tb.cursor!=tb.selcur)
					{
						int k=tb.cursor<tb.selcur?tb.cursor:tb.selcur, k2=tb.cursor>tb.selcur?tb.cursor:tb.selcur;
						char *clipboard=(char*)LocalAlloc(LMEM_FIXED, (k2-k+1)*sizeof(char));
						memcpy(clipboard, &tb.text[k], (k2-k)*sizeof(char));
						clipboard[k2-k]='\0';
						OpenClipboard(ghWnd), EmptyClipboard(), SetClipboardData(CF_OEMTEXT, (void*)clipboard), CloseClipboard();
					}
				}
				return 0;//*/
			}
			if(tb.inputKeyDown(wParam, lParam)||wParam==VK_ESCAPE&&modes::ready)
				a_draw();
			return 0;
		}
		int inputKeyUp(int wParam){return 0;}
		void print()
		{
			tb.text=(char*)realloc(tb.text, ((tb.textlen=0)+1)*sizeof(char));
			const int aSize=1024;
			char a[aSize];
			if(!paused)
				solver.synchronize();
			for(unsigned k=0;k<expr.size();++k)
			{
				auto &ex=expr[k];
				if(ex.rmode[0]==1)
				{
					int alen=0;
					ex.n[0].ndr[0].print(a, alen, ex.resultMathSet, base);
				//	ex.n[0].ndr[0].print(a, alen, ex.n[0].mathSet, base);
					append(tb.text, tb.textlen, a, alen);
					for(++k;k<expr.size();++k)
					{
						auto &ex=expr[k];
						if(ex.rmode[0]==1)
						{
							alen=sprintf_s(a, "\r\n");
							ex.n[0].ndr[0].print(a, alen, ex.resultMathSet, base);
						//	ex.n[0].ndr[0].print(a, alen, ex.n[0].mathSet, base);
							append(tb.text, tb.textlen, a, alen);
						}
					}
					break;
				}
			}
		}
		void draw()
		{
			if(toSolve)
			{
				auto old_time_variance=time_variance;
				time_variance=false;
			//	std::fill(nExpr.begin(), nExpr.end(), 0);
				labels.clear();
			//	print();
				tb.text=(char*)realloc(tb.text, ((tb.textlen=0)+1)*sizeof(char));
				const int aSize=1024;
				char a[aSize];
				int alen;
				if(!paused)
					solver.synchronize();
				for(unsigned k=0;k<expr.size();++k)
				{
					auto &ex=expr[k];
				//	++nExpr[ex.rmode[0]];
					if(ex.rmode[0]==1)
					{
						time_variance|=ex.nITD;
						solver.full(ex);
						labels.fill(k);
						alen=0;
						ex.n[0].ndr[0].print(a, alen, ex.resultMathSet, base);
					//	ex.n[0].ndr[0].print(a, alen, ex.n[0].mathSet, base);
						append(tb.text, tb.textlen, a, alen);
						for(++k;k<expr.size();++k)
						{
							auto &ex=expr[k];
						//	++nExpr[ex.rmode[0]];
							if(ex.rmode[0]==1)
							{
								time_variance|=ex.nITD;
								solver.full(ex);
								labels.fill(k);
								alen=sprintf_s(a, "\r\n");
								ex.n[0].ndr[0].print(a, alen, ex.resultMathSet, base);
							//	ex.n[0].ndr[0].print(a, alen, ex.n[0].mathSet, base);
							//	ex.n[0].ndr[0].print(a, (alen=0)+=sprintf_s(a+alen, aSize-alen, "\r\n"), ex.n[0].mathSet);
								append(tb.text, tb.textlen, a, alen);
							}
						}
						break;
					}
				}//*/
				if(time_variance)
				{
					if(!paused)
						SetTimer(ghWnd, 0, 10, 0);
				}
				else if(old_time_variance)
					KillTimer(ghWnd, 0);
				toSolve=false;
			//	if(tb.cursor>tb.textlen)
					tb.cursor=tb.selcur=0;
			}
			else if(time_variance)
			{
			//	print();
				tb.text=(char*)realloc(tb.text, ((tb.textlen=0)+1)*sizeof(char));
				const int aSize=1024;
				char a[aSize];
				int alen;
				if(!paused)
					solver.synchronize();
				for(unsigned k=0;k<expr.size();++k)
				{
					auto &ex=expr[k];
					if(ex.rmode[0]==1)
					{
						if(ex.nITD)
							solver.full(ex);
						ex.n[0].ndr[0].print(a, alen=0, ex.resultMathSet, base);
					//	ex.n[0].ndr[0].print(a, alen=0, ex.n[0].mathSet, base);
						append(tb.text, tb.textlen, a, alen);
						for(++k;k<expr.size();++k)
						{
							auto &ex=expr[k];
							if(ex.rmode[0]==1)
							{
								if(ex.nITD)
									solver.full(ex);
								alen=sprintf_s(a, aSize, "\r\n");
								ex.n[0].ndr[0].print(a, alen, ex.resultMathSet, base);
							//	ex.n[0].ndr[0].print(a, alen, ex.n[0].mathSet, base);
								append(tb.text, tb.textlen, a, alen);
							}
						}
						break;
					}
				}//*/
				if(tb.cursor>tb.textlen)
					tb.cursor=tb.selcur=0;
			}
			else if(toPrint)
				print();
			toPrint=false;
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			if(active)
			//	tb.setDimensions(bpx, bpy, bw, bh);
				tb.draw();
			else
			{
			//	tb.setDimensions(bpx+bw/2, bpy, bw/2, bh);
				SetTextColor(ghMemDC, 0x00777777);
				HPEN__ *hPen=(HPEN__*)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, 0x00777777));
				if(labels.colored)
					tb.draw_corresponding_color(modes, &::itb);
				else
					tb.draw_corresponding(modes, &::itb);
				DeleteObject(SelectObject(ghMemDC, hPen));
				SetTextColor(ghMemDC, 0);
			}
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int Ys=0;
				auto colorCondition=nExpr[1]>1;
				int textColor;
				if(colorCondition)
					textColor=GetTextColor(ghMemDC);
				for(auto &label:labels.Clabels)
				{
					if(colorCondition)
						SetTextColor(ghMemDC, expr[label.exNo].winColor);
					int linelen=sprintf_s(g_buf, g_buf_size, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
					TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen);
				//	linelen=sprintf_s(line, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
				//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, line, linelen);
					Ys+=16;
				}
				if(colorCondition)
					SetTextColor(ghMemDC, textColor);
			}
			switch(base)
			{
			case 2:
				GUIPrint(ghMemDC, w-const_label_offset_X, h-16, "binary");
				break;
			case 8:
				GUIPrint(ghMemDC, w-const_label_offset_X, h-16, "octal");
				break;
			case 16:
				GUIPrint(ghMemDC, w-const_label_offset_X, h-16, "hexadecimal");
				break;
			}
		}
		void i_draw();
		void a_draw();
	} n0d;
	const std::set<int> Numeric_0D::modes({1});//C++11
	void			Numeric_0D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				std::copy(rgb, rgb+w*h, modeRGB);
			
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, OPAQUE);
				itb.draw();
				SetBkMode(ghMemDC, bkMode);
			}
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);

			if(showBenchmark)
				Performance(0, h-32);//
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		}
		else
		{
			std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Numeric_0D::a_draw()
	{
		Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();

		if(showBenchmark)
			Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
	class		Implicit_1D:public Mode
	{
	public:
	//	int toSolve;
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		int Xoffset, exprRemoved;
	//	int bpx, bpy, bh, bw;

		int Xplaces;
		double VX, DX, step;
		int prec;
		Solve_1D_Implicit solver;
		
		_2D _2d;
		bool clearScreen;
		Labels_1D labels;
		static const std::set<int> modes;
		HPEN__ *hPen;
		HBRUSH__ *hBrush;

	//	char line[128];
	//	int linelen;
		bool timer, drag, m_bypass;
		int kp;

		Implicit_1D():
			VX(0), DX(20),
		//	bpx(0), bpy(0), bw(0), bh(0),
			timer(false), drag(false), m_bypass(false), kp(0),
			shiftOnly(2), Xoffset(0), exprRemoved(0),
		//	toSolve(1), shiftOnly(2), Xoffset(0),
			clearScreen(false)
		{
			hPen=CreatePen(PS_SOLID, 1, _2dCheckColor), hBrush=CreateSolidBrush(_2dCheckColor);
		}
		~Implicit_1D(){DeleteObject(hPen), DeleteObject(hBrush);}

		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
				drag=1;
			}
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag)
			{
				drag=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		
		void setDimentions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h;
			function1();
			toSolve=true, shiftOnly=0;
			ready=true;
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimentions(x, y, w, h);
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
		}
		void messageTimer()
		{
			if(_2d_drag_graph_not_window)
			{
				if(kb[VK_LEFT		]){	VX+=DX/w*10, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_RIGHT		]){	VX-=DX/w*10, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_UP			]){	itb.tpy+=10;	if(itb.tpy>itb.th-h	)itb.tpy=itb.th-h;}//VY-=DX/w*10;
				if(kb[VK_DOWN		]){	itb.tpy-=10;	if(itb.tpy<0		)itb.tpy=0;}//VY+=DX/w*10;
			}
			else
			{
				if(kb[VK_LEFT		]){	VX-=DX*10/w, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_RIGHT		]){	VX+=DX*10/w, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_UP			]){	itb.tpy-=10;	if(itb.tpy<0		)itb.tpy=0;}//VY+=DX*10/w;
				if(kb[VK_DOWN		]){	itb.tpy+=10;	if(itb.tpy>itb.th-h	)itb.tpy=itb.th-h;}//VY-=DX*10/w;
			}
			if(kb[VK_ADD		]||kb[VK_OEM_PLUS	]||kb[VK_RETURN	])	DX/=1.05, function1(), toSolve=true, shiftOnly=0;
			if(kb[VK_SUBTRACT	]||kb[VK_OEM_MINUS	]||kb[VK_BACK	])	DX*=1.05, function1(), toSolve=true, shiftOnly=0;
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
				SetCapture(ghWnd);
				drag=1;
				if(!time_variance&&!timer)
				{
					POINT p=centerP;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=short(p.x), ((short*)&oldMouse)[1]=short(p.y);
					a_draw();
				}
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			bool draw=false;
			if(drag)
			{
				if(!m_bypass)
				{
					int dx=((short*)&lParam)[0]-w/2, dy=h/2-((short*)&lParam)[1];
					if(_2d_drag_graph_not_window)
						dx=-dx, dy=-dy;
					VX+=DX/w*dx, itb.tpy-=dy;//, VY+=DX/w*dy;
					if(itb.tpy<0)
						itb.tpy=0;
					else if(itb.tpy>itb.th-h)
						itb.tpy=itb.th-h;
					toSolve=true;
					if(shiftOnly)
						shiftOnly=1, Xoffset+=dx;
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						draw=true;
				}
				m_bypass=!m_bypass;
			}
			if(draw)
				a_draw();
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
				if(!time_variance&&!timer)
				{
					POINT p=mouseP0;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=(short)p.x, ((short*)&oldMouse)[1]=(short)p.y;
					a_draw();
				}
			}
		}
		int inputMouseWheel(int wParam)
		{
			double dx=DX*(((short*)&oldMouse)[0]-w/2)/w, dy=DX*(h/2-((short*)&oldMouse)[1])/w;
				 if(((short*)&wParam)[1]>0)	VX=VX+dx-dx/1.1, DX/=1.1;//, VY=VY+dy-dy/1.1;
			else							VX=VX+dx-dx*1.1, DX*=1.1;//, VY=VY+dy-dy*1.1;
			function1();
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT:
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[wParam])
					++kp;
				if(!time_variance&&!timer)
					SetTimer(ghWnd, 0, 10, 0), timer=true;
				return 0;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'R':
				if(!kb[VK_CONTROL])
					DX=20, function1();
				VX=0;
				toSolve=true, shiftOnly=0;
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(kp)//start+key
					--kp;
				return 0;
			}
			return 0;
		}
		void function1(){derive_step(DX, w, step, prec);}
		void draw()
		{
			double Xr=w/DX;
			if(!clearScreen)
			{
				hPen=(HPEN__*)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH__*)SelectObject(ghMemDC, hBrush);
				{
					double Xstart=VX-DX/2, Xstepx2=2*step;
					for(double x=floor(Xstart/Xstepx2)*Xstepx2, xEnd=ceil((VX+DX/2)/step)*step;x<xEnd;x+=Xstepx2)
					{
						double x1=(x-Xstart)*Xr, x2=(x+step-Xstart)*Xr;
					//	Rectangle(ghMemDC, int(x1)-(x1<0)+1, 0, int(x2)-(x2<0)+1, h);
						Rectangle(ghMemDC, int(x1)-(x1<0), 0, int(x2)-(x2<0), h);
					}
				}
				hPen=(HPEN__*)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH__*)SelectObject(ghMemDC, hBrush);
			}
			if(toSolve)
			{
				if(shiftOnly==1&&abs(Xoffset)<Xplaces)
				{
					if(Xoffset)
					{
						solver.partial_bounds(VX, DX, Xoffset);
						solver.synchronize();
						for(auto &ex:expr)
						{
							if(ex.rmode[0]==10)
							{
								if(ex.nITD)
									solver.full(ex);
								else
									solver.partial(ex);
							}
							//	(solver.*(ex.nITD?&Solve_1D_Implicit::full:&Solve_1D_Implicit::partial))(ex);
						}
					}
				}
				else
				{
					auto old_time_variance=time_variance;
					time_variance=false;
				//	std::fill(nExpr.begin(), nExpr.end(), 0);
					labels.clear();
					solver.full_resize(VX, DX, Xplaces=w);
					if(!paused)
						solver.synchronize();
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
					//	++nExpr[ex.rmode[0]];
						if(ex.rmode[0]==10)
						{
							time_variance|=ex.nITD;
							labels.fill(e);
							solver.full(ex);
						}
					}
					if(time_variance)
					{
						if(!paused)
							SetTimer(ghWnd, 0, 10, 0);
					}
					else if(old_time_variance&&!timer)
						KillTimer(ghWnd, 0);
				}
				toSolve=false, shiftOnly=2, Xoffset=0;
				exprRemoved=false;
			}
			else if(exprRemoved)
			{
				auto old_time_variance=time_variance;
				time_variance=false;
			//	std::fill(nExpr.begin(), nExpr.end(), 0);
				labels.clear();
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
				//	++nExpr[ex.rmode[0]];
					if(ex.rmode[0]==10)
					{
						time_variance|=ex.nITD;
						labels.fill(e);
					}
				}
				if(old_time_variance&&!time_variance&&!timer)
					KillTimer(ghWnd, 0);
				exprRemoved=false;
			}
			else if(time_variance)
			{
				if(!paused)
					solver.synchronize();
				for(auto &ex:expr)
					if(ex.rmode[0]==10&&ex.nITD)
						solver.full(ex);
			}
			int colorCondition=nExpr[10]>1;
			if(!clearScreen)
			{
				int H=h/2+1;
			//	int H=h/2;
			//	int H=h*3/4;
			//	int H=!drag&&((short*)&oldMouse)[1]>h/2?h/4:h*3/4;
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, TRANSPARENT);
				for(double x=floor(solver.Xstart/step)*step, xEnd=ceil((VX+DX/2)/step)*step, step_2=step/2;x<xEnd;x+=step)
				{
					int linelen=x>-step_2&&x<step_2?
							sprintf_s(g_buf, 128, "0")
						:	sprintf_s(g_buf, 128, "%g", x);
					double X=(x-solver.Xstart)*Xr;
					TextOutA(ghMemDC, int(X)-(X<0)+2, H, g_buf, linelen);
				//	linelen=x>-step_2&&x<step_2?
				//			sprintf_s(line, 128, "0")
				//		:	sprintf_s(line, 128, "%g", x);
				//	double X=(x-solver.Xstart)*Xr;
				//	TextOutA(ghMemDC, int(X)-(X<0)+2, H, line, linelen);
				}
				{
					int textColor;
					if(colorCondition)
						textColor=GetTextColor(ghMemDC);
					int Ys=H+(H>h-46?-34:18)-2, Ys0=Ys;
				//	int Ys=H+(H>h-46?-34:18), Ys0=Ys;
					for(auto &label:labels.Xlabels)
					{
						if(colorCondition)
							SetTextColor(ghMemDC, expr[label.exNo].winColor);
						TextOutA(ghMemDC, w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					}
					Ys=Ys0>h/3?0:h-16*labels.Clabels.size();
					for(auto &label:labels.Clabels)
					{
						if(colorCondition)
							SetTextColor(ghMemDC, expr[label.exNo].winColor);
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen);
					//	linelen=sprintf_s(line, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, line, linelen);
						Ys+=16;
					}
					if(colorCondition)
						SetTextColor(ghMemDC, textColor);
				}
				SetBkMode(ghMemDC, bkMode);
			}
			if(colorCondition)//draw the solutions
			{
				for(auto &ex:expr)
			//	for(int e=0, eEnd=expr.size();e<eEnd;++e)
				{
				//	auto &ex=expr[e];
					if(ex.rmode[0]==10)
					{
						auto &ndr=ex.n[0].ndr;
						int y_eStart=ex.lineNo*font.H-itb.tpy, y_eEnd=(ex.endLineNo+1)*font.H;
					//	int yStart=ex.lineNo*font.H-itb.tpy, yEnd=(e+1<(signed)expr.size()?expr[e+1].lineNo:nLines)*font.H;
					//	int yStart=ex.lineNo*font.H-itb.tpy, yEnd=yStart+font.H;
						if(y_eStart<0)
							y_eStart=0;
						if(y_eEnd<0)
							y_eEnd=0;
						if(y_eEnd>h)
							y_eEnd=h;
						auto color=(unsigned char*)&ex.color;
						double Ab=(0xFF-color[0])/510., Ag=(0xFF-color[1])/510., Ar=(0xFF-color[2])/510.;
						if(ex.resultLogicType==2)//= equations aa		several color
					//	if(ex.resultLogicType>=2)
						{
							for(int x=0;x<w;++x)
						//	for(int x=0, xEnd=ndr.size()-2;x<xEnd;++x)
							{
								auto a=ndr[x].r;
							//	for(int y=y_eStart;y<h;++y)
								for(int y=y_eStart;y<y_eEnd;++y)
								{
									auto px=(unsigned char*)&rgb[w*y+x];
									px[0]-=unsigned char(Ab*a*px[0]);
									px[1]-=unsigned char(Ag*a*px[1]);
									px[2]-=unsigned char(Ar*a*px[2]);
								}
								a/=2;
								for(int y=y_eEnd;y<h;++y)
								{
									auto px=(unsigned char*)&rgb[w*y+x];
									px[0]-=unsigned char(a*px[0]);
									px[1]-=unsigned char(a*px[1]);
									px[2]-=unsigned char(a*px[2]);
								}//*/
							}
						}
						else if(ex.resultLogicType==3)//!=		aa inverted		several color
						{
							double Bb=1-Ab, Bg=1-Ag, Br=1-Ar;
							for(int x=0;x<w;++x)
						//	for(int x=0, xEnd=ndr.size()-2;x<xEnd;++x)
							{
								auto a=ndr[x].r;
							//	for(int y=y_eStart;y<h;++y)
								for(int y=y_eStart;y<y_eEnd;++y)
								{
									auto px=(unsigned char*)&rgb[w*y+x];
									px[0]=unsigned char((Bb+Ab*a)*px[0]);
									px[1]=unsigned char((Bg+Ag*a)*px[1]);
									px[2]=unsigned char((Br+Ar*a)*px[2]);
								}
								a=(1+a)/2;
								for(int y=y_eEnd;y<h;++y)
								{
									auto px=(unsigned char*)&rgb[w*y+x];
									px[0]=unsigned char(a*px[0]);
									px[1]=unsigned char(a*px[1]);
									px[2]=unsigned char(a*px[2]);
								}//*/
							}
						}
						else//&& ## || < <= > >= logic/inequality		several color
						{
							for(int x=0;x<w;++x)
						//	for(int x=0, xEnd=ndr.size();x<xEnd;++x)
							{
								if(ndr[x].r)
								{
								//	for(int y=y_eStart;y<h;++y)
									for(int y=y_eStart;y<y_eEnd;++y)
									{
										auto px=(unsigned char*)&rgb[w*y+x];
										px[0]-=unsigned char(Ab*px[0]);
										px[1]-=unsigned char(Ag*px[1]);
										px[2]-=unsigned char(Ar*px[2]);
									}
									for(int y=y_eEnd;y<h;++y)
									{
										auto px=(unsigned char*)&rgb[w*y+x];
										px[0]/=2;
										px[1]/=2;
										px[2]/=2;
									}//*/
								}
							}
						}
					}
				}
			}
			else
			{
				for(auto &ex:expr)
				{
					if(ex.rmode[0]==10)
					{
						auto &ndr=ex.n[0].ndr;
						if(ex.resultLogicType==2)//= equation aa	one greyscale
					//	if(ex.resultLogicType>=2)
						{
							for(int x=0;x<w;++x)
						//	for(int x=0, xEnd=ndr.size()-2;x<xEnd;++x)
							{
								auto &a=ndr[x].r;
								for(int y=0;y<h;++y)
								{
									auto p0=(unsigned char*)&rgb[w*y+x];
									p0[0]-=unsigned char(p0[0]*a)/2;
									p0[1]-=unsigned char(p0[1]*a)/2;
									p0[2]-=unsigned char(p0[2]*a)/2;
								}
							}
						}
						else if(ex.resultLogicType==3)//!=	aa inverted	one greyscale
						{
							for(int x=0;x<w;++x)
						//	for(int x=0, xEnd=ndr.size()-2;x<xEnd;++x)
							{
								auto a=(1+ndr[x].r)/2;
								for(int y=0;y<h;++y)
								{
									auto p0=(unsigned char*)&rgb[w*y+x];
									p0[0]=unsigned char(p0[0]*a);
									p0[1]=unsigned char(p0[1]*a);
									p0[2]=unsigned char(p0[2]*a);
								}
							}
						}
						else//&& ## || < <= > >= logic/inequality	one greyscale
						{
							for(int x=0;x<w;++x)
						//	for(int x=0, xEnd=ndr.size();x<xEnd;++x)
							{
								if(ndr[x].r)
								{
									for(int y=0;y<h;++y)
									{
										auto p0=(unsigned char*)&rgb[w*y+x];
										p0[0]/=2;
										p0[1]/=2;
										p0[2]/=2;
									}
								}
							}
						}
					}
				}
			}//*/
		/*	if(colorCondition)//draw the solutions
			{
				for(auto &ex:expr)
				{
					if(ex.rmode[0]==10)
					{
						auto &ndr=ex.n[0].ndr;
						auto c=(unsigned char*)&ex.color;
						if(ex.resultLogicType>=2)//anti-aliasing
						{
							int yStart=ex.lineNo*font.H-itb.tpy, yEnd=yStart+font.H;
							if(yStart<0)
								yStart=0;
							if(yEnd>h)
								yEnd=h;
							if(yEnd<0)
								yEnd=0;
							for(int x=0, xEnd=ndr.size()-1;x<xEnd;++x)
							{
								auto &a=ndr[x].r;
								if(a==0)
								{
									for(int y=yStart;y<yEnd;++y)
										rgb[w*y+x]=ex.color;
								//	if(0<yStart)
								//		MoveToEx(ghMemDC, x, 0, 0), LineTo(ghMemDC, x, yStart);
									if(yEnd<h)
										MoveToEx(ghMemDC, x, yEnd, 0), LineTo(ghMemDC, x, h);
								}
								else if(a<1)
								{
									double _1_a=1-a;
									unsigned char c0=(unsigned char)(c[0]*_1_a), c1=(unsigned char)(c[1]*_1_a), c2=(unsigned char)(c[2]*_1_a);
									for(int y=yStart;y<yEnd;++y)
									{
										auto p0=(unsigned char*)&rgb[w*y+x];
										p0[0]=unsigned char(p0[0]*a)+c0;
										p0[1]=unsigned char(p0[1]*a)+c1;
										p0[2]=unsigned char(p0[2]*a)+c2;
									}
									//for(int y=0;y<yStart;++y)
									//{
									//	auto p0=(unsigned char*)&rgb[w*y+x];
									//	p0[0]=unsigned char(p0[0]*a);
									//	p0[1]=unsigned char(p0[1]*a);
									//	p0[2]=unsigned char(p0[2]*a);
									//}
									for(int y=yEnd;y<h;++y)
									{
										auto p0=(unsigned char*)&rgb[w*y+x];
										p0[0]=unsigned char(p0[0]*a);
										p0[1]=unsigned char(p0[1]*a);
										p0[2]=unsigned char(p0[2]*a);
									}
								}
							}
						}
						else
						{
							for(int v=0, vEnd=ndr.size();v<vEnd;++v)
								if(ndr[v].r)
									MoveToEx(ghMemDC, v, 0, 0), LineTo(ghMemDC, v, h);
							if(colorCondition)
							{
								int yStart=ex.lineNo*font.H-itb.tpy;
								HPEN hPen=(HPEN)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, ex.winColor));
								for(int v=0, vEnd=ndr.size();v<vEnd;++v)
									if(ndr[v].r)
										MoveToEx(ghMemDC, v, yStart, 0), LineTo(ghMemDC, v, yStart+font.H);
								DeleteObject(SelectObject(ghMemDC, hPen));
							}
						}
					}
				}
			}
			else
			{
				for(auto &ex:expr)
				{
					if(ex.rmode[0]==10)
					{
						auto &ndr=ex.n[0].ndr;
						if(ex.resultLogicType>=2)//anti-aliasing
						{
							int yStart=ex.lineNo*font.H-itb.tpy, yEnd=yStart+font.H;
							if(yStart<0)
								yStart=0;
							if(yEnd>h)
								yEnd=h;
							for(int x=0, xEnd=ndr.size()-1;x<xEnd;++x)
							{
								auto &a=ndr[x].r;
								if(a==0)
									MoveToEx(ghMemDC, x, 0, 0), LineTo(ghMemDC, x, h);
								else if(a<1)
								{
									for(int y=0;y<h;++y)
									{
										auto p0=(unsigned char*)&rgb[w*y+x];
										p0[0]=unsigned char(p0[0]*a);
										p0[1]=unsigned char(p0[1]*a);
										p0[2]=unsigned char(p0[2]*a);
									}
								}
							}
						}
						else
						{
							for(int v=0, vEnd=ndr.size();v<vEnd;++v)
								if(ndr[v].r)
									MoveToEx(ghMemDC, v, 0, 0), LineTo(ghMemDC, v, h);
						}
					}
				}
			}//*/
		/*	for(auto &ex:expr)//draw the solutions
			{
				if(ex.rmode[0]==10)
				{
					auto &ndr=ex.n[0].ndr;
					if(ex.resultLogicType>=2)
					{
						for(int x=0, xEnd=ndr.size()-1;x<xEnd;++x)
						{
							auto &a=ndr[x].r;
							if(a==0)
								MoveToEx(ghMemDC, x, 0, 0), LineTo(ghMemDC, x, h);
							else if(a<1)
							{
								for(int y=0;y<h;++y)
								{
									auto p0=(unsigned char*)&rgb[w*y+x];
									p0[0]=unsigned char(p0[0]*a);
									p0[1]=unsigned char(p0[1]*a);
									p0[2]=unsigned char(p0[2]*a);
								}
							}
							//if(ndr[x].r!=1)
							//{
							//	auto &a=ndr[x].r;
							//	for(int y=0;y<h;++y)
							//	{
							//		auto p0=(unsigned char*)&rgb[w*y+x];
							//		p0[0]*=a;
							//		p0[1]*=a;
							//		p0[2]*=a;
							//	}
							//}
						}
						if(colorCondition)
						{
							int Ystart=ex.lineNo*font.H-itb.tpy;
							if(Ystart<0)
								Ystart=0;
							if(Ystart<h)
							{
								int Yend=Ystart+font.H;
								if(Yend>h)
									Yend=h;
								auto c=(unsigned char*)&ex.color;
								for(int x=0, xEnd=ndr.size()-1;x<xEnd;++x)
								{
									auto &a=ndr[x].r;
									if(a==0)
										for(int y=Ystart;y<Yend;++y)
											rgb[w*y+x]=ex.color;
									else if(a<1)
									{
										double _1_a=1-a;
										unsigned char c0=(unsigned char)(c[0]*_1_a), c1=(unsigned char)(c[1]*_1_a), c2=(unsigned char)(c[2]*_1_a);
										for(int y=Ystart;y<Yend;++y)
										{
											auto p0=(unsigned char*)&rgb[w*y+x];
											p0[0]=unsigned char(p0[0]*a)+c0;
											p0[1]=unsigned char(p0[1]*a)+c1;
											p0[2]=unsigned char(p0[2]*a)+c2;
										}
									}
									//if(ndr[x].r<1)
									//{
									//	auto &a=ndr[x].r;
									//	double _1_a=1-a;
									//	unsigned char c0=c[0]*_1_a, c1=c[1]*_1_a, c2=c[2]*_1_a;
									//	for(int y=Ystart;y<Yend;++y)
									//	{
									//		auto p0=(unsigned char*)&rgb[w*y+x];
									//		p0[0]=p0[0]*a+c0;
									//		p0[1]=p0[1]*a+c1;
									//		p0[2]=p0[2]*a+c2;
									//	}
									//}
								}
							}
						}
					}
					else
					{
						for(int v=0, vEnd=ndr.size();v<vEnd;++v)
							if(ndr[v].r)
								MoveToEx(ghMemDC, v, 0, 0), LineTo(ghMemDC, v, h);
						if(colorCondition)
						{
							int Ystart=ex.lineNo*font.H-itb.tpy;
							HPEN hPen=(HPEN)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, ex.winColor));
							for(int v=0, vEnd=ndr.size();v<vEnd;++v)
								if(ndr[v].r)
									MoveToEx(ghMemDC, v, Ystart, 0), LineTo(ghMemDC, v, Ystart+font.H);
							DeleteObject(SelectObject(ghMemDC, hPen));
						}
					}
				}
			}//*/
		}
		void i_draw();
		void a_draw();
	} ti1d;
	const std::set<int> Implicit_1D::modes({10});
	void			Implicit_1D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				std::copy(rgb, rgb+w*h, modeRGB);

			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, OPAQUE);
				if(nExpr[10]>1)
					itb.draw_color(modes);
				else
					itb.draw();
				SetBkMode(ghMemDC, bkMode);
			}
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		}
		else
		{
			std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Implicit_1D::a_draw()
	{
		Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
	class		Numeric_1D:public Mode
	{
		TextBox tb;
	public:
	//	int toSolve;
	//	int bpx, bpy, bw, bh;
		Solve_1D solver;

		bool drag;

		Numeric_1D():drag(false){}
	//	Numeric_1D():toSolve(0), drag(0){}

		void enter(){}
		void exit(){}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				ReleaseCapture();
				tb.inputLButtonUp();
			}
		}
		void appActivate(){}

		void setDimentions(int x, int y, int w, int h){tb.setDimensions(x, y, w, h);}
		void messagePaint(){}
		void messageTimer(){}
		int inputLButtonDown(int lParam){}
		int inputMouseMove(int lParam){}
		void inputLButtonUp(int lParam){}
		int inputMouseWheel(int wParam){}
		int inputKeyDown(int wParam, int lParam){}
		int inputKeyUp(int wParam){}
		void draw()
		{
			tb.textlen=0, tb.text=(char*)realloc(tb.text, (tb.textlen+1)*sizeof(char));
			const int aSize=1024;
			char a[aSize];
			int alen;
			Expression *exprk=&expr[cursorEx];
			if(exprk->n[0].ndr.size())
			{
				switch(exprk->resultMathSet)
			//	switch(exprk->n[0].mathSet)
				{
				case 'r':
			//	case 'R':
					alen=0;
					exprk->n[0].ndr[0].printReal(a, alen);
					append(tb.text, tb.textlen, a, alen);
					for(unsigned k=1;k<exprk->n[0].ndr.size();++k)
					{
						alen=0;
						alen+=sprintf_s(a+alen, aSize-alen, "\r\n");
						exprk->n[0].ndr[k].printReal(a, alen);
						append(tb.text, tb.textlen, a, alen);
					}
					break;
				case 'c':
			//	case 'C':
					alen=0;
					exprk->n[0].ndr[0].printComplex(a, alen);
					append(tb.text, tb.textlen, a, alen);
					for(unsigned k=1;k<exprk->n[0].ndr.size();++k)
					{
						alen=0;
						alen+=sprintf_s(a+alen, aSize-alen, "\r\n");
						exprk->n[0].ndr[k].printComplex(a, alen);
						append(tb.text, tb.textlen, a, alen);
					}
					break;
				case 'H':
					alen=0;
					exprk->n[0].ndr[0].printQuaternion(a, alen);
					append(tb.text, tb.textlen, a, alen);
					for(unsigned k=1;k<exprk->n[0].ndr.size();++k)
					{
						alen=0;
						alen+=sprintf_s(a+alen, aSize-alen, "\r\n");
						exprk->n[0].ndr[k].printQuaternion(a, alen);
						append(tb.text, tb.textlen, a, alen);
					}
					break;
				}
			}
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			if(active)
				tb.draw();
			else
			{
				SetTextColor(ghMemDC, 0x00777777);
				HPEN__ *hPen=(HPEN__*)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, 0x00777777));
				tb.draw();
				DeleteObject(SelectObject(ghMemDC, hPen));
				SetTextColor(ghMemDC, 0);
			}
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
		}
		void i_draw();
		void a_draw();
	};
	void			Numeric_1D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				std::copy(rgb, rgb+w*h, modeRGB);

			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, OPAQUE);
				itb.draw();
				SetBkMode(ghMemDC, bkMode);
			}
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		}
		else
		{
			std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Numeric_1D::a_draw()
	{
		Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(showBenchmark)
			Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}

	bool		difference_t1d_t1dc();
	class		Transverse_1D:public Mode
	{
	public:
	//	int toSolve;
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		int Xoffset, exprRemoved;
	//	int bpx, bpy, bh, bw;

		int Xplaces;
		double VX, VY, DX, AR_Y, Xstep, Ystep;
		int prec;
		Solve_1D_Disc solver;
		std::list<int> operations;
		bool drawImag;
		
		int contourOn, contourOnly;
		//contours[e]=contour, contour[y level (y/step)]=points, *points.begin()=x pos
		std::map<unsigned, std::unordered_map<int, std::list<double>>> contours;

		_2D _2d;
		bool clearScreen;
		Labels_1D labels;
		static const std::set<int> modes;
		HPEN__ *hPen;
		HBRUSH__ *hBrush;

	//	char line[128];
	//	int linelen;
		bool timer, drag, m_bypass;
		int kp;
		friend bool difference_t1d_t1dc();

		Transverse_1D():
			VX(0), VY(0), DX(20), AR_Y(1),
		//	bpx(0), bpy(0), bw(0), bh(0),
			timer(false), drag(false), m_bypass(false), kp(0),
			shiftOnly(2), Xoffset(0), exprRemoved(0),
		//	toSolve(1), shiftOnly(2), Xoffset(0),
			drawImag(false),
			contourOnly(false),
			clearScreen(false)
		{
			hPen=CreatePen(PS_SOLID, 1, _2dCheckColor), hBrush=CreateSolidBrush(_2dCheckColor);
		}
		~Transverse_1D(){DeleteObject(hPen), DeleteObject(hBrush);}
		
		void doContour(unsigned e, double Xs, double Ystart, double Yend, double Ystep, unsigned nySteps)
		{
			auto &ndr=expr[e].n[0].ndr;
			auto &contour=contours[e];
			double YLstart=std::ceil((Ystart-10*Xs)/Ystep)*Ystep, YLend=std::ceil((Yend+25*Xs)/Ystep)*Ystep;
			for(unsigned v=0, vEnd=ndr.size()-1;v<vEnd;++v)
			{
				auto &V1=(double)ndr[v], &V2=(double)ndr[v+1];
				double Y1, Y2;
				if(V1<V2)
					Y1=V1, Y2=V2;
				else
					Y1=V2, Y2=V1;
				for(int y=int(std::floor((Y1>YLstart?Y1:YLstart)/Ystep)), yEnd=int(std::floor((Y2<YLend?Y2:YLend)/Ystep));y<=yEnd;++y)
				{
					double YL=Ystep*y;
					if(Y1<=YL&&YL<Y2)
						contour[y].push_back(solver.Xstart+Xs*(v+(YL-V1)/(V2-V1)));
				}
			}
		}
		void differentiate						(std::vector<Value> &ndr)
		{
			double step=DX/Xplaces;
			for(unsigned k=0;k<ndr.size()-1;++k)
				ndr[k]=((double)ndr[k+1]-(double)ndr[k])/step;
			(double)*ndr.rbegin()/=-step;
		}
		void integrate							(std::vector<Value> &ndr)
		{
		/*	double step=DX/Xplaces;
			auto &V0=ndr[0].r;
			double sum=V0!=V0?0:V0;
			ndr[0].r=sum*step;
			for(unsigned k=1;k<ndr.size();++k)
			{
				auto &V=ndr[k].r;
				sum+=V!=V?0:V;
				ndr[k].r=sum*step;
			}//*/
			double step=DX/Xplaces;
			double sum=0;
			for(unsigned k=0;k<ndr.size();++k)
			{
				sum+=ndr[k].r;
				ndr[k].r=sum*step;
			}//*/
		/*	double step=DX/Xplaces;
			double sum(0);
			for(unsigned k=0;k<ndr.size();++k)
			{
				sum+=(double)ndr[k];
				ndr[k]=sum*step;
			}//*/
		}
		fftw_complex *fft_in, *fft_out;
		fftw_plan fft_p, ifft_p;
		unsigned fft_N;
		double fft_sqrt_N;
		void discreteFourrierTransform			(std::vector<Value> &ndr)
		{
			if(fft_N!=Xplaces)
			{
				if(fft_N)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_in=(fftw_complex*)fftw_malloc((fft_N=Xplaces)*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(fft_N*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt(fft_N);
				fft_p=fftw_plan_dft_1d(fft_N, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE), ifft_p=fftw_plan_dft_1d(fft_N, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
			for(unsigned k=0;k<fft_N;++k)
				fft_in[k][0]=ndr[k].r, fft_in[k][1]=ndr[k].i;
			fftw_execute(fft_p);

			int fft_N_2=fft_N/2;
			for(int k=0, k2=fft_N-fft_N_2;k<fft_N_2;++k, ++k2)
				ndr[k].r=fft_out[k2][0]/fft_sqrt_N, ndr[k].i=fft_out[k2][1]/fft_sqrt_N;
			for(unsigned k=fft_N_2, k2=0;k<fft_N;++k, ++k2)
				ndr[k].r=fft_out[k2][0]/fft_sqrt_N, ndr[k].i=fft_out[k2][1]/fft_sqrt_N;
		//	for(unsigned k=0;k<fft_N;++k)
		//		ndr[k].r=fft_out[k][0]/fft_sqrt_N, ndr[k].i=fft_out[k][1]/fft_sqrt_N;
		}
		void inverseDiscreteFourrierTransform	(std::vector<Value> &ndr)
		{
			if(fft_N!=Xplaces)
			{
				if(fft_N)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_in=(fftw_complex*)fftw_malloc((fft_N=Xplaces)*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(fft_N*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt(fft_N);
				fft_p=fftw_plan_dft_1d(fft_N, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE), ifft_p=fftw_plan_dft_1d(fft_N, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}

			int fft_N_2=fft_N/2;
			for(int k=0, k2=fft_N-fft_N_2;k<fft_N_2;++k, ++k2)
				fft_in[k2][0]=ndr[k].r, fft_in[k2][1]=ndr[k].i;
			for(unsigned k=fft_N_2, k2=0;k<fft_N;++k, ++k2)
				fft_in[k2][0]=ndr[k].r, fft_in[k2][1]=ndr[k].i;
		//	for(unsigned k=0;k<fft_N;++k)
		//		fft_in[k][0]=ndr[k].r, fft_in[k][1]=ndr[k].i;
			fftw_execute(ifft_p);
			for(unsigned k=0;k<fft_N;++k)
				ndr[k].r=fft_out[k][0]/fft_sqrt_N, ndr[k].i=fft_out[k][1]/fft_sqrt_N;
		}
		void lowPassFilter						(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			double sum(0);
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		/*	int T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=0;k<T/2;++k)
				sum+=(decltype(sum))ndr[k];
			for(unsigned k=0;k<T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[k+T/2];
			for(unsigned k=T/2;k<ndr.size()-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[k+T/2]-t0[(k-T/2)%T];
			for(unsigned k=ndr.size()-T/2;k<ndr.size();++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum-=t0[(k-T/2)%T];//*/
		}
		void highPassFilter						(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			double sum(0);
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		/*	int T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=0;k<T/2;++k)
				sum+=(decltype(sum))ndr[k];
			for(unsigned k=0;k<T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[k+T/2];
			for(unsigned k=T/2;k<ndr.size()-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[k+T/2]-t0[(k-T/2)%T];
			for(unsigned k=ndr.size()-T/2;k<ndr.size();++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum-=t0[(k-T/2)%T];//*/
		}

		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
				drag=1;
			}
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag)
			{
				drag=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}

		void function1();
		void setDimentions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h;
			function1();
			toSolve=true, shiftOnly=0;
			ready=true;
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimentions(x, y, w, h);
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
		}
		void messageTimer()
		{
			if(_2d_drag_graph_not_window)
			{
				if(kb[VK_LEFT		]){	VX+=10*DX/w, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_RIGHT		]){	VX-=10*DX/w, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_UP			])	VY-=10*DX/(w*AR_Y);
				if(kb[VK_DOWN		])	VY+=10*DX/(w*AR_Y);
			}
			else
			{
				if(kb[VK_LEFT		]){	VX-=10*DX/w, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_RIGHT		]){	VX+=10*DX/w, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_UP			])	VY+=10*DX/(w*AR_Y);
				if(kb[VK_DOWN		])	VY-=10*DX/(w*AR_Y);
			}
			if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])
			{
				if(kb['X'])
					DX/=1.05, AR_Y/=1.05;
				else if(kb['Y'])
					AR_Y*=1.05;
				else
					DX/=1.05;
				function1(), toSolve=true, shiftOnly=0;
			}
			if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])
			{
				if(kb['X'])
					DX*=1.05, AR_Y*=1.05;
				else if(kb['Y'])
					AR_Y/=1.05;
				else
					DX*=1.05;
				function1(), toSolve=true, shiftOnly=0;
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
				SetCapture(ghWnd);
				drag=1;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=centerP;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=short(p.x), ((short*)&oldMouse)[1]=short(p.y);
					a_draw();
				}
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			bool draw=false;
			if(drag)
			{
				if(!m_bypass)
				{
					int dx=((short*)&lParam)[0]-w/2, dy=h/2-((short*)&lParam)[1];
					if(_2d_drag_graph_not_window)
						dx=-dx, dy=-dy;
					VX+=dx*DX/w, VY+=dy*DX/(w*AR_Y);
					toSolve=true;
					if(shiftOnly)
						shiftOnly=1, Xoffset+=dx;
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						draw=true;
				}
				m_bypass=!m_bypass;
			}
			if(contourOn&&!time_variance&&!timer)
				oldMouse=lParam, draw=true;
			if(draw)
				a_draw();
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=mouseP0;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=(short)p.x, ((short*)&oldMouse)[1]=(short)p.y;
					a_draw();
				}
			}
		}
		int inputMouseWheel(int wParam)
		{
			double dx=(((short*)&oldMouse)[0]-w/2)*DX/w, dy=(h/2-((short*)&oldMouse)[1])*DX/(w*AR_Y);
			if(kb['X'])
			{
					 if(((short*)&wParam)[1]>0)	DX/=1.1, AR_Y/=1.1, VX=VX+dx-dx/1.1;
				else							DX*=1.1, AR_Y*=1.1, VX=VX+dx-dx*1.1;
			}
			else if(kb['Y'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Y*=1.1, VY=VY+dy-dy/1.1;
				else							AR_Y/=1.1, VY=VY+dy-dy*1.1;
			}
			else
			{
					 if(((short*)&wParam)[1]>0)	DX/=1.1, VX=VX+dx-dx/1.1, VY=VY+dy-dy/1.1;
				else							DX*=1.1, VX=VX+dx-dx*1.1, VY=VY+dy-dy*1.1;
			}
			function1();
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[wParam])
					++kp;
				if(!time_variance&&!timer)
					SetTimer(ghWnd, 0, 10, 0), timer=true;
				return 0;
			case VK_OEM_3://~	contour
				if(contourOn)//was on
				{
					if(kb[VK_CONTROL])
						contourOnly=!contourOnly;
					else
						contourOn=false;
				}
				else//was off
				{
					contourOn=true, contourOnly=false;//turn contour on
					if(!toSolve)
					{
						contours.clear();
						double Xs=DX/Xplaces, DY=DX*h/(w*AR_Y);
						for(unsigned e=0;e<expr.size();++e)
							if(expr[e].rmode[0]==2)
								doContour(e, Xs, VY-DY/2, VY+DY/2, Ystep, 10);
					}
				}
				break;
			case '0':case VK_NUMPAD0://reset
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				drawImag=false;
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
				contours.clear();
				{
					auto op=&Transverse_1D::differentiate;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:operations.push_back(1), op=&Transverse_1D::differentiate;										break;
					case '2':case VK_NUMPAD2:operations.push_back(2), op=&Transverse_1D::integrate;											break;
					case '3':case VK_NUMPAD3:operations.push_back(3), op=&Transverse_1D::discreteFourrierTransform,			drawImag=true;	break;
					case '4':case VK_NUMPAD4:operations.push_back(4), op=&Transverse_1D::inverseDiscreteFourrierTransform,	drawImag=true;	break;
					case '5':case VK_NUMPAD5:operations.push_back(5), op=&Transverse_1D::lowPassFilter;										break;
					case '6':case VK_NUMPAD6:operations.push_back(6), op=&Transverse_1D::highPassFilter;									break;
					}
					double Xs=DX/Xplaces, DY=DX*h/(w*AR_Y);
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if(ex.rmode[0]==2)
						{
							(this->*op)(ex.n[0].ndr);
							if(contourOn)
								doContour(e, Xs, VY-DY/2, VY+DY/2, Ystep, 10);
						}
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				DX=20, AR_Y=1, function1();
				toSolve=true, shiftOnly=0;
				break;
			case 'R':
				if(!kb[VK_CONTROL])
					DX=20, AR_Y=1, function1();
				VX=VY=0;
				toSolve=true, shiftOnly=0;
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(kp)//start+key
					--kp;
				return 0;
			}
			return 0;
		}
		void draw()
		{
			double DY=DX*h/(w*AR_Y);
			if(DY<=0)
				DY=1;
			_2dMode_DrawCheckboard(hPen, hBrush, VX, VY, DX, DY, Xstep, Ystep);
			if(toSolve)
			{
				if(!operations.size()&&shiftOnly==1&&abs(Xoffset)<Xplaces)
				{
					if(Xoffset)
					{
						solver.partial_bounds(VX, DX, Xoffset);
						solver.synchronize();
						for(auto &ex:expr)
						{
							if(ex.rmode[0]==2)
							{
								if(ex.nITD)
									solver.full(ex);
								else
									solver.partial(ex);
							}
							//	(solver.*(ex.nITD?&Solve_1D_Disc::full:&Solve_1D_Disc::partial))(ex);
						}
					}
				}
				else
				{
					auto old_time_variance=time_variance;
					time_variance=false;
				//	std::fill(nExpr.begin(), nExpr.end(), 0);
					labels.clear();
					solver.full_resize(VX, DX, Xplaces=w);
					if(!paused)
						solver.synchronize();
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
					//	++nExpr[ex.rmode[0]];
						if(ex.rmode[0]==2)
						{
							time_variance|=ex.nITD;
							labels.fill(e);
							solver.full(ex);
							for(auto &operation:operations)
							{
								switch(operation)
								{
								case 1:differentiate					(ex.n[0].ndr);break;
								case 2:integrate						(ex.n[0].ndr);break;
								case 3:discreteFourrierTransform		(ex.n[0].ndr);break;
								case 4:inverseDiscreteFourrierTransform	(ex.n[0].ndr);break;
								case 5:lowPassFilter					(ex.n[0].ndr);break;
								case 6:highPassFilter					(ex.n[0].ndr);break;
								}
							}
						}
					}
					if(time_variance)
					{
						if(!paused)
							SetTimer(ghWnd, 0, 10, 0);
					}
					else if(old_time_variance&&!timer)
						KillTimer(ghWnd, 0);
				}
				if(contourOn)
				{
					contours.clear();
					double Xs=DX/Xplaces;//, DY=DX*h/(w*AR_Y);
					for(unsigned e=0;e<expr.size();++e)
						if(expr[e].rmode[0]==2)
							doContour(e, Xs, VY-DY/2, VY+DY/2, Ystep, 10);
				}
				toSolve=false, shiftOnly=2, Xoffset=0;
			}
			else if(exprRemoved)
			{
				auto old_time_variance=time_variance;
				time_variance=false;
			//	std::fill(nExpr.begin(), nExpr.end(), 0);
				labels.clear();
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
				//	++nExpr[ex.rmode[0]];
					if(ex.rmode[0]==2)
					{
						time_variance|=ex.nITD;
						labels.fill(e);
					}
				}
				if(old_time_variance&&!time_variance&&!timer)
					KillTimer(ghWnd, 0);
				exprRemoved=false;
			}
			else if(time_variance)
			{
				if(!paused)
					solver.synchronize();
				for(auto &ex:expr)
				{
					if(ex.rmode[0]==2&&ex.nITD)
					{
						solver.full(ex);
						for(auto &operation:operations)
						{
							switch(operation)
							{
							case 1:differentiate					(ex.n[0].ndr);break;
							case 2:integrate						(ex.n[0].ndr);break;
							case 3:discreteFourrierTransform		(ex.n[0].ndr);break;
							case 4:inverseDiscreteFourrierTransform	(ex.n[0].ndr);break;
							case 5:lowPassFilter					(ex.n[0].ndr);break;
							case 6:highPassFilter					(ex.n[0].ndr);break;
							}
						}
					}
				}
				if(contourOn)
				{
					double Xs=DX/Xplaces;//, DY=DX*h/(w*AR_Y);
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if(ex.rmode[0]==2&&ex.nITD)
							doContour(e, Xs, VY-DY/2, VY+DY/2, Ystep, 10);
					}
				}
			}
			else if(nExpr[3]&&difference_t1d_t1dc())
			{
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==2&&!ex.nITD)
					{
						solver.full(ex);
						for(auto &operation:operations)
						{
							switch(operation)
							{
							case 1:differentiate					(ex.n[0].ndr);break;
							case 2:integrate						(ex.n[0].ndr);break;
							case 3:discreteFourrierTransform		(ex.n[0].ndr);break;
							case 4:inverseDiscreteFourrierTransform	(ex.n[0].ndr);break;
							case 5:lowPassFilter					(ex.n[0].ndr);break;
							case 6:highPassFilter					(ex.n[0].ndr);break;
							}
						}
					}
				}
			}
			int colorCondition=nExpr[2]>1;
			if(!clearScreen)
			{
				int bkMode=GetBkMode(ghMemDC);
				int H=0, V=0, VT=0;
				_2dMode_NumberAxes(VX, VY, DX, DY, Xstep, Ystep, prec, H, V, VT);
				MoveToEx(ghMemDC, 0, H, 0), LineTo(ghMemDC, w, H), MoveToEx(ghMemDC, V, 0, 0), LineTo(ghMemDC, V, h);
				{
					int textColor;
					if(colorCondition)
						textColor=GetTextColor(ghMemDC);
					int Ys=H+(H>h-46?-34:18), Ys0=Ys;
					for(auto &label:labels.Xlabels)
					{
						if(colorCondition)
							SetTextColor(ghMemDC, expr[label.exNo].winColor);
						TextOutA(ghMemDC, w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					}
					Ys=Ys0>h/3?0:h-16*labels.Clabels.size();
					for(auto &label:labels.Clabels)
					{
						if(colorCondition)
							SetTextColor(ghMemDC, expr[label.exNo].winColor);
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen);
					//	linelen=sprintf_s(line, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, line, linelen);
						Ys+=16;
					}
					if(colorCondition)
						SetTextColor(ghMemDC, textColor);
				}
				SetBkMode(ghMemDC, bkMode);
			}
			HPEN hGPen=0;
			int colored=0;
			double Yend=VY+DY/2, Yr=h/DY;
			if(!contourOnly)//draw the curves
			{
				if(operations.size())
				{
					for(auto &ex:expr)
					{
						if(ex.rmode[0]==2)
						{
							if(colorCondition)
								hGPen=(HPEN)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, ex.winColor)), _2d.lineColor=ex.color, colored=1;
							auto &ndr=ex.n[0].ndr;
							_2d.curve_start();
							for(int v=0, vEnd=ndr.size();v<vEnd;++v)
								_2d.curve_point(bpx+v, Yr*(Yend-ndr[v].r));
							_2d.set_point();
							if(drawImag)
							{
								_2d.curve_start();
								for(int v=0, vEnd=ndr.size();v<vEnd;++v)
									_2d.curve_point(bpx+v, Yr*(Yend-ndr[v].i));
								_2d.set_point();
								_2d.curve_start();
								for(int v=0, vEnd=ndr.size();v<vEnd;++v)
									_2d.curve_point(bpx+v, Yr*(Yend-ndr[v].i)+1);
								_2d.set_point();
							}
							if(colored)
								DeleteObject(SelectObject(ghMemDC, hGPen)), _2d.lineColor=0, colored=0;
						}
					}
				}
				else
				{
					for(auto &ex:expr)
					{
						if(ex.rmode[0]==2)
						{
							if(colorCondition)
								hGPen=(HPEN)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, ex.winColor)), _2d.lineColor=ex.color, colored=1;
							auto &ndr=ex.n[0].ndr;

							_2d.curve_start();
							for(int v=0, vEnd=ndr.size()-1;v<vEnd;++v)
							{
								_2d.curve_point(bpx+v, Yr*(Yend-ndr[v].r));
								if(ex.discontinuities[v])
									_2d.curve_start();
							}
							_2d.curve_point(bpx+Xplaces-1, Yr*(Yend-ndr[Xplaces-1].r));
							_2d.set_point();

							if(colored)
								DeleteObject(SelectObject(ghMemDC, hGPen)), _2d.lineColor=0, colored=0;
						}
					}
				}
			}
			if(contourOn)//draw contour
			{
				int mrX1=-60, mrX2=60, mrY1=-60, mrY2=60;
				auto &mx=((short*)&oldMouse)[0], &my=((short*)&oldMouse)[1];
				double Xstart=VX-DX/2;
				double Ystart=VY-DY/2, Yend=VY+DY/2;
				double Xs=DX/Xplaces, YLstart=std::ceil((Ystart-10*Xs)/Ystep)*Ystep;
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==2)
					{
						if(colorCondition)
							hGPen=(HPEN)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, ex.winColor)), _2d.lineColor=ex.color, colored=1;
						for(auto &L:contours[e])
						{
							double Y=L.first*Ystep;
							int y;
							{
								double _Y=(Yend-Y)*h/DY;
								y=int(_Y)-(_Y<0);
							}
						//	int y=int((Yend-Y)*h/DY);
							for(auto &X:L.second)
							{
								int x=int((X-Xstart)*w/DX);
								MoveToEx(ghMemDC, x-5, y, 0), LineTo(ghMemDC, x+5, y);
								MoveToEx(ghMemDC, x, y-5, 0), LineTo(ghMemDC, x, y+5);
								if(active&&x>=mx+mrX1&&x<mx+mrX2&&y>=my+mrY1&&y<my+mrY2)
									GUIPrint(ghMemDC, x, y, "%g, %g", X, Y);
							}
						}
						if(colored)
							DeleteObject(SelectObject(ghMemDC, hGPen)), _2d.lineColor=0, colored=0;
					}
				}
				{
					auto ClearDIBPixel=[&](int x, int y){if(x>=0&&x<w&&y>=0&&y<h)rgb[y*w+x]=0;};
					if(active)
					{
						if(drag)
						{
							int w_2=w/2, h_2=h/2;
							ClearDIBPixel(w_2+mrX1, h_2+mrY1), ClearDIBPixel(w_2+mrX2, h_2+mrY1);
							ClearDIBPixel(w_2+mrX1, h_2+mrY2), ClearDIBPixel(w_2+mrX2, h_2+mrY2);
						}
						else
						{
							ClearDIBPixel(mx+mrX1, my+mrY1), ClearDIBPixel(mx+mrX2, my+mrY1);
							ClearDIBPixel(mx+mrX1, my+mrY2), ClearDIBPixel(mx+mrX2, my+mrY2);
						}
					}
				}
			}
			{
				int k=0, Y=h-operations.size()*16;
				for(auto &operation:operations)
				{
					char const *a=0;
					switch(operation)
					{
					case 1:a="%d: Differentiate";break;
					case 2:a="%d: Integrate";break;
					case 3:a="%d: DFT";break;
					case 4:a="%d: IDFT";break;
					case 5:a="%d: LPF";break;
					case 6:a="%d: HPF";break;
					}
					GUIPrint(ghMemDC, w-const_label_offset_X, Y, a, k);
					++k, Y+=16;
				}
			}
		}
		void i_draw();
		void a_draw();
	} t1d;
	const std::set<int> Transverse_1D::modes({2});
	void			Transverse_1D::function1(){derive_step_2D(DX, AR_Y, w, Xstep, Ystep, prec, prec);}
	void			Transverse_1D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				std::copy(rgb, rgb+w*h, modeRGB);
		
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, OPAQUE);
				if(nExpr[2]>1)
					itb.draw_color(modes);
				else
					itb.draw();
				SetBkMode(ghMemDC, bkMode);
			}
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		}
		else
		{
			std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Transverse_1D::a_draw()
	{
		Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
	namespace contour
	{
		struct Double_x_i
		{
			double x, i;
			Double_x_i(double x, double i):x(x), i(i){}
		};
		struct Double_x_r
		{
			double x, r;
			Double_x_r(double x, double r):x(x), r(r){}
		};
	}
	class		Transverse_1D_C:public Mode
	{
	public:
	//	int toSolve;
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		int Xoffset, exprRemoved;
		int X0, Y0;
	//	int bpx, bpy, bh, bw, X0, Y0;

		int Xplaces;
		int KXplaces;
		double VX, VY, VZ, DX, AR_Y, AR_Z, Xstep, Ystep, Zstep;
		Solve_1D_Disc solver;
		std::list<int> operations;

		bool contourOn, contourOnly;
		//Rcontours[e]=Rcontour, Rcontour[r level (r/rStep)]=points, *points.begin()=(x,i)
		std::map<unsigned, std::unordered_map<int, std::list<contour::Double_x_i>>> Rcontours;
		//Icontours[e]=Icontour, Icontour[i level (i/iStep)]=points, *points.begin()=(x,r)
		std::map<unsigned, std::unordered_map<int, std::list<contour::Double_x_r>>> Icontours;
		
		_3D _3d;
		bool clearScreen, kb_VK_F6_msg;
		Labels_1D labels;
		int gridColor;
		static const std::set<int> modes;
		
	//	char line[128];
	//	int linelen;
		bool timer, drag, m_bypass, shift;
		int kp;
		friend bool difference_t1d_t1dc();

		Transverse_1D_C():
			VX(0), VY(0), VZ(0), DX(20), AR_Y(1), AR_Z(1),
			_3d(4, 4, 4, 225*G2::_pi/180, 324.7356103172454*G2::_pi/180, 1),
			gridColor(_3dGridColor),
			timer(false), m_bypass(false), drag(false), shift(false), kp(0),
			shiftOnly(2), Xoffset(0), exprRemoved(0),
		//	toSolve(1), shiftOnly(2), Xoffset(0),
			fft_N(0),
			contourOnly(false),
			clearScreen(false), kb_VK_F6_msg(false)
		{}
		~Transverse_1D_C()
		{
			if(fft_N)
			{
				fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
				fftw_free(fft_in), fftw_free(fft_out);
			}
		}
		
		void doContour(unsigned e, double Xs, double Rstart, double Rend, double Rstep, unsigned nrSteps, double Istart, double Iend, double Istep, unsigned niSteps)
		{
			using namespace contour;
			auto &ndr=expr[e].n[0].ndr;
			auto &Rcontour=Rcontours[e];
			auto &Icontour=Icontours[e];
			Rcontour.clear(), Icontour.clear();
			double RLstart=std::ceil((Rstart-10*Xs)/Rstep)*Rstep, RLend=std::ceil((Rend+25*Xs)/Rstep)*Rstep;
			double ILstart=std::ceil((Istart-10*Xs)/Istep)*Istep, ILend=std::ceil((Iend+25*Xs)/Istep)*Istep;
			for(unsigned v=0, vEnd=ndr.size()-1;v<vEnd;++v)
			{
				auto &V1=ndr[v], &V2=ndr[v+1];
				{
					double R1, R2;
					if(V1.r<V2.r)
						R1=V1.r, R2=V2.r;
					else
						R1=V2.r, R2=V1.r;
					for(int r=int(std::floor((R1<RLstart?RLstart:R1)/Rstep)), rEnd=int(std::floor((R2>RLend?RLend:R2)/Rstep));r<=rEnd;++r)
					{
						double RL=Rstep*r;
						if(R1<=RL&&RL<R2)
						{
							double M=(RL-V1.r)/(V2.r-V1.r);
							Rcontour[r].push_back(Double_x_i(solver.Xstart+Xs*(v+M), V1.i+(V2.i-V1.i)*M));
						}
					}
				}
				{
					double I1, I2;
					if(V1.i<V2.i)
						I1=V1.i, I2=V2.i;
					else
						I1=V2.i, I2=V1.i;
					for(int i=int(std::floor((I1<ILstart?ILstart:I1)/Istep)), iEnd=int(std::floor((I2>ILend?ILend:I2)/Istep));i<=iEnd;++i)
					{
						double IL=Istep*i;
						if(I1<=IL&&IL<I2)
						{
							double M=(IL-V1.i)/(V2.i-V1.i);
							Icontour[i].push_back(Double_x_r(solver.Xstart+Xs*(v+M), V1.r+(V2.r-V1.r)*M));
						}
					}
				}
			}
		}
		void differentiate						(std::vector<Value> &ndr)
		{
			double step=DX/Xplaces;
			for(unsigned k=0;k<ndr.size()-1;++k)
				ndr[k]=((std::complex<double>)ndr[k+1]-(std::complex<double>)ndr[k])/step;
			ndr.rbegin()->r/=-step, ndr.rbegin()->i/=-step;
		}
		void integrate							(std::vector<Value> &ndr)
		{
			double step=DX/Xplaces;
			std::complex<double> sum;
			for(unsigned k=0;k<ndr.size();++k)
			{
				sum+=(std::complex<double>)ndr[k];
				ndr[k]=sum*step;
			}
		}
		fftw_complex *fft_in, *fft_out;
		fftw_plan fft_p, ifft_p;
		unsigned fft_N;
		double fft_sqrt_N;
		void discreteFourrierTransform			(std::vector<Value> &ndr)
		{
			if(fft_N!=Xplaces)
			{
				if(fft_N)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_in=(fftw_complex*)fftw_malloc((fft_N=Xplaces)*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(fft_N*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt(fft_N);
				fft_p=fftw_plan_dft_1d(fft_N, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE), ifft_p=fftw_plan_dft_1d(fft_N, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
			for(unsigned k=0;k<fft_N;++k)
				fft_in[k][0]=ndr[k].r, fft_in[k][1]=ndr[k].i;
			fftw_execute(fft_p);
			for(unsigned k=0;k<fft_N;++k)
				ndr[k].r=fft_out[k][0]/fft_sqrt_N, ndr[k].i=fft_out[k][1]/fft_sqrt_N;
		/*	std::vector<std::complex<double>> t0(ndr.size());
			for(unsigned k=0;k<ndr.size();++k)
				t0[k]=(std::complex<double>)ndr[k];
			std::vector<std::complex<double>> t1(t0.size());
			for(unsigned k=0;k<t0.size();++k)
			{
				std::complex<double> p=-2*G2::_pi*std::complex<double>(0, 1)*double(k)/double(t0.size());
				for(unsigned k2=0;k2<t0.size();++k2)
					t1[k]+=t0[k2]*std::exp(p*double(k2));
				t1[k]/=t0.size();
			}
			for(unsigned k=0;k<ndr.size();++k)
				ndr[k]=t1[k];//*/
		}
		void inverseDiscreteFourrierTransform	(std::vector<Value> &ndr)
		{
			if(fft_N!=Xplaces)
			{
				if(fft_N)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_in=(fftw_complex*)fftw_malloc((fft_N=Xplaces)*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(fft_N*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt(fft_N);
				fft_p=fftw_plan_dft_1d(fft_N, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE), ifft_p=fftw_plan_dft_1d(fft_N, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
			for(unsigned k=0;k<fft_N;++k)
				fft_in[k][0]=ndr[k].r, fft_in[k][1]=ndr[k].i;
			fftw_execute(ifft_p);
			for(unsigned k=0;k<fft_N;++k)
				ndr[k].r=fft_out[k][0]/fft_sqrt_N, ndr[k].i=fft_out[k][1]/fft_sqrt_N;
		/*	std::vector<std::complex<double>> t0(ndr.size());
			for(unsigned k=0;k<ndr.size();++k)
				t0[k]=(std::complex<double>)ndr[k];
			std::vector<std::complex<double>> t1(t0.size());
			for(unsigned k=0;k<t0.size();++k)
			{
				std::complex<double> p=2*G2::_pi*std::complex<double>(0, 1)*double(k)/double(t0.size());
				for(unsigned k2=0;k2<t0.size();++k2)
					t1[k]+=t0[k2]*std::exp(p*double(k2));
			}
			for(unsigned k=0;k<ndr.size();++k)
				ndr[k]=t1[k];*/
		}
		void lowPassFilter						(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		/*	int T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=0;k<T/2;++k)
				sum+=(decltype(sum))ndr[k];
			for(unsigned k=0;k<T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[k+T/2];
			for(unsigned k=T/2;k<ndr.size()-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[k+T/2]-t0[(k-T/2)%T];
			for(unsigned k=ndr.size()-T/2;k<ndr.size();++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum-=t0[(k-T/2)%T];//*/
		/*	int T=10;
			std::complex<double> sum;
			std::vector<std::complex<double>> t0(ndr.size());
			for(unsigned k=0;k<t0.size();++k)
				t0[k]=(std::complex<double>)ndr[k];
			for(unsigned k=0;k<T/2;++k)
				sum+=t0[k];
			for(unsigned k=0;k<T/2;++k)
				t0[k]=sum/double(T), sum+=t0[k+1+T/2];
			for(unsigned k=T/2;k<t0.size()-T/2;++k)
				t0[k]=sum/double(T), sum+=t0[k+1+T/2]-(std::complex<double>)ndr[k-T/2];
			for(unsigned k=t0.size()-T/2;k<t0.size();++k)
				t0[k]=sum/double(T), sum-=(std::complex<double>)ndr[k-T/2];
			for(unsigned k=0;k<t0.size();++k)
				ndr[k]=t0[k];//*/
		/*	auto t=(std::complex<double>)ndr[0];
			for(unsigned k=0;k<ndr.size()-1;++k)
				ndr[k]=((std::complex<double>)ndr[k]+(std::complex<double>)ndr[k+1])/2.;
			ndr.rbegin()->operator=(t+(std::complex<double>)*ndr.rbegin())/2.;//*/
		}
		void highPassFilter						(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		/*	int T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=0;k<T/2;++k)
				sum+=(decltype(sum))ndr[k];
			for(unsigned k=0;k<T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[k+T/2];
			for(unsigned k=T/2;k<ndr.size()-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[k+T/2]-t0[(k-T/2)%T];
			for(unsigned k=ndr.size()-T/2;k<ndr.size();++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum-=t0[(k-T/2)%T];*/
		/*	auto t=(std::complex<double>)ndr[0];
			for(unsigned k=0;k<ndr.size()-1;++k)
				ndr[k]-=((std::complex<double>)ndr[k]+(std::complex<double>)ndr[k+1])/2.;
			ndr.rbegin()->operator-=(t+(std::complex<double>)*ndr.rbegin())/2.;*/
		}

		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
				drag=1;
			}
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
		//	kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]+kb[VK_ADD]+kb[VK_OEM_PLUS]+kb[VK_SUBTRACT]+kb[VK_OEM_MINUS];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag||shift)
			{
				drag=0, shift=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}

		void setDimentions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h, X0=bpx+bw/2, Y0=bpy+bh/2;
			_3d.setDimentions(x, y, w, h);
			double old_Ystep=Ystep, old_Zstep=Zstep;
			function1();
			if(!toSolve&&contourOn&&(old_Ystep!=Ystep||old_Zstep!=Zstep))
			{
				Rcontours.clear(), Icontours.clear();
				double Xs=DX/Xplaces, DY=DX/AR_Y, DZ=DX/AR_Z;
				for(unsigned e=0;e<expr.size();++e)
					if(expr[e].rmode[0]==2||expr[e].rmode[0]==3)
						doContour(e, Xs, VY-DY/2, VY+DY/2, Ystep, 10, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
			}
			ready=true;
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimentions(x, y, w, h);
			if(!time_variance&&!timer)
				a_draw();
		}
		void messageTimer()
		{
				 if(kb[VK_SHIFT	]){	 if(kb['W'])	_3d.moveForwardFast();
									 if(kb['A'])	_3d.moveLeftFast();
									 if(kb['S'])	_3d.moveBackFast();
									 if(kb['D'])	_3d.moveRightFast();
									 if(kb['T'])	_3d.camz+=10*_3d.dcam;
									 if(kb['G'])	_3d.camz-=10*_3d.dcam;}
			else				  {	 if(kb['W'])	_3d.moveForward();
									 if(kb['A'])	_3d.moveLeft();
									 if(kb['S'])	_3d.moveBack();
									 if(kb['D'])	_3d.moveRight();
									 if(kb['T'])	_3d.camz+=_3d.dcam;
									 if(kb['G'])	_3d.camz-=_3d.dcam;}
			double dVD=KXplaces*DX/Xplaces;
			if(kb['X'])
			{
				if(kb['Y'])
				{
					if(kb['Z'])
					{
					}
					else		//xy
					{
						if(kb[VK_UP])		VY+=dVD, _3d.camy+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])		VY-=dVD, _3d.camy-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT]){	VX+=dVD, _3d.camx+=_3d_shift_move_cam*dVD, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
						if(kb[VK_LEFT]){	VX-=dVD, _3d.camx-=_3d_shift_move_cam*dVD, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
				}
				else
				{
					if(kb['Z'])	//xz
					{
						if(kb[VK_UP])		VZ+=dVD, _3d.camz+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])		VZ-=dVD, _3d.camz-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT]){	VX+=dVD, _3d.camx+=_3d_shift_move_cam*dVD, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
						if(kb[VK_LEFT]){	VX-=dVD, _3d.camx-=_3d_shift_move_cam*dVD, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
					else		//x
					{
						if(kb[VK_UP]||kb[VK_RIGHT]){	VX+=dVD, _3d.camx+=_3d_shift_move_cam*dVD, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
						if(kb[VK_DOWN]||kb[VK_LEFT]){	VX-=dVD, _3d.camx-=_3d_shift_move_cam*dVD, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
				}
			}
			else
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//yz
					{
						if(kb[VK_UP])		VZ+=dVD, _3d.camz+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])		VZ-=dVD, _3d.camz-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])	VY+=dVD, _3d.camy+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])		VY-=dVD, _3d.camy-=_3d_shift_move_cam*dVD;
					}
					else		//y
					{
						if(kb[VK_UP]||kb[VK_RIGHT])		VY+=dVD, _3d.camy+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])	VY-=dVD, _3d.camy-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//z
					{
						if(kb[VK_UP]||kb[VK_RIGHT])		VZ+=dVD, _3d.camx+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])	VZ-=dVD, _3d.camx-=_3d_shift_move_cam*dVD;
					}
					else
					{
						if(kb[VK_UP])	_3d.rotateUp();
						if(kb[VK_DOWN])	_3d.rotateDown();
						if(kb[VK_RIGHT])_3d.rotateRight();
						if(kb[VK_LEFT])	_3d.rotateLeft();
					}
				}
			}
			if(kb[VK_ADD]||kb[VK_RETURN]||kb[VK_OEM_PLUS])
			{
				if(kb[VK_MENU])//alt+
				{
					if(_3d_zoom_move_cam)//zoom in
						DX/=1.1, _3d.camx=VX+(_3d.camx-VX)/1.1, _3d.camy=VY+(_3d.camy-VY)/1.1, _3d.camz=VZ+(_3d.camz-VZ)/1.1, _3d.dcam/=1.1;
					else//zoom out
						DX*=1.1;
					function1();
					toSolve=true, shiftOnly=0;
				}
				//	DX*=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['X'])//x+ stretch (zoom in (stretch), compress y, z)
				{
					if(_3d_stretch_move_cam)
						_3d.camx=VX+(_3d.camx-VX)/1.1;
					else
						_3d.camx/=1.1;
					_3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
				//	VX/=1.1;//
					VY/=1.1, VZ/=1.1;
#if 0
					if(_3d_stretch_move_cam)
					{
						_3d.camx=VX+(_3d.camx-VX)/1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
						DX/=1.1, AR_Y/=1.1, AR_Z/=1.1,	VY/=1.1, VZ/=1.1;//*/
					/*	_3d.camx=VX+(_3d.camx-VX)/1.1;
						_3d.camy=VY+(_3d.camy-VY)/1.1-VY/11.;
						_3d.camz=VZ+(_3d.camz-VZ)/1.1-VZ/11.;
						_3d.dcam/=1.1;
						DX/=1.1, AR_Y/=1.1, AR_Z/=1.1,	VY/=1.1, VZ/=1.1;//*/
					/*	_3d.camx=VX+(_3d.camx-VX)/1.1;
						_3d.camy=VY+(_3d.camy-VY)/1.1, _3d.camy-=VY/11.;
						_3d.camz=VZ+(_3d.camz-VZ)/1.1, _3d.camz-=VZ/11.;
						_3d.dcam/=1.1;
						DX/=1.1, AR_Y/=1.1, AR_Z/=1.1,	VY/=1.1, VZ/=1.1;//*/
					/*	DX/=1.1, _3d.camx=VX+(_3d.camx-VX)/1.1, _3d.camy=VY+(_3d.camy-VY)/1.1, _3d.camz=VZ+(_3d.camz-VZ)/1.1, _3d.dcam/=1.1;//zoom out
						_3d.camy-=VY/11., AR_Y/=1.1,	VY/=1.1;//stretch y
						_3d.camz-=VZ/11., AR_Z/=1.1,	VZ/=1.1;//stretch z
						function1();//*/
					/*	DX/=1.1, _3d.camx=VX+(_3d.camx-VX)/1.1, _3d.camy=VY+(_3d.camy-VY)/1.1, _3d.camz=VZ+(_3d.camz-VZ)/1.1, _3d.dcam/=1.1;//zoom out
						function1();
					//	shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					//	shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);

						double VY0=VY;//stretch y
						VY/=1.1;//YshiftPoint/=1.1;
						AR_Y/=1.1, function1();
					//	shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.camy+=VY-VY0;

						_3d.camz-=VZ/11., VZ/=1.1;//stretch z
						AR_Z/=1.1, function1();//*/
					}
					else
					{
						_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
						DX/=1.1, AR_Y/=1.1, AR_Z/=1.1;
					//	VX/=1.1;
						VY/=1.1, VZ/=1.1;
					//	function1();
					}
					function1();
#endif
					toSolve=true, shiftOnly=0;
				/*	DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
					toSolve=true, shiftOnly=0;//*/
				}
				else if(kb['Y'])//y+ stretch
				{
					if(_3d_stretch_move_cam)
						_3d.camy+=VY*0.1;
					VY*=1.1;//move cube
					AR_Y*=1.1, function1();
					if(contourOn)
						toSolve=true, shiftOnly=0;
				}
				else if(kb['Z'])//z+ stretch
				{
					if(_3d_stretch_move_cam)
						_3d.camy+=VZ*0.1;
					VZ*=1.1;//move cube
					AR_Z*=1.1, function1();
					if(contourOn)
						toSolve=true, shiftOnly=0;
				}
				else if(!kb[VK_CONTROL])
					_3d.zoomIn();
			}
			if(kb[VK_SUBTRACT]||kb[VK_BACK]||kb[VK_OEM_MINUS])
			{
				if(kb[VK_MENU])//alt-
					DX/=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['X'])//x- compress (zoom out (compress), stretch y z)
				{
					if(_3d_stretch_move_cam)
						_3d.camx=VX+(_3d.camx-VX)*1.1;
					else
						_3d.camx*=1.1;
					_3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
				//	VX*=1.1;//
					VY*=1.1, VZ*=1.1;
#if 0
					if(_3d_stretch_move_cam)
					{
						_3d.camx=VX+(_3d.camx-VX)*1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
						DX*=1.1, AR_Y*=1.1, AR_Z*=1.1,	VY*=1.1, VZ*=1.1;//*/
					/*	DX*=1.1, _3d.camx=VX+(_3d.camx-VX)*1.1, _3d.camy=VY+(_3d.camy-VY)*1.1, _3d.camz=VZ+(_3d.camz-VZ)*1.1, _3d.dcam*=1.1;//zoom out
						function1();
					//	shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					//	shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);

						double VY0=VY;//stretch y
						VY*=1.1;//YshiftPoint/=1.1;
						AR_Y*=1.1, function1();
					//	shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.camy+=VY-VY0;

						_3d.camz+=VZ*0.1, VZ*=1.1;//stretch z
						AR_Z*=1.1, function1();//*/
					}
					else
					{
						_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
						DX*=1.1, AR_Y*=1.1, AR_Z*=1.1;
					//	VX*=1.1;
						VY*=1.1, VZ*=1.1;
					//	function1();
					}
					function1();
#endif
					toSolve=true, shiftOnly=0;
				/*	DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
					toSolve=true, shiftOnly=0;//*/
				}
				else if(kb['Y'])//y- compress
				{
					if(_3d_stretch_move_cam)
						_3d.camy-=VY/11.;
					VY/=1.1;//move cube
					AR_Y/=1.1, function1();
					if(contourOn)
						toSolve=true, shiftOnly=0;
				}
				else if(kb['Z'])//z- compress
				{
					if(_3d_stretch_move_cam)
						_3d.camy-=VZ/11.;
					VZ/=1.1;//move cube
					AR_Z/=1.1, function1();
					if(contourOn)
						toSolve=true, shiftOnly=0;
				}
				else if(!kb[VK_CONTROL])
					_3d.zoomOut();
			}
		//		 if(kb[VK_MENU	]){		if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	DX*=1.1, function1(), toSolve=true, shiftOnly=0;
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	DX/=1.1, function1(), toSolve=true, shiftOnly=0;}
		//	else if(!kb[VK_CONTROL]){	if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	_3d.zoomIn();
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	_3d.zoomOut();}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				if(!shift)
				{
					ShowCursor(0);
					GetCursorPos(&mouseP0);
					SetCursorPos(centerP.x, centerP.y);
					SetCapture(ghWnd);
				}
				drag=1;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=centerP;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=(short)p.x, ((short*)&oldMouse)[1]=(short)p.y;
					a_draw();
				}
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			int draw=0;
			if(!m_bypass)
			{
				int dmx=((short*)&lParam)[0]-w/2, dmy=h/2-((short*)&lParam)[1];
				if(kb['X'])
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//xyz	mx my mw
						{
							double dVD=DX/Xplaces, dVX=dmx*dVD, dVY=dmy*dVD;
							VX+=dVX, _3d.camx+=dVX*_3d_shift_move_cam;
							VY+=dVY, _3d.camy+=dVY*_3d_shift_move_cam;
							toSolve=true;
							if(shiftOnly)
								shiftOnly=1, Xoffset+=dmx;
							draw=1;
						}
						else		//xy	mx my
						{
							double dVD=DX/Xplaces, dVX=dmx*dVD, dVY=dmy*dVD;
							VX+=dVX, _3d.camx+=dVX*_3d_shift_move_cam;
							VY+=dVY, _3d.camy+=dVY*_3d_shift_move_cam;
							toSolve=true;
							if(shiftOnly)
								shiftOnly=1, Xoffset+=dmx;
							draw=1;
						}
					}
					else
					{
						if(kb['Z'])	//xz	mx my
						{
							double dVD=DX/Xplaces, dVX=dmx*dVD, dVZ=dmy*dVD;
							VX+=dVX, _3d.camx+=dVX*_3d_shift_move_cam;
							VZ+=dVZ, _3d.camz+=dVZ*_3d_shift_move_cam;
							toSolve=true;
							if(shiftOnly)
								shiftOnly=1, Xoffset+=dmx;
						}
						else		//x		mx
						{
							double dVX=dmx*DX/Xplaces;
							VX+=dVX, _3d.camx+=dVX*_3d_shift_move_cam;
							toSolve=true;
							if(shiftOnly)
								shiftOnly=1, Xoffset+=dmx;
						}
						draw=1;
					}
				}
				else
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//yz	mx my
						{
							double dVD=DX/Xplaces, dVY=dmx*dVD, dVZ=dmy*dVD;
							VY+=dVY, _3d.camy+=dVY*_3d_shift_move_cam;
							VZ+=dVZ, _3d.camz+=dVZ*_3d_shift_move_cam;
						}
						else		//y		mx
						{
							double dVY=dmx*DX/Xplaces;
							VY+=dVY, _3d.camy+=dVY*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//z		my
						{
							double dVZ=dmy*DX/Xplaces;
							VZ+=dVZ, _3d.camz+=dVZ*_3d_shift_move_cam;
							draw=1;
						}
						else if(drag)
						{
							_3d.rotate(lParam);
							draw=1;
						}
					}
				}
			}
			if(draw)
			{
				SetCursorPos(centerP.x, centerP.y);
				if(!time_variance&&!timer)
					a_draw();
			}
			else if(contourOn&&!time_variance&&!timer)
				oldMouse=lParam, a_draw();
			m_bypass=!m_bypass;
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				if(!shift)
				{
					ReleaseCapture();
					SetCursorPos(mouseP0.x, mouseP0.y);
					ShowCursor(1);
				}
				drag=0;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=mouseP0;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=(short)p.x, ((short*)&oldMouse)[1]=(short)p.y;
				//	oldMouse=p.y<<16|p.x;
					a_draw();
				}
			}
		}
		int inputMouseWheel(int wParam)
		{
			bool mw_forward=((short*)&wParam)[1]>0;
			if(kb['X']&&kb['Y']&&kb['Z'])
			{
					 if(mw_forward)	VZ+=KXplaces*DX/Xplaces;
				else				VZ-=KXplaces*DX/Xplaces;
			}
			else if(kb[VK_MENU])//alt wheel
			{
					 if(mw_forward)	DX*=1.1;
				else				DX/=1.1;
				function1();
				if(_3d_zoom_move_cam)
				{
						 if(mw_forward)	_3d.camx=VX+(_3d.camx-VX)*1.1, _3d.camy=VY+(_3d.camy-VY)*1.1, _3d.camz=VZ+(_3d.camz-VZ)*1.1, _3d.dcam*=1.1;
					else				_3d.camx=VX+(_3d.camx-VX)/1.1, _3d.camy=VY+(_3d.camy-VY)/1.1, _3d.camz=VZ+(_3d.camz-VZ)/1.1, _3d.dcam/=1.1;
				}
				toSolve=true, shiftOnly=0;
			}
			else if(kb['X'])//x wheel
			{
				if(mw_forward)
				{
					if(_3d_stretch_move_cam)
						_3d.camx=VX+(_3d.camx-VX)/1.1;
					else
						_3d.camx/=1.1;
					_3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1;
					VY/=1.1, VZ/=1.1;
				}
				else
				{
					if(_3d_stretch_move_cam)
						_3d.camx=VX+(_3d.camx-VX)*1.1;
					else
						_3d.camx*=1.1;
					_3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1;
					VY*=1.1, VZ*=1.1;
				}
			/*	if(mw_forward)
				{
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1;
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
				}
				else
				{
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1;
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
				}//*/
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Y'])
			{
					 if(mw_forward)	AR_Y*=1.1, _3d.camy+=VY*0.1*_3d_stretch_move_cam, VY*=1.1;
				else				AR_Y/=1.1, _3d.camy-=VY/11.*_3d_stretch_move_cam, VY/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Z'])
			{
					 if(mw_forward)	AR_Z*=1.1, _3d.camz+=VZ*0.1*_3d_stretch_move_cam, VZ*=1.1;
				else				AR_Z/=1.1, _3d.camz-=VZ/11.*_3d_stretch_move_cam, VZ/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb[VK_CONTROL])
			{
					 if(mw_forward)	_3d.faster();
				else				_3d.slower();
			}
			else
			{
					 if(mw_forward)	_3d.zoomIn();
				else				_3d.zoomOut();
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:case 'T':case 'G':
				if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
		//	case VK_CONTROL:
		//		if(!(lParam&1<<30))
		//		{
		//			kp-=kb[VK_ADD]+kb[VK_SUBTRACT]+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]+kb[VK_RETURN]+kb[VK_BACK];
		//			if(kp<0)
		//				kp=0;
		//		}
		//		return 0;
			case VK_ADD:case VK_OEM_PLUS:case VK_RETURN:
				if(kb[VK_CONTROL])
					_3d.faster();
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_SUBTRACT:case VK_OEM_MINUS:case VK_BACK:
				if(kb[VK_CONTROL])
					_3d.slower();
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case 'X':
				if(kb[VK_CONTROL])
				{
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
					break;
				}
				else if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case 'Y':
				if(kb[VK_CONTROL])
				{
					_3d.teleport_degrees(0, 20, 0, -90, 0, 1);
					break;
				}
				else if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case 'Z':
				if(kb[VK_CONTROL])
				{
					_3d.teleport_degrees(0, 0, 20, 0, -90, 1);
					break;
				}
				else if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			//case 'X':case 'Y':case 'Z':
			//	if(!(lParam&1<<30)&&!shift)
			//	{
			//		if(!drag)
			//		{
			//			GetCursorPos(&mouseP0);
			//			ShowCursor(0);
			//			SetCursorPos(centerP.x, centerP.y);
			//			SetCapture(ghWnd);
			//		}
			//		shift=1;
			//	}
			//	return 0;
			case VK_OEM_3://contour
				if(contourOn)
				{
					if(kb[VK_CONTROL])
						contourOnly=!contourOnly;//toggle contour with / without the curves
					else
						contourOn=false;
				}
				else
				{
					contourOn=true, contourOnly=false;//turn contour on
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear();
						double Xs=DX/Xplaces, DY=DX/AR_Y, DZ=DX/AR_Z;
						for(unsigned e=0;e<expr.size();++e)
							if(expr[e].rmode[0]==2||expr[e].rmode[0]==3)
								doContour(e, Xs, VY-DY/2, VY+DY/2, Ystep, 10, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
					}
				}
				break;
			case '0':case VK_NUMPAD0:
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
				Rcontours.clear(), Icontours.clear();
				{
					auto op=&Transverse_1D_C::differentiate;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:operations.push_back(1), op=&Transverse_1D_C::differentiate;					break;
					case '2':case VK_NUMPAD2:operations.push_back(2), op=&Transverse_1D_C::integrate;						break;
					case '3':case VK_NUMPAD3:operations.push_back(3), op=&Transverse_1D_C::discreteFourrierTransform;		break;
					case '4':case VK_NUMPAD4:operations.push_back(4), op=&Transverse_1D_C::inverseDiscreteFourrierTransform;break;
					case '5':case VK_NUMPAD5:operations.push_back(5), op=&Transverse_1D_C::lowPassFilter;					break;
					case '6':case VK_NUMPAD6:operations.push_back(6), op=&Transverse_1D_C::highPassFilter;					break;
					}
					if(!toSolve)//lazy solve?
					{
						for(unsigned e=0;e<expr.size();++e)
						{
							auto &ex=expr[e];
							if(ex.rmode[0]==2||ex.rmode[0]==3)
								(this->*op)(ex.n[0].ndr);
						}
						if(contourOn)
						{
							double Xs=DX/Xplaces, DY=DX/AR_Y, DZ=DX/AR_Z;
							for(unsigned e=0;e<expr.size();++e)
							{
								auto &ex=expr[e];
								if(ex.rmode[0]==2||ex.rmode[0]==3)
									doContour(e, Xs, VY-DY/2, VY+DY/2, Ystep, 10, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
							}
						}
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				{
					double r=20/DX;
					VX*=r, VY*=r, VZ*=r;
					_3d.camx*=r, _3d.camy*=r, _3d.camz*=r, _3d.dcam*=r;
					DX=20, AR_Y=1, AR_Z=1, function1();
					toSolve=true, shiftOnly=0;
				}
				break;
			case 'R':
				_3d.dcam=.04, _3d.tanfov=1;
				if(!kb[VK_CONTROL])
					DX=20, AR_Y=1, AR_Z=1, function1();
				if(VX!=0||VY!=0||VZ!=0)
					VX=VY=VZ=0;
				toSolve=true, shiftOnly=0;
				if(kb['X'])
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
				else if(kb['Y'])
					_3d.teleport_degrees(0, 20, 0, 270, 0, 1);
				else if(kb['Z'])
					_3d.teleport_degrees(0, 0, 20, 90, 270, 1);
				else
					_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
			//	if(kb[VK_CONTROL])
			//	{
			//		_3d.dcam=.04;
			//		DX=20, AR_Y=1, AR_Z=1, function1();
			//		toSolve=true, shiftOnly=0;
			//	}
			//	if(VX!=0||VY!=0||VZ!=0)
			//	{
			//		VX=VY=VZ=0;
			//		toSolve=true, shiftOnly=0;
			//	}
			//	if(kb[VK_CONTROL])
			//		_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
			//	else
			//		_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
				break;
			case VK_F6:
				if(!(lParam&1<<30))
				{
					kb_VK_F6_msg=true;
					if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_stretch_move_cam=true;
					else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_shift_move_cam=true;
					else if(!_3d_zoom_move_cam)
						_3d_zoom_move_cam=true;
					else
						_3d_stretch_move_cam=_3d_shift_move_cam=_3d_zoom_move_cam=false;
				}
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:case 'T':case 'G':
				if(kp>0)
					--kp;
				return 0;
		//	case VK_CONTROL:
		//		kp+=kb[VK_ADD]+kb[VK_SUBTRACT]+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]+kb[VK_RETURN]+kb[VK_BACK];
		//		if(!time_variance&&!timer)
		//			SetTimer(ghWnd, 0, 10, 0), timer=true;
		//		return 0;
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[VK_CONTROL]&&kp>0)
					--kp;
				return 0;
			case 'X':
				if(!kb['Y']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Y':
				if(!kb['X']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Z':
				if(!kb['X']&&!kb['Y']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
		/*	case 'X':case 'Y':case 'Z':
				if(shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;*/
			}
			return 0;
		}
		void function1(){derive_step_3D(DX, AR_Y, AR_Z, w, Xstep, Ystep, Zstep);}
		void draw()
		{
			if(toSolve)
			{
				if(!operations.size()&&shiftOnly==1&&abs(Xoffset)<Xplaces)
				{
					if(Xoffset)
					{
						solver.partial_bounds(VX, DX, Xoffset);
						if(time_variance)
							solver.synchronize();
						for(auto &ex:expr)
						{
							if(ex.rmode[0]==2||ex.rmode[0]==3)
							{
								if(ex.nITD)
									solver.full(ex);
								else
									solver.partial(ex);
							}
							//	(solver.*(ex.nITD?&Solve_1D_Disc::full:&Solve_1D_Disc::partial))(ex);
						}
					}
				}
				else
				{
					int old_time_variance=time_variance;
					time_variance=0;
				//	std::fill(nExpr.begin(), nExpr.end(), 0);
					labels.clear();
					solver.full_resize(VX, DX, Xplaces=1000), KXplaces=Xplaces/100?Xplaces/100:1;
					if(!paused)
						solver.synchronize();
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
					//	++nExpr[ex.rmode[0]];
						if(ex.rmode[0]==2||ex.rmode[0]==3)
						{
							time_variance|=ex.nITD;
							labels.fill(e);
							solver.full(ex);
							for(auto &operation:operations)
							{
								switch(operation)
								{
								case 1:differentiate					(ex.n[0].ndr);break;
								case 2:integrate						(ex.n[0].ndr);break;
								case 3:discreteFourrierTransform		(ex.n[0].ndr);break;
								case 4:inverseDiscreteFourrierTransform	(ex.n[0].ndr);break;
								case 5:lowPassFilter					(ex.n[0].ndr);break;
								case 6:highPassFilter					(ex.n[0].ndr);break;
								}
							}
						}
					}
					if(time_variance)
					{
						if(!paused)
							SetTimer(ghWnd, 0, 10, 0);
					}
					else if(old_time_variance&&!timer)
						KillTimer(ghWnd, 0);
				}
				if(contourOn)
				{
					Rcontours.clear(), Icontours.clear();
					double Xs=DX/Xplaces, DY=DX/AR_Y, DZ=DX/AR_Z;
					for(unsigned e=0;e<expr.size();++e)
						if(expr[e].rmode[0]==2||expr[e].rmode[0]==3)
							doContour(e, Xs, VY-DY/2, VY+DY/2, Ystep, 10, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
				}
				toSolve=false, shiftOnly=2, Xoffset=0;
				exprRemoved=false;
			}
			else if(exprRemoved)
			{
				auto old_time_variance=time_variance;
				time_variance=false;
			//	std::fill(nExpr.begin(), nExpr.end(), 0);
				labels.clear();
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
				//	++nExpr[ex.rmode[0]];
					if(ex.rmode[0]==2||ex.rmode[0]==3)
					{
						time_variance|=ex.nITD;
						labels.fill(e);
					}
				}
				if(old_time_variance&&!time_variance&&!timer)
					KillTimer(ghWnd, 0);
				exprRemoved=false;
			}
			else if(time_variance)
			{
				if(!paused)
					solver.synchronize();
				for(auto &ex:expr)
				{
					if((ex.rmode[0]==2||ex.rmode[0]==3)&&ex.nITD)
					{
						solver.full(ex);
						for(auto &operation:operations)
						{
							switch(operation)
							{
							case 1:differentiate					(ex.n[0].ndr);break;
							case 2:integrate						(ex.n[0].ndr);break;
							case 3:discreteFourrierTransform		(ex.n[0].ndr);break;
							case 4:inverseDiscreteFourrierTransform	(ex.n[0].ndr);break;
							case 5:lowPassFilter					(ex.n[0].ndr);break;
							case 6:highPassFilter					(ex.n[0].ndr);break;
							}
						}
					}
				}
				if(contourOn)
				{
					double Xs=DX/Xplaces, DY=DX/AR_Y, DZ=DX/AR_Z;//contour
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if((ex.rmode[0]==2||ex.rmode[0]==3)&&ex.nITD)
							doContour(e, Xs, VY-DY/2, VY+DY/2, Ystep, 10, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
					}
				}
			}
			else if(difference_t1d_t1dc())
			{
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==2&&!ex.nITD)
					{
						solver.full(ex);
						for(auto &operation:operations)
						{
							switch(operation)
							{
							case 1:differentiate					(ex.n[0].ndr);break;
							case 2:integrate						(ex.n[0].ndr);break;
							case 3:discreteFourrierTransform		(ex.n[0].ndr);break;
							case 4:inverseDiscreteFourrierTransform	(ex.n[0].ndr);break;
							case 5:lowPassFilter					(ex.n[0].ndr);break;
							case 6:highPassFilter					(ex.n[0].ndr);break;
							}
						}
					}
				}
			}

			_3dMode_FrameStart(_3d, VX, VY, VZ, DX, Xstep, Ystep, Zstep, AR_Y, AR_Z);
		//	_3dMode_FrameStart(_3d, VX, VY, VZ, DX, Xstep, AR_Y*Ystep, AR_Z*Zstep, AR_Y, AR_Z);
			int colorCondition=nExpr[2]+nExpr[3]>1;
#if 1
			if(!contourOnly)//draw the curves
			{
				double Xstart=VX-DX/2, Xstep=DX/Xplaces;
				if(operations.size())
				{
					for(auto &ex:expr)
					{
						switch(ex.rmode[0])
						{
						case 2:
						case 3:
							{
								if(colorCondition)
									_3d.lineColor=ex.color;
								auto &ndr=ex.n[0].ndr;
								_3d.curve_start();
								for(unsigned x=0;x<ndr.size();++x)
									_3d.curve_point(Xstart+x*Xstep, AR_Y*ndr[x].r, AR_Z*ndr[x].i);
								_3d.lineColor=0;
							}
							break;
						}
					}
				}
				else
				{
					for(auto &ex:expr)
					{
						switch(ex.rmode[0])
						{
						case 2:
						case 3:
							{
								if(colorCondition)
									_3d.lineColor=ex.color;
								auto &ndr=ex.n[0].ndr;

								_3d.curve_start();
								for(unsigned x=0, xEnd=ndr.size()-1;x<xEnd;++x)
								{
									_3d.curve_point(Xstart+x*Xstep, AR_Y*ndr[x].r, AR_Z*ndr[x].i);
									if(ex.discontinuities[x])
										_3d.curve_start();
								}
								_3d.curve_point(Xstart+(Xplaces-1)*Xstep, AR_Y*ndr[Xplaces-1].r, AR_Z*ndr[Xplaces-1].i);

								_3d.lineColor=0;
							}
							break;
						}
					}
				}
			}
			if(contourOn)//draw contour
			{
				int mrX1=-60, mrX2=60, mrY1=-60, mrY2=60;
				int mx=((short*)&oldMouse)[0], my=((short*)&oldMouse)[1];
			//	double Xstart=VX-DX/2,
			//		DY=DX/AR_Y, Ystart=VY-DY/2,
			//		DZ=DX/AR_Z, Zstart=VZ-DZ/2;
				double cross=5*DX/w;
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==2||ex.rmode[0]==3)
					{
						if(colorCondition)
							_3d.lineColor=ex.color;
						for(auto &L:Rcontours[e])
						{
							double RL=AR_Y*Ystep*L.first;
						//	double RL=Ystep*L.first;
							for(auto &X_I:L.second)
							{
								_3d.line(X_I.x-cross, RL			, AR_Z* X_I.i		, X_I.x+cross	, RL			, AR_Z* X_I.i);
							//	_3d.line(X_I.x		, RL-AR_Y*cross	, AR_Z* X_I.i		, X_I.x			, RL+AR_Y*cross	, AR_Z* X_I.i);
								_3d.line(X_I.x		, RL			, AR_Z*(X_I.i-cross), X_I.x			, RL			, AR_Z*(X_I.i+cross));
						//		_3d.line(X_I.x-cross, RL, X_I.i, X_I.x+cross, RL, X_I.i);
						//	//	_3d.line(X_I.x, RL-cross, X_I.i, X_I.x, RL+cross, X_I.i);
						//		_3d.line(X_I.x, RL, X_I.i-cross, X_I.x, RL, X_I.i+cross);
								int x, y;
								if(active&&_3d.pointCoordinates3dText(X_I.x, RL, X_I.i, x, y)&&x>=mx+mrX1&&x<mx+mrX2&&y>=my+mrY1&&y<my+mrY2)
									_3d.textIn3D_screenCoord(x, y, OPAQUE, "%g, %g + %g i", X_I.x, RL, X_I.i);
							}
						}
						for(auto &L:Icontours[e])
						{
							double IL=AR_Z*Zstep*L.first;
						//	double IL=Zstep*L.first;
							for(auto &X_R:L.second)
							{
								_3d.line(X_R.x-cross, AR_Y* X_R.r		, IL			, X_R.x+cross	, AR_Y* X_R.r		, IL);
								_3d.line(X_R.x		, AR_Y*(X_R.r-cross), IL			, X_R.x			, AR_Y*(X_R.r+cross), IL);
							//	_3d.line(X_R.x		, AR_Y* X_R.r		, IL-AR_Z*cross	, X_R.x			, AR_Y* X_R.r		, IL+AR_Z*cross);
						//		_3d.line(X_R.x-cross, X_R.r, IL, X_R.x+cross, X_R.r, IL);
						//		_3d.line(X_R.x, X_R.r-cross, IL, X_R.x, X_R.r+cross, IL);
						//	//	_3d.line(X_R.x, X_R.r, IL-cross, X_R.x, X_R.r, IL+cross);
								int x, y;
								if(active&&_3d.pointCoordinates3dText(X_R.x, X_R.r, IL, x, y)&&x>=mx+mrX1&&x<mx+mrX2&&y>=my+mrY1&&y<my+mrY2)
									_3d.textIn3D_screenCoord(x, y, OPAQUE, "%g, %g + %g i", X_R.x, X_R.r, IL);
							}
						}
						if(colorCondition)
							_3d.lineColor=0;
					}
				}
				if(active)
				{
					auto ClearDIBPixel=[&](int x, int y){if(x>=0&&x<w&&y>=0&&y<h)rgb[y*w+x]=0;};
					if(drag)
					{
						int X0=w/2, Y0=h/2;
						ClearDIBPixel(X0+mrX1, Y0+mrY1), ClearDIBPixel(X0+mrX2, Y0+mrY1);
						ClearDIBPixel(X0+mrX1, Y0+mrY2), ClearDIBPixel(X0+mrX2, Y0+mrY2);
					}
					else
					{
						ClearDIBPixel(mx+mrX1, my+mrY1), ClearDIBPixel(mx+mrX2, my+mrY1);
						ClearDIBPixel(mx+mrX1, my+mrY2), ClearDIBPixel(mx+mrX2, my+mrY2);
					}
				}
			}
#endif
			if(!clearScreen)
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, TRANSPARENT);
				for(double X=floor((VX-DX/2)/Xstep)*Xstep+Xstep, Xend=ceil((VX+DX/2)/Xstep)*Xstep;X<Xend;X+=Xstep)
					if(abs(X)>Xstep/2)
						_3d.label(X, VY, VZ, "%g", X);
				if(AR_Y==1)
				{
					for(double Y=floor((VY-DX/2)/Ystep)*Ystep+Ystep, Yend=ceil((VY+DX/2)/Ystep)*Ystep;Y<Yend;Y+=Ystep)
						if(Y<-Ystep/2||Y>Ystep/2)
							_3d.label(VX, Y, VZ, "%g", Y);
				}
				else
				{
					double aYstep=AR_Y*Ystep, Ycore=floor((VY-DX/2)/aYstep);
					for(double Y=Ycore*aYstep+aYstep, Yend=ceil((VY+DX/2)/aYstep)*aYstep, aY=Ycore*Ystep+Ystep;Y<Yend;Y+=aYstep, aY+=Ystep)
						if(Y<-aYstep/2||Y>aYstep/2)
							_3d.label(VX, Y, VZ, "%g", aY);
				}
				if(AR_Z==1)
				{
					for(double Z=floor((VZ-DX/2)/Zstep)*Zstep+Zstep, Zend=ceil((VZ+DX/2)/Zstep)*Zstep;Z<Zend;Z+=Zstep)
						if(Z<-Zstep/2||Z>Zstep/2)
							_3d.label(VX, VY, Z, "%g", Z);
				}
				else
				{
					double aZstep=AR_Z*Zstep, Zcore=floor((VZ-DX/2)/aZstep);
					for(double Z=Zcore*aZstep+aZstep, Zend=ceil((VZ+DX/2)/aZstep)*aZstep, aZ=Zcore*Zstep+Zstep;Z<Zend;Z+=aZstep, aZ+=Zstep)
						if(Z<-aZstep/2||Z>aZstep/2)
							_3d.label(VX, VY, Z, "%g", aZ);
				}
				if(colorCondition)
					_3d.arrowLabelsColor(0, 0, 0, 1, 0, 0, labels.Xlabels);
				else
					_3d.arrowLabels		(0, 0, 0, 1, 0, 0, labels.Xlabels);
			/*	(_3d.*(colorCondition?
						(void (_3D::*)(double, double, double, double, double, double, std::vector<Label>&))&_3D::arrowLabelsColor
					:	(void (_3D::*)(double, double, double, double, double, double, std::vector<Label>&))&_3D::arrowLabels))
					(0, 0, 0, 1, 0, 0, labels.Xlabels);//*/
			/*	{
					auto al=colorCondition?
							(void (_3D::*)(double, double, double, double, double, double, std::vector<Label>&))&_3D::arrowLabelsColor
						:	(void (_3D::*)(double, double, double, double, double, double, std::vector<Label>&))&_3D::arrowLabels;
				//	void (_3D::*al)(double, double, double, double, double, double, std::vector<Label>&);
				//	if(colorCondition)
				//		al=&_3D::arrowLabelsColor;
				//	else
				//		al=&_3D::arrowLabels;

					(_3d.*al)(0, 0, 0, 1, 0, 0, labels.Xlabels);
				}//*/
			//	(_3d.*(colorCondition?&_3D::arrowLabelsColor:&_3D::arrowLabels))(0, 0, 0, 1, 0, 0, labels.Xlabels);
				{
					int textColor;
					if(colorCondition)
						textColor=GetTextColor(ghMemDC);
					int Ys=0;
					for(auto &label:labels.Clabels)
					{
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
					//	linelen=sprintf_s(line, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						if(colorCondition)
							SetTextColor(ghMemDC, expr[label.exNo].winColor);
						TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, line, linelen), Ys+=16;
					}
					if(colorCondition)
						SetTextColor(ghMemDC, textColor);
				}
				_3d.arrowLabel(0, 0, 0, 0, 1, 0, "Re()");
				_3d.arrowLabel(0, 0, 0, 0, 0, 1, "Im()");
				SetBkMode(ghMemDC, bkMode);
				{
					int k=0, Y=h-operations.size()*16;
					for(auto operation:operations)
					{
						char const *a=0;
						switch(operation)
						{
						case 1:a="%d: Differentiate";break;
						case 2:a="%d: Integrate";break;
						case 3:a="%d: DFT";break;
						case 4:a="%d: IDFT";break;
						case 5:a="%d: LPF";break;
						case 6:a="%d: HPF";break;
						}
						GUIPrint(ghMemDC, w-const_label_offset_X, Y, a, k);
						++k, Y+=16;
					}
				}
			}
			_3d.text_show();
			if(kb_VK_F6_msg||kb[VK_F6])
			{
				int kb_mode=SetBkMode(ghMemDC, OPAQUE);
				kb_VK_F6_msg=false;
				if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
					GUIPrint(ghMemDC, 0, h-18*3, "move cam: [-] scale, [-] shift, [-] zoom");
				else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
					GUIPrint(ghMemDC, 0, h-18*3, "move cam: [v] scale, [-] shift, [-] zoom");
				else if(!_3d_zoom_move_cam)
					GUIPrint(ghMemDC, 0, h-18*3, "move cam: [v] scale, [v] shift, [-] zoom");
				else
					GUIPrint(ghMemDC, 0, h-18*3, "move cam: [v] scale, [v] shift, [v] zoom");
				SetBkMode(ghMemDC, kb_mode);
			}
		}
		void i_draw();
		void a_draw();
	} t1d_c;
	const std::set<int> Transverse_1D_C::modes({2, 3});
	void			Transverse_1D_C::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				std::copy(rgb, rgb+w*h, modeRGB);

			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, OPAQUE);
				if(nExpr[2]+nExpr[3]>1)
					itb.draw_color(modes);
				else
					itb.draw();
				SetBkMode(ghMemDC, bkMode);
			}
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		}
		else
		{
			std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Transverse_1D_C::a_draw()
	{
		Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
	bool		difference_t1d_t1dc(){return t1d.VX!=t1d_c.VX||t1d.DX!=t1d_c.DX||t1d.Xplaces!=t1d_c.Xplaces;}

	namespace contour
	{
		struct Double_x_i_j_k
		{
			double x, i, j, k;
			Double_x_i_j_k(double x, double i, double j, double k):x(x), i(i), j(j), k(k){}
		};
		struct Double_x_r_j_k
		{
			double x, r, j, k;
			Double_x_r_j_k(double x, double r, double j, double k):x(x), r(r), j(j), k(k){}
		};
		struct Double_x_r_i_k
		{
			double x, r, i, k;
			Double_x_r_i_k(double x, double r, double i, double k):x(x), r(r), i(i), k(k){}
		};
		struct Double_x_r_i_j
		{
			double x, r, i, j;
			Double_x_r_i_j(double x, double r, double i, double j):x(x), r(r), i(i), j(j){}
		};
	}
	class		Transverse_1D_H:public Mode
	{
	public:
	//	int toSolve;
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		int Xoffset;
	//	int bpx, bpy, bh, bw;

		int Xplaces;
		double VX, VY, DX, AR_Y, Xstep, Ystep;
		int prec;
		Solve_1D_Disc solver;
		std::list<int> operations;

		bool contourOn, contourOnly;
		std::map<unsigned, std::unordered_map<int, std::list<contour::Double_x_i_j_k>>> Rcontours;
		//Rcontours[e]=Rcontour, Rcontour[r level (r/step)]=points, *points.begin()=(x,i,j,k)
		std::map<unsigned, std::unordered_map<int, std::list<contour::Double_x_r_j_k>>> Icontours;
		//Icontours[e]=Icontour, Icontour[i level (i/step)]=points, *points.begin()=(x,r,j,k)
		std::map<unsigned, std::unordered_map<int, std::list<contour::Double_x_r_i_k>>> Jcontours;
		//Jcontours[e]=Jcontour, Jcontour[j level (j/step)]=points, *points.begin()=(x,r,i,k)
		std::map<unsigned, std::unordered_map<int, std::list<contour::Double_x_r_i_j>>> Kcontours;
		//Kcontours[e]=Kcontour, Kcontour[k level (k/step)]=points, *points.begin()=(x,r,i,j)
		
		_2D _2d;
		bool clearScreen;
		Labels_1D labels;
		static const int rColor=0, iColor=0x00EF0000, jColor=0x0000EF00, kColor=0x000000EF;
		HPEN__ *hPenGrid, *hPenR, *hPenI, *hPenJ, *hPenK;
		HBRUSH__ *hBrush;

	//	char line[128];
	//	int linelen;
		bool timer, drag, m_bypass;
		int kp;

		Transverse_1D_H():
			VX(0), VY(0), DX(20), AR_Y(1),
		//	bpx(0), bpy(0), bw(0), bh(0),
			timer(false), drag(false), m_bypass(false), kp(0),
			shiftOnly(2), Xoffset(0),
		//	toSolve(1), shiftOnly(2), Xoffset(0),
			clearScreen(false)
		{
			hPenGrid=CreatePen(PS_SOLID, 1, _2dCheckColor), hBrush=CreateSolidBrush(_2dCheckColor);
			hPenR=CreatePen(PS_SOLID, 1, rColor), hPenI=CreatePen(PS_SOLID, 1, iColor), hPenJ=CreatePen(PS_SOLID, 1, jColor), hPenK=CreatePen(PS_SOLID, 1, kColor);
		}
		~Transverse_1D_H()
		{
			DeleteObject(hPenGrid), DeleteObject(hBrush);
			DeleteObject(hPenR), DeleteObject(hPenI), DeleteObject(hPenJ), DeleteObject(hPenK);
		}
		
		void doContour(unsigned e, double Xs, double Ystart, double Yend, double Ystep, unsigned nySteps)
		{
			using namespace contour;
			auto &ndr=expr[e].n[0].ndr;
			auto &Rcontour=Rcontours[e];
			auto &Icontour=Icontours[e];
			auto &Jcontour=Jcontours[e];
			auto &Kcontour=Kcontours[e];
			double YLstart=std::ceil((Ystart-10*Xs)/Ystep)*Ystep, YLend=std::ceil((Yend+25*Xs)/Ystep)*Ystep;
			for(unsigned v=0;v<ndr.size()-1;++v)
			{
				auto &V1=ndr[v], V2=ndr[v+1];
				{
					double R1, R2;
					if(V1.r<V2.r)
						R1=V1.r, R2=V2.r;
					else
						R1=V2.r, R2=V1.r;
					for(int r=int(std::floor((R1<YLstart?YLstart:R1)/Ystep)), rEnd=int(std::floor((R2>YLend?YLend:R2)/Ystep));r<=rEnd;++r)
					{
						double RL=Ystep*r;
						if(R1<=RL&&RL<R2)
						{
							double M=(RL-V1.r)/(V2-V1.r);
							Rcontour[r].push_back(Double_x_i_j_k(solver.Xstart+Xs*(v+M), V1.i+(V2.i-V1.i)*M, V1.j+(V2.j-V1.j)*M, V1.k+(V2.k-V1.k)*M));
						}
					}
				}
				{
					double I1, I2;
					if(V1.i<V2.i)
						I1=V1.i, I2=V2.i;
					else
						I1=V2.i, I2=V1.i;
					for(int i=int(std::floor((I1<YLstart?YLstart:I1)/Ystep)), iEnd=int(std::floor((I2>YLend?YLend:I2)/Ystep));i<=iEnd;++i)
					{
						double IL=Ystep*i;
						if(I1<=IL&&IL<I2)
						{
							double M=(IL-V1.i)/(V2-V1.i);
							Icontour[i].push_back(Double_x_r_j_k(solver.Xstart+Xs*(v+M), V1.r+(V2.r-V1.r)*M, V1.j+(V2.j-V1.j)*M, V1.k+(V2.k-V1.k)*M));
						}
					}
				}
				{
					double J1, J2;
					if(V1.j<V2.j)
						J1=V1.j, J2=V2.j;
					else
						J1=V2.j, J2=V1.j;
					for(int j=int(std::floor((J1<YLstart?YLstart:J1)/Ystep)), jEnd=int(std::floor((J2>YLend?YLend:J2)/Ystep));j<=jEnd;++j)
					{
						double JL=Ystep*j;
						if(J1<=JL&&JL<J2)
						{
							double M=(JL-V1.j)/(V2.j-V1.j);
							Jcontour[j].push_back(Double_x_r_i_k(solver.Xstart+Xs*(v+M), V1.r+(V2.r-V1.r)*M, V1.i+(V2.i-V1.i)*M, V1.k+(V2.k-V1.k)*M));
						}
					}
				}
				{
					double K1, K2;
					if(V1.k<V2.k)
						K1=V1.k, K2=V2.k;
					else
						K1=V2.k, K2=V1.k;
					for(int k=int(std::floor((K1<YLstart?YLstart:K1)/Ystep)), kEnd=int(std::floor((K2>YLend?YLend:K2)/Ystep));k<=kEnd;++k)
					{
						double KL=Ystep*k;
						if(K1<=KL&&KL<K2)
						{
							double M=(KL-V1.k)/(V2.k-V1.k);
							Kcontour[k].push_back(Double_x_r_i_j(solver.Xstart+Xs*(v+M), V1.r+(V2.r-V1.r)*M, V1.i+(V2.i-V1.i)*M, V1.j+(V2.j-V1.j)*M));
						}
					}
				}
			}
		}
		void differentiate						(std::vector<Value> &ndr)
		{
			double step=DX/Xplaces;
			for(unsigned k=0;k<ndr.size()-1;++k)
				ndr[k]=((boost::math::quaternion<double>)ndr[k+1]-(boost::math::quaternion<double>)ndr[k])/step;
			ndr.rbegin()->r/=-step, ndr.rbegin()->i/=-step, ndr.rbegin()->j/=-step, ndr.rbegin()->k/=-step;
		}
		void integrate							(std::vector<Value> &ndr)
		{
			double step=DX/Xplaces;
			boost::math::quaternion<double> sum;
			for(unsigned k=0;k<ndr.size();++k)
			{
				sum+=(boost::math::quaternion<double>)ndr[k];
				ndr[k]=sum*step;
			}
		}
		void discreteFourrierTransform			(std::vector<Value> &ndr)
		{
			std::vector<boost::math::quaternion<double>> t0(ndr.size());
			for(unsigned k=0;k<ndr.size();++k)
				t0[k]=(boost::math::quaternion<double>)ndr[k];
			std::vector<boost::math::quaternion<double>> t1(t0.size());
			for(unsigned k=0;k<t0.size();++k)
			{
				boost::math::quaternion<double> p=-2*G2::_pi*boost::math::quaternion<double>(0, 1)*double(k)/double(t0.size());
				for(unsigned k2=0;k2<t0.size();++k2)
					t1[k]+=t0[k2]*boost::math::exp(p*double(k2));
				t1[k]/=t0.size();
			}
			for(unsigned k=0;k<ndr.size();++k)
				ndr[k]=t1[k];//*/
		}
		void inverseDiscreteFourrierTransform	(std::vector<Value> &ndr)
		{
			std::vector<boost::math::quaternion<double>> t0(ndr.size());
			for(unsigned k=0;k<ndr.size();++k)
				t0[k]=(boost::math::quaternion<double>)ndr[k];
			std::vector<boost::math::quaternion<double>> t1(t0.size());
			for(unsigned k=0;k<t0.size();++k)
			{
				boost::math::quaternion<double> p=2*G2::_pi*boost::math::quaternion<double>(0, 1)*double(k)/double(t0.size());
				for(unsigned k2=0;k2<t0.size();++k2)
					t1[k]+=t0[k2]*boost::math::exp(p*double(k2));
			}
			for(unsigned k=0;k<ndr.size();++k)
				ndr[k]=t1[k];
		}
		void lowPassFilter						(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			boost::math::quaternion<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		/*	int T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=0;k<T/2;++k)
				sum+=(decltype(sum))ndr[k];
			for(unsigned k=0;k<T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[k+T/2];
			for(unsigned k=T/2;k<ndr.size()-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[k+T/2]-t0[(k-T/2)%T];
			for(unsigned k=ndr.size()-T/2;k<ndr.size();++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum-=t0[(k-T/2)%T];//*/
		/*	int T=10;
			std::complex<double> sum;
			std::vector<std::complex<double>> t0(ndr.size());
			for(unsigned k=0;k<t0.size();++k)
				t0[k]=(std::complex<double>)ndr[k];
			for(unsigned k=0;k<T/2;++k)
				sum+=t0[k];
			for(unsigned k=0;k<T/2;++k)
				t0[k]=sum/double(T), sum+=t0[k+1+T/2];
			for(unsigned k=T/2;k<t0.size()-T/2;++k)
				t0[k]=sum/double(T), sum+=t0[k+1+T/2]-(std::complex<double>)ndr[k-T/2];
			for(unsigned k=t0.size()-T/2;k<t0.size();++k)
				t0[k]=sum/double(T), sum-=(std::complex<double>)ndr[k-T/2];
			for(unsigned k=0;k<t0.size();++k)
				ndr[k]=t0[k];//*/
		/*	auto t=(std::complex<double>)ndr[0];
			for(unsigned k=0;k<ndr.size()-1;++k)
				ndr[k]=((std::complex<double>)ndr[k]+(std::complex<double>)ndr[k+1])/2.;
			ndr.rbegin()->operator=(t+(std::complex<double>)*ndr.rbegin())/2.;//*/
		}
		void highPassFilter						(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			boost::math::quaternion<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		/*	int T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=0;k<T/2;++k)
				sum+=(decltype(sum))ndr[k];
			for(unsigned k=0;k<T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[k+T/2];
			for(unsigned k=T/2;k<ndr.size()-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[k+T/2]-t0[(k-T/2)%T];
			for(unsigned k=ndr.size()-T/2;k<ndr.size();++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum-=t0[(k-T/2)%T];*/
		/*	auto t=(std::complex<double>)ndr[0];
			for(unsigned k=0;k<ndr.size()-1;++k)
				ndr[k]-=((std::complex<double>)ndr[k]+(std::complex<double>)ndr[k+1])/2.;
			ndr.rbegin()->operator-=(t+(std::complex<double>)*ndr.rbegin())/2.;*/
		}

		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
				drag=1;
			}
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
		//	kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]+kb[VK_ADD]+kb[VK_OEM_PLUS]+kb[VK_SUBTRACT]+kb[VK_OEM_MINUS];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag)
			{
				drag=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}

		void function1();
		void setDimentions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h;
			function1();
			toSolve=true, shiftOnly=0;
			ready=true;
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimentions(x, y, w, h);
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
		}
		void messageTimer()
		{
			if(_2d_drag_graph_not_window)
			{
				if(kb[VK_LEFT		])	VX+=10*DX/ w	, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;
				if(kb[VK_RIGHT		])	VX-=10*DX/ w	, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;
				if(kb[VK_UP			])	VY-=10*DX/(w*AR_Y);
				if(kb[VK_DOWN		])	VY+=10*DX/(w*AR_Y);
			}
			else
			{
				if(kb[VK_LEFT		])	VX-=10*DX/ w	, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;
				if(kb[VK_RIGHT		])	VX+=10*DX/ w	, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;
				if(kb[VK_UP			])	VY+=10*DX/(w*AR_Y);
				if(kb[VK_DOWN		])	VY-=10*DX/(w*AR_Y);
			}
			if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])
			{
				if(kb['X'])
					DX/=1.05, AR_Y/=1.05;
				else if(kb['Y'])
					AR_Y*=1.05;
				else
					DX/=1.05;
				function1(), toSolve=true, shiftOnly=0;
			}
			if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])
			{
				if(kb['X'])
					DX*=1.05, AR_Y*=1.05;
				else if(kb['Y'])
					AR_Y/=1.05;
				else
					DX*=1.05;
				function1(), toSolve=true, shiftOnly=0;
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
				SetCapture(ghWnd);
				drag=1;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=centerP;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=(short)p.x, ((short*)&oldMouse)[1]=(short)p.y;
					a_draw();
				}
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			int draw=0;
			if(drag)
			{
				if(!m_bypass)
				{
					int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
					int dx=mx-w/2, dy=h/2-my;
					if(_2d_drag_graph_not_window)
						dx=-dx, dy=-dy;
					VX+=dx*DX/w, VY+=dy*DX/(w*AR_Y);
					toSolve=true;
					if(shiftOnly)
						shiftOnly=1, Xoffset+=dx;
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						draw=1;
				}
				m_bypass=!m_bypass;
			}
			else if(contourOn&&!time_variance&&!timer)
				oldMouse=lParam, draw=1;
			if(draw)
				a_draw();
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=mouseP0;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=(short)p.x, ((short*)&oldMouse)[1]=(short)p.y;
					a_draw();
				}
			}
		}
		int inputMouseWheel(int wParam)
		{
			double dx=(((short*)&oldMouse)[0]-w/2)*DX/w, dy=(h/2-((short*)&oldMouse)[1])*DX/(w*AR_Y);
			if(kb['X'])
			{
					 if(((short*)&wParam)[1]>0)	DX/=1.1, AR_Y/=1.1, VX=VX+dx-dx/1.1;
				else							DX*=1.1, AR_Y*=1.1, VX=VX+dx-dx*1.1;
			}
			else if(kb['Y'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Y*=1.1, VY=VY+dy-dy/1.1;
				else							AR_Y/=1.1, VY=VY+dy-dy*1.1;
			}
			else
			{
					 if(((short*)&wParam)[1]>0)	DX/=1.1, VX=VX+dx-dx/1.1, VY=VY+dy-dy/1.1;
				else							DX*=1.1, VX=VX+dx-dx*1.1, VY=VY+dy-dy*1.1;
			}
		/*	double dx=DX*(short(oldMouse)-w/2)/w, dy=DX*(h/2-short(oldMouse>>16))/w;
				 if(short(wParam>>16)>0)	VX=VX+dx-dx/1.1, DX/=1.1, VY=VY+dy-dy/1.1;
			else							VX=VX+dx-dx*1.1, DX*=1.1, VY=VY+dy-dy*1.1;//*/
			function1();
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[wParam])
					++kp;
				if(!time_variance&&!timer)
					SetTimer(ghWnd, 0, 10, 0), timer=true;
				break;
			case VK_OEM_3://~: contour
				if(contourOn)
				{
					if(kb[VK_CONTROL])
						contourOnly=!contourOnly;
					else
						contourOn=false;
				}
				else
				{
					contourOn=true, contourOnly=false;//contour on
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						double DY=DX*h/(w*AR_Y);
						doContour(cursorEx, DX/Xplaces, VY-DY/2, VY+DY/2, Ystep, 10);
					}
				}
				break;
			case '0':case VK_NUMPAD0:
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
				{
					auto op=&Transverse_1D_H::differentiate;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:operations.push_back(1), op=&Transverse_1D_H::differentiate;					break;
					case '2':case VK_NUMPAD2:operations.push_back(2), op=&Transverse_1D_H::integrate;						break;
					case '3':case VK_NUMPAD3:operations.push_back(3), op=&Transverse_1D_H::discreteFourrierTransform;		break;
					case '4':case VK_NUMPAD4:operations.push_back(4), op=&Transverse_1D_H::inverseDiscreteFourrierTransform;break;
					case '5':case VK_NUMPAD5:operations.push_back(5), op=&Transverse_1D_H::lowPassFilter;					break;
					case '6':case VK_NUMPAD6:operations.push_back(6), op=&Transverse_1D_H::highPassFilter;					break;
					}
					for(auto &ex:expr)
						if(ex.rmode[0]==4)
							differentiate(ex.n[0].ndr);
					if(contourOn)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						double DY=DX*h/(w*AR_Y);
						doContour(cursorEx, DX/Xplaces, VY-DY/2, VY+DY/2, Ystep, 10);
					}
				}
				break;
		/*	case '1':case VK_NUMPAD1:
				operations.push_back(1);
				for(auto &ex:expr)
					if(ex.rmode[0]==4)
						differentiate(ex.n[0].ndr);
				break;
			case '2':case VK_NUMPAD2:
				operations.push_back(2);
				for(auto &ex:expr)
					if(ex.rmode[0]==4)
						integrate(ex.n[0].ndr);
				break;
			case '3':case VK_NUMPAD3:
				operations.push_back(3);
				for(auto &ex:expr)
					if(ex.rmode[0]==4)
						discreteFourrierTransform(ex.n[0].ndr);
				break;
			case '4':case VK_NUMPAD4:
				operations.push_back(4);
				for(auto &ex:expr)
					if(ex.rmode[0]==4)
						inverseDiscreteFourrierTransform(ex.n[0].ndr);
				break;
			case '5':case VK_NUMPAD5:
				operations.push_back(5);
				for(auto &ex:expr)
					if(ex.rmode[0]==4)
						lowPassFilter(ex.n[0].ndr);
				break;
			case '6':case VK_NUMPAD6:
				operations.push_back(6);
				for(auto &ex:expr)
					if(ex.rmode[0]==4)
						highPassFilter(ex.n[0].ndr);//*/
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				DX=20, AR_Y=1, function1();
				toSolve=true, shiftOnly=0;
				break;
			case 'R':
				if(!kb[VK_CONTROL])
					DX=20, AR_Y=1, function1();
				VX=VY=0;
				toSolve=true, shiftOnly=0;
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(kp)//start+key
					--kp;
				break;
			}
			return 0;
		}
		void draw()
		{
			double DY=DX*h/(w*AR_Y);
			if(DY<=0)
				DY=1;
			_2dMode_DrawCheckboard(hPenGrid, hBrush, VX, VY, DX, DY, Xstep, Ystep);
			auto &ex=expr[cursorEx];
			{
				bool changed=false;
				if(toSolve)
				{
					if(!operations.size()&&shiftOnly==1&&abs(Xplaces)<Xoffset)
					{
						if(Xoffset)
						{
							if(ex.nITD)
							{
								solver.synchronize();
								solver.full(ex);
							}
							else
							{
								solver.partial_bounds(VX, DX, Xoffset);
								solver.partial(ex);
							}
						}
					}
					else
					{
						auto old_time_variance=time_variance;
						time_variance=false;
					//	std::fill(nExpr.begin(), nExpr.end(), 0);
						labels.clear();
					//	for(auto &ex:expr)
					//		++nExpr[ex.rmode[0]];
						Xplaces=w;
						solver.full_resize(VX, DX, Xplaces);
						time_variance|=ex.nITD;
						labels.fill(cursorEx);
						if(!paused)
							solver.synchronize();
						solver.full(ex);
						for(auto &operation:operations)
						{
							switch(operation)
							{
							case 1:differentiate					(ex.n[0].ndr);break;
							case 2:integrate						(ex.n[0].ndr);break;
							case 3:discreteFourrierTransform		(ex.n[0].ndr);break;
							case 4:inverseDiscreteFourrierTransform	(ex.n[0].ndr);break;
							case 5:lowPassFilter					(ex.n[0].ndr);break;
							case 6:highPassFilter					(ex.n[0].ndr);break;
							}
						}
						if(time_variance)
						{
							if(!paused)
								SetTimer(ghWnd, 0, 10, 0);
						}
						else if(old_time_variance&&!timer)
							KillTimer(ghWnd, 0);
					}
					changed=true;
					toSolve=false, shiftOnly=2, Xoffset=0;
				}
				else if(time_variance)
				{
					if(!paused)
						solver.synchronize();
					solver.full(ex);
					for(auto &operation:operations)
					{
						switch(operation)
						{
						case 1:differentiate					(ex.n[0].ndr);break;
						case 2:integrate						(ex.n[0].ndr);break;
						case 3:discreteFourrierTransform		(ex.n[0].ndr);break;
						case 4:inverseDiscreteFourrierTransform	(ex.n[0].ndr);break;
						case 5:lowPassFilter					(ex.n[0].ndr);break;
						case 6:highPassFilter					(ex.n[0].ndr);break;
						}
					}
					changed=true;
				}
				if(changed&&contourOn)
				{
					Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
					double DY=DX*h/(w*AR_Y);
					doContour(cursorEx, DX/Xplaces, VY-DY/2, VY+DY/2, Ystep, 10);
				}
			}
			if(!clearScreen)
			{
				int bkMode=GetBkMode(ghMemDC);
				int H=0, V=0, VT=0;
				_2dMode_NumberAxes(VX, VY, DX, DY, Xstep, Ystep, prec, H, V, VT);
				MoveToEx(ghMemDC, 0, H, 0), LineTo(ghMemDC, w, H), MoveToEx(ghMemDC, V, 0, 0), LineTo(ghMemDC, V, h);
				{
					int textColor=GetTextColor(ghMemDC), Xs=VT+24+8*prec>w-24-prec*8?VT-24-8*prec:VT+24+8*prec, Ys=0;
					SetTextColor(ghMemDC, rColor), TextOutA(ghMemDC, Xs, Ys, "R()", 3), Ys+=16;
					SetTextColor(ghMemDC, iColor), TextOutA(ghMemDC, Xs, Ys, "I()", 3), Ys+=16;
					SetTextColor(ghMemDC, jColor), TextOutA(ghMemDC, Xs, Ys, "J()", 3), Ys+=16;
					SetTextColor(ghMemDC, kColor), TextOutA(ghMemDC, Xs, Ys, "K()", 3);
					SetTextColor(ghMemDC, textColor);
				}
				{
					int Ys=H+(H>h-46?-34:18), Ys0=Ys;
					for(auto &label:labels.Xlabels)
						TextOutA(ghMemDC, w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					Ys=Ys0>h/3?0:h-16*labels.Clabels.size();
					for(auto &label:labels.Clabels)
					{
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					//	linelen=sprintf_s(line, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, line, linelen), Ys+=16;
					}
				}
				SetBkMode(ghMemDC, bkMode);
			}
			if(!contourOnly)//draw the curves
			{
				HPEN p[]={hPenR, hPenI, hPenJ, hPenK};
				double Yend=VY+DY/2, Yr=h/DY;
				auto &ndr=ex.n[0].ndr;
				if(operations.size())
				{
					for(unsigned c=0;c<4;++c)
					{
						p[c]=(HPEN)SelectObject(ghMemDC, p[c]);
						_2d.curve_start();
						for(int v=0, vEnd=ndr.size();v<vEnd;++v)
							_2d.curve_point(bpx+v, Yr*(Yend-(&ndr[v].r)[c]));
						_2d.set_point();
						p[c]=(HPEN)SelectObject(ghMemDC, p[c]);
					}
				}
				else
				{
					for(unsigned c=0;c<4;++c)
					{
						p[c]=(HPEN)SelectObject(ghMemDC, p[c]);
						_2d.curve_start();
						for(int v=0, vEnd=Xplaces-1;v<vEnd;++v)
						{
							_2d.curve_point(bpx+v, Yr*(Yend-(&ndr[v].r)[c]));
							if(ex.discontinuities[v])
								_2d.curve_start();
						}
						_2d.curve_point(bpx+Xplaces-1, Yr*(Yend-(&ndr[Xplaces-1].r)[c]));
						_2d.set_point();
						p[c]=(HPEN)SelectObject(ghMemDC, p[c]);
					}
				}
			/*	double Yend=VY+DY/2;
				auto &ndr=ex.n[0].ndr;
				auto ndrIT=ndr.begin(), ndrIT2=ndr.end()-1;
				std::function<double()> f[]=
				{
					std::function<double()>([&]{return ndrIT->k;}),
					std::function<double()>([&]{return ndrIT->j;}),
					std::function<double()>([&]{return ndrIT->i;}),
					std::function<double()>([&]{return ndrIT->r;})
				};
				HPEN p[]={hPenK, hPenJ, hPenI, hPenR};
				if(ndrIT!=ndr.end())
				{
					for(int LOL_k=0, LOL_k_end=sizeof(f)/sizeof(f[0]);LOL_k<LOL_k_end;++LOL_k)
					{
						ndrIT=ndr.begin();
						p[LOL_k]=(HPEN__*)SelectObject(ghMemDC, p[LOL_k]);
						int k=0;
						MoveToEx(ghMemDC, bpx+k, int(h*(Yend-f[LOL_k]())/DY), 0);
						for(++ndrIT, ++k;ndrIT!=ndrIT2;++ndrIT, ++k)
						{
							LineTo	(ghMemDC, bpx+k, int(h*(Yend-f[LOL_k]())/DY));
							MoveToEx(ghMemDC, bpx+k, int(h*(Yend-f[LOL_k]())/DY), 0);
						}
						LineTo	(ghMemDC, bpx+k, int(h*(Yend-f[LOL_k]())/DY));
						p[LOL_k]=(HPEN__*)SelectObject(ghMemDC, p[LOL_k]);
					}
				}//*/
				int k=0, Y=h-operations.size()*16;
				for(auto operation:operations)
				{
					char const *a=0;
					switch(operation)
					{
					case 1:a="%d: Differentiate";	break;
					case 2:a="%d: Integrate";		break;
					case 3:a="%d: DFT";				break;
					case 4:a="%d: IDFT";			break;
					case 5:a="%d: LPF";				break;
					case 6:a="%d: HPF";				break;
					}
					GUIPrint(ghMemDC, w-const_label_offset_X, Y, a, k);
					++k, Y+=16;
				}
			}
			if(contourOn)//mark the crossings
			{
				int mrX1=-60, mrX2=60, mrY1=-60, mrY2=60;
				int mx=((short*)&oldMouse)[0], my=((short*)&oldMouse)[1];
				double Xstart=VX-DX/2, Yend=VY+DY/2;
			//	HPEN p[]={hPenR, hPenI, hPenJ, hPenK};
			//	void *cont[]={&Rcontours[cursorEx], &Icontours[cursorEx], &Jcontours[cursorEx], &Kcontours[cursorEx]};
				hPenR=(HPEN__*)SelectObject(ghMemDC, hPenR);
				for(auto &L:Rcontours[cursorEx])
				{
					double R=Ystep*L.first;
					int y;
					{
						double Y=(Yend-R)*h/DY;
						y=int(Y)-(Y<0);
					}
				//	int y=int((Yend-R)*h/DY);
					for(auto &X:L.second)
					{
						int x=int((X.x-Xstart)*w/DX);
						MoveToEx(ghMemDC, x-5, y, 0), LineTo(ghMemDC, x+5, y);
						MoveToEx(ghMemDC, x, y-5, 0), LineTo(ghMemDC, x, y+5);
						if(active&&x>=mx+mrX1&&x<mx+mrX2&&y>=my+mrY1&&y<my+mrY2)
							GUIPrint(ghMemDC, x, y, "%g, %g+%gi+%gj+%gk", X.x, R, X.i, X.j, X.k);
					}
				}
				hPenR=(HPEN__*)SelectObject(ghMemDC, hPenR);
				hPenI=(HPEN__*)SelectObject(ghMemDC, hPenI);
				for(auto &L:Icontours[cursorEx])
				{
					double I=Ystep*L.first;
					int y;
					{
						double Y=(Yend-I)*h/DY;
						y=int(Y)-(Y<0);
					}
				//	int y=int((Yend-I)*h/DY);
					for(auto &X:L.second)
					{
						int x=int((X.x-Xstart)/DX*w);
						MoveToEx(ghMemDC, x-5, y, 0), LineTo(ghMemDC, x+5, y);
						MoveToEx(ghMemDC, x, y-5, 0), LineTo(ghMemDC, x, y+5);
						if(active&&x>=mx+mrX1&&x<mx+mrX2&&y>=my+mrY1&&y<my+mrY2)
							GUIPrint(ghMemDC, x, y, "%g, %g+%gi+%gj+%gk", X.x, X.r, I, X.j, X.k);
					}
				}
				hPenI=(HPEN__*)SelectObject(ghMemDC, hPenI);
				hPenJ=(HPEN__*)SelectObject(ghMemDC, hPenJ);
				for(auto &L:Jcontours[cursorEx])
				{
					double J=Ystep*L.first;
					int y;
					{
						double Y=(Yend-J)*h/DY;
						y=int(Y)-(Y<0);
					}
				//	int y=int((Yend-J)*h/DY);
					for(auto &X:L.second)
					{
						int x=int((X.x-Xstart)/DX*w);
						MoveToEx(ghMemDC, x-5, y, 0), LineTo(ghMemDC, x+5, y);
						MoveToEx(ghMemDC, x, y-5, 0), LineTo(ghMemDC, x, y+5);
						if(active&&x>=mx+mrX1&&x<mx+mrX2&&y>=my+mrY1&&y<my+mrY2)
							GUIPrint(ghMemDC, x, y, "%g, %g+%gi+%gj+%gk", X.x, X.r, X.i, J, X.k);
					}
				}
				hPenJ=(HPEN__*)SelectObject(ghMemDC, hPenJ);
				hPenK=(HPEN__*)SelectObject(ghMemDC, hPenK);
				for(auto &L:Kcontours[cursorEx])
				{
					double K=Ystep*L.first;
					int y;
					{
						double Y=(Yend-K)*h/DY;
						y=int(Y)-(Y<0);
					}
				//	int y=int((Yend-K)*h/DY);
					for(auto &X:L.second)
					{
						int x=int((X.x-Xstart)/DX*w);
						MoveToEx(ghMemDC, x-5, y, 0), LineTo(ghMemDC, x+5, y);
						MoveToEx(ghMemDC, x, y-5, 0), LineTo(ghMemDC, x, y+5);
						if(active&&x>=mx+mrX1&&x<mx+mrX2&&y>=my+mrY1&&y<my+mrY2)
							GUIPrint(ghMemDC, x, y, "%g, %g+%gi+%gj+%gk", X.x, X.r, X.i, X.j, K);
					}
				}
				hPenK=(HPEN__*)SelectObject(ghMemDC, hPenK);//*/
				if(active)
				{
					auto ClearDIBPixel=[&](int x, int y){if(x>=0&&x<w&&y>=0&&y<h)rgb[y*w+x]=0;};
					if(drag)
					{
						int w_2=w/2, h_2=h/2;
						ClearDIBPixel(w_2+mrX1, h_2+mrY1), ClearDIBPixel(w_2+mrX2, h_2+mrY1);
						ClearDIBPixel(w_2+mrX1, h_2+mrY2), ClearDIBPixel(w_2+mrX2, h_2+mrY2);
					}
					else
					{
						ClearDIBPixel(mx+mrX1, my+mrY1), ClearDIBPixel(mx+mrX2, my+mrY1);
						ClearDIBPixel(mx+mrX1, my+mrY2), ClearDIBPixel(mx+mrX2, my+mrY2);
					}
				}
			}
		}
		void i_draw();
		void a_draw();
	} t1d_h;
	void			Transverse_1D_H::function1(){derive_step_2D(DX, AR_Y, w, Xstep, Ystep, prec, prec);}
	void			Transverse_1D_H::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				std::copy(rgb, rgb+w*h, modeRGB);

			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, OPAQUE);
				itb.draw();
				SetBkMode(ghMemDC, bkMode);
			}
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		}
		else
		{
			std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Transverse_1D_H::a_draw()
	{
		Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
	class		Implicit_2D:public Mode
	{
	public:
	//	int toSolve;
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		int Xoffset, Yoffset, exprRemoved;
	//	int bpx, bpy, bh, bw;

		int Xplaces, Yplaces;
		double VX, VY, DX, AR_Y, Xstep, Ystep;
		int prec;
		Solve_2D_Implicit solver;
		
		_2D _2d;
		bool clearScreen;
		Labels_2D labels;
		static const std::set<int> modes;
		HPEN hPen;
		HBRUSH hBrush;

	//	char line[128];
	//	int linelen;
		bool timer, drag, m_bypass;
		int kp;

		Implicit_2D():
			VX(0), VY(0), DX(20), AR_Y(1),
		//	bpx(0), bpy(0), bw(0), bh(0),
			timer(false), drag(false), m_bypass(false), kp(0),
			shiftOnly(2), Xoffset(0), Yoffset(0), exprRemoved(0),
		//	toSolve(1), shiftOnly(2), Xoffset(0), Yoffset(0),
			clearScreen(false)
		{
			hPen=CreatePen(PS_SOLID, 1, _2dCheckColor), hBrush=CreateSolidBrush(_2dCheckColor);
		}
		~Implicit_2D(){DeleteObject(hPen), DeleteObject(hBrush);}

		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				drag=1;
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
			}
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
		//	kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]+kb[VK_ADD]+kb[VK_OEM_PLUS]+kb[VK_SUBTRACT]+kb[VK_OEM_MINUS];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag)
			{
				drag=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		
		void setDimentions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h;
			function1();
			toSolve=true, shiftOnly=0;
			ready=true;
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimentions(x, y, w, h);
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
		}
		void messageTimer()
		{
			if(_2d_drag_graph_not_window)
			{
				if(kb[VK_LEFT		]){	VX+=10*DX/ Xplaces		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_RIGHT		]){	VX-=10*DX/ Xplaces		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_UP			]){	VY-=10*DX/(Xplaces*AR_Y), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset-=10;}
				if(kb[VK_DOWN		]){	VY+=10*DX/(Xplaces*AR_Y), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset+=10;}
			}
			else
			{
				if(kb[VK_LEFT		]){	VX-=10*DX/ Xplaces		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_RIGHT		]){	VX+=10*DX/ Xplaces		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_UP			]){	VY+=10*DX/(Xplaces*AR_Y), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset+=10;}
				if(kb[VK_DOWN		]){	VY-=10*DX/(Xplaces*AR_Y), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset-=10;}
			}//*/
		/*	{
				if(kb[VK_LEFT		]||kb[VK_RIGHT		]||kb[VK_UP			]||kb[VK_DOWN		])
				{
					VX+=10*DX/ Xplaces		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;
					VY+=10*DX/(Xplaces*AR_Y), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset+=10;
				}
			}//*/
			if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])
			{
				if(kb['X'])
					DX/=1.1, AR_Y/=1.1;
				else if(kb['Y'])
					AR_Y*=1.1;
				else
					DX/=1.1;
				function1(), toSolve=true, shiftOnly=0;
			}
			if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])
			{
				if(kb['X'])
					DX*=1.1, AR_Y*=1.1;
				else if(kb['Y'])
					AR_Y/=1.1;
				else
					DX*=1.1;
				function1(), toSolve=true, shiftOnly=0;
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				drag=1;
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
				SetCapture(ghWnd);
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(drag)
			{
				if(!m_bypass)
				{
					int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
					int dx=mx-w/2, dy=h/2-my;
					if(_2d_drag_graph_not_window)
						dx=-dx, dy=-dy;
					VX+=dx*DX/w, VY+=dy*DX/(w*AR_Y);
					toSolve=true;
					if(shiftOnly)
						shiftOnly=1, Xoffset+=dx, Yoffset+=dy;
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
				m_bypass=!m_bypass;
			}
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
		}
		int inputMouseWheel(int wParam)
		{
			int mx=((short*)&oldMouse)[0], my=((short*)&oldMouse)[1];
			double dx=(mx-w/2)*DX/w, dy=(h/2-my)*DX/(w*AR_Y);
			if(kb['X'])
			{
					 if(((short*)&wParam)[1]>0)	DX/=1.1, AR_Y/=1.1, VX=VX+dx-dx/1.1;
				else							DX*=1.1, AR_Y*=1.1, VX=VX+dx-dx*1.1;
			}
			else if(kb['Y'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Y*=1.1, VY=VY+dy-dy/1.1;
				else							AR_Y/=1.1, VY=VY+dy-dy*1.1;
			}
			else
			{
					 if(((short*)&wParam)[1]>0)	DX/=1.1, VX=VX+dx-dx/1.1, VY=VY+dy-dy/1.1;
				else							DX*=1.1, VX=VX+dx-dx*1.1, VY=VY+dy-dy*1.1;
			}
			function1();
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[wParam])
					++kp;
				if(!time_variance&&!timer)
					SetTimer(ghWnd, 0, 10, 0), timer=true;
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				DX=20, AR_Y=1, function1();
				toSolve=true, shiftOnly=0;
				break;
			case 'R':
				if(!kb[VK_CONTROL])
					DX=20, AR_Y=1, function1();
				VX=VY=0;
				toSolve=true, shiftOnly=0;
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(kp)//start+key
					--kp;
				return 0;
			}
			return 0;
		}
		void function1(){derive_step_2D(DX, AR_Y, w, Xstep, Ystep, prec, prec);}
		void draw()
		{
			double DY=DX*h/(w*AR_Y);
			if(DY<=0)
				DY=1;
			double Xr=w/DX;
			if(toSolve)
			{
				if(shiftOnly==1&&abs(Xoffset)<Xplaces&&abs(Yoffset)<Yplaces)
				{
					if(Xoffset||Yoffset)
					{
					/*	solver.partial_bounds(VX, DX, VY, DY, Xoffset, Yoffset);

						solver.hBitmap=(HBITMAP)SelectObject(ghMemDC, solver.hBitmap), solver.prgb=&solver.rgb;
						solver.shiftAndCheckboard(hPen, hBrush, VX, DX, VY, DY, Xstep, Ystep);
						for(auto &ex:expr)
							if(ex.rmode[0]==11&&!ex.nITD)
								(solver.*solver.partial)(ex);

						solver.hBitmap=(HBITMAP)SelectObject(ghMemDC, solver.hBitmap), solver.prgb=&rgb;
						std::copy(solver.rgb, solver.rgb+solver.ndrSize, rgb);
						solver.synchronize();
						for(auto &ex:expr)
							if(ex.rmode[0]==11&&ex.nITD)
								solver.full(ex);//*/
						solver.partial_bounds(VX, DX, VY, DY, Xoffset, Yoffset);
						solver.hBitmap=(HBITMAP)SelectObject(ghMemDC, solver.hBitmap);
						solver.shiftAndCheckboard(hPen, hBrush, VX, DX, VY, DY, Xstep, Ystep, clearScreen);
						solver.prgb=&solver.rgb;
						for(auto &ex:expr)
							if(ex.rmode[0]==11&&!ex.nITD)
								(solver.*solver.partial)(ex);
						solver.hBitmap=(HBITMAP)SelectObject(ghMemDC, solver.hBitmap);
						std::copy(solver.rgb, solver.rgb+solver.ndrSize, rgb);
						solver.prgb=&rgb;
						solver.synchronize();
						for(auto &ex:expr)
							if(ex.rmode[0]==11&&ex.nITD)
								solver.full(ex), solver.draw(ex);//*/
					}
				}
				else
				{
					auto old_time_variance=time_variance;
					time_variance=false;
				//	std::fill(nExpr.begin(), nExpr.end(), 0);
				//	for(auto &ex:expr)
				//		++nExpr[ex.rmode[0]];
					labels.clear();
					solver.full_resize(VX, DX, VY, DY, Xplaces=w, Yplaces=h);
					solver.hBitmap=(HBITMAP)SelectObject(ghMemDC, solver.hBitmap);//draw grid and time-fixed expressions on solver bitmap
					{
						Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);
					//	if(!clearScreen)
							_2dMode_DrawCheckboard(hPen, hBrush, VX, VY, DX, DY, Xstep, Ystep);
					}
					solver.prgb=&solver.rgb;
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if(ex.rmode[0]==11&&!ex.nITD)
						{
							labels.fill(e);
							solver.full(ex), solver.draw(ex);
						}
					}
					solver.hBitmap=(HBITMAP)SelectObject(ghMemDC, solver.hBitmap);
					std::copy(solver.rgb, solver.rgb+solver.ndrSize, rgb);//draw time variant expressions on screen
					solver.prgb=&rgb;
					if(!paused)
						solver.synchronize();
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if(ex.rmode[0]==11&&ex.nITD)
					//	if(ex.rmode[0]==11&&(time_variance|=ex.nITD))
						{
							labels.fill(e);
							solver.full(ex), solver.draw(ex);
							time_variance=true;
						}
					}
					if(time_variance)
					{
						if(!paused)
							SetTimer(ghWnd, 0, 10, 0);
					}
					else if(old_time_variance&&!timer)
						KillTimer(ghWnd, 0);
				}
				toSolve=false, shiftOnly=2, Xoffset=0, Yoffset=0;
				exprRemoved=false;
			}
			else if(exprRemoved)//expression(s) was removed
			{
				solver.hBitmap=(HBITMAP)SelectObject(ghMemDC, solver.hBitmap);
				{
					Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);
				//	if(!clearScreen)
						_2dMode_DrawCheckboard(hPen, hBrush, VX, VY, DX, DY, Xstep, Ystep);
				}
				solver.prgb=&solver.rgb;

				auto old_time_variance=time_variance;
				time_variance=false;
			//	std::fill(nExpr.begin(), nExpr.end(), 0);
				labels.clear();
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
				//	++nExpr[ex.rmode[0]];
					if(ex.rmode[0]==11&&!ex.nITD)
					{
						labels.fill(e);
						solver.draw(ex);
					}
				}
				solver.hBitmap=(HBITMAP)SelectObject(ghMemDC, solver.hBitmap);
				std::copy(solver.rgb, solver.rgb+solver.ndrSize, rgb);
				solver.prgb=&rgb;
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==11&&ex.nITD)
					{
						labels.fill(e);
						solver.draw(ex);
						time_variance=true;
					}
				}
				if(old_time_variance&&!time_variance&&!timer)
					KillTimer(ghWnd, 0);
				exprRemoved=false;
			}
			else if(time_variance)
			{
				std::copy(solver.rgb, solver.rgb+solver.ndrSize, rgb);
				if(!paused)
					solver.synchronize();
				for(auto &ex:expr)
					if(ex.rmode[0]==11&&ex.nITD)
						solver.full(ex), solver.draw(ex);
			}
			else
				std::copy(solver.rgb, solver.rgb+solver.ndrSize, rgb);
			int colorCondition=nExpr[11]>1;
			if(!clearScreen)
			{
				int bkMode=GetBkMode(ghMemDC);
				int H=0, V=0, VT=0;
				_2dMode_NumberAxes(VX, VY, DX, DY, Xstep, Ystep, prec, H, V, VT);
				{
					int textColor;
					if(colorCondition)
						textColor=GetTextColor(ghMemDC);
					int Ys=H+(H>h-46?-34:18)-2, Ys0=Ys;
					for(auto &label:labels.Xlabels)
					{
						if(colorCondition)
							SetTextColor(ghMemDC, expr[label.exNo].winColor);
						TextOutA(ghMemDC, w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					}
					int Xs=	V+VT+24+8*prec>w-24-prec*8
						?	V+VT-24-8*prec
						:	V+VT+24+8*prec;
					Ys=0;
					for(auto &label:labels.Ylabels)
					{
						if(colorCondition)
							SetTextColor(ghMemDC, expr[label.exNo].winColor);
						TextOutA(ghMemDC, Xs, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					}
					Ys=Ys0>h/3?0:h-16*labels.Clabels.size();
					for(auto &label:labels.Clabels)
					{
						if(colorCondition)
							SetTextColor(ghMemDC, expr[label.exNo].winColor);
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen);
					//	linelen=sprintf_s(line, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, line, linelen);
						Ys+=16;
					}
					if(colorCondition)
						SetTextColor(ghMemDC, textColor);
				}
				SetBkMode(ghMemDC, bkMode);
			}
		}
		void i_draw();
		void a_draw();
	} ti2d;
	const std::set<int> Implicit_2D::modes({11});
	void			Implicit_2D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				std::copy(rgb, rgb+w*h, modeRGB);

			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, OPAQUE);
				if(nExpr[11]>1)
					itb.draw_color(modes);
				else
					itb.draw();
				SetBkMode(ghMemDC, bkMode);
			}
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		}
		else
		{
			std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Implicit_2D::a_draw()
	{
	//	Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
	namespace contour
	{
		struct Double_X_Y
		{
			double x, y;
			Double_X_Y(double x, double y):x(x), y(y){}
		};
		struct Double_X_Y_V
		{
			double X, Y, V;
			Double_X_Y_V(double X, double Y, double V):X(X), Y(Y), V(V){}
		};
		void solve_quadratic(double a, double b, double c, std::complex<double> &r1, std::complex<double> &r2)
		{
			if(a==0)
				r1=-c/b, r2=_HUGE;
			else
			{
				if(std::abs(b)/std::abs(a)>=1e10&&std::abs(c)/std::abs(a)>=1e10)
					r1=-c/b, r2=-b/a;
				else
				{
					b/=a, c/=a;
					double horse=-b;
					std::complex<double> shit=std::sqrt(b*b-4*c);
					r1=.5*(horse+shit), r2=.5*(horse-shit);
				//	double _2a=2*a, horse=-b;
				//	std::complex<double> shit=std::sqrt(b*b-4*a*c);
				//	r1=(horse+shit)/_2a, r2=(horse-shit)/_2a;
				}
			}
		}
	}
	class		Transverse_2D:public Mode
	{
	public:
	//	int toSolve;
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		int Xoffset, Yoffset, exprRemoved;
		int X0, Y0;
	//	int bpx, bpy, bh, bw, X0, Y0;

		int Xplaces, Yplaces;
		double XshiftPoint, YshiftPoint;
		double XsamplePos, YsamplePos;
	//	int KXplaces, KYplaces;

		double VX, VY, VZ, DX, AR_Y, AR_Z, Xstep, Ystep, Zstep;
		Solve_2D_Disc solver;
		std::list<int> operations;

		bool contourOn, contourOnly, contourFlat;
		std::map<unsigned, std::unordered_map<int, std::list<std::pair<contour::Double_X_Y, contour::Double_X_Y>>>>
			contours;//contours[e]=contour, contour[z level (z/step)]=sticks, *stick.begin()=((x,y),(x,y))
		
		bool clearScreen, kb_VK_F6_msg;
		Labels_2D labels;
		_3D _3d;
		int gridColor;
		static const std::set<int> modes;
		
	//	char line[128];
	//	int linelen;
		bool timer, drag, m_bypass, shift;
		int kp;

		Transverse_2D():
			VX(0), VY(0), VZ(0), DX(20), AR_Y(1), AR_Z(1),
			Xplaces(100), Yplaces(100),
			XshiftPoint(0), YshiftPoint(0),
			XsamplePos(0), YsamplePos(0),
			_3d(4, 4, 4, 225*G2::_pi/180, 324.7356103172454*G2::_pi/180, 1),
			gridColor(_3dGridColor),
			timer(false), drag(false), m_bypass(false), shift(false), kp(0),
			shiftOnly(2), Xoffset(0), Yoffset(0),
		//	toSolve(1), shiftOnly(2), Xoffset(0), Yoffset(0),
			contourOn(false), contourOnly(false), contourFlat(false),
			clearScreen(false), kb_VK_F6_msg(false)
		{}

		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
				drag=1;
			}
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
		//	kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]+kb[VK_ADD]+kb[VK_OEM_PLUS]+kb[VK_SUBTRACT]+kb[VK_OEM_MINUS];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag||shift)
			{
				drag=0, shift=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag||shift)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}

		void doContour(unsigned e, double Xs, double Vstart, double Vend, double Vstep, unsigned nzSteps)
		{
			using namespace contour;
			auto &ex=expr[e];
			auto &ndr=ex.n[0].ndr;
			auto &contour=contours[e];
			unsigned yDiscOffset=(Xplaces-1)*Yplaces;
			double X0, X1, Y0, Y1, V00, V01, V10, V11;
			auto getPos=[&](double &t, double Vx, Double_X_Y_V &A, Double_X_Y_V &B)
			{
				double
					Xd=B.X-A.X, X1a=X1-A.X, Xa0=A.X-X0,
					Yd=B.Y-A.Y, Y1a=Y1-A.Y, Ya0=A.Y-Y0,
					
					A0=(V01-V00)*Xd, B0=X1a*V00+Xa0*V01,
					A1=(V11-V10)*Xd, B1=X1a*V10+Xa0*V11,
					
					a=(A1-A0)*Yd, b=(B1-B0)*Yd+Y1a*A0+Ya0*A1, c=Y1a*B0+Ya0*B1-(X1-X0)*(Y1-Y0)*Vx;

				if(a==0&&b==0)
				{
					t=(Vx-A.V)/(B.V-A.V);
					return true;
				}
				std::complex<double> r1, r2;
				solve_quadratic(a, b, c, r1, r2);
				if(r1.real()>=0&&r1.real()<=1)
				{
					t=r1.real();
					return true;
				}
				if(r2.real()>=0&&r2.real()<=1)
				{
					t=r2.real();
					return true;
				}
				if(r1.real()>=-1e-5&&r1.real()<=1+1e-5)
				{
					t=r1.real();
					return true;
				}
				if(r2.real()>=-1e-5&&r2.real()<=1+1e-5)
				{
					t=r2.real();
					return true;
				}
				if(r1.real()>=-1e-1&&r1.real()<=1+1e-1)
				{
					t=r1.real();
					return true;
				}
				if(r2.real()>=-1e-1&&r2.real()<=1+1e-1)
				{
					t=r2.real();
					return true;
				}
				return false;
			};
			auto cutTrgl=[&](Double_X_Y_V &A, Double_X_Y_V &B, Double_X_Y_V &C)
			{
				Double_X_Y_V *_1, *_2, *_3;//ordered by z in acscending order
				if(A.V<B.V)//ab
				{
						 if(B.V<C.V)	_1=&A, _2=&B, _3=&C;
					else if(A.V<C.V)	_1=&A, _2=&C, _3=&B;
					else				_1=&C, _2=&A, _3=&B;
				}
				else//ba
				{
						 if(A.V<C.V)	_1=&B, _2=&A, _3=&C;
					else if(B.V<C.V)	_1=&B, _2=&C, _3=&A;
					else				_1=&C, _2=&B, _3=&A;
				}
				//for V1 -> V2
				for(double v=std::floor((_1->V<Vstart?Vstart:_1->V)/Vstep), vEnd=std::floor((_2->V>Vend?Vend:_2->V)/Vstep);v<=vEnd;++v)
				{
					double VL=Vstep*v;
					if(_1->V<=VL&&VL<_2->V)
					{
						double M12, M13;
						if(getPos(M12, VL, *_1, *_2)&&getPos(M13, VL, *_1, *_3))
						{
							contour[int(v)].push_back(std::pair<Double_X_Y, Double_X_Y>(
								Double_X_Y(_1->X+M12*(_2->X-_1->X), _1->Y+M12*(_2->Y-_1->Y)),
								Double_X_Y(_1->X+M13*(_3->X-_1->X), _1->Y+M13*(_3->Y-_1->Y))
								));
						}
					}
				}
				//for V2 -> V3
				for(double v=std::floor((_2->V<Vstart?Vstart:_2->V)/Vstep), vEnd=std::floor((_3->V>Vend?Vend:_3->V)/Vstep);v<=vEnd;++v)
				{
					double VL=Vstep*v;
					if(_2->V<=VL&&VL<_3->V)
					{
						double M32, M31;
						if(getPos(M32, VL, *_2, *_3)&&getPos(M31, VL, *_1, *_3))
						{
							contour[int(v)].push_back(std::pair<Double_X_Y, Double_X_Y>(
								Double_X_Y(_2->X+M32*(_3->X-_2->X), _2->Y+M32*(_3->Y-_2->Y)),
								Double_X_Y(_1->X+M31*(_3->X-_1->X), _1->Y+M31*(_3->Y-_1->Y))
								));
						}
					}
				}
			};
			double Xstart=solver.Xstart, Ystart=AR_Y*solver.Ystart;
			for(unsigned vy=0, vyEnd=Yplaces-1;vy<vyEnd;++vy)
			{
				Y0=Ystart+Xs*vy, Y1=Ystart+Xs*(vy+1);
				for(unsigned vx=0, vxEnd=Xplaces-1;vx<vxEnd;++vx)
				{
					X0=solver.Xstart+Xs*vx, X1=solver.Xstart+Xs*(vx+1);
					double Xm=solver.Xstart+Xs*(vx+.5), Ym=Ystart+Xs*(vy+.5);

					Double_X_Y_V//yx
						P00(X0, Y0, V00=ndr[Xplaces* vy   +vx  ].r), P01(X1, Y0, V01=ndr[Xplaces* vy   +vx+1].r),
						P10(X0, Y1, V10=ndr[Xplaces*(vy+1)+vx  ].r), P11(X1, Y1, V11=ndr[Xplaces*(vy+1)+vx+1].r),
						
						Pmm(Xm, Ym, .25*(V00+V01+V10+V11));

					if(!ex.discontinuities[(Xplaces-1)*vy+vx]&&!ex.discontinuities[yDiscOffset+(Yplaces-1)*(vx+1)+vy]&&!ex.discontinuities[(Xplaces-1)*(vy+1)+vx]&&!ex.discontinuities[yDiscOffset+(Yplaces-1)*vx+vy])
					{
						cutTrgl(P00, Pmm, P01);
						cutTrgl(P01, Pmm, P11);
						cutTrgl(P11, Pmm, P10);
						cutTrgl(P10, Pmm, P00);
					}
				/*	if(!ex.discontinuities[(Xplaces-1)*vy+vx])
						cutTrgl(P00, Pmm, P01);
					if(!ex.discontinuities[yDiscOffset+(Yplaces-1)*(vx+1)+vy])
						cutTrgl(P01, Pmm, P11);
					if(!ex.discontinuities[(Xplaces-1)*(vy+1)+vx])
						cutTrgl(P11, Pmm, P10);
					if(!ex.discontinuities[yDiscOffset+(Yplaces-1)*vx+vy])
						cutTrgl(P10, Pmm, P00);//*/
				}
			}//*/

		/*	using namespace contour;
			auto &ndr=expr[e].n[0].ndr;
			auto &contour=contours[e];
			auto cutTrgl=[&](Double_X_Y_V &A, Double_X_Y_V &B, Double_X_Y_V &C)
			{
				Double_X_Y_V *_1, *_2, *_3;//ordered by z in acscending order
				if(A.V<B.V)//ab
				{
						 if(B.V<C.V)	_1=&A, _2=&B, _3=&C;
					else if(A.V<C.V)	_1=&A, _2=&C, _3=&B;
					else				_1=&C, _2=&A, _3=&B;
				}
				else//ba
				{
						 if(A.V<C.V)	_1=&B, _2=&A, _3=&C;
					else if(B.V<C.V)	_1=&B, _2=&C, _3=&A;
					else				_1=&C, _2=&B, _3=&A;
				}
				double X13, Y13;
				{
					double Zr=(_2->V-_1->V)/(_3->V-_1->V);
					X13=_1->X+Zr*(_3->X-_1->X), Y13=_1->Y+Zr*(_3->Y-_1->Y);//V13=V2;
				}
				//for V1 -> V2
				for(double v=std::floor((_1->V<Vstart?Vstart:_1->V)/Vstep), vEnd=std::floor((_2->V>Vend?Vend:_2->V)/Vstep);v<=vEnd;++v)
				{
					double VL=Vstep*v;
					if(_1->V<=VL&&VL<_2->V)
					{
					//	double M12=(VL-_1->V)/(_2->V-_1->V), M13=(VL-_1->V)/(_3->V-_1->V);
					//	contour[int(v)].push_back(std::pair<Double_X_Y, Double_X_Y>(
					//		Double_X_Y(_1->X+M12*(_2->X-_1->X), _1->Y+M12*(_2->Y-_1->Y)),
					//		Double_X_Y(_1->X+M13*(_3->X-_1->X), _1->Y+M13*(_3->Y-_1->Y))
					//		));

						double M=(VL-_1->V)/(_2->V-_1->V);
						contour[int(v)].push_back(std::pair<Double_X_Y, Double_X_Y>(
							Double_X_Y(_1->X+M*(_2->X-_1->X), _1->Y+M*(_2->Y-_1->Y)),
							Double_X_Y(_1->X+M*(X13-_1->X), _1->Y+M*(Y13-_1->Y))
							));
					}
				}
				//for V2 -> V3
				for(double v=std::floor((_2->V<Vstart?Vstart:_2->V)/Vstep), vEnd=std::floor((_3->V>Vend?Vend:_3->V)/Vstep);v<=vEnd;++v)
				{
					double VL=Vstep*v;
					if(_2->V<=VL&&VL<_3->V)
					{
					//	double M32=(VL-_2->V)/(_3->V-_2->V), M31=(VL-_1->V)/(_3->V-_1->V);
					//	contour[int(v)].push_back(std::pair<Double_X_Y, Double_X_Y>(
					//		Double_X_Y(_2->X+M32*(_3->X-_2->X), _2->Y+M32*(_3->Y-_2->Y)),
					//		Double_X_Y(_1->X+M31*(_3->X-_1->X), _1->Y+M31*(_3->Y-_1->Y))
					//		));

						double M=(VL-_2->V)/(_3->V-_2->V);
						contour[int(v)].push_back(std::pair<Double_X_Y, Double_X_Y>(
							Double_X_Y(_2->X+M*(_3->X-_2->X), _2->Y+M*(_3->Y-_2->Y)),
							Double_X_Y(X13+M*(_3->X-X13), Y13+M*(_3->Y-Y13))
							));
					}
				}
			};
			for(unsigned vy=0, vyEnd=Yplaces-1;vy<vyEnd;++vy)
			{
				for(unsigned vx=0, vxEnd=Xplaces-1;vx<vxEnd;++vx)
				{
					double
						X0=solver.Xstart+Xs*vx, Xm=solver.Xstart+Xs*(vx+.5), X1=solver.Xstart+Xs*(vx+1),
						Y0=solver.Ystart+Xs*vy, Ym=solver.Ystart+Xs*(vy+.5), Y1=solver.Ystart+Xs*(vy+1);

					Double_X_Y_V//yx
						P00(X0, Y0, ndr[Xplaces* vy   +vx  ].r),
						P01(X1, Y0, ndr[Xplaces* vy   +vx+1].r),
						P10(X0, Y1, ndr[Xplaces*(vy+1)+vx  ].r),
						P11(X1, Y1, ndr[Xplaces*(vy+1)+vx+1].r),
						
						Pmm(Xm, Ym, .25*(P00.V+P01.V+P10.V+P11.V));

					cutTrgl(P00, Pmm, P01);
					cutTrgl(P01, Pmm, P11);
					cutTrgl(P11, Pmm, P10);
					cutTrgl(P10, Pmm, P00);
				}
			}//*/
		}
		void differentiate_x					(std::vector<Value> &ndr)
		{
			double step=DX/Xplaces;
			for(int ky=0;ky<Yplaces;++ky)
			{
				for(int kx=0;kx<Xplaces-1;++kx)
					ndr[Xplaces*ky+kx]=((std::complex<double>)ndr[Xplaces*ky+kx+1]-(std::complex<double>)ndr[Xplaces*ky+kx])/step;
				ndr[Xplaces*ky+Xplaces-1].r/=-step, ndr[Xplaces*ky+Xplaces-1].i/=-step;
			}
			ndr.rbegin()->r/=-step, ndr.rbegin()->i/=-step;
		}
		void differentiate_y					(std::vector<Value> &ndr)
		{
			double step=DX/Xplaces;
			for(int ky=0;ky<Yplaces-1;++ky)
				for(int kx=0;kx<Xplaces;++kx)
					ndr[Xplaces*ky+kx]=((std::complex<double>)ndr[Xplaces*(ky+1)+kx]-(std::complex<double>)ndr[Xplaces*ky+kx])/step;
			for(int kx=0;kx<Xplaces;++kx)
				ndr[Xplaces*(Yplaces-1)+kx].r/=-step, ndr[Xplaces*(Yplaces-1)+kx].i/=-step;
			ndr.rbegin()->r/=-step, ndr.rbegin()->i/=-step;
		}
		void integrate_x						(std::vector<Value> &ndr)
		{
			double step=DX/Xplaces;
			std::complex<double> sum;
			for(int ky=0;ky<Yplaces;++ky)
			{
				for(int kx=0;kx<Xplaces;++kx)
				{
					auto &v=ndr[Xplaces*ky+kx];
					v=(sum+=(std::complex<double>)v)*step;
				}
				sum=0;
			}
		}
		void integrate_y						(std::vector<Value> &ndr)
		{
			double step=DX/Xplaces;
			std::vector<std::complex<double>> sum(Xplaces);
			for(int ky=0;ky<Yplaces;++ky)
				for(int kx=0;kx<Xplaces;++kx)
				{
					auto &v=ndr[Xplaces*ky+kx];
					v=(sum[kx]+=(std::complex<double>)v)*step;
				}
		}
		fftw_complex *fft_in, *fft_out;
		fftw_plan fft_p, ifft_p;
		unsigned fft_N0, fft_N1;
		double fft_sqrt_N;
		void discreteFourrierTransform			(std::vector<Value> &ndr)
		{
			int ndrSize=Xplaces*Yplaces;
			if(fft_N0!=Yplaces||fft_N1!=Xplaces)
			{
				if(fft_N0||fft_N1)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_N0=Yplaces, fft_N1=Xplaces;
				fft_in=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt(ndrSize);
				fft_p=fftw_plan_dft_2d(fft_N0, fft_N1, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE), ifft_p=fftw_plan_dft_2d(fft_N0, fft_N1, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
			for(int k=0;k<ndrSize;++k)
			{
				unsigned x=k%Xplaces, y=k/Xplaces;
				int sign=1-((x%2^y%2)<<1);
				fft_in[k][0]=ndr[k].r*sign, fft_in[k][1]=ndr[k].i*sign;
			//	fft_in[k][0]=ndr[k].r*(1-2*(k%Xplaces%2^k/Xplaces%2)), fft_in[k][1]=ndr[k].i*(1-2*(k%Xplaces%2^k/Xplaces%2));
			}
			fftw_execute(fft_p);
			for(int k=0;k<ndrSize;++k)
				ndr[k].r=fft_out[k][0]/fft_sqrt_N, ndr[k].i=fft_out[k][1]/fft_sqrt_N;
		}
		void inverseDiscreteFourrierTransform	(std::vector<Value> &ndr)
		{
			int ndrSize=Xplaces*Yplaces;
			if(fft_N0!=Yplaces||fft_N1!=Xplaces)
			{
				if(fft_N0||fft_N1)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_N0=Yplaces, fft_N1=Xplaces;
				fft_in=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt(ndrSize);
				fft_p=fftw_plan_dft_2d(fft_N0, fft_N1, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE), ifft_p=fftw_plan_dft_2d(fft_N0, fft_N1, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
			for(int k=0;k<ndrSize;++k)
				fft_in[k][0]=ndr[k].r, fft_in[k][1]=ndr[k].i;
			fftw_execute(ifft_p);
			for(int k=0;k<ndrSize;++k)
				ndr[k].r=fft_out[k][0]*(1-2*(k%Xplaces%2^k/Xplaces%2))/fft_sqrt_N, ndr[k].i=fft_out[k][1]*(1-2*(k%Xplaces%2^k/Xplaces%2))/fft_sqrt_N;
		}
		void lowPassFilter						(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		/*	int T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=0;k<T/2;++k)
				sum+=(decltype(sum))ndr[k];
			for(unsigned k=0;k<T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[k+T/2];
			for(unsigned k=T/2;k<ndr.size()-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[k+T/2]-t0[(k-T/2)%T];
			for(unsigned k=ndr.size()-T/2;k<ndr.size();++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum-=t0[(k-T/2)%T];//*/
		/*	int T=10;
			std::complex<double> sum;
			std::vector<std::complex<double>> t0(ndr.size());
			for(unsigned k=0;k<t0.size();++k)
				t0[k]=(std::complex<double>)ndr[k];
			for(unsigned k=0;k<T/2;++k)
				sum+=t0[k];
			for(unsigned k=0;k<T/2;++k)
				t0[k]=sum/double(T), sum+=t0[k+1+T/2];
			for(unsigned k=T/2;k<t0.size()-T/2;++k)
				t0[k]=sum/double(T), sum+=t0[k+1+T/2]-(std::complex<double>)ndr[k-T/2];
			for(unsigned k=t0.size()-T/2;k<t0.size();++k)
				t0[k]=sum/double(T), sum-=(std::complex<double>)ndr[k-T/2];
			for(unsigned k=0;k<t0.size();++k)
				ndr[k]=t0[k];//*/
		/*	auto t=(std::complex<double>)ndr[0];
			for(unsigned k=0;k<ndr.size()-1;++k)
				ndr[k]=((std::complex<double>)ndr[k]+(std::complex<double>)ndr[k+1])/2.;
			ndr.rbegin()->operator=(t+(std::complex<double>)*ndr.rbegin())/2.;//*/
		}
		void highPassFilter						(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		/*	int T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=0;k<T/2;++k)
				sum+=(decltype(sum))ndr[k];
			for(unsigned k=0;k<T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[k+T/2];
			for(unsigned k=T/2;k<ndr.size()-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[k+T/2]-t0[(k-T/2)%T];
			for(unsigned k=ndr.size()-T/2;k<ndr.size();++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum-=t0[(k-T/2)%T];*/
		/*	auto t=(std::complex<double>)ndr[0];
			for(unsigned k=0;k<ndr.size()-1;++k)
				ndr[k]-=((std::complex<double>)ndr[k]+(std::complex<double>)ndr[k+1])/2.;
			ndr.rbegin()->operator-=(t+(std::complex<double>)*ndr.rbegin())/2.;*/
		}

		void setDimentions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h, X0=bpx+bw/2, Y0=bpy+bh/2;
			_3d.setDimentions(x, y, w, h);
			double old_Zstep=Zstep;
			function1();
			if(!toSolve&&contourOn&&old_Zstep!=Zstep)
			{
				contours.clear();
				double Xs=DX/Xplaces, DZ=DX/AR_Z;
				for(unsigned e=0;e<expr.size();++e)
					if(expr[e].rmode[0]==5)
						doContour(e, Xs, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
			}
			ready=true;
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimentions(x, y, w, h);
			if(!time_variance&&!timer)
				a_draw();
		}
		void shiftNDR(double &DshiftPoint, double Dsample, double &DsamplePos, double &VD, int &Doffset, double ammount)
		{
			double newDsamplePos=std::floor((DshiftPoint+=ammount)/Dsample);
			if(newDsamplePos!=DsamplePos)
			{
				toSolve=true;
				if(shiftOnly)
					shiftOnly=1, Doffset+=int(newDsamplePos-DsamplePos);
				DsamplePos=newDsamplePos, VD=newDsamplePos*Dsample;
			}
		}
	/*	void shiftNDR(double &DshiftPoint, double Dsample, double &VD, int &Doffset, double ammount)
		{
			double
				DsamplePos0=std::floor(DshiftPoint/Dsample),
				newDsamplePos=std::floor((DshiftPoint+=ammount)/Dsample);
			if(newDsamplePos!=DsamplePos0)
			{
				toSolve=true;
				if(shiftOnly)
					shiftOnly=1, Doffset+=int(newDsamplePos-DsamplePos0);
				VD=newDsamplePos*Dsample;
			}
		}//*/
		void shiftNDRupdate(double DshiftPoint, double Dsample, double &DsamplePos, double &VD)
		{
			double newDsamplePos=std::floor(DshiftPoint/Dsample);
			if(newDsamplePos!=DsamplePos)
				DsamplePos=newDsamplePos, VD=newDsamplePos*Dsample;
		}
	//	void shiftNDRupdate(double DshiftPoint, double Dsample, double &VD){VD=std::floor(DshiftPoint/Dsample)*Dsample;}
		void messageTimer()
		{
		//	int Xoffset0=Xoffset, Yoffset0=Yoffset;
				 if(kb[VK_SHIFT	]){	 if(kb['W'])	_3d.moveForwardFast();
									 if(kb['A'])	_3d.moveLeftFast();
									 if(kb['S'])	_3d.moveBackFast();
									 if(kb['D'])	_3d.moveRightFast();
									 if(kb['T'])	_3d.camz+=10*_3d.dcam;
									 if(kb['G'])	_3d.camz-=10*_3d.dcam;}
			else				  {	 if(kb['W'])	_3d.moveForward();
									 if(kb['A'])	_3d.moveLeft();
									 if(kb['S'])	_3d.moveBack();
									 if(kb['D'])	_3d.moveRight();
									 if(kb['T'])	_3d.camz+=_3d.dcam;
									 if(kb['G'])	_3d.camz-=_3d.dcam;}
			double dVD=DX/100;
			if(kb['X'])
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//xyz
					{
					}
					else		//xy
					{
						if(kb[VK_UP])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, dVD), _3d.camy+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, -dVD), _3d.camy-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dVD), _3d.camx+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, -dVD), _3d.camx-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//xz
					{
						if(kb[VK_UP])	VZ+=dVD, _3d.camz+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	VZ-=dVD, _3d.camz-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, dVD), _3d.camx+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, -dVD), _3d.camx-=_3d_shift_move_cam*dVD;
					}
					else		//x
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, dVD), _3d.camx+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, -dVD), _3d.camx-=_3d_shift_move_cam*dVD;
					}
				}
			}
			else
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//yz
					{
						if(kb[VK_UP])	VZ+=dVD, _3d.camz+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	VZ-=dVD, _3d.camz-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dVD), _3d.camy+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, -dVD), _3d.camy-=_3d_shift_move_cam*dVD;
					}
					else		//y
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dVD), _3d.camy+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, -dVD), _3d.camy-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//z
					{
						if(kb[VK_UP]||kb[VK_RIGHT]){	VZ+=dVD, _3d.camx+=_3d_shift_move_cam*dVD;	if(contourOn)toSolve=true, shiftOnly=0;}//just to update contour
						if(kb[VK_DOWN]||kb[VK_LEFT]){	VZ-=dVD, _3d.camx-=_3d_shift_move_cam*dVD;	if(contourOn)toSolve=true, shiftOnly=0;}
					}
					else
					{
						if(kb[VK_UP])	_3d.rotateUp();
						if(kb[VK_DOWN])	_3d.rotateDown();
						if(kb[VK_RIGHT])_3d.rotateRight();
						if(kb[VK_LEFT])	_3d.rotateLeft();
					}
				}
			}
			if(kb[VK_ADD]|kb[VK_RETURN]|kb[VK_OEM_PLUS])
			{
				if(kb[VK_MENU])//alt+
				{
					if(_3d_zoom_move_cam)//zoom in
						DX/=1.1, _3d.camx=VX+(_3d.camx-VX)/1.1, _3d.camy=VY+(_3d.camy-VY)/1.1, _3d.camz=VZ+(_3d.camz-VZ)/1.1, _3d.dcam/=1.1;
					else//zoom out
						DX*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					toSolve=true, shiftOnly=0;
				}
				else if(kb['X'])//x+ stretch (zoom out (compress), stretch y, z)
				{
					if(_3d_stretch_move_cam)
					{
						double VX0=VX, VY0=VY;
						DX/=1.1;//zoom out
						function1();
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.camx=VX+(_3d.camx-VX0)/1.1, _3d.camy=VY+(_3d.camy-VY0)/1.1, _3d.camz=VZ+(_3d.camz-VZ)/1.1, _3d.dcam/=1.1;

						VY0=VY;//stretch y
						YshiftPoint/=1.1;
						AR_Y/=1.1, function1();
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.camy+=VY-VY0;

						_3d.camz-=VZ/11., VZ/=1.1;//stretch z
						AR_Z/=1.1, function1();
					}
					else
					{
						DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
						_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					}
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])//y+ stretch
				{
					double VY0=VY;
					YshiftPoint*=1.1;//move cube
					AR_Y*=1.1, function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					if(_3d_stretch_move_cam)
						_3d.camy+=VY-VY0;
					toSolve=true, shiftOnly=0;
				/*	double VY0=VY;
					if(_3d_stretch_move_cam)
						YshiftPoint*=1.1;
					//	VY=0;
					//	VY*=1.1;
					//	_3d.camy=VY+(_3d.camy-VY)*1.1, VY*=1.1;
					//	_3d.camy+=0.1*VY, VY*=1.1;
					//	VY*=1.1, _3d.camy=VY+(_3d.camy-VY)*1.1;
					//	VY*=1.1, _3d.camy+=0.1*VY;
					//	VY*=1.1, _3d.camy+=0.1*VY*AR_Y;
					//	_3d.camy+=0.1*VY;
					AR_Y*=1.1, function1();
				//	_3d.camy+=0.1*VY;//
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					toSolve=true, shiftOnly=0;
					if(_3d_stretch_move_cam)
						_3d.camy+=VY-VY0;//*/
				}
				else if(kb['Z'])//z+ stretch
				{
					if(_3d_stretch_move_cam)
						_3d.camz+=VZ*0.1;
					VZ*=1.1;//move cube
					AR_Z*=1.1, function1();
					if(contourOn)
						toSolve=true, shiftOnly=0;
				}
				else if(!kb[VK_CONTROL])//zoom in fov
					_3d.zoomIn();
			}
			if(kb[VK_SUBTRACT]||kb[VK_BACK]||kb[VK_OEM_MINUS])
			{
				if(kb[VK_MENU])//alt-
				{
					if(_3d_zoom_move_cam)//zoom out
						DX*=1.1, _3d.camx=VX+(_3d.camx-VX)*1.1, _3d.camy=VY+(_3d.camy-VY)*1.1, _3d.camz=VZ+(_3d.camz-VZ)*1.1, _3d.dcam*=1.1;
					else//zoom in
						DX/=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					toSolve=true, shiftOnly=0;
				}
				else if(kb['X'])//x- compress (zoom in (stretch), compress y z)
				{
					if(_3d_stretch_move_cam)
					{
						double VX0=VX, VY0=VY;
						DX*=1.1;//zoom in
						function1();
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.camx=VX+(_3d.camx-VX0)*1.1, _3d.camy=VY+(_3d.camy-VY0)*1.1, _3d.camz=VZ+(_3d.camz-VZ)*1.1, _3d.dcam*=1.1;
					
						VY0=VY;//compress y
						YshiftPoint*=1.1;
						AR_Y*=1.1, function1();
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.camy+=VY-VY0;
					
						_3d.camz+=VZ*0.1, VZ*=1.1;//compress z
						AR_Z*=1.1, function1();
					}
					else
					{
						DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
						_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					}
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])//y- compress
				{
					double VY0=VY;
					YshiftPoint/=1.1;//move cube
					AR_Y/=1.1, function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					if(_3d_stretch_move_cam)
						_3d.camy+=VY-VY0;
					toSolve=true, shiftOnly=0;
				/*	double VY0=VY;
					if(_3d_stretch_move_cam)
						YshiftPoint/=1.1;
					//	VY=0;
					//	VY*=1.1;
					//	_3d.camy=VY+(_3d.camy-VY)/1.1, VY*=1.1;
					//	_3d.camy-=VY/11., VY*=1.1;
					//	VY*=1.1, _3d.camy=VY+(_3d.camy-VY)/1.1;
					//	VY/=1.1, _3d.camy-=VY/11.;
					//	VY/=1.1, _3d.camy-=VY*AR_Y/11.;
					AR_Y/=1.1, function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					toSolve=true, shiftOnly=0;
					if(_3d_stretch_move_cam)
						_3d.camy+=VY-VY0;//*/
				}
				else if(kb['Z'])//z- compress
				{
					if(_3d_stretch_move_cam)
						_3d.camz-=VZ/11.;
					VZ/=1.1;//move cube
					AR_Z/=1.1, function1();
					if(contourOn)
						toSolve=true, shiftOnly=0;
				}
				else if(!kb[VK_CONTROL])//zoom out fov
					_3d.zoomOut();
			}
		//		 if(kb[VK_MENU]){		if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	DX*=1.1, DY*=1.1, function1(), toSolve=true, shiftOnly=0;
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	DX/=1.1, DY/=1.1, function1(), toSolve=true, shiftOnly=0;}
		//	else if(!kb[VK_CONTROL]){	if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	_3d.zoomIn();
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	_3d.zoomOut();}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				if(!shift)
				{
					ShowCursor(0);
					GetCursorPos(&mouseP0);
					SetCursorPos(centerP.x, centerP.y);
					SetCapture(ghWnd);
				}
				drag=1;
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(!m_bypass)
			{
				int draw=0;
				int dmx=((short*)&lParam)[0]-w/2, dmy=h/2-((short*)&lParam)[1];
				if(kb['X'])
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//xyz	mx my mw
						{
							double VX0=VX, VY0=VY;
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dmx*DX/w), _3d.camx+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, dmy*DX/w), _3d.camy+=(VY-VY0)*_3d_shift_move_cam;
						}
						else		//xy	mx my
						{
							double VX0=VX, VY0=VY;
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dmx*DX/w), _3d.camx+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, dmy*DX/w), _3d.camy+=(VY-VY0)*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//xz	mx my
						{
							double VX0=VX;
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, dmx*DX/w), _3d.camx+=(VX-VX0)*_3d_shift_move_cam;
							double dVZ=dmy*DX/w;
							VZ+=dVZ, _3d.camx+=dVZ*_3d_shift_move_cam;
						}
						else		//x		mx
						{
							double VX0=VX;
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, dmx*DX/w), _3d.camx+=(VX-VX0)*_3d_shift_move_cam;
						}
						draw=1;
					}
				}
				else
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//yz	mx my
						{
							double VY0=VY;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.camy+=(VY-VY0)*_3d_shift_move_cam;
							double dVZ=dmy*DX/w;
							VZ+=dVZ, _3d.camx+=dVZ*_3d_shift_move_cam;
						}
						else		//y		mx
						{
							double VY0=VY;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.camy+=(VY-VY0)*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//z		my
						{
							double dVZ=dmy*DX/w;
						//	double dVZ=dmy*DX/Xplaces;
							VZ+=dVZ, _3d.camz+=dVZ*_3d_shift_move_cam;
							if(contourOn)
								toSolve=true, shiftOnly=0;//just to update contour
							draw=1;
						}
						else if(drag)
						{
							_3d.rotate(lParam);
							draw=1;
						}
					}
				}
				if(draw)
				{
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
			}
			m_bypass=!m_bypass;
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				if(!shift)
				{
					ReleaseCapture();
					SetCursorPos(mouseP0.x, mouseP0.y);
					ShowCursor(1);
				}
				drag=0;
			}
		}
		int inputMouseWheel(int wParam)
		{
			bool mw_forward=((short*)&wParam)[1]>0;
			if(kb['X']&&kb['Y']&&kb['Z'])//ordered by case priority
			{
				double dVD=DX/100;
					 if(mw_forward)	VZ+=dVD, _3d.camz+=dVD*_3d_shift_move_cam;
				else				VZ-=dVD, _3d.camz-=dVD*_3d_shift_move_cam;
			}
			else if(kb[VK_MENU])//alt wheel
			{
				double VX0=VX, VY0=VY;
					 if(mw_forward)	DX*=1.1;//, DY*=1.1;
				else				DX/=1.1;//, DY/=1.1;
				function1();
				shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);//
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);//
				if(_3d_zoom_move_cam)
				{
						 if(mw_forward)	_3d.camx=VX+(_3d.camx-VX0)*1.1, _3d.camy=VY+(_3d.camy-VY0)*1.1, _3d.camz=VZ+(_3d.camz-VZ)*1.1, _3d.dcam*=1.1;
					else				_3d.camx=VX+(_3d.camx-VX0)/1.1, _3d.camy=VY+(_3d.camy-VY0)/1.1, _3d.camz=VZ+(_3d.camz-VZ)/1.1, _3d.dcam/=1.1;
				}
				toSolve=true, shiftOnly=0;
			}
			else if(kb['X'])//x wheel
			{
				if(_3d_stretch_move_cam)
				{
					double VX0=VX, VY0=VY;
						 if(mw_forward)	DX/=1.1;//zoom out
					else				DX*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						 if(mw_forward)	_3d.camx=VX+(_3d.camx-VX0)/1.1, _3d.camy=VY+(_3d.camy-VY0)/1.1, _3d.camz=VZ+(_3d.camz-VZ)/1.1, _3d.dcam/=1.1;
					else				_3d.camx=VX+(_3d.camx-VX0)*1.1, _3d.camy=VY+(_3d.camy-VY0)*1.1, _3d.camz=VZ+(_3d.camz-VZ)*1.1, _3d.dcam*=1.1;

					VY0=VY;//stretch y
						 if(mw_forward)	AR_Y/=1.1,	YshiftPoint/=1.1;
					else				AR_Y*=1.1,	YshiftPoint*=1.1;
					function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					_3d.camy+=VY-VY0;

						 if(mw_forward)	_3d.camz-=VZ/11., AR_Z/=1.1,	VZ/=1.1;//stretch z
					else				_3d.camz+=VZ*0.1, AR_Z*=1.1,	VZ*=1.1;
					function1();
				}
				else
				{
						 if(mw_forward)	DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, _3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
					else				DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, _3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
				}
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Y'])//y wheel
			{
				double VY0=VY;
					 if(mw_forward)	AR_Y*=1.1,	YshiftPoint*=1.1;
				else				AR_Y/=1.1,	YshiftPoint/=1.1;
				function1();
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
				_3d.camy+=(VY-VY0)*_3d_stretch_move_cam;
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Z'])//z wheel
			{
					 if(mw_forward)	AR_Z*=1.1, _3d.camz+=VZ*0.1*_3d_stretch_move_cam,	VZ*=1.1;
				else				AR_Z/=1.1, _3d.camz-=VZ/11.*_3d_stretch_move_cam,	VZ/=1.1;
				function1();
				if(contourOn)
					toSolve=true, shiftOnly=0;
			}
			else if(kb[VK_CONTROL])//ctrl wheel
			{
					 if(mw_forward)	_3d.faster();
				else				_3d.slower();
			}
			else if(kb[VK_SHIFT])//shift wheel
			{
				if(mw_forward)
					Yplaces=++Xplaces, toSolve=true, shiftOnly=0;
				else if(Xplaces>1)
					Yplaces=--Xplaces, toSolve=true, shiftOnly=0;
			}
			else//wheel
			{
					 if(mw_forward)	_3d.zoomIn();
				else				_3d.zoomOut();
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:case 'T':case 'G':
				if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_ADD:case VK_OEM_PLUS:case VK_RETURN:
				if(kb[VK_CONTROL])
					_3d.faster();
				else if(kb[VK_SHIFT])
				{
					Yplaces=++Xplaces, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_SUBTRACT:case VK_OEM_MINUS:case VK_BACK:
				if(kb[VK_CONTROL])
					_3d.slower();
				else if(kb[VK_SHIFT])
				{
					if(Xplaces>1)
						Yplaces=--Xplaces, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case 'X':case 'Y':case 'Z':
				if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case VK_OEM_3:
				if(contourOn)//was on
				{
					if(kb[VK_CONTROL])
					{
						//contour+surface
						//contour only
						//flat contour
						//flat+surface
						if(contourFlat)
						{
							if(contourOnly)
								contourOnly=false;//3: surface appears
							else
								contourFlat=false;//4: pops up
						}
						else
						{
							if(contourOnly)
								contourFlat=true;//2: gets flat
							else
								contourOnly=true;//1: surface disappears
						}
					}
					else
						contourOn=false, contourOnly=false, contourFlat=false;
				}
				else//was off
				{
					contourOn=true;
					if(!toSolve)
					{
						contours.clear();
						double Xs=DX/Xplaces, DZ=DX/AR_Z;
						for(unsigned e=0;e<expr.size();++e)
							if(expr[e].rmode[0]==5)
								doContour(e, Xs, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
					}
				}
				break;
			case '0':case VK_NUMPAD0:
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
			case '7':case VK_NUMPAD7:
			case '8':case VK_NUMPAD8:
				{
					auto op=&Transverse_2D::differentiate_x;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:	operations.push_back( 1), op=&Transverse_2D::differentiate_x;					break;
					case '2':case VK_NUMPAD2:	operations.push_back( 2), op=&Transverse_2D::differentiate_y;					break;
					case '3':case VK_NUMPAD3:	operations.push_back( 3), op=&Transverse_2D::integrate_x;						break;
					case '4':case VK_NUMPAD4:	operations.push_back( 4), op=&Transverse_2D::integrate_y;						break;
					case '5':case VK_NUMPAD5:	operations.push_back( 5), op=&Transverse_2D::discreteFourrierTransform;			break;
					case '6':case VK_NUMPAD6:	operations.push_back( 6), op=&Transverse_2D::inverseDiscreteFourrierTransform;	break;
					case '7':case VK_NUMPAD7:	operations.push_back( 7), op=&Transverse_2D::lowPassFilter;						break;
					case '8':case VK_NUMPAD8:	operations.push_back( 8), op=&Transverse_2D::highPassFilter;					break;
					}
					if(!toSolve)
					{
						contours.clear();
						double Xs=DX/Xplaces, DY=DX/AR_Y, DZ=DX/AR_Z;
						for(unsigned e=0;e<expr.size();++e)
						{
							auto &ndr=expr[e].n[0].ndr;
							(this->*op)(ndr);
							if(contourOn)
								doContour(e, Xs, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
						}
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E'://reset axes scale
				{
					double r=20/DX;

					XshiftPoint*=r, YshiftPoint*=r, VZ*=r;
					_3d.camx*=r, _3d.camy*=r, _3d.camz*=r, _3d.dcam*=r;
					DX=20, AR_Y=1, AR_Z=1, function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
			//		VX*=r, VY*=r, VZ*=r;
			//		_3d.camx*=r, _3d.camy*=r, _3d.camz*=r, _3d.dcam*=r;
			//		DX=20, AR_Y=1, AR_Z=1, function1();
					toSolve=true, shiftOnly=0;
				}
				break;
			case 'R'://reset position and zoom,		ctrl: position only
				_3d.dcam=.04, _3d.tanfov=1;
				if(!kb[VK_CONTROL])
					DX=20, AR_Y=1, AR_Z=1, function1(), Xplaces=Yplaces=100;

				if(XshiftPoint!=0||YshiftPoint!=0||VZ!=0)
					XshiftPoint=0, YshiftPoint=0, VZ=0;
				shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
			//	if(VX!=0||VY!=0||VZ!=0)
			//		VX=VY=VZ=0;

				toSolve=true, shiftOnly=0;
				if(kb['X'])
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
				else if(kb['Y'])
					_3d.teleport_degrees(0, 20, 0, 270, 0, 1);
				else if(kb['Z'])
					_3d.teleport_degrees(0, 0, 20, 90, 270, 1);
				else
					_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
			/*	if(kb[VK_CONTROL])
				{
					DX=20, DY=20, function1();
					toSolve=true, shiftOnly=0;
				}
				if(VX!=0||VY!=0||VZ!=0)
				{
					VX=VY=VZ=0;
					toSolve=true, shiftOnly=0;
				}
				_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);//*/
				break;
			case VK_F6:
				if(!(lParam&1<<30))
				{
					kb_VK_F6_msg=true;
					if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_stretch_move_cam=true;
					else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_shift_move_cam=true;
					else if(!_3d_zoom_move_cam)
						_3d_zoom_move_cam=true;
					else
						_3d_stretch_move_cam=_3d_shift_move_cam=_3d_zoom_move_cam=false;
				}
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:case 'T':case 'G':
				if(kp>0)
					--kp;
				break;
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[VK_CONTROL]&&kp>0)
					--kp;
				return 0;
			case 'X':
				if(!kb['Y']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Y':
				if(!kb['X']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Z':
				if(!kb['X']&&!kb['Y']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			}
			return 0;
		}
		void function1(){derive_step_3D(DX, AR_Y, AR_Z, w, Xstep, Ystep, Zstep);}
		void draw()
		{
			double DY=DX/AR_Y, DZ=DX/AR_Z;
			if(toSolve)
			{
				if(!operations.size()&&shiftOnly==1&&abs(Xoffset)<Xplaces&&abs(Yoffset)<Yplaces)
				{
					if(Xoffset||Yoffset)
					{
					//	GUIPrint(ghMemDC, w-200, h/2, "Xoffset=%d", Xoffset);//
					//	GUIPrint(ghMemDC, w-200, h/2+18, "Yoffset=%d", Yoffset);//
						solver.partial_bounds(VX, DX, VY/AR_Y, DY, Xoffset, Yoffset);
						solver.synchronize();
						for(auto &ex:expr)
							if(ex.rmode[0]==5)
								(solver.*(ex.nITD?&Solve_2D_Disc::full:solver.partial))(ex);
					}
				}
				else
				{
					auto old_time_variance=time_variance;
					time_variance=false;
				//	std::fill(nExpr.begin(), nExpr.end(), 0);
					labels.clear();
					solver.full_resize(VX, DX, VY/AR_Y, DY, Xplaces, Yplaces);
					XsamplePos=std::floor(XshiftPoint/solver.Xsample);
					YsamplePos=std::floor(YshiftPoint/(solver.Ysample*AR_Y));
				//	solver.full_resize(VX, DX, VY/AR_Y, DY, Xplaces=100, Yplaces=100), KXplaces=Xplaces/100?Xplaces/100:1, KYplaces=Yplaces/100?Yplaces/100:1;
					if(!paused)
						solver.synchronize();
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
					//	++nExpr[ex.rmode[0]];
						if(ex.rmode[0]==5)
						{
							time_variance|=ex.nITD;
							labels.fill(e);
							solver.full(ex);
							for(auto &operation:operations)
							{
								switch(operation)
								{
								case  1:differentiate_x					(ex.n[0].ndr);break;
								case  2:differentiate_y					(ex.n[0].ndr);break;
								case  3:integrate_x						(ex.n[0].ndr);break;
								case  4:integrate_y						(ex.n[0].ndr);break;
								case  5:discreteFourrierTransform		(ex.n[0].ndr);break;
								case  6:inverseDiscreteFourrierTransform(ex.n[0].ndr);break;
								case  7:lowPassFilter					(ex.n[0].ndr);break;
								case  8:highPassFilter					(ex.n[0].ndr);break;
								}
							}
						}
					}
					if(time_variance)
					{
						if(!paused)
							SetTimer(ghWnd, 0, 10, 0);
					}
					else if(old_time_variance&&!timer)
						KillTimer(ghWnd, 0);
				}
				if(contourOn)
				{
					contours.clear();
					double Xs=DX/Xplaces, DZ=DX/AR_Z;
					for(unsigned e=0;e<expr.size();++e)
						if(expr[e].rmode[0]==5)
							doContour(e, Xs, VZ/AR_Z-DZ/2, VZ/AR_Z+DZ/2, Zstep, 10);
				}
				toSolve=false, shiftOnly=2, Xoffset=0, Yoffset=0;
				exprRemoved=false;
			}
			else if(time_variance)
			{
				if(!paused)
					solver.synchronize();
				for(auto &ex:expr)
				{
					if(ex.rmode[0]==5&&ex.nITD)
					{
						solver.full(ex);
						for(auto &operation:operations)
						{
							switch(operation)
							{
							case  1:differentiate_x					(ex.n[0].ndr);break;
							case  2:differentiate_y					(ex.n[0].ndr);break;
							case  3:integrate_x						(ex.n[0].ndr);break;
							case  4:integrate_y						(ex.n[0].ndr);break;
							case  5:discreteFourrierTransform		(ex.n[0].ndr);break;
							case  6:inverseDiscreteFourrierTransform(ex.n[0].ndr);break;
							case  7:lowPassFilter					(ex.n[0].ndr);break;
							case  8:highPassFilter					(ex.n[0].ndr);break;
							}
						}
					}
				}
				if(contourOn)
				{
					double Xs=DX/Xplaces, DZ=DX/AR_Z;
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if(ex.rmode[0]==5&&ex.nITD)
						{
							contours[e].clear();
							doContour(e, Xs, VZ/AR_Z-DZ/2, VZ/AR_Z+DZ/2, Zstep, 10);
						}
					}
				}
			}
			else if(exprRemoved)
			{
				auto old_time_variance=time_variance;
				time_variance=false;
			//	std::fill(nExpr.begin(), nExpr.end(), 0);
				labels.clear();
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
				//	++nExpr[ex.rmode[0]];
					if(ex.rmode[0]==5)
					{
						time_variance|=ex.nITD;
						labels.fill(e);
					}
				}
				if(old_time_variance&&!time_variance&&!timer)
					KillTimer(ghWnd, 0);
				exprRemoved=false;
			}
			
			_3dMode_FrameStart(_3d, VX, VY, VZ, DX, Xstep, Ystep, Zstep, AR_Y, AR_Z);
			int colorCondition=nExpr[5]>1;
			double Xstart=solver.Xstart, Xr=solver.Xsample, Ystart=AR_Y*solver.Ystart, Yr=AR_Y*solver.Ysample;
			if(!contourOnly)//draw the surfaces
			{
				if(operations.size())
				{
					for(auto &ex:expr)
					{
						if(ex.rmode[0]==5)
						{
							if(colorCondition)
								_3d.lineColor=ex.color;
							auto &ndr=ex.n[0].ndr;

							for(int y=0;y<Yplaces;++y)
							{
								_3d.curve_start();
								for(int x=0;x<Xplaces;++x)
									_3d.curve_point(Xstart+x*Xr, Ystart+y*Yr, AR_Z*ndr[Xplaces*y+x]);
							}
							for(int x=0;x<Xplaces;++x)
							{
								_3d.curve_start();
								for(int y=0;y<Yplaces;++y)
									_3d.curve_point(Xstart+x*Xr, Ystart+y*Yr, AR_Z*ndr[Xplaces*y+x]);
							}
							//auto ndrIT=ndr.begin();
							//if(ndrIT!=ndr.end())
							//{
							//	for(int y=0;y<Yplaces;++y)
							//	{
							//		_3d.curve_start();
							//		for(int x=0;x<Xplaces;++x, ++ndrIT)
							//			_3d.curve_point(Xstart+x*Xsample, Ystart+y*Ysample, ndrIT->r);
							//	}
							//	for(int x=0;x<Xplaces;++x)
							//	{
							//		ndrIT=ndr.begin()+x;
							//		_3d.curve_start();
							//		for(int y=0;;)
							//		{
							//			_3d.curve_point(Xstart+x*Xsample, Ystart+y*Ysample, ndrIT->r);
							//			if(++y>=Yplaces)
							//				break;
							//			ndrIT+=Xplaces;
							//		}
							//	}
							//}
							_3d.lineColor=0;
						}
					}
				}
				else
				{
					unsigned yDiscOffset=(Xplaces-1)*Yplaces;
					for(auto &ex:expr)
					{
						if(ex.rmode[0]==5)
						{
							if(colorCondition)
								_3d.lineColor=ex.color;
							auto &ndr=ex.n[0].ndr;

						//	auto &Xdisc=solver.Xdiscs[e], &Ydisc=solver.Ydiscs[e];
							for(int y=0;y<Yplaces;++y)
							{
								_3d.curve_start();
								for(int x=0;x<Xplaces-1;++x)
								{
									_3d.curve_point(Xstart+x*Xr, Ystart+y*Yr, AR_Z*ndr[Xplaces*y+x]);
									if(ex.discontinuities[(Xplaces-1)*y+x])
								//	if(Xdisc[(Xplaces-1)*y+x])
										_3d.curve_start();
								}
								_3d.curve_point(Xstart+(Xplaces-1)*Xr, Ystart+y*Yr, AR_Z*ndr[Xplaces*y+(Xplaces-1)]);
							}
							for(int x=0;x<Xplaces;++x)
							{
								_3d.curve_start();
								for(int y=0;y<Yplaces-1;++y)
								{
									_3d.curve_point(Xstart+x*Xr, Ystart+y*Yr, AR_Z*ndr[Xplaces*y+x]);
									if(ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y])
								//	if(Ydisc[(Yplaces-1)*x+y])
										_3d.curve_start();
								}
								_3d.curve_point(Xstart+x*Xr, Ystart+(Yplaces-1)*Yr, AR_Z*ndr[Xplaces*(Yplaces-1)+x]);
							}
							_3d.lineColor=0;
						}
					}
				}
			}
			if(contourOn)//draw the contour
			{
			//	double Xstart=VX-DX/2;
			//	double Ystart=VY/AR_Y-DY/2;
			//	double Zstart=VZ/AR_Z-DX/2, Zend=VZ/AR_Z+DX/2;
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==5)
					{
						if(colorCondition)
							_3d.lineColor=ex.color;
						for(auto &L:contours[e])
						{
							double Z=contourFlat?VZ:L.first*Zstep;
							for(auto &p:L.second)
								_3d.line(p.first.x, p.first.y, AR_Z*Z, p.second.x, p.second.y, AR_Z*Z);
						}
					}
				}
			}
			if(!clearScreen)
			{
				{
					int bkMode=GetBkMode(ghMemDC);
					SetBkMode(ghMemDC, TRANSPARENT);
					for(double X=floor((VX-DX/2)/Xstep)*Xstep+Xstep, Xend=ceil((VX+DX/2)/Xstep)*Xstep;X<Xend;X+=Xstep)
						if(abs(X)>Xstep/2)
							_3d.label(X, VY, VZ, "%g", X);
					if(AR_Y==1)
					{
						for(double Y=floor((VY-DX/2)/Ystep)*Ystep+Ystep, Yend=ceil((VY+DX/2)/Ystep)*Ystep;Y<Yend;Y+=Ystep)
							if(Y<-Ystep/2||Y>Ystep/2)
								_3d.label(VX, Y, VZ, "%g", Y);
					}
					else
					{
						double aYstep=AR_Y*Ystep, Ycore=floor((VY-DX/2)/aYstep);
						for(double Y=Ycore*aYstep+aYstep, Yend=ceil((VY+DX/2)/aYstep)*aYstep, aY=Ycore*Ystep+Ystep;Y<Yend;Y+=aYstep, aY+=Ystep)
							if(Y<-aYstep/2||Y>aYstep/2)
								_3d.label(VX, Y, VZ, "%g", aY);
					}
					if(AR_Z==1)
					{
						for(double Z=floor((VZ-DX/2)/Zstep)*Zstep+Zstep, Zend=ceil((VZ+DX/2)/Zstep)*Zstep;Z<Zend;Z+=Zstep)
							if(Z<-Zstep/2||Z>Zstep/2)
								_3d.label(VX, VY, Z, "%g", Z);
					}
					else
					{
						double aZstep=AR_Z*Zstep, Zcore=floor((VZ-DX/2)/aZstep);
						for(double Z=Zcore*aZstep+aZstep, Zend=ceil((VZ+DX/2)/aZstep)*aZstep, aZ=Zcore*Zstep+Zstep;Z<Zend;Z+=aZstep, aZ+=Zstep)
							if(Z<-aZstep/2||Z>aZstep/2)
								_3d.label(VX, VY, Z, "%g", aZ);
					}
					//for(double x=floor((VX-DX/2)/step)*step+step;x<ceil((VX+DX/2)/step)*step;x+=step)
					//	if(abs(x)>step/2)
					//		_3d.label(x, VY, VZ, "%g", x);
					//for(double y=floor((VY-DX/2)/step)*step+step;y<ceil((VY+DX/2)/step)*step;y+=step)
					//	if(abs(y)>step/2)
					//		_3d.label(VX, y, VZ, "%g", y);
					//for(double z=floor((VZ-DX/2)/step)*step+step;z<ceil((VZ+DX/2)/step)*step;z+=step)
					//	if(abs(z)>step/2)
					//		_3d.label(VX, VY, z, "%g", z);
					{
						auto al=colorCondition?(void (_3D::*)(double, double, double, double, double, double, std::vector<Label>&))&_3D::arrowLabelsColor:&_3D::arrowLabels;
					//	void (_3D::*al)(double, double, double, double, double, double, std::vector<Label>&);
					//	if(colorCondition)
					//		al=&_3D::arrowLabelsColor;
					//	else
					//		al=&_3D::arrowLabels;
					//	auto LOL=colorCondition?&_3D::arrowLabelsColor:&_3D::arrowLabels;
						(_3d.*al)(0, 0, 0, 1, 0, 0, labels.Xlabels);
						(_3d.*al)(0, 0, 0, 0, 1, 0, labels.Ylabels);
					}
					{
						int textColor;
						if(colorCondition)
							textColor=GetTextColor(ghMemDC);
						int Ys=0;
						for(auto &label:labels.Clabels)
						{
							int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						//	linelen=sprintf_s(line, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
							if(colorCondition)
								SetTextColor(ghMemDC, expr[label.exNo].winColor);
							TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
						//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, line, linelen), Ys+=16;
						}
						if(colorCondition)
							SetTextColor(ghMemDC, textColor);
					}
					SetBkMode(ghMemDC, bkMode);
				}
				{
					int k=0, Y=h-operations.size()*16;
					for(auto operation:operations)
					{
						char const *a=0;
						switch(operation)
						{
						case 1:a="%d: Differentiate X";	break;
						case 2:a="%d: Differentiate Y";	break;
						case 3:a="%d: Integrate X";		break;
						case 4:a="%d: Integrate Y";		break;
						case 5:a="%d: DFT";				break;
						case 6:a="%d: IDFT";			break;
						case 7:a="%d: LPF";				break;
						case 8:a="%d: HPF";				break;
						case 9:a="%d: HT";				break;
						case 10:a="%d: IHT";			break;
						}
						_3d.textIn2D(w-const_label_offset_X, Y, OPAQUE, a, k);
						++k, Y+=16;
					}
				}
				_3d.text_show();
				if(kb_VK_F6_msg||kb[VK_F6])
				{
					int kb_mode=SetBkMode(ghMemDC, OPAQUE);
					kb_VK_F6_msg=false;
					if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
						GUIPrint(ghMemDC, 0, h-18*3, "move cam: [-] scale, [-] shift, [-] zoom");
					else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
						GUIPrint(ghMemDC, 0, h-18*3, "move cam: [v] scale, [-] shift, [-] zoom");
					else if(!_3d_zoom_move_cam)
						GUIPrint(ghMemDC, 0, h-18*3, "move cam: [v] scale, [v] shift, [-] zoom");
					else
						GUIPrint(ghMemDC, 0, h-18*3, "move cam: [v] scale, [v] shift, [v] zoom");//*/
				/*	if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
						GUIPrint(ghMemDC, 0, h-18*3, "move cam: -");
					else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
						GUIPrint(ghMemDC, 0, h-18*3, "move cam: scale");
					else if(!_3d_zoom_move_cam)
						GUIPrint(ghMemDC, 0, h-18*3, "move cam: scale, shift");
					else
						GUIPrint(ghMemDC, 0, h-18*3, "move cam: scale, shift, zoom");//*/
				/*	if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
						GUIPrint(ghMemDC, 0, h-18*3, "3D modes scale, shift & zoom don't move cam");
					else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
						GUIPrint(ghMemDC, 0, h-18*3, "3D modes move cam: scale");
					else if(!_3d_zoom_move_cam)
						GUIPrint(ghMemDC, 0, h-18*3, "3D modes move cam: scale, shift");
					else
						GUIPrint(ghMemDC, 0, h-18*3, "3D modes move cam: scale, shift, zoom");//*/
					SetBkMode(ghMemDC, kb_mode);
				}
			}
		}
		void i_draw();
		void a_draw();
	} t2d;
	const std::set<int> Transverse_2D::modes({5});
	void			Transverse_2D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				std::copy(rgb, rgb+w*h, modeRGB);

			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, OPAQUE);
				if(nExpr[5]>1)
					itb.draw_color(modes);
				else
					itb.draw();
				SetBkMode(ghMemDC, bkMode);
			}
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		}
		else
		{
			std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Transverse_2D::a_draw()
	{
		Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
	namespace contour
	{
		struct Int_x_y_z_Double_Z
		{
			int x, y, c;
			double Z;
			Int_x_y_z_Double_Z(int x, int y, int c, double Z):x(x), y(y), c(c), Z(Z){}
		};
	}
	class		Color_2D:public Mode
	{
	public:
	//	int toSolve;
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		int Xoffset, Yoffset;
	//	int bpx, bpy, bh, bw;

		int Xplaces, Yplaces;
		double VX, VY, DX, AR_Y, Xstep, Ystep;
		int prec;
		Solve_C2D solver;
		std::list<int> operations;

		bool contourOn, contourOnly;//, contourFlat;
		
		bool clearScreen;
		Labels_2D labels;
		HPEN__ *hPen;
		HBRUSH__ *hBrush;
		
	//	char line[128];
	//	int linelen;
		bool timer, drag, m_bypass;
		int kp;

		Color_2D():
			VX(0), VY(0), DX(20), AR_Y(1),
		//	bpx(0), bpy(0), bw(0), bh(0),
			timer(false), drag(false), m_bypass(false), kp(0),
			shiftOnly(2), Xoffset(0), Yoffset(0),
		//	toSolve(1), shiftOnly(2), Xoffset(0), Yoffset(0),
			fft_N0(0), fft_N1(0),
			clearScreen(true),
			contourOnly(false)//, contourFlat(true)
		{
			hPen=CreatePen(PS_SOLID, 1, 0x00EFEFEF), hBrush=CreateSolidBrush(0x00EFEFEF);
		}
		~Color_2D()
		{
			DeleteObject(hPen), DeleteObject(hBrush);
			if(fft_N0||fft_N1)
			{
				fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
				fftw_free(fft_in), fftw_free(fft_out);
			}
		}

		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				drag=1;
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
			}
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
		//	kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]+kb[VK_ADD]+kb[VK_OEM_PLUS]+kb[VK_SUBTRACT]+kb[VK_OEM_MINUS];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag)
			{
				drag=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		
		void doContour_component_range(std::vector<Value> &ndr, double Xs, double Zstart, double Zend, double Zstep, unsigned nzSteps, unsigned const component, int x1, int x2, int y1, int y2)
		{
			int dx=x2-x1, dy=y2-y1, x11=x1+1, y11=y1+1, x2_1=x2-1, y2_1=y2-1;
			if(dx>=3&&dy>=3)
			{
				const double aa_thickness=1,
				
					_1_aa_thickness=1/aa_thickness;
				const int aa_bound=int(std::round(aa_thickness));

				//crossings
				int Xplaces_1=Xplaces-1, Yplaces_1=Yplaces-1,
					XCsize=Xplaces_1*Yplaces, YCsize=Yplaces_1*Xplaces, ndrSize=Xplaces*Yplaces,
					Xplaces1=Xplaces+aa_bound;
				std::vector<double>
					Xcross(XCsize, -1),//._
					Ycross(YCsize, -1);//!
				std::vector<bool> shade(Xplaces1*(Yplaces+aa_bound));
				{
					// _	top left
					//|_!
					auto&v00=(&ndr[Xplaces*y1	+x1].r)[component], &v01=(&ndr[Xplaces*y1	+x11].r)[component],
						&v10=(&ndr[Xplaces*y11	+x1].r)[component], &v11=(&ndr[Xplaces*y11	+x11].r)[component];
					auto&corner=shade[Xplaces1*y11+x11];
					if(std::signbit(v00)!=std::signbit(v01))
						corner=true, Xcross[Xplaces_1*y1+x1]=(0-v00)/(v01-v00);		//zero cross
					if(std::signbit(v10)!=std::signbit(v11))
						corner=true, Xcross[Xplaces_1*y11+x1]=(0-v10)/(v11-v10);
					if(std::signbit(v00)!=std::signbit(v10))
						corner=true, Ycross[Xplaces*y1+x1]=(0-v00)/(v10-v00);
					if(std::signbit(v01)!=std::signbit(v11))
						corner=true, Ycross[Xplaces*y1+x11]=(0-v01)/(v11-v01);
				}
				{
					// _	top right
					//._|
					auto&v00=(&ndr[Xplaces*y1	+x2_1-1].r)[component], &v01=(&ndr[Xplaces*y1	+x2_1].r)[component],
						&v10=(&ndr[Xplaces*y11	+x2_1-1].r)[component], &v11=(&ndr[Xplaces*y11	+x2_1].r)[component];
					auto&corner=shade[Xplaces1*y11+x2_1-1];
					if(std::signbit(v00)!=std::signbit(v01))
						corner=true, Xcross[Xplaces_1*y1	+x2_1-1]=(0-v00)/(v01-v00);		//zero cross
					if(std::signbit(v10)!=std::signbit(v11))
						corner=true, Xcross[Xplaces_1*y11	+x2_1-1]=(0-v10)/(v11-v10);
					if(std::signbit(v01)!=std::signbit(v11))
						corner=true, Ycross[Xplaces*y11+	x2_1]=(0-v01)/(v11-v01);
				}
				{
					//  .	bottom left
					//|_|
					auto&v00=(&ndr[Xplaces*(y2_1-1)	+x1].r)[component], &v01=(&ndr[Xplaces*(y2_1-1)	+x11].r)[component],
						&v10=(&ndr[Xplaces* y2_1	+x1].r)[component], &v11=(&ndr[Xplaces* y2_1	+x11].r)[component];
					auto&corner=shade[Xplaces1*(y2_1-1)+x11];
					if(std::signbit(v10)!=std::signbit(v11))
						corner=true, Xcross[Xplaces_1*y2_1	+x1]=(0-v10)/(v11-v10);		//zero cross
					if(std::signbit(v00)!=std::signbit(v10))
						corner=true, Ycross[Xplaces*(y2_1-1)	+x1]=(0-v00)/(v10-v00);
					if(std::signbit(v01)!=std::signbit(v11))
						corner=true, Ycross[Xplaces*(y2_1-1)	+x11]=(0-v01)/(v11-v01);
				}
				for(int x=x11, xEnd=x2_1-1;x<xEnd;++x)
				{
					// _	upper row
					//._!
					auto&v00=(&ndr[Xplaces*y1	+x].r)[component], &v01=(&ndr[Xplaces*y1	+x+1].r)[component],
						&v10=(&ndr[Xplaces*y11	+x].r)[component], &v11=(&ndr[Xplaces*y11	+x+1].r)[component];
					auto&p0=shade[Xplaces1*y11+x], &p1=shade[Xplaces1*y11+x+1];
					if(std::signbit(v00)!=std::signbit(v01))
						p0=p1=true, Xcross[Xplaces_1*y1	+x]=(0-v00)/(v01-v00);		//zero cross
					if(std::signbit(v10)!=std::signbit(v11))
						p0=p1=true, Xcross[Xplaces_1*y11+x]=(0-v10)/(v11-v10);
					if(std::signbit(v01)!=std::signbit(v11))
						p0=p1=true, Ycross[Xplaces*y1	+x+1]=(0-v01)/(v11-v01);
				}
				for(int y=y11, yEnd=y2_1-1;y<yEnd;++y)
				{
					//  .	left column
					//|_!
					auto&v00=(&ndr[Xplaces* y   +x1].r)[component], &v01=(&ndr[Xplaces* y   +x11].r)[component],
						&v10=(&ndr[Xplaces*(y+1)+x1].r)[component], &v11=(&ndr[Xplaces*(y+1)+x11].r)[component];
					auto&p0=shade[Xplaces1*y+x11], &p1=shade[Xplaces1*(y+1)+x11];
					if(std::signbit(v10)!=std::signbit(v11))
						p0=p1=true, Xcross[Xplaces_1*(y+1)	+x1]=(0-v10)/(v11-v10);		//zero cross
					if(std::signbit(v00)!=std::signbit(v10))
						p0=p1=true, Ycross[Xplaces*y	+x1]=(0-v00)/(v10-v00);
					if(std::signbit(v01)!=std::signbit(v11))
						p0=p1=true, Ycross[Xplaces*y	+x11]=(0-v01)/(v11-v01);
				}
				auto aa_straight=[&](double d){return d>aa_thickness?1:d*_1_aa_thickness;};
				auto aa_close=[&](double x, double y)
				{
					double d=x*y*inv_sqrt(x*x+y*y);
				//	double d=std::abs(x*y)*inv_sqrt(x*x+y*y);
					return d>aa_thickness?1:d*_1_aa_thickness;
				};
				auto aa_middle=[&](double a, double b)//|. |
				{
					double b_a=b-a, d=a*inv_sqrt(1+b_a*b_a);
					return d>aa_thickness?1:d*_1_aa_thickness;
				};
				auto aa_far=[&](double x, double y)
				{
					double x_1=x-1, y_1=y-1;
					double d=std::abs(x*y-1)*inv_sqrt(x_1*x_1+y_1*y_1);
					return d>aa_thickness?1:d*_1_aa_thickness;
				};
				int complement=component?0x00FF00:0x0000FF;
			//	int complement=component?0xFFFFFF:0;
				int *&_rgb=solver.rgb;
				auto ApplyDIBPixelUnchecked=[&](int x, int y, double a)
				{
					auto p=(unsigned char*)&_rgb[y*w+x];
				//	auto p=(unsigned char*)&solver.rgb[y*w+x];
					*(int*)p^=complement;
					p[0]=unsigned char(p[0]*a), p[1]=unsigned char(p[1]*a), p[2]=unsigned char(p[2]*a);
					*(int*)p^=complement;
				};
				for(int y=y1+aa_bound, yEnd=y2_1;y<yEnd;++y)
				{
					for(int x=x1+aa_bound, xEnd=x2_1;x<xEnd;++x)
					{
						int ndrP=Xplaces*y+x;
						int sp=Xplaces1*y+x;
						{
							auto										&v01=(&ndr[ndrP			+1].r)[component],
								&v10=(&ndr[ndrP+Xplaces].r)[component], &v11=(&ndr[ndrP+Xplaces	+1].r)[component];
							if(std::signbit(v10)!=std::signbit(v11))
							{
								Xcross[Xplaces_1*(y+1)+x]=(0-v10)/(v11-v10);	//zero cross
								shade[sp				]=true, shade[sp			+1	]=true;
								shade[sp+Xplaces1		]=true, shade[sp+Xplaces1	+1	]=true;
								shade[sp+Xplaces1*2		]=true, shade[sp+Xplaces1*2	+1	]=true;
							}
							if(std::signbit(v01)!=std::signbit(v11))
							{
								Ycross[ndrP+1]=(0-v01)/(v11-v01);
								shade[sp				]=true, shade[sp			+1	]=true, shade[sp			+2	]=true;
								shade[sp+Xplaces1		]=true, shade[sp+Xplaces1	+1	]=true, shade[sp+Xplaces1	+2	]=true;
							}
						}
						if(shade[sp])
						{
							//	 	Dx
							//	Lx	+	Rx
							//		Ux  '
							auto		&Dx=Ycross[Xplaces*(y-1)+x],
								&Lx=Xcross[Xplaces_1*y+x-1],	&Rx=Xcross[Xplaces_1*y+x],
										&Ux=Ycross[Xplaces* y   +x];
							if(Ux!=-1)
							{
								if(Dx!=-1)
								{
									if(Lx!=-1)
									{
										if(Rx!=-1)	//udlr	>=2 lines	\+\	/+/
										{
											double d, d_min=aa_close(Rx, Ux);
											if(d_min>(d=aa_close(Rx, 1-Dx)))
												d_min=d;
											if(d_min>(d=aa_close(1-Lx, 1-Dx)))
												d_min=d;
											if(d_min>(d=aa_close(1-Lx, Ux)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		//udl	>=2 lines	<+
										{
											double d, d_min=aa_close(1-Lx, 1-Dx);
											if(d_min>(d=aa_close(1-Lx, Ux)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
									}
									else
									{
										if(Rx!=-1)	//ud r	>=2 lines	+>
										{
											double d, d_min=aa_close(Rx, Ux);
											if(d_min>(d=aa_close(Rx, 1-Dx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		//ud				_F_
										{
											double d, d_min=Ux;
											if(d_min>(d=1-Dx))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
									}
								}
								else
								{
									if(Lx!=-1)
									{
										if(Rx!=-1)	//u lr	>=2 lines	\+/
										{
											double d, d_min=aa_close(Rx, 1-Dx);
											if(d_min>(d=aa_close(1-Lx, 1-Dx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		//u l	>=1 line	\+
											ApplyDIBPixelUnchecked(x, y, aa_close(1-Lx, Ux));
									}
									else
									{
										if(Rx!=-1)	//u  r	>=1 line	+/
											ApplyDIBPixelUnchecked(x, y, aa_close(Rx, Ux));
										else		//u		>=1 line	_+_
										{
											auto &LUx=Ycross[Xplaces* y   +x-1], &RUx=Ycross[Xplaces* y   +x+1];
											double d, d_min=Ux;
											if(LUx!=-1&&LUx<Ux&&d_min>(d=aa_middle(Ux, LUx)))
												d_min=d;
											if(RUx!=-1&&RUx<Ux&&d_min>(d=aa_middle(Ux, RUx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
									}
								}
							}
							else
							{
								if(Dx!=-1)
								{
									if(Lx!=-1)
									{
										if(Rx!=-1)	// dlr	>=2 lines	/+\ 
										{
											double d, d_min=aa_close(Rx, Ux);
											if(d_min>(d=aa_close(1-Lx, Ux)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		// dl	>=1 line	/+
											ApplyDIBPixelUnchecked(x, y, aa_close(1-Lx, 1-Dx));
									}
									else
									{
										if(Rx!=-1)	// d r	>=1 line	+\ 
											ApplyDIBPixelUnchecked(x, y, aa_close(Rx, 1-Dx));
										else		// d	>=1 line	F
										{
											auto &LDx=Ycross[Xplaces*(y-1)+x-1], &RDx=Ycross[Xplaces*(y-1)+x+1];
											double d, d_min=1-Dx;
											if(LDx!=-1&&LDx>Dx&&d_min>(d=aa_middle(1-Dx, 1-LDx)))
												d_min=d;
											if(RDx!=-1&&RDx>Dx&&d_min>(d=aa_middle(1-Dx, 1-RDx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
									}
								}
								else
								{
									if(Lx!=-1)
									{
										if(Rx!=-1)	//  lr	>=1 line	|+|
										{
											double d, d_min=Rx;
											if(d_min>(d=1-Lx))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		//  l	>=1 line	|+
										{
											auto &DLx=Xcross[Xplaces_1*(y-1)+x-1], &ULx=Xcross[Xplaces_1*(y+1)+x-1];
											double d, d_min=1-Lx;
											if(DLx!=-1&&DLx>Lx&&d_min>(d=aa_middle(1-Lx, 1-DLx)))
												d_min=d;
											if(ULx!=-1&&ULx>Lx&&d_min>(d=aa_middle(1-Lx, 1-ULx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
									}
									else
									{
										if(Rx!=-1)	//   r	>=1 line	+|
										{
											auto &DRx=Xcross[Xplaces_1*(y-1)+x  ], &URx=Xcross[Xplaces_1*(y+1)+x  ];
											double d, d_min=Rx;
											if(DRx!=-1&&DRx<Rx&&d_min>(d=aa_middle(Rx, DRx)))
												d_min=d;
											if(URx!=-1&&URx<Rx&&d_min>(d=aa_middle(Rx, URx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		//		>=0 lines
										{
											auto
												&DLx=Xcross[Xplaces_1*(y-1)+x-1],	&LDx=Ycross[Xplaces*(y-1)+x-1],//	 _    _
												&DRx=Xcross[Xplaces_1*(y-1)+x  ],	&RDx=Ycross[Xplaces*(y-1)+x+1],//	| 1  2 | D
												&ULx=Xcross[Xplaces_1*(y+1)+x-1],	&LUx=Ycross[Xplaces* y   +x-1],//	    .
												&URx=Xcross[Xplaces_1*(y+1)+x  ],	&RUx=Ycross[Xplaces* y   +x+1];//	|_3  4_| U
											double d, d_min=_HUGE;
											if(DLx!=-1&&LDx!=-1&&d_min>(d=aa_far(1-DLx, 1-LDx)))//1
												d_min=d;
											if(DRx!=-1&&RDx!=-1&&d_min>(d=aa_far(  DRx, 1-RDx)))//2
												d_min=d;
											if(ULx!=-1&&LUx!=-1&&d_min>(d=aa_far(1-ULx,   LUx)))//3
												d_min=d;
											if(URx!=-1&&RUx!=-1&&d_min>(d=aa_far(  URx,   RUx)))//4
												d_min=d;
											if(d_min!=_HUGE)
												ApplyDIBPixelUnchecked(x, y, d_min>aa_thickness?1:d_min*_1_aa_thickness);
										}
									}
								}
							}
						}
					}
				}
			}
		}
		void doContour_component_partial(std::vector<Value> &ndr, double Xs, double Zstart, double Zend, double Zstep, unsigned nzSteps, unsigned const component, int Xoffset, int Yoffset)
		{
			int Xoffset2=std::abs(Xoffset)+2, Yoffset2=std::abs(Yoffset)+2;
				 if(Xoffset>0){							 if(Yoffset>0)					doContour_component_range(ndr, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xplaces,	0,					Yoffset2),			doContour_component_range(ndr, Xs, Zstart, Zend, Zstep, nzSteps, component,	Xplaces-Xoffset2,	Xplaces,	Yoffset,			Yplaces);
													else if(Yoffset<0)Yoffset=-Yoffset,	doContour_component_range(ndr, Xs, Zstart, Zend, Zstep, nzSteps, component,	Xplaces-Xoffset2,	Xplaces,	0,					Yplaces-Yoffset),	doContour_component_range(ndr, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xplaces,	Yplaces-Yoffset2,	Yplaces);
													else								doContour_component_range(ndr, Xs, Zstart, Zend, Zstep, nzSteps, component,	Xplaces-Xoffset2,	Xplaces,	0,					Yplaces);}
			else if(Xoffset<0){Xoffset=-Xoffset;		 if(Yoffset>0)					doContour_component_range(ndr, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xplaces,	0,					Yoffset2),			doContour_component_range(ndr, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xoffset2,	Yoffset,			Yplaces);
													else if(Yoffset<0)Yoffset=-Yoffset,	doContour_component_range(ndr, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xoffset2,	0,					Yplaces-Yoffset),	doContour_component_range(ndr, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xplaces,	Yplaces-Yoffset2,	Yplaces);
													else								doContour_component_range(ndr, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xoffset2,	0,					Yplaces);}
			else{										 if(Yoffset>0)					doContour_component_range(ndr, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xplaces,	0,					Yoffset2);
													else if(Yoffset<0)Yoffset=-Yoffset,	doContour_component_range(ndr, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xplaces,	Yplaces-Yoffset2,	Yplaces);
													else;}
		/*		 if(Xoffset>0){							 if(Yoffset>0)					doContour_component_range(ndr, contour, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xplaces,	0,					Yoffset2),			doContour_component_range(ndr, contour, Xs, Zstart, Zend, Zstep, nzSteps, component,	Xplaces-Xoffset2,	Xplaces,	Yoffset,			Yplaces);
													else if(Yoffset<0)Yoffset=-Yoffset,	doContour_component_range(ndr, contour, Xs, Zstart, Zend, Zstep, nzSteps, component,	Xplaces-Xoffset2,	Xplaces,	0,					Yplaces-Yoffset),	doContour_component_range(ndr, contour, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xplaces,	Yplaces-Yoffset2,	Yplaces);
													else								doContour_component_range(ndr, contour, Xs, Zstart, Zend, Zstep, nzSteps, component,	Xplaces-Xoffset2,	Xplaces,	0,					Yplaces);}
			else if(Xoffset<0){Xoffset=-Xoffset;		 if(Yoffset>0)					doContour_component_range(ndr, contour, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xplaces,	0,					Yoffset2),			doContour_component_range(ndr, contour, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xoffset2,	Yoffset,			Yplaces);
													else if(Yoffset<0)Yoffset=-Yoffset,	doContour_component_range(ndr, contour, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xoffset2,	0,					Yplaces-Yoffset),	doContour_component_range(ndr, contour, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xplaces,	Yplaces-Yoffset2,	Yplaces);
													else								doContour_component_range(ndr, contour, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xoffset2,	0,					Yplaces);}
			else{										 if(Yoffset>0)					doContour_component_range(ndr, contour, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xplaces,	0,					Yoffset2);
													else if(Yoffset<0)Yoffset=-Yoffset,	doContour_component_range(ndr, contour, Xs, Zstart, Zend, Zstep, nzSteps, component,	0,					Xplaces,	Yplaces-Yoffset2,	Yplaces);
													else;}//*/
		}
		void doContour_partial(unsigned e, double Xs, double Zstart, double Zend, double Zstep, unsigned nzSteps, int Xoffset, int Yoffset)
		{
			auto &ndr=expr[e].n[0].ndr;
			doContour_component_partial(ndr, Xs, Zstart, Zend, Zstep, nzSteps, 0, Xoffset, Yoffset);
			doContour_component_partial(ndr, Xs, Zstart, Zend, Zstep, nzSteps, 1, Xoffset, Yoffset);
		}
		void doContour_component(std::vector<Value> &ndr, double Xs, double Zstart, double Zend, double Zstep, unsigned nzSteps, unsigned const component)
		{
			if(Xplaces>=3&&Yplaces>=3)
			{
				//using namespace contour;
				//LARGE_INTEGER li;
				//QueryPerformanceCounter(&li);
				//long long time_start=li.QuadPart;

				const double aa_thickness=1,
				
					_1_aa_thickness=1/aa_thickness;
				const int aa_bound=int(std::round(aa_thickness));

				//crossings
				int Xplaces_1=Xplaces-1, Yplaces_1=Yplaces-1,
					XCsize=Xplaces_1*Yplaces, YCsize=Xplaces*Yplaces_1,
					Xplaces1=Xplaces+aa_bound;
				std::vector<double>
					Xcross(XCsize, -1),//._
					Ycross(YCsize, -1);//!
				std::vector<bool> shade(Xplaces1*(Yplaces+aa_bound));
				{
					// _	top left
					//|_!
					auto&v00=(&ndr[				0].r)[component], &v01=(&ndr[			1].r)[component],
						&v10=(&ndr[Xplaces*1+	0].r)[component], &v11=(&ndr[Xplaces*1+	1].r)[component];
					auto&corner=shade[Xplaces1*1+1];
					if(std::signbit(v00)!=std::signbit(v01))
						corner=true, Xcross[Xplaces_1*0+0]=(0-v00)/(v01-v00);	//zero cross
					if(std::signbit(v10)!=std::signbit(v11))
						corner=true, Xcross[Xplaces_1*1+0]=(0-v10)/(v11-v10);
					if(std::signbit(v00)!=std::signbit(v10))
						corner=true, Ycross[Xplaces*0+0]=(0-v00)/(v10-v00);
					if(std::signbit(v01)!=std::signbit(v11))
						corner=true, Ycross[Xplaces*0+1]=(0-v01)/(v11-v01);
				}
				{
					// _	top right
					//._|
					auto&v00=(&ndr[				Xplaces_1-1].r)[component], &v01=(&ndr[				Xplaces_1].r)[component],
						&v10=(&ndr[Xplaces*1+	Xplaces_1-1].r)[component], &v11=(&ndr[Xplaces*1+	Xplaces_1].r)[component];
					auto&corner=shade[Xplaces1*1+Xplaces_1-1];
					if(std::signbit(v00)!=std::signbit(v01))
						corner=true, Xcross[Xplaces_1*0+	Xplaces_1-1]=(0-v00)/(v01-v00);		//zero cross
					if(std::signbit(v10)!=std::signbit(v11))
						corner=true, Xcross[Xplaces_1*1+	Xplaces_1-1]=(0-v10)/(v11-v10);
					if(std::signbit(v01)!=std::signbit(v11))
						corner=true, Ycross[Xplaces*1+	Xplaces_1]=(0-v01)/(v11-v01);
				}
				{
					//  .	bottom left
					//|_|
					auto&v00=(&ndr[Xplaces*(Yplaces_1-1)+0].r)[component], &v01=(&ndr[Xplaces*(Yplaces_1-1)	+1].r)[component],
						&v10=(&ndr[Xplaces* Yplaces_1	+0].r)[component], &v11=(&ndr[Xplaces* Yplaces_1	+1].r)[component];
					auto&corner=shade[Xplaces1*(Yplaces_1-1)+1];
					if(std::signbit(v10)!=std::signbit(v11))
						corner=true, Xcross[Xplaces_1*Yplaces_1		+0]=(0-v10)/(v11-v10);		//zero cross
					if(std::signbit(v00)!=std::signbit(v10))
						corner=true, Ycross[Xplaces*(Yplaces_1-1)	+0]=(0-v00)/(v10-v00);
					if(std::signbit(v01)!=std::signbit(v11))
						corner=true, Ycross[Xplaces*(Yplaces_1-1)	+1]=(0-v01)/(v11-v01);
				}
				for(int x=1, xEnd=Xplaces_1-1;x<xEnd;++x)
				{
					// _	upper row
					//._!
					auto&v00=(&ndr[Xplaces*0	+x].r)[component], &v01=(&ndr[Xplaces*0	+x+1].r)[component],
						&v10=(&ndr[Xplaces*1	+x].r)[component], &v11=(&ndr[Xplaces*1	+x+1].r)[component];
					auto&p0=shade[Xplaces1*1+x], &p1=shade[Xplaces1*1+x+1];
					if(std::signbit(v00)!=std::signbit(v01))
						p0=p1=true, Xcross[Xplaces_1*0	+x]=(0-v00)/(v01-v00);	//zero cross
					if(std::signbit(v10)!=std::signbit(v11))
						p0=p1=true, Xcross[Xplaces_1*1	+x]=(0-v10)/(v11-v10);
					if(std::signbit(v01)!=std::signbit(v11))
						p0=p1=true, Ycross[Xplaces*0	+x+1]=(0-v01)/(v11-v01);
				}
				for(int y=1, yEnd=Yplaces_1-1;y<yEnd;++y)
				{
					//  .	left column
					//|_!
					auto&v00=(&ndr[Xplaces* y   +0].r)[component], &v01=(&ndr[Xplaces* y   +1].r)[component],
						&v10=(&ndr[Xplaces*(y+1)+0].r)[component], &v11=(&ndr[Xplaces*(y+1)+1].r)[component];
					auto&p0=shade[Xplaces1*y+1], &p1=shade[Xplaces1*(y+1)+1];
					if(std::signbit(v10)!=std::signbit(v11))
						p0=p1=true, Xcross[Xplaces_1*(y+1)		+0]=(0-v10)/(v11-v10);	//zero cross
					if(std::signbit(v00)!=std::signbit(v10))
						p0=p1=true, Ycross[Xplaces*y	+0]=(0-v00)/(v10-v00);
					if(std::signbit(v01)!=std::signbit(v11))
						p0=p1=true, Ycross[Xplaces*y	+1]=(0-v01)/(v11-v01);
				}
			
				//QueryPerformanceCounter(&li);
				//time_start=li.QuadPart-time_start;
				//long long time_aa=li.QuadPart;

				auto aa_straight=[&](double d){return d>aa_thickness?1:d*_1_aa_thickness;};
				auto aa_close=[&](double x, double y)
				{
					double d=x*y*inv_sqrt(x*x+y*y);
				//	double d=std::abs(x*y)*inv_sqrt(x*x+y*y);
					return d>aa_thickness?1:d*_1_aa_thickness;
				};
				auto aa_middle=[&](double a, double b)//|. |
				{
					double b_a=b-a, d=a*inv_sqrt(1+b_a*b_a);
					return d>aa_thickness?1:d*_1_aa_thickness;
				};
				auto aa_far=[&](double x, double y)
				{
					double x_1=x-1, y_1=y-1;
					double d=std::abs(x*y-1)*inv_sqrt(x_1*x_1+y_1*y_1);
					return d>aa_thickness?1:d*_1_aa_thickness;
				};
			
				int complement=component?0x00FF00:0x0000FF;
			//	int complement=component?0xFFFFFF:0;
				int *&_rgb=solver.rgb;
				auto ApplyDIBPixelUnchecked=[&](int x, int y, double a)
				{
					auto p=(unsigned char*)&_rgb[y*w+x];
				//	auto p=(unsigned char*)&solver.rgb[y*w+x];
					*(int*)p^=complement;
					p[0]=unsigned char(p[0]*a), p[1]=unsigned char(p[1]*a), p[2]=unsigned char(p[2]*a);
					*(int*)p^=complement;
				};
			/*	auto DimDIBPixelUnchecked=[&](int x, int y, double a)
				{
				//	if(x>=0&&x<w&&y>=0&&y<h)
				//	{
						auto p=(unsigned char*)&solver.rgb[y*w+x];
						p[0]=unsigned char(p[0]*a), p[1]=unsigned char(p[1]*a), p[2]=unsigned char(p[2]*a);
				//	}
				};//*/
				for(int y=aa_bound, yEnd=Yplaces_1;y<yEnd;++y)
				{
					for(int x=aa_bound, xEnd=Xplaces_1;x<xEnd;++x)
					{
						int ndrP=Xplaces*y+x;
						int sp=Xplaces1*y+x;
						{
							auto										&v01=(&ndr[ndrP			+1].r)[component],
								&v10=(&ndr[ndrP+Xplaces].r)[component], &v11=(&ndr[ndrP+Xplaces	+1].r)[component];
							if(std::signbit(v10)!=std::signbit(v11))
							{
								Xcross[Xplaces_1*(y+1)+x]=(0-v10)/(v11-v10);	//zero cross
								shade[sp			]=true, shade[sp			+1]=true;
								shade[sp+Xplaces1	]=true, shade[sp+Xplaces1	+1]=true;
								shade[sp+Xplaces1*2	]=true, shade[sp+Xplaces1*2	+1]=true;
							}
							if(std::signbit(v01)!=std::signbit(v11))
							{
								Ycross[ndrP+1]=(0-v01)/(v11-v01);
								shade[sp			]=true, shade[sp			+1]=true, shade[sp			+2]=true;
								shade[sp+Xplaces1	]=true, shade[sp+Xplaces1	+1]=true, shade[sp+Xplaces1	+2]=true;
							}
						}
						if(shade[sp])
						{
							//	 	Dx
							//	Lx	+	Rx
							//		Ux  '
							auto		&Dx=Ycross[Xplaces*(y-1)+x],
								&Lx=Xcross[Xplaces_1*y+x-1],	&Rx=Xcross[Xplaces_1*y+x],
										&Ux=Ycross[Xplaces* y   +x];
							if(Ux!=-1)
							{
								if(Dx!=-1)
								{
									if(Lx!=-1)
									{
										if(Rx!=-1)	//udlr	>=2 lines	\+\	/+/
										{
											double d, d_min=aa_close(Rx, Ux);
											if(d_min>(d=aa_close(Rx, 1-Dx)))
												d_min=d;
											if(d_min>(d=aa_close(1-Lx, 1-Dx)))
												d_min=d;
											if(d_min>(d=aa_close(1-Lx, Ux)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		//udl	>=2 lines	<+
										{
											double d, d_min=aa_close(1-Lx, 1-Dx);
											if(d_min>(d=aa_close(1-Lx, Ux)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
									}
									else
									{
										if(Rx!=-1)	//ud r	>=2 lines	+>
										{
											double d, d_min=aa_close(Rx, Ux);
											if(d_min>(d=aa_close(Rx, 1-Dx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		//ud				_F_
										{
											double d, d_min=Ux;
											if(d_min>(d=1-Dx))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
									}
								}
								else
								{
									if(Lx!=-1)
									{
										if(Rx!=-1)	//u lr	>=2 lines	\+/
										{
											double d, d_min=aa_close(Rx, 1-Dx);
											if(d_min>(d=aa_close(1-Lx, 1-Dx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		//u l	>=1 line	\+
											ApplyDIBPixelUnchecked(x, y, aa_close(1-Lx, Ux));
									}
									else
									{
										if(Rx!=-1)	//u  r	>=1 line	+/
											ApplyDIBPixelUnchecked(x, y, aa_close(Rx, Ux));
										else		//u		>=1 line	_+_
										{
											auto &LUx=Ycross[Xplaces* y   +x-1], &RUx=Ycross[Xplaces* y   +x+1];
											double d, d_min=Ux;
											if(LUx!=-1&&LUx<Ux&&d_min>(d=aa_middle(Ux, LUx)))
												d_min=d;
											if(RUx!=-1&&RUx<Ux&&d_min>(d=aa_middle(Ux, RUx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
									}
								}
							}
							else
							{
								if(Dx!=-1)
								{
									if(Lx!=-1)
									{
										if(Rx!=-1)	// dlr	>=2 lines	/+\ 
										{
											double d, d_min=aa_close(Rx, Ux);
											if(d_min>(d=aa_close(1-Lx, Ux)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		// dl	>=1 line	/+
											ApplyDIBPixelUnchecked(x, y, aa_close(1-Lx, 1-Dx));
									}
									else
									{
										if(Rx!=-1)	// d r	>=1 line	+\ 
											ApplyDIBPixelUnchecked(x, y, aa_close(Rx, 1-Dx));
										else		// d	>=1 line	F
										{
											auto &LDx=Ycross[Xplaces*(y-1)+x-1], &RDx=Ycross[Xplaces*(y-1)+x+1];
											double d, d_min=1-Dx;
											if(LDx!=-1&&LDx>Dx&&d_min>(d=aa_middle(1-Dx, 1-LDx)))
												d_min=d;
											if(RDx!=-1&&RDx>Dx&&d_min>(d=aa_middle(1-Dx, 1-RDx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
									}
								}
								else
								{
									if(Lx!=-1)
									{
										if(Rx!=-1)	//  lr	>=1 line
										{
											double d, d_min=Rx;
											if(d_min>(d=1-Lx))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		//  l	>=1 line	|+
										{
											auto &DLx=Xcross[Xplaces_1*(y-1)+x-1], &ULx=Xcross[Xplaces_1*(y+1)+x-1];
											double d, d_min=1-Lx;
											if(DLx!=-1&&DLx>Lx&&d_min>(d=aa_middle(1-Lx, 1-DLx)))
												d_min=d;
											if(ULx!=-1&&ULx>Lx&&d_min>(d=aa_middle(1-Lx, 1-ULx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
									}
									else
									{
										if(Rx!=-1)	//   r	>=1 line	+|
										{
											auto &DRx=Xcross[Xplaces_1*(y-1)+x  ], &URx=Xcross[Xplaces_1*(y+1)+x  ];
											double d, d_min=Rx;
											if(DRx!=-1&&DRx<Rx&&d_min>(d=aa_middle(Rx, DRx)))
												d_min=d;
											if(URx!=-1&&URx<Rx&&d_min>(d=aa_middle(Rx, URx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		//		>=0 lines
										{
											auto
												&DLx=Xcross[Xplaces_1*(y-1)+x-1],	&LDx=Ycross[Xplaces*(y-1)+x-1],//	 _    _
												&DRx=Xcross[Xplaces_1*(y-1)+x  ],	&RDx=Ycross[Xplaces*(y-1)+x+1],//	| 1  2 | D
												&ULx=Xcross[Xplaces_1*(y+1)+x-1],	&LUx=Ycross[Xplaces* y   +x-1],//	    .
												&URx=Xcross[Xplaces_1*(y+1)+x  ],	&RUx=Ycross[Xplaces* y   +x+1];//	|_3  4_| U
											double d, d_min=_HUGE;
											if(DLx!=-1&&LDx!=-1&&d_min>(d=aa_far(1-DLx, 1-LDx)))//1
												d_min=d;
											if(DRx!=-1&&RDx!=-1&&d_min>(d=aa_far(  DRx, 1-RDx)))//2
												d_min=d;
											if(ULx!=-1&&LUx!=-1&&d_min>(d=aa_far(1-ULx,   LUx)))//3
												d_min=d;
											if(URx!=-1&&RUx!=-1&&d_min>(d=aa_far(  URx,   RUx)))//4
												d_min=d;
											if(d_min!=_HUGE)
												ApplyDIBPixelUnchecked(x, y, d_min>aa_thickness?1:d_min*_1_aa_thickness);
										}
									}
								}
							}
						}
					}
					//		memset(rgb, 0xFF, h*w*sizeof(int));
					//QueryPerformanceCounter(&li);
					//time_aa=li.QuadPart-time_aa;
					//GUIPrint(ghMemDC, w/2, h/2, "%f", time_start/1000.);
					//GUIPrint(ghMemDC, w/2, h/2+18, "%f", time_aa/1000.);
				}
			}
		}
		void doContour(unsigned e, double Xs, double Zstart, double Zend, double Zstep, unsigned nzSteps)
		{
			auto &ndr=expr[e].n[0].ndr;
			doContour_component(ndr, Xs, Zstart, Zend, Zstep, nzSteps, 0);
			doContour_component(ndr, Xs, Zstart, Zend, Zstep, nzSteps, 1);
		}
		void differentiate_x					(std::vector<Value> &ndr)
		{
			double step=DX/Xplaces;
			for(int ky=0;ky<Yplaces;++ky)
			{
				for(int kx=0;kx<Xplaces-1;++kx)
					ndr[Xplaces*ky+kx]=((std::complex<double>)ndr[Xplaces*ky+kx+1]-(std::complex<double>)ndr[Xplaces*ky+kx])/step;
				ndr[Xplaces*ky+Xplaces-1].r/=-step, ndr[Xplaces*ky+Xplaces-1].i/=-step;
			}
			ndr.rbegin()->r/=-step, ndr.rbegin()->i/=-step;
		}
		void differentiate_y					(std::vector<Value> &ndr)
		{
			double step=DX/Xplaces;
			for(int ky=0;ky<Yplaces-1;++ky)
				for(int kx=0;kx<Xplaces;++kx)
					ndr[Xplaces*ky+kx]=((std::complex<double>)ndr[Xplaces*(ky+1)+kx]-(std::complex<double>)ndr[Xplaces*ky+kx])/step;
			for(int kx=0;kx<Xplaces;++kx)
				ndr[Xplaces*(Yplaces-1)+kx].r/=-step, ndr[Xplaces*(Yplaces-1)+kx].i/=-step;
			ndr.rbegin()->r/=-step, ndr.rbegin()->i/=-step;
		}
		void integrate_x						(std::vector<Value> &ndr)
		{
			double step=DX/Xplaces;
			std::complex<double> sum;
			for(int ky=0;ky<Yplaces;++ky)
			{
				for(int kx=0;kx<Xplaces;++kx)
				{
					auto &v=ndr[Xplaces*ky+kx];
					v=(sum+=(std::complex<double>)v)*step;
				}
				sum=0;
			}
		}
		void integrate_y						(std::vector<Value> &ndr)
		{
			double step=DX/Xplaces;
			std::vector<std::complex<double>> sum(Xplaces);
			for(int ky=Yplaces-1;ky>=0;--ky)
				for(int kx=0;kx<Xplaces;++kx)
				{
					auto &v=ndr[Xplaces*ky+kx];
					v=(sum[kx]+=(std::complex<double>)v)*step;
				}
		}
		fftw_complex *fft_in, *fft_out;
		fftw_plan fft_p, ifft_p;
		unsigned fft_N0, fft_N1;
		double fft_sqrt_N;
		void discreteFourrierTransform			(std::vector<Value> &ndr)
		{
			int ndrSize=Xplaces*Yplaces;
			if(fft_N0!=Yplaces||fft_N1!=Xplaces)
			{
				if(fft_N0||fft_N1)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_N0=Yplaces, fft_N1=Xplaces;
				fft_in=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt(ndrSize);
				fft_p=fftw_plan_dft_2d(fft_N0, fft_N1, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE), ifft_p=fftw_plan_dft_2d(fft_N0, fft_N1, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
			for(int k=0;k<ndrSize;++k)
				fft_in[k][0]=ndr[k].r*(1-2*(k%Xplaces%2^k/Xplaces%2)), fft_in[k][1]=ndr[k].i*(1-2*(k%Xplaces%2^k/Xplaces%2));
			fftw_execute(fft_p);
			for(int k=0;k<ndrSize;++k)
				ndr[k].r=fft_out[k][0]/fft_sqrt_N, ndr[k].i=fft_out[k][1]/fft_sqrt_N;
		}
		void inverseDiscreteFourrierTransform	(std::vector<Value> &ndr)
		{
			int ndrSize=Xplaces*Yplaces;
			if(fft_N0!=Yplaces||fft_N1!=Xplaces)
			{
				if(fft_N0||fft_N1)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_N0=Yplaces, fft_N1=Xplaces;
				fft_in=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt(ndrSize);
				fft_p=fftw_plan_dft_2d(fft_N0, fft_N1, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE), ifft_p=fftw_plan_dft_2d(fft_N0, fft_N1, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
			for(int k=0;k<ndrSize;++k)
				fft_in[k][0]=ndr[k].r, fft_in[k][1]=ndr[k].i;
			fftw_execute(ifft_p);
			for(int k=0;k<ndrSize;++k)
				ndr[k].r=fft_out[k][0]*(1-2*(k%Xplaces%2^k/Xplaces%2))/fft_sqrt_N, ndr[k].i=fft_out[k][1]*(1-2*(k%Xplaces%2^k/Xplaces%2))/fft_sqrt_N;
		}
		void lowPassFilter						(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		/*	int T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=0;k<T/2;++k)
				sum+=(decltype(sum))ndr[k];
			for(unsigned k=0;k<T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[k+T/2];
			for(unsigned k=T/2;k<ndr.size()-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[k+T/2]-t0[(k-T/2)%T];
			for(unsigned k=ndr.size()-T/2;k<ndr.size();++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum-=t0[(k-T/2)%T];//*/
		/*	int T=10;
			std::complex<double> sum;
			std::vector<std::complex<double>> t0(ndr.size());
			for(unsigned k=0;k<t0.size();++k)
				t0[k]=(std::complex<double>)ndr[k];
			for(unsigned k=0;k<T/2;++k)
				sum+=t0[k];
			for(unsigned k=0;k<T/2;++k)
				t0[k]=sum/double(T), sum+=t0[k+1+T/2];
			for(unsigned k=T/2;k<t0.size()-T/2;++k)
				t0[k]=sum/double(T), sum+=t0[k+1+T/2]-(std::complex<double>)ndr[k-T/2];
			for(unsigned k=t0.size()-T/2;k<t0.size();++k)
				t0[k]=sum/double(T), sum-=(std::complex<double>)ndr[k-T/2];
			for(unsigned k=0;k<t0.size();++k)
				ndr[k]=t0[k];//*/
		/*	auto t=(std::complex<double>)ndr[0];
			for(unsigned k=0;k<ndr.size()-1;++k)
				ndr[k]=((std::complex<double>)ndr[k]+(std::complex<double>)ndr[k+1])/2.;
			ndr.rbegin()->operator=(t+(std::complex<double>)*ndr.rbegin())/2.;//*/
		}
		void highPassFilter						(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		/*	int T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=0;k<T/2;++k)
				sum+=(decltype(sum))ndr[k];
			for(unsigned k=0;k<T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[k+T/2];
			for(unsigned k=T/2;k<ndr.size()-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[k+T/2]-t0[(k-T/2)%T];
			for(unsigned k=ndr.size()-T/2;k<ndr.size();++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum-=t0[(k-T/2)%T];*/
		/*	auto t=(std::complex<double>)ndr[0];
			for(unsigned k=0;k<ndr.size()-1;++k)
				ndr[k]-=((std::complex<double>)ndr[k]+(std::complex<double>)ndr[k+1])/2.;
			ndr.rbegin()->operator-=(t+(std::complex<double>)*ndr.rbegin())/2.;*/
		}
		void HemalyTransform					(std::vector<Value> &ndr)
		{
			std::vector<std::complex<double>> t0(ndr.begin(), ndr.end()), t1(t0.size());
			for(unsigned k=0;k<ndr.size();++k)
				t0[k]=(std::complex<double>)ndr[k];
			auto sqrtsize=::sqrt(Xplaces*Yplaces);
			int Xplaces3=Xplaces*Xplaces*Xplaces, Yplaces3=Yplaces*Yplaces*Yplaces;
		//	auto Xplaces3_2=sqrt(Xplaces3), Yplaces3_2=sqrt(Yplaces3);
			for(int kv=0;kv<Yplaces;++kv)
			{
				for(int ku=0;ku<Xplaces;++ku)
				{
					auto &Fuv=t1[Xplaces*kv+ku];

					std::complex<double>//reversible with noise
						pu=-2*G2::_pi*std::complex<double>(0, 1)*(double(ku-Xplaces/2)/Xplaces3),
						pv=-2*G2::_pi*std::complex<double>(0, 1)*(double(kv-Yplaces/2)/Yplaces3);
					for(int ky=0;ky<Yplaces;++ky)
					{
						double py=ky-Yplaces/2; std::complex<double> ty=pv*(py*py*py);
						for(int kx=0;kx<Xplaces;++kx)
						{
							double px=kx-Xplaces/2;
							Fuv+=t0[Xplaces*ky+kx]*std::exp(pu*(px*px*px)+ty);
						}
					}
					Fuv/=sqrtsize;//*/

				/*	std::complex<double>//reversible with noise
						pu=-2*G2::_pi*std::complex<double>(0, 1)*(double(ku-Xplaces/2)/Xplaces/Xplaces),
						pv=-2*G2::_pi*std::complex<double>(0, 1)*(double(kv-Yplaces/2)/Yplaces/Yplaces);
					for(int ky=0;ky<Yplaces;++ky)
						for(int kx=0;kx<Xplaces;++kx)
							Fuv+=t0[Xplaces*ky+kx]*std::exp(pu*double(kx-Xplaces/2)*double(kx-Xplaces/2)+pv*double(ky-Yplaces/2)*double(ky-Yplaces/2));
					Fuv/=sqrtsize;//*/

				/*	auto//irreversible
						pu=(double(ku-Xplaces/2)/Xplaces/Xplaces),
						pv=(double(kv-Yplaces/2)/Yplaces/Yplaces);
					auto c=-2*G2::_pi*std::complex<double>(0, 1);
					for(int ky=0;ky<Yplaces;++ky)
						for(int kx=0;kx<Xplaces;++kx)
							Fuv+=t0[Xplaces*ky+kx]*std::exp(c*sqrt(pu*double(kx-Xplaces/2)*double(kx-Xplaces/2)+pv*double(ky-Yplaces/2)*double(ky-Yplaces/2)));
					Fuv/=sqrtsize;//*/

				/*	std::complex<double>//reversible with noise
						pu=-2*G2::_pi*std::complex<double>(0, 1)*(double(ku-Xplaces/2)/Xplaces2_3),
						pv=-2*G2::_pi*std::complex<double>(0, 1)*(double(kv-Yplaces/2)/Yplaces2_3);
					for(int ky=0;ky<Yplaces;++ky)
						for(int kx=0;kx<Xplaces;++kx)
							Fuv+=t0[Xplaces*ky+kx]*std::exp(pu*double(kx-Xplaces/2)*double(kx-Xplaces/2)+pv*double(ky-Yplaces/2)*double(ky-Yplaces/2));
						//	Fuv+=t0[Xplaces*ky+kx]*std::exp(pu*double(kx)*double(kx)+pv*double(ky)*double(ky));
					Fuv/=sqrtsize;//*/

				/*	std::complex<double>//irreversible
						pu=-2*G2::_pi*std::complex<double>(0, 1)*(double(ku-Xplaces/2)/Xplaces/Xplaces),
						pv=-2*G2::_pi*std::complex<double>(0, 1)*(double(kv-Yplaces/2)/Yplaces/Yplaces);
					for(int ky=0;ky<Yplaces;++ky)
						for(int kx=0;kx<Xplaces;++kx)
							Fuv+=t0[Xplaces*ky+kx]*std::exp(pu*double(kx-Xplaces/2)*double(kx-Xplaces/2)*double(kx-Xplaces/2)+pv*double(ky-Yplaces/2)*double(ky-Yplaces/2)*double(ky-Yplaces/2));
						//	Fuv+=t0[Xplaces*ky+kx]*std::exp(pu*double(kx)*double(kx)+pv*double(ky)*double(ky));
					Fuv/=sqrtsize;//*/

				/*	std::complex<double>//doesn't work
						pu=-2*G2::_pi*std::complex<double>(0, 1)*(double(ku-Xplaces/2)*double(ku-Xplaces/2)/Xplaces/Xplaces),
						pv=-2*G2::_pi*std::complex<double>(0, 1)*(double(kv-Yplaces/2)*double(kv-Yplaces/2)/Yplaces/Yplaces);
					for(int ky=0;ky<Yplaces;++ky)
						for(int kx=0;kx<Xplaces;++kx)
							Fuv+=t0[Xplaces*ky+kx]*std::exp(pu*double(kx-Xplaces/2)*double(kx-Xplaces/2)+pv*double(ky-Yplaces/2)*double(ky-Yplaces/2));
						//	Fuv+=t0[Xplaces*ky+kx]*std::exp(pu*double(kx)*double(kx)+pv*double(ky)*double(ky));
					Fuv/=sqrtsize;//*/

				/*	std::complex<double>
						pu=-2*G2::_pi*std::complex<double>(0, 1)*(double(ku)/Xplaces-.5),
						pv=-2*G2::_pi*std::complex<double>(0, 1)*(double(kv)/Yplaces-.5);
					for(int ky=0;ky<Yplaces;++ky)
						for(int kx=0;kx<Xplaces;++kx)
							Fuv+=t0[Xplaces*ky+kx]*std::exp(pu*double(kx-Xplaces/2)*double(kx-Xplaces/2)+pv*double(ky-Yplaces/2)*double(ky-Yplaces/2));
						//	Fuv+=t0[Xplaces*ky+kx]*std::exp(pu*double(kx)*double(kx)+pv*double(ky)*double(ky));
					Fuv/=sqrtsize;//*/

				/*	std::complex<double>//DFT, SHIFT
						pu=-2*G2::_pi*std::complex<double>(0, 1)*(double(ku-Xplaces/2)/Xplaces),
						pv=-2*G2::_pi*std::complex<double>(0, 1)*(double(kv-Yplaces/2)/Yplaces);
					for(int ky=0;ky<Yplaces;++ky)
						for(int kx=0;kx<Xplaces;++kx)
							Fuv+=t0[Xplaces*ky+kx]*std::exp(pu*double(kx)+pv*double(ky));
					Fuv/=sqrtsize;//*/

				/*	std::complex<double>//DFT
						pu=-2*G2::_pi*std::complex<double>(0, 1)*(double(ku)/Xplaces),
						pv=-2*G2::_pi*std::complex<double>(0, 1)*(double(kv)/Yplaces);
					for(int ky=0;ky<Yplaces;++ky)
						for(int kx=0;kx<Xplaces;++kx)
							Fuv+=t0[Xplaces*ky+kx]*std::exp(pu*double(kx)+pv*double(ky));
					Fuv/=sqrtsize;//*/
				}
			}
			for(unsigned k=0;k<ndr.size();++k)
				ndr[k]=t1[k];
		}
		void inverseHemalyTransform				(std::vector<Value> &ndr)
		{
			std::vector<std::complex<double>> t0(ndr.size()), t1(t0.size());
			for(unsigned k=0;k<ndr.size();++k)
				t0[k]=(std::complex<double>)ndr[k];
			auto sqrtsize=::sqrt(Xplaces*Yplaces);
			int Xplaces3=Xplaces*Xplaces*Xplaces, Yplaces3=Yplaces*Yplaces*Yplaces;
		//	auto Xplaces3_2=sqrt(Xplaces3), Yplaces3_2=sqrt(Yplaces3);
			for(int ky=0;ky<Yplaces;++ky)
			{
				for(int kx=0;kx<Xplaces;++kx)
				{
					auto &Fxy=t1[Xplaces*ky+kx];

					std::complex<double>//reversible with noise
						px=2*G2::_pi*std::complex<double>(0, 1)*(double(kx-Xplaces/2)*double(kx-Xplaces/2)*double(kx-Xplaces/2)/Xplaces3),
						py=2*G2::_pi*std::complex<double>(0, 1)*(double(ky-Yplaces/2)*double(ky-Yplaces/2)*double(ky-Yplaces/2)/Yplaces3);
					for(int kv=0;kv<Yplaces;++kv)
					{
						std::complex<double> tv=py*double(kv-Yplaces/2);
						for(int ku=0;ku<Xplaces;++ku)
							Fxy+=t0[Xplaces*kv+ku]*std::exp(px*double(ku-Xplaces/2)+tv);
					}
					Fxy/=sqrtsize;//*/

				/*	std::complex<double>//reversible with noise
						px=2*G2::_pi*std::complex<double>(0, 1)*(double(kx-Xplaces/2)*double(kx-Xplaces/2)/Xplaces/Xplaces),
						py=2*G2::_pi*std::complex<double>(0, 1)*(double(ky-Yplaces/2)*double(ky-Yplaces/2)/Yplaces/Yplaces);
					for(int kv=0;kv<Yplaces;++kv)
						for(int ku=0;ku<Xplaces;++ku)
							Fxy+=t0[Xplaces*kv+ku]*std::exp(px*double(ku-Xplaces/2)+py*double(kv-Yplaces/2));
					Fxy/=sqrtsize;//*/

				/*	auto//irreversible
						px=(double(kx-Xplaces/2)*double(kx-Xplaces/2)/Xplaces/Xplaces),
						py=(double(ky-Yplaces/2)*double(ky-Yplaces/2)/Yplaces/Yplaces);
					auto c=2*G2::_pi*std::complex<double>(0, 1);
					for(int kv=0;kv<Yplaces;++kv)
						for(int ku=0;ku<Xplaces;++ku)
							Fxy+=t0[Xplaces*kv+ku]*std::exp(c*sqrt(px*double(ku-Xplaces/2)+py*double(kv-Yplaces/2)));
					Fxy/=sqrtsize;//*/

				/*	std::complex<double>//reversible with noise
						px=2*G2::_pi*std::complex<double>(0, 1)*(double(kx-Xplaces/2)*double(kx-Xplaces/2)/Xplaces2_3),
						py=2*G2::_pi*std::complex<double>(0, 1)*(double(ky-Yplaces/2)*double(ky-Yplaces/2)/Yplaces2_3);
					for(int kv=0;kv<Yplaces;++kv)
						for(int ku=0;ku<Xplaces;++ku)
							Fxy+=t0[Xplaces*kv+ku]*std::exp(px*double(ku-Xplaces/2)+py*double(kv-Yplaces/2));
					Fxy/=sqrtsize;//*/

				/*	std::complex<double>//irreversible
						px=2*G2::_pi*std::complex<double>(0, 1)*(double(kx-Xplaces/2)*double(kx-Xplaces/2)*double(kx-Xplaces/2)/Xplaces/Xplaces),
						py=2*G2::_pi*std::complex<double>(0, 1)*(double(ky-Yplaces/2)*double(ky-Yplaces/2)*double(ky-Yplaces/2)/Yplaces/Yplaces);
					for(int kv=0;kv<Yplaces;++kv)
						for(int ku=0;ku<Xplaces;++ku)
							Fxy+=t0[Xplaces*kv+ku]*std::exp(px*double(ku-Xplaces/2)+py*double(kv-Yplaces/2));
					Fxy/=sqrtsize;//*/

				/*	std::complex<double>//doesn't work
						px=2*G2::_pi*std::complex<double>(0, 1)*(double(kx-Xplaces/2)*double(kx-Xplaces/2)/Xplaces/Xplaces),
						py=2*G2::_pi*std::complex<double>(0, 1)*(double(ky-Yplaces/2)*double(ky-Yplaces/2)/Yplaces/Yplaces);
					for(int kv=0;kv<Yplaces;++kv)
						for(int ku=0;ku<Xplaces;++ku)
							Fxy+=t0[Xplaces*kv+ku]*std::exp(px*double(ku-Xplaces/2)*double(ku-Xplaces/2)+py*double(kv-Yplaces/2)*double(kv-Yplaces/2));
					Fxy/=sqrtsize;//*/

				/*	std::complex<double>
						px=2*G2::_pi*std::complex<double>(0, 1)*(double(kx-Xplaces/2)*double(kx-Xplaces/2)/Xplaces),
						py=2*G2::_pi*std::complex<double>(0, 1)*(double(ky-Yplaces/2)*double(ky-Yplaces/2)/Yplaces);
				//	std::complex<double>
				//		px=2*G2::_pi*std::complex<double>(0, 1)*(double(kx)*double(kx)/Xplaces),
				//		py=2*G2::_pi*std::complex<double>(0, 1)*(double(ky)*double(ky)/Yplaces);
					for(int kv=0;kv<Yplaces;++kv)
						for(int ku=0;ku<Xplaces;++ku)
							Fxy+=t0[Xplaces*kv+ku]*std::exp(px*double(ku-Xplaces/2)+py*double(kv-Yplaces/2));
					//	{
					//		if(ku>Xplaces/4&&ku<Xplaces*0.75&&kv>Yplaces/4&&kv<Yplaces*0.75)
					//			Fxy+=1.*std::exp(px*double(ku)+py*double(kv));
					//	}
					Fxy/=sqrtsize;//*/

				/*	std::complex<double>//SHIFT, IDFT
						px=2*G2::_pi*std::complex<double>(0, 1)*(double(kx)/Xplaces),
						py=2*G2::_pi*std::complex<double>(0, 1)*(double(ky)/Yplaces);
					for(int kv=0;kv<Yplaces;++kv)
						for(int ku=0;ku<Xplaces;++ku)
							Fxy+=t0[Xplaces*kv+ku]*std::exp(px*double(ku-Xplaces/2)+py*double(kv-Yplaces/2));
					Fxy/=sqrtsize;//*/

				/*	std::complex<double>//IDFT
						px=2*G2::_pi*std::complex<double>(0, 1)*(double(kx)/Xplaces),
						py=2*G2::_pi*std::complex<double>(0, 1)*(double(ky)/Yplaces);
					for(int kv=0;kv<Yplaces;++kv)
						for(int ku=0;ku<Xplaces;++ku)
							Fxy+=t0[Xplaces*kv+ku]*std::exp(px*double(ku)+py*double(kv));
					Fxy/=sqrtsize;//*/
				}
			}
			for(unsigned k=0;k<ndr.size();++k)
				ndr[k]=t1[k];
		}

		void setDimentions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h;
			function1();
			toSolve=true, shiftOnly=0;
			ready=true;
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimentions(x, y, w, h);
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
		}
		void messageTimer()
		{
			if(_2d_drag_graph_not_window)
			{
				if(kb[VK_LEFT		]){	VX+=10*DX/ Xplaces		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_RIGHT		]){	VX-=10*DX/ Xplaces		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_UP			]){	VY-=10*DX/(Xplaces*AR_Y), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset-=10;}
				if(kb[VK_DOWN		]){	VY+=10*DX/(Xplaces*AR_Y), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset+=10;}
			}
			else
			{
				if(kb[VK_LEFT		]){	VX-=10*DX/ Xplaces		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_RIGHT		]){	VX+=10*DX/ Xplaces		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_UP			]){	VY+=10*DX/(Xplaces*AR_Y), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset+=10;}
				if(kb[VK_DOWN		]){	VY-=10*DX/(Xplaces*AR_Y), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset-=10;}
			}
			if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])
			{
				if(kb['X'])
					DX/=1.1, AR_Y/=1.1;
				else if(kb['Y'])
					AR_Y*=1.1;
				else
					DX/=1.1;
				function1(), toSolve=true, shiftOnly=0;
			}
			if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])
			{
				if(kb['X'])
					DX*=1.1, AR_Y*=1.1;
				else if(kb['Y'])
					AR_Y/=1.1;
				else
					DX*=1.1;
				function1(), toSolve=true, shiftOnly=0;
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
				SetCapture(ghWnd);
				drag=1;
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(drag)
			{
				if(!m_bypass)
				{
					int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
					int dx=mx-w/2, dy=h/2-my;
					if(_2d_drag_graph_not_window)
						dx=-dx, dy=-dy;
					VX+=dx*DX/w, VY+=dy*DX/(w*AR_Y);
					toSolve=true;
					if(shiftOnly)
						shiftOnly=1, Xoffset+=dx, Yoffset+=dy;
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
				m_bypass=!m_bypass;
			}
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
		}
		int inputMouseWheel(int wParam)
		{
			int mx=((short*)&oldMouse)[0], my=((short*)&oldMouse)[1];
			double dx=(mx-w/2)*DX/w, dy=(h/2-my)*DX/(w*AR_Y);
			if(kb['X'])
			{
					 if(((short*)&wParam)[1]>0)	DX/=1.1, AR_Y/=1.1, VX=VX+dx-dx/1.1;
				else							DX*=1.1, AR_Y*=1.1, VX=VX+dx-dx*1.1;
			}
			else if(kb['Y'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Y*=1.1, VY=VY+dy-dy/1.1;
				else							AR_Y/=1.1, VY=VY+dy-dy*1.1;
			}
			else
			{
					 if(((short*)&wParam)[1]>0)	DX/=1.1, VX=VX+dx-dx/1.1, VY=VY+dy-dy/1.1;
				else							DX*=1.1, VX=VX+dx-dx*1.1, VY=VY+dy-dy*1.1;
			}
			function1();
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[wParam])
					++kp;
				if(!time_variance&&!timer)
					SetTimer(ghWnd, 0, 10, 0), timer=true;
				break;
			case VK_OEM_3://~	contour
				if(contourOn)//was on
				{
					if(kb[VK_CONTROL])
						contourOnly=!contourOnly, toSolve=true, shiftOnly=0;
				/*	{
						//1: flat contour+surface
						//2: flat contour
						//3: contour
						//4: contour+surface
						if(kb[VK_SHIFT])//reverse
						{
							if(contourFlat)
							{
								if(contourOnly)
									contourOnly=false, toSolve=true, shiftOnly=0;//4: surface reappears
								else
									contourFlat=false, toSolve=true, shiftOnly=0;//1: pops up
							}
							else
							{
								if(contourOnly)
									contourFlat=true, toSolve=true, shiftOnly=0;//3: flat
								else
									contourOnly=true;//2: surface disappears
							}
						}
						else
						{
							if(contourFlat)
							{
								if(contourOnly)
									contourFlat=false, toSolve=true, shiftOnly=0;//2: pops up
								else
									contourOnly=true;//1: surface disappears
							}
							else
							{
								if(contourOnly)
									contourOnly=false, toSolve=true, shiftOnly=0;//3: surface reappears
								else
									contourFlat=true, toSolve=true, shiftOnly=0;//4: flat
							}
						}
					}//*/
					else
						contourOn=false, contourOnly=false, toSolve=true, shiftOnly=0;//contour off
					//	contourOn=false, contourOnly=false, contourFlat=true, toSolve=true, shiftOnly=0;//contour off
				}
				else//was off
				{
					contourOn=true;
					if(kb[VK_CONTROL])//
						contourOnly=!contourOnly;//
					if(!toSolve)
					{
					//	Rcontours.clear(), Icontours.clear();
						double Xs=DX/Xplaces, DZ=DX, Zstep=Xstep;
						if(contourOn)
						{
							if(contourOnly)
								memset(solver.rgb, 0xFF, solver.Xplaces*solver.Yplaces*sizeof(int));//
							doContour(cursorEx, Xs, -DZ/2, +DZ/2, Zstep, 10);
						}
					}
				}
				break;
			case '0':case VK_NUMPAD0:
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
			case '7':case VK_NUMPAD7:
			case '8':case VK_NUMPAD8:
			case 'H':
			case 'J':
				{
					auto op=&Color_2D::differentiate_x;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:	operations.push_back( 1), op=&Color_2D::differentiate_x;					break;
					case '2':case VK_NUMPAD2:	operations.push_back( 2), op=&Color_2D::differentiate_y;					break;
					case '3':case VK_NUMPAD3:	operations.push_back( 3), op=&Color_2D::integrate_x;						break;
					case '4':case VK_NUMPAD4:	operations.push_back( 4), op=&Color_2D::integrate_y;						break;
					case '5':case VK_NUMPAD5:	operations.push_back( 5), op=&Color_2D::discreteFourrierTransform;			break;
					case '6':case VK_NUMPAD6:	operations.push_back( 6), op=&Color_2D::inverseDiscreteFourrierTransform;	break;
					case '7':case VK_NUMPAD7:	operations.push_back( 7), op=&Color_2D::lowPassFilter;						break;
					case '8':case VK_NUMPAD8:	operations.push_back( 8), op=&Color_2D::highPassFilter;						break;
					case 'H':					operations.push_back( 9), op=&Color_2D::HemalyTransform;					break;
					case 'J':					operations.push_back(10), op=&Color_2D::inverseHemalyTransform;				break;
					}
					if(!toSolve)
					{
						auto &ndr=expr[cursorEx].n[0].ndr;
						(this->*op)(ndr);
						if(contourOnly)
							memset(solver.rgb, 0xFF, Xplaces*Yplaces*sizeof(int));
						else
							solver.updateRGB(ndr);
						if(contourOn)
						{
						//	Rcontours.clear(), Icontours.clear();
							double Xs=DX/Xplaces, DZ=DX, Zstep=Xstep;
							doContour(cursorEx, Xs, -DZ/2, +DZ/2, Zstep, 10);
						}
					}
				}
				break;
		/*	case '1':case VK_NUMPAD1:
				operations.push_back(1);
				{
					auto &ndr=expr[cursorEx].n[0].ndr;
					differentiate_x(ndr), solver.updateRGB(ndr);
				}
				break;
			case '2':case VK_NUMPAD2:
				operations.push_back(2);
				{
					auto &ndr=expr[cursorEx].n[0].ndr;
					differentiate_y(ndr);
					solver.updateRGB(ndr);
				}
				break;
			case '3':case VK_NUMPAD3:
				operations.push_back(3);
				{
					auto &ndr=expr[cursorEx].n[0].ndr;
					integrate_x(ndr);
					solver.updateRGB(ndr);
				}
				break;
			case '4':case VK_NUMPAD4:
				operations.push_back(4);
				{
					auto &ndr=expr[cursorEx].n[0].ndr;
					integrate_y(ndr);
					solver.updateRGB(ndr);
				}
				break;
			case '5':case VK_NUMPAD5:
				operations.push_back(5);
				{
					auto &ndr=expr[cursorEx].n[0].ndr;
					discreteFourrierTransform(ndr);
					solver.updateRGB(ndr);
				}
				break;
			case '6':case VK_NUMPAD6:
				operations.push_back(6);
				{
					auto &ndr=expr[cursorEx].n[0].ndr;
					inverseDiscreteFourrierTransform(ndr);
					solver.updateRGB(ndr);
				}
				break;
			case '7':case VK_NUMPAD7:
				operations.push_back(7);
				{
					auto &ndr=expr[cursorEx].n[0].ndr;
					lowPassFilter(ndr);
					solver.updateRGB(ndr);
				}
				break;
			case '8':case VK_NUMPAD8:
				operations.push_back(8);
				{
					auto &ndr=expr[cursorEx].n[0].ndr;
					highPassFilter(ndr);
					solver.updateRGB(ndr);
				}
				break;
			case 'H':
				operations.push_back(9);
				{
					auto &ndr=expr[cursorEx].n[0].ndr;
					HemalyTransform(ndr);
					solver.updateRGB(ndr);
				}
				break;
			case 'J':
				operations.push_back(10);
				{
					auto &ndr=expr[cursorEx].n[0].ndr;
					inverseHemalyTransform(ndr);
					solver.updateRGB(ndr);
				}
				break;//*/
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				DX=20, AR_Y=1, function1();
				toSolve=true, shiftOnly=0;
				break;
			case 'R':
				if(!kb[VK_CONTROL])
					DX=20, AR_Y=1, function1();
				VX=VY=0;
				toSolve=true, shiftOnly=0;
			//	if(kb[VK_CONTROL])
			//		DX=20, function1();
			//	VX=VY=0;
			//	toSolve=true, shiftOnly=0;
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
				if(kp)//start+key
					--kp;
				break;
			case VK_ADD:case VK_SUBTRACT:
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
			//	if(!kb[VK_CONTROL]&&kp>0)
					--kp;
				return 0;
			}
			return 0;
		}
		void function1();
		void draw()
		{
			double DY=DX*h/(w*AR_Y);
			if(DY<=0)
				DY=1;
			auto &ex=expr[cursorEx];
			{
				bool changed=false;
				if(toSolve)
				{
					if(!operations.size()&&shiftOnly==1&&abs(Xoffset)<Xplaces&&abs(Yoffset)<Yplaces)
					{
						if(Xoffset||Yoffset)
						{
							solver.partial_bounds(VX, DX, VY, DY, Xoffset, Yoffset);
							solver.synchronize();
							if(ex.nITD)
							{
								solver.full(ex);
								if(contourOnly)
									memset(solver.rgb, 0xFF, Xplaces*Yplaces*sizeof(int));
								else
									solver.updateRGB(ex.n[0].ndr);
							}
							else
								(solver.*(solver.partial))(ex, contourOnly);
							if(contourOn&&abs(Xoffset)+2<Xplaces&&abs(Yoffset)+2<Yplaces)
							{
							//	Rcontours.clear(), Icontours.clear();
								double Xs=DX/Xplaces, DZ=DX, Zstep=Xstep;
								doContour_partial(cursorEx, Xs, -DZ/2, +DZ/2, Zstep, 10, Xoffset, Yoffset);
							}
							else changed=true;
						}
					}
					else
					{
						auto old_time_variance=time_variance;
						time_variance=false;
					//	std::fill(nExpr.begin(), nExpr.end(), 0);
					//	for(auto &ex:expr)
					//		++nExpr[ex.rmode[0]];
						labels.clear();
						solver.full_resize(VX, DX, VY, DY, Xplaces=w, Yplaces=h);
						if(!paused)
							solver.synchronize();
						time_variance|=ex.nITD;
						labels.fill(cursorEx);
						solver.full(ex);
						for(auto &operation:operations)
						{
							switch(operation)
							{
							case  1:differentiate_x					(ex.n[0].ndr);break;
							case  2:differentiate_y					(ex.n[0].ndr);break;
							case  3:integrate_x						(ex.n[0].ndr);break;
							case  4:integrate_y						(ex.n[0].ndr);break;
							case  5:discreteFourrierTransform		(ex.n[0].ndr);break;
							case  6:inverseDiscreteFourrierTransform(ex.n[0].ndr);break;
							case  7:lowPassFilter					(ex.n[0].ndr);break;
							case  8:highPassFilter					(ex.n[0].ndr);break;
							case  9:HemalyTransform					(ex.n[0].ndr);break;
							case 10:inverseHemalyTransform			(ex.n[0].ndr);break;
							}
						}
						if(contourOnly)
							memset(solver.rgb, 0xFF, Xplaces*Yplaces*sizeof(int));
						else
							solver.updateRGB(ex.n[0].ndr);
						if(time_variance)
						{
							if(!paused)
								SetTimer(ghWnd, 0, 10, 0);
						}
						else if(old_time_variance&&!timer)
							KillTimer(ghWnd, 0);
						changed=true;
					}
				//	changed=true;
					toSolve=false, shiftOnly=2, Xoffset=0, Yoffset=0;
				}
				else if(time_variance)
				{
					if(!paused)
						solver.synchronize();
					solver.full(ex);
					for(auto &operation:operations)
					{
						switch(operation)
						{
						case  1:differentiate_x					(ex.n[0].ndr);break;
						case  2:differentiate_y					(ex.n[0].ndr);break;
						case  3:integrate_x						(ex.n[0].ndr);break;
						case  4:integrate_y						(ex.n[0].ndr);break;
						case  5:discreteFourrierTransform		(ex.n[0].ndr);break;
						case  6:inverseDiscreteFourrierTransform(ex.n[0].ndr);break;
						case  7:lowPassFilter					(ex.n[0].ndr);break;
						case  8:highPassFilter					(ex.n[0].ndr);break;
						case  9:HemalyTransform					(ex.n[0].ndr);break;
						case 10:inverseHemalyTransform			(ex.n[0].ndr);break;
						}
					}
					if(contourOnly)
						memset(solver.rgb, 0xFF, Xplaces*Yplaces*sizeof(int));
					else
						solver.updateRGB(ex.n[0].ndr);
					changed=true;
				}
				if(changed&&contourOn)
				{
				//	Rcontours.clear(), Icontours.clear();
					double Xs=DX/Xplaces, DZ=DX, Zstep=Xstep;
					doContour(cursorEx, Xs, -DZ/2, +DZ/2, Zstep, 10);
				}
			}
		//	if(!contourOnly)//draw the mona lisa
				std::copy(solver.rgb, solver.rgb+Xplaces*Yplaces, rgb);
		/*	if(contourOn)
			{
				auto DimDIBPixel=[&](int x, int y, double a)
				{
					if(x>=0&&x<w&&y>=0&&y<h)
					{
						auto p=(unsigned char*)&rgb[y*w+x];
						p[0]=unsigned char(p[0]*a), p[1]=unsigned char(p[1]*a), p[2]=unsigned char(p[2]*a);
					}
				};
				auto BrightenDIBPixel=[&](int x, int y, double a)
				{
					if(x>=0&&x<w&&y>=0&&y<h)
					{
						auto p=(unsigned char*)&rgb[y*w+x];
						*(unsigned int*)p=~*(unsigned int*)p;
						p[0]=unsigned char(p[0]*a), p[1]=unsigned char(p[1]*a), p[2]=unsigned char(p[2]*a);
						*(unsigned int*)p=~*(unsigned int*)p;
					//	auto p=(unsigned char*)&rgb[y*w+x];
					//	p[0]=~unsigned char(~p[0]*a), p[1]=~unsigned char(~p[1]*a), p[2]=~unsigned char(~p[2]*a);
					}
				};
				auto SetDIBPixel=[&](int x, int y, int c){if(x>=0&&x<w&&y>=0&&y<h)rgb[y*w+x]=c;};
				auto ClearDIBPixel=[&](int x, int y){if(x>=0&&x<w&&y>=0&&y<h)rgb[y*w+x]=0;};
				auto AlterDIBPixel=[&](int x, int y)
				{
					if(x>=0&&x<w&&y>=0&&y<h)
					{
						auto p=(unsigned char*)&rgb[y*w+x];
						p[0]+=128, p[1]+=128, p[2]+=128;
					}
				};
				if(contourOnly)//on white
				{
				//	memset(rgb, 0xFF, h*w*sizeof(int));
					if(contourFlat)
					{
						for(auto &L:Rcontours[cursorEx])//R
							for(auto &p:L.second)
								DimDIBPixel(p.x, p.y, p.Z);
							//	ClearDIBPixel(p.x, p.y);//black curves
						for(auto &L:Icontours[cursorEx])//I
							for(auto &p:L.second)
								BrightenDIBPixel(p.x, p.y, p.Z);
					}
					else
					{
						double Zstart=-DX/2, Zend=+DX/2;
						for(auto &L:Rcontours[cursorEx])//R
							for(auto &p:L.second)
								DimDIBPixel(p.x, p.y, p.Z);
							//	SetDIBPixel(p.x, p.y, p.c);
						for(auto &L:Icontours[cursorEx])//I
							for(auto &p:L.second)
								DimDIBPixel(p.x, p.y, p.Z);
					}
				}
				else if(contourFlat)
				{
					for(auto &L:Rcontours[cursorEx])
						for(auto &p:L.second)
							DimDIBPixel(p.x, p.y, p.Z);
						//	ClearDIBPixel(p.x, p.y);
					for(auto &L:Icontours[cursorEx])
						for(auto &p:L.second)
							BrightenDIBPixel(p.x, p.y, p.Z);
				}
				else
				{
					for(auto &L:Rcontours[cursorEx])
						for(auto &p:L.second)
							DimDIBPixel(p.x, p.y, p.Z);
						//	AlterDIBPixel(p.x, p.y);
					for(auto &L:Icontours[cursorEx])
						for(auto &p:L.second)
							DimDIBPixel(p.x, p.y, p.Z);
				}
			}//*/
			//if(kb['S'])
			//{
			//	auto &ndr=ex.n[0].ndr;
			//	std::complex<double>sum;
			//	for(unsigned k=0;k<ndr.size();++k)
			//		sum+=(std::complex<double>)ndr[k];
			//	sum*=DX/Xplaces;
			//	GUIPrint(ghMemDC, 0, 0, "%d", sum.real());
			//	GUIPrint(ghMemDC, 0, 16, "%d", sum.imag());
			//}

			if(!clearScreen)
			{
				{
					int H=int(VY-DY/2>0?h:VY+DY/2<0?-1:h*(VY/DY+.5)), HT=int(H>h-30?-18:2), V=int(VX-DX/2>0?-1:VX+DX/2<0?w:w*(-VX+DX/2)/DX), VT=int(V>w-24-prec*8?-24-prec*8:2);
					int bkMode=GetBkMode(ghMemDC);
					SetBkMode(ghMemDC, TRANSPARENT);
					for(double x=floor((VX-DX/2)/Xstep)*Xstep, xEnd=ceil((VX+DX/2)/Xstep)*Xstep;x<xEnd;x+=Xstep)
					{
						if(x>-Xstep/2&&x<Xstep/2)
							continue;
						int linelen=sprintf_s(g_buf, 128, "%g", x);
						double X=(x-(VX-DX/2))/DX*w;
						TextOutA(ghMemDC, int(X)-(X<0)+2, H+HT, g_buf, linelen);
					//	linelen=sprintf_s(line, 128, "%g", x);
					//	double X=(x-(VX-DX/2))/DX*w;
					//	TextOutA(ghMemDC, int(X)-(X<0)+2, H+HT, line, linelen);
					}
					for(double y=ceil((VY+DY/2)/Ystep)*Ystep, yEnd=floor((VY-DY/2)/Ystep)*Ystep;y>yEnd;y-=Ystep)
					{
						if(y>-Ystep/2&&y<Ystep/2)
							continue;
						int linelen=sprintf_s(g_buf, 128, "%g", y);
						double Y=((VY+DY/2)-y)/DY*h;
						TextOutA(ghMemDC, V+VT, int(Y)-(Y<0)+2, g_buf, linelen);
					//	linelen=sprintf_s(line, 128, "%g", y);
					//	double Y=((VY+DY/2)-y)/DY*h;
					//	TextOutA(ghMemDC, V+VT, int(Y)-(Y<0)+2, line, linelen);
					}
					{
						int Ys=H+(H>h-46?-34:18);
						for(auto &label:labels.Xlabels)
							TextOutA(ghMemDC, w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
						int Xs=	V+VT+24+8*prec>w-24-prec*8
							?	V+VT-24-8*prec
							:	V+VT+24+8*prec;
						Ys=0;
						for(auto &label:labels.Ylabels)
							TextOutA(ghMemDC, Xs, Ys, label.label.c_str(), label.label.size()), Ys+=16;
						Ys=0;
						for(auto &label:labels.Clabels)
						{
							int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
							TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen);
						//	linelen=sprintf_s(line, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, line, linelen);
							Ys+=16;
						}
					}
					SetBkMode(ghMemDC, bkMode);
				}
				{
					int k=0, Y=h-operations.size()*16;
					for(auto operation:operations)
					{
						char const *a=0;
						switch(operation)
						{
						case 1:a="%d: Differentiate X";break;
						case 2:a="%d: Differentiate Y";break;
						case 3:a="%d: Integrate X";break;
						case 4:a="%d: Integrate Y";break;
						case 5:a="%d: DFT";break;
						case 6:a="%d: IDFT";break;
						case 7:a="%d: LPF";break;
						case 8:a="%d: HPF";break;
						case 9:a="%d: HT";break;
						case 10:a="%d: IHT";break;
						}
						GUIPrint(ghMemDC, w-const_label_offset_X, Y, a, k);
						++k, Y+=16;
					}
				}
			}
		}
		void i_draw();
		void a_draw();
	} c2d;
	void			Color_2D::function1(){derive_step_2D(DX, AR_Y, w, Xstep, Ystep, prec, prec);}
	void			Color_2D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				std::copy(rgb, rgb+w*h, modeRGB);

			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, OPAQUE);
				itb.draw();
				SetBkMode(ghMemDC, bkMode);
			}
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		}
		else
		{
			std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Color_2D::a_draw()
	{
		Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);
		
		draw();
		
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
	class		Longitudinal_2D:public Mode
	{
	public:
	//	int toSolve;
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		int Xoffset, Yoffset, exprRemoved;
	//	int bpx, bpy, bh, bw;

		int Xplaces, Yplaces, old_nX, old_nY;
		double VX, VY, DX, AR_Y, Xstep, Ystep;
	//	double VX, VY, DX, DY, AR_Y, step;
		int prec;
		double T;
		Solve_L2D_Disc solver;
		
		bool clearScreen;
		Labels_2D labels;
		_2D_L2D _2d;
		static const std::set<int> modes;
		HPEN__ *hPen;
		HBRUSH__ *hBrush;
		
	//	char line[128];
	//	int linelen;
		bool timer, drag, m_bypass;
		int kp;

		Longitudinal_2D():
			VX(0), VY(0), DX(20), AR_Y(1),
		//	bpx(0), bpy(0), bw(0), bh(0),
			timer(false), drag(false), m_bypass(false), kp(0),
			shiftOnly(2), Xoffset(0), Yoffset(0), exprRemoved(0),
		//	toSolve(1), shiftOnly(2), Xoffset(0), Yoffset(0),
			clearScreen(false)
		{hPen=CreatePen(PS_SOLID, 1, _3dGridColor);}
		~Longitudinal_2D(){DeleteObject(hPen);}

		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
				drag=1;
			}
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
		//	kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]+kb[VK_ADD]+kb[VK_OEM_PLUS]+kb[VK_SUBTRACT]+kb[VK_OEM_MINUS];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag)
			{
				drag=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}

		void setDimentions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h;

		//	Xplaces=bw, Yplaces=bh;
			function1();
		//	DY=DX*h/w;
			toSolve=true, shiftOnly=0;
			ready=true;
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimentions(x, y, w, h);
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
		}
		void messageTimer()
		{
			if(_2d_drag_graph_not_window)
			{
				if(kb[VK_LEFT		]){	VX+=10*DX/ w		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_RIGHT		]){	VX-=10*DX/ w		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_UP			]){	VY-=10*DX/(w*AR_Y)	, toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset-=10;}
				if(kb[VK_DOWN		]){	VY+=10*DX/(w*AR_Y)	, toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset+=10;}
			}
			else
			{
				if(kb[VK_LEFT		]){	VX-=10*DX/ w		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_RIGHT		]){	VX+=10*DX/ w		, toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_UP			]){	VY+=10*DX/(w*AR_Y)	, toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset+=10;}
				if(kb[VK_DOWN		]){	VY-=10*DX/(w*AR_Y)	, toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset-=10;}
			}
			if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])
			{
				if(kb['X'])
					DX/=1.05, AR_Y/=1.05;
				else if(kb['Y'])
					AR_Y*=1.05;
				else
					DX/=1.05;
				//	DX/=1.1, DY=DX*h/w;
				function1(), toSolve=true, shiftOnly=0;
			}
			if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])
			{
				if(kb['X'])
					DX*=1.05, AR_Y*=1.05;
				else if(kb['Y'])
					AR_Y/=1.05;
				else
					DX*=1.05;
				function1(), toSolve=true, shiftOnly=0;
			//	DX*=1.1, DY=DX*h/w, function1(), toSolve=true, shiftOnly=0;
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				drag=1;
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
				SetCapture(ghWnd);
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(drag)
			{
				if(!m_bypass)
				{
					int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
					int dx=mx-w/2, dy=h/2-my;
					if(_2d_drag_graph_not_window)
						dx=-dx, dy=-dy;
					VX+=dx*DX/w, VY+=dy*DX/(w*AR_Y);
					toSolve=true;
					if(shiftOnly)
						shiftOnly=1, Xoffset+=dx, Yoffset+=dy;
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
				m_bypass=!m_bypass;
			}
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				drag=0;
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
		}
		int inputMouseWheel(int wParam)
		{
			int mx=((short*)&oldMouse)[0], my=((short*)&oldMouse)[1];
			double dx=(mx-w/2)*DX/w, dy=(h/2-my)*DX/(w*AR_Y);
			if(kb['X'])
			{
					 if(((short*)&wParam)[1]>0)	DX/=1.1, AR_Y/=1.1, VX=VX+dx-dx/1.1;
				else							DX*=1.1, AR_Y*=1.1, VX=VX+dx-dx*1.1;
			}
			else if(kb['Y'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Y*=1.1, VY=VY+dy-dy/1.1;
				else							AR_Y/=1.1, VY=VY+dy-dy*1.1;
			}
			else
			{
					 if(((short*)&wParam)[1]>0)	DX/=1.1, VX=VX+dx-dx/1.1, VY=VY+dy-dy/1.1;
				else							DX*=1.1, VX=VX+dx-dx*1.1, VY=VY+dy-dy*1.1;
			//		 if(((short*)&wParam)[1]>0)	VX=VX+dx-dx/1.1, VY=VY+dy-dy/1.1, DX/=1.1, DY=DX*h/w;
			//	else							VX=VX+dx-dx*1.1, VY=VY+dy-dy*1.1, DX*=1.1, DY=DX*h/w;
			}
			function1(), toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[wParam])
					++kp;
				if(!time_variance&&!timer)
					SetTimer(ghWnd, 0, 10, 0), timer=true;
				return 0;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				DX=20, AR_Y=1, function1();
				toSolve=true, shiftOnly=0;
				break;
			case 'R':
				if(!kb[VK_CONTROL])
					DX=20, AR_Y=1, function1();
				//	DX=20, DY=DX*h/w, function1();
				VX=VY=0;
				toSolve=true, shiftOnly=0;
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(kp)//start+key
					--kp;
				break;
			}
			return 0;
		}
		void function1();
		void draw()
		{
			double DY=DX*h/(w*AR_Y);
			if(DY<=0)
				DY=1;
			//{
			//	HPEN hPen=CreatePen(PS_SOLID, 1, _2dCheckColor);
			//	HBRUSH hBrush=CreateSolidBrush(_2dCheckColor);
			//	hPen=(HPEN__*)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH__*)SelectObject(ghMemDC, hBrush);
			//	for(double y=ceil ((VY+DY/2)/(2*Ystep))*(2*Ystep);y>floor((VY-DY/2)/Ystep)*Ystep-2*Ystep;y-=2*Ystep)
			//	{
			//		for(double x=floor((VX-DX/2)/(2*Xstep))*(2*Xstep);x<ceil ((VX+DX/2)/Xstep)*Xstep;x+=2*Xstep)
			//		{
			//			Rectangle(ghMemDC, int(w*(x			-(VX-DX/2))/DX), int(h*((VY+DY/2)-y			)/DY), int(w*(x+	Xstep-(VX-DX/2))/DX), int(h*((VY+DY/2)-y-	Ystep)/DY));
			//			Rectangle(ghMemDC, int(w*(x+Xstep	-(VX-DX/2))/DX), int(h*((VY+DY/2)-y-Ystep	)/DY), int(w*(x+2*	Xstep-(VX-DX/2))/DX), int(h*((VY+DY/2)-y-2*Ystep)/DY));
			//		}
			//	}
			//	hPen=(HPEN__*)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH__*)SelectObject(ghMemDC, hBrush);
			//	DeleteObject(hBrush);
			//	DeleteObject(hPen);
			//}
			hPen=(HPEN__*)SelectObject(ghMemDC, hPen);//draw the grid
			{
				double Ystart=VY-DY/2, Yend=VY+DY/2, Xstart=VX-DX/2, Xend=VX+DX/2;
				for(double x=floor(Xstart/Xstep)*Xstep, xEnd=ceil(Xend/Xstep)*Xstep;x<xEnd;x+=Xstep)
				{
					double _X=(x-Xstart)/DX*w;
					int X=int(_X)-(_X<0);
					MoveToEx(ghMemDC, X, 0, 0), LineTo(ghMemDC, X, h);
				}
				for(double y=ceil(Yend/Ystep)*Ystep, yEnd=floor(Ystart/Ystep)*Ystep-Ystep;y>yEnd;y-=Ystep)
				{
					double _Y=(Yend-y)/DY*h;
					int Y=int(_Y)-(_Y<0);
					MoveToEx(ghMemDC, 0, Y, 0), LineTo(ghMemDC, w, Y);
				}
			}
		/*	for(double X=floor((VX-DX/2)/Xstep)*Xstep;X<ceil ((VX+DX/2)/Xstep)*Xstep;X+=Xstep)
				MoveToEx(ghMemDC, int(w*(X-(VX-DX/2))/DX), 0, 0), LineTo(ghMemDC, int(w*(X-(VX-DX/2))/DX), h);
			for(double Y=ceil ((VY+DY/2)/Ystep)*Ystep;Y>floor((VY-DY/2)/Ystep)*Ystep;Y-=Ystep)
				MoveToEx(ghMemDC, 0, int(h*((VY+DY/2)-Y)/DY), 0), LineTo(ghMemDC, w, int(h*((VY+DY/2)-Y)/DY));//*/
			//	MoveToEx(ghMemDC, 0, int(h*((VY+DY/2)-Y)/DY+2), 0), LineTo(ghMemDC, w, int(h*((VY+DY/2)-Y)/DY+2));
			hPen=(HPEN__*)SelectObject(ghMemDC, hPen);
			if(toSolve)
			{
				if(_dangerous_code&&//
					shiftOnly==1&&abs(Xoffset)<Xplaces&&abs(Yoffset)<Yplaces)
				{
					if(Xoffset||Yoffset)
					{
						solver.partial_bounds(VX, DX, VY, DY, Xoffset, Yoffset);
						solver.synchronize();
						for(auto &ex:expr)
							if(ex.rmode[0]==7)
								(solver.*(ex.nITD?&Solve_L2D_Disc::full:solver.partial))(ex);
					}
				}
				else
				{
					auto old_time_variance=time_variance;
					time_variance=false;
				//	std::fill(nExpr.begin(), nExpr.end(), 0);
					labels.clear();
					Xplaces=w, Yplaces=h;
					function1();
				//	DY=DX*h/w;
					solver.full_resize(VX, DX, VY, DY, Xstep, Ystep, Xplaces, Yplaces);
					if(!paused)
						solver.synchronize();
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
					//	++nExpr[ex.rmode[0]];
						if(ex.rmode[0]==7)
						{
							time_variance|=ex.nITD;
							labels.fill(e);
							solver.full(ex);
						}
					}
					if(time_variance)
					{
						if(!paused)
							SetTimer(ghWnd, 0, 10, 0);
					}
					else if(old_time_variance&&!timer)
						KillTimer(ghWnd, 0);
				}
				toSolve=false, shiftOnly=2, Xoffset=Yoffset=0;
				exprRemoved=false;
			}
			else if(exprRemoved)
			{
				auto old_time_variance=time_variance;
				time_variance=false;
			//	std::fill(nExpr.begin(), nExpr.end(), 0);
				labels.clear();
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
				//	++nExpr[ex.rmode[0]];
					if(ex.rmode[0]==7)
					{
						time_variance|=ex.nITD;
						labels.fill(e);
					}
				}
				if(old_time_variance&&!time_variance&&!timer)
					KillTimer(ghWnd, 0);
				exprRemoved=false;
			}
			else if(time_variance)
			{
				if(!paused)
					solver.synchronize();
				for(auto &ex:expr)
					if(ex.rmode[0]==7&&ex.nITD)
						solver.full(ex);
			}
			int colorCondition=nExpr[7]>1;
			if(!clearScreen)
			{
			//	double LOL_1=h*(VY+DY/2)/DY;//242.99999999999997
			//	double LOL_2=h*(VY/DY+.5);//243.00000000000000
				int H=int(VY-DY/2>0?h:VY+DY/2<0?-1:h*(VY/DY+.5)), HT=H+(H>h-30?-18:2), V=int(VX-DX/2>0?-1:VX+DX/2<0?w:w*(-VX+DX/2)/DX), VT=int(V>w-24-prec*8?-24-prec*8:2);
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, TRANSPARENT);
				for(double x=floor((VX-DX/2)/Xstep)*Xstep, xEnd=ceil((VX+DX/2)/Xstep)*Xstep;x<xEnd;x+=Xstep)
				{
					if(x>-Xstep/2&&x<Xstep/2)
						continue;
					int linelen=sprintf_s(g_buf, 128, "%g", x);
					double X=(x-(VX-DX/2))/DX*w;
					TextOutA(ghMemDC, int(X)-(X<0)+2, HT, g_buf, linelen);
				//	linelen=sprintf_s(line, 128, "%g", x);
				//	double X=(x-(VX-DX/2))/DX*w;
				//	TextOutA(ghMemDC, int(X)-(X<0)+2, HT, line, linelen);
				}
				for(double y=ceil((VY+DY/2)/Ystep)*Ystep, yEnd=floor((VY-DY/2)/Ystep)*Ystep;y>yEnd;y-=Ystep)
				{
					if(y>-Ystep/2&&y<Ystep/2)
						continue;
					int linelen=sprintf_s(g_buf, 128, "%g", y);
					double Y=((VY+DY/2)-y)/DY*h;
					TextOutA(ghMemDC, V+VT, int(Y)-(Y<0)+2, g_buf, linelen);
				//	linelen=sprintf_s(line, 128, "%g", y);
				//	double Y=((VY+DY/2)-y)/DY*h;
				//	TextOutA(ghMemDC, V+VT, int(Y)-(Y<0)+2, line, linelen);
				}
				MoveToEx(ghMemDC, 0, H, 0), LineTo(ghMemDC, w, H), MoveToEx(ghMemDC, V, 0, 0), LineTo(ghMemDC, V, h);
				{
					int textColor;
					if(colorCondition)
						textColor=GetTextColor(ghMemDC);
					int Ys=H+(H>h-46?-34:18);
					for(auto &label:labels.Xlabels)
					{
						if(colorCondition)
							SetTextColor(ghMemDC, expr[label.exNo].winColor);
						TextOutA(ghMemDC, w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					}
					int Xs=	V+VT+24+8*prec>w-24-prec*8
						?	V+VT-24-8*prec
						:	V+VT+24+8*prec;
					Ys=0;
					for(auto &label:labels.Ylabels)
					{
						if(colorCondition)
							SetTextColor(ghMemDC, expr[label.exNo].winColor);
						TextOutA(ghMemDC, Xs, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					}
					Ys=0;
					for(auto &label:labels.Clabels)
					{
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
					//	linelen=sprintf_s(line, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						if(colorCondition)
							SetTextColor(ghMemDC, expr[label.exNo].winColor);
						TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, line, linelen), Ys+=16;
					}
					if(colorCondition)
						SetTextColor(ghMemDC, textColor);
				}
				SetBkMode(ghMemDC, bkMode);
			}
			double XXstart=solver.XXstart, YYend=VY+DY/2;
			double Xr=w/DX, Yr=h/DY;
			HPEN hGPen=0;
			int colored=0;
			unsigned yDiscOffset=(Xplaces-1)*solver.nX;
			for(auto &ex:expr)//draw the curves/lines
			{
				if(ex.rmode[0]==7)
				{
					if(colorCondition)
						hGPen=(HPEN)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, ex.winColor)), colored=1;
					auto &ndr=ex.n[0].ndr;
				//	auto &Xdisc=solver.Xdiscs[e], &Ydisc=solver.Ydiscs[e];
					for(int y=0;y<solver.nX;++y)//horizontal projected lines
					{
						_2d.curve_start();
						for(int x=0;x<Xplaces-1;++x)
						{
							auto &V=ndr[Xplaces*y+x];
							auto LOL=Yr*(YYend-V.i);//
							_2d.curve_point(Xr*(V.r-XXstart), Yr*(YYend-V.i));
							if(ex.discontinuities[(Xplaces-1)*y+x])
								_2d.curve_start();
						}
						auto &V=ndr[Xplaces*y+Xplaces-1];
						_2d.curve_point(Xr*(V.r-XXstart), Yr*(YYend-V.i));
					}
					int yPos=Xplaces*solver.nX;
					for(int x=0;x<solver.nY;++x)//vertical projected lines
					{
						_2d.curve_start();
						for(int y=0;y<Yplaces-1;++y)
						{
							auto &V=ndr[yPos+Yplaces*x+y];
							_2d.curve_point(Xr*(V.r-XXstart), Yr*(YYend-V.i));
							if(ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y])
								_2d.curve_start();
						}
						auto &V=ndr[yPos+Yplaces*x+Yplaces-1];
						_2d.curve_point(Xr*(V.r-XXstart), Yr*(YYend-V.i));
						_2d.set_point();
					}

				/*	auto &ndr=ex.n[0].ndr;
					for(int y=0;y<solver.nX;++y)
					{
						_2d.curve_start();
						for(int x=0;x<Xplaces;++x)
						{
							auto &V=ndr[Xplaces*y+x];
							_2d.curve_point(Xr*(V.r-XXstart), Yr*(YYend-V.i));
						}
					}
					int yPos=Xplaces*solver.nX;
					for(int x=0;x<solver.nY;++x)
					{
						_2d.curve_start();
						for(int y=0;y<Yplaces;++y)
						{
							auto &V=ndr[yPos+Xplaces*y+x];
							_2d.curve_point(Xr*(V.r-XXstart), Yr*(YYend-V.i));
						}
					}//*/

					//auto &ndr=ex.n[0].ndr;
					//auto ndrIT=ndr.begin();
					//if(ndrIT!=ndr.end())
					//{
					//	int k=0;
					//	for(int k2=0;k2<solver.nX;++k2, ++k, ++ndrIT)
					//	{
					//		MoveToEx(ghMemDC, int(w*(ndrIT->r-XXstart)/DX), int(h*(-ndrIT->i+YYend)/DY), 0);
					//		++ndrIT, ++k;
					//		for(int kEnd=Xplaces*(k2+1)-1;k<kEnd;++k, ++ndrIT)
					//		{
					//			LineTo	(ghMemDC, int(w*(ndrIT->r-XXstart)/DX), int(h*(-ndrIT->i+YYend)/DY));
					//			MoveToEx(ghMemDC, int(w*(ndrIT->r-XXstart)/DX), int(h*(-ndrIT->i+YYend)/DY), 0);
					//		}
					//		LineTo(ghMemDC, int(w*(ndrIT->r-XXstart)/DX), int(h*(-ndrIT->i+YYend)/DY));
					//	}
					//	for(int k2=0;k2<solver.nY;++k2, ++k, ++ndrIT)
					//	{
					//		MoveToEx(ghMemDC, int(w*(ndrIT->r-XXstart)/DX), int(h*(-ndrIT->i+YYend)/DY), 0);
					//		++ndrIT, ++k;
					//		for(int kEnd=Xplaces*solver.nX+Yplaces*(k2+1)-1;k<kEnd;++k, ++ndrIT)
					//		{
					//			LineTo	(ghMemDC, int(w*(ndrIT->r-XXstart)/DX), int(h*(-ndrIT->i+YYend)/DY));
					//			MoveToEx(ghMemDC, int(w*(ndrIT->r-XXstart)/DX), int(h*(-ndrIT->i+YYend)/DY), 0);
					//		}
					//		LineTo(ghMemDC, int(w*(ndrIT->r-XXstart)/DX), int(h*(-ndrIT->i+YYend)/DY));
					//	}
					//}
					if(colored)
						DeleteObject(SelectObject(ghMemDC, hGPen)), colored=0;
				}
			}
			GUIPrint(ghMemDC, 0, h-48, _dangerous_code?"partial shift, F9 for full shift":"full shift, F9 for partial shift");
		//	GUIPrint(ghMemDC, 0, h-48, _dangerous_code?"F9 for full shift":"F9 for partial shift");
		//	GUIPrint(ghMemDC, 0, h-48, _dangerous_code?"F9: toggle full solve on shifting":"F9: toggle partial solve on shifting");
		//	GUIPrint(ghMemDC, 0, h-48, _dangerous_code?"F9: to solve whole buffer":"F9: to shift buffer");
		}
		void i_draw();
		void a_draw();
	} l2d;
	const std::set<int> Longitudinal_2D::modes({7});
	void			Longitudinal_2D::function1(){derive_step_2D(DX, AR_Y, w, Xstep, Ystep, prec, prec);}
	void			Longitudinal_2D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				std::copy(rgb, rgb+w*h, modeRGB);

			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, OPAQUE);
				if(nExpr[7]>1)
					itb.draw_color(modes);
				else
					itb.draw();
				SetBkMode(ghMemDC, bkMode);
			}
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		}
		else
		{
			std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Longitudinal_2D::a_draw()
	{
		Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);
		
		draw();
		
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
	class		Transverse_2D_H:public Mode
	{
	public:
	//	int toSolve;
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		int Xoffset, Yoffset;
		int X0, Y0;
	//	int bpx, bpy, bh, bw, X0, Y0;

		int Xplaces, Yplaces;
		double XshiftPoint, YshiftPoint;
		double XsamplePos, YsamplePos;
	//	int KXplaces, KYplaces;

		double VX, VY, VZ, DX, AR_Y, AR_Z, Xstep, Ystep, Zstep;
		double Xstart, Xr, Ystart, Yr;
		Solve_2D_Disc solver;
		std::list<int> operations;
		
		bool contourOn, contourOnly, contourFlat;
		std::map<unsigned, std::unordered_map<int, std::list<std::pair<contour::Double_X_Y, contour::Double_X_Y>>>>
			Rcontours,//contours[e]=contour, contour[r level (r/step)]=sticks, *stick.begin()=((x,y),(x,y))
			Icontours,//contours[e]=contour, contour[i level (i/step)]=sticks, *stick.begin()=((x,y),(x,y))
			Jcontours,//contours[e]=contour, contour[j level (j/step)]=sticks, *stick.begin()=((x,y),(x,y))
			Kcontours;//contours[e]=contour, contour[k level (k/step)]=sticks, *stick.begin()=((x,y),(x,y))
		
		bool clearScreen, kb_VK_F6_msg;
		Labels_2D labels;
		_3D _3d;
		int gridColor, rColor, iColor, jColor, kColor;
		
	//	char line[128];
	//	int linelen;
		bool timer, drag, m_bypass, shift;
		int kp;

		Transverse_2D_H():
			VX(0), VY(0), VZ(0), DX(20), AR_Y(1), AR_Z(1),
			Xplaces(100), Yplaces(100),
			XshiftPoint(0), YshiftPoint(0),
			XsamplePos(0), YsamplePos(0),
			_3d(4, 4, 4, 225*G2::_pi/180, 324.7356103172454*G2::_pi/180, 1),
			gridColor(_3dGridColor), rColor(0), iColor(0x000000EF), jColor(0x0000EF00), kColor(0x00EF0000),//rgb
			timer(false), drag(false), m_bypass(false), shift(false), kp(0),
			shiftOnly(2), Xoffset(0), Yoffset(0),
		//	toSolve(1), shiftOnly(2), Xoffset(0), Yoffset(0),
			contourOnly(false),
			clearScreen(false), kb_VK_F6_msg(false)
		{}

		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
				drag=1;
			}
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
		//	kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]+kb[VK_ADD]+kb[VK_OEM_PLUS]+kb[VK_SUBTRACT]+kb[VK_OEM_MINUS];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag||shift)
			{
				drag=0, shift=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag||shift)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}

		void doContour_component(unsigned e, unsigned c, double Xs, double Zstart, double Zend, double Zstep, unsigned nzSteps)
		{
			using namespace contour;
			auto &ndr=expr[e].n[0].ndr;
			auto contour=&Rcontours[e];
			switch(c)
			{
			case 0:contour=&Rcontours[e];break;
			case 1:contour=&Icontours[e];break;
			case 2:contour=&Jcontours[e];break;
			case 3:contour=&Kcontours[e];break;
			}
			auto cutTrgl=[&](double &Xa, double &Ya, double &Za, double &Xb, double &Yb, double &Zb, double &Xc, double &Yc, double &Zc)
			{
				double X1, Y1, Z1, X2, Y2, Z2, X3, Y3, Z3;//ordered by z in acscending order
				if(Za<Zb)
				{
					if(Zb<Zc)
						X1=Xa, Y1=Ya, Z1=Za, X2=Xb, Y2=Yb, Z2=Zb, X3=Xc, Y3=Yc, Z3=Zc;
					else if(Za<Zc)
						X1=Xa, Y1=Ya, Z1=Za, X2=Xc, Y2=Yc, Z2=Zc, X3=Xb, Y3=Yb, Z3=Zb;
					else
						X1=Xc, Y1=Yc, Z1=Zc, X2=Xa, Y2=Ya, Z2=Za, X3=Xb, Y3=Yb, Z3=Zb;
				}
				else if(Zb<Zc)
				{
					if(Za<Zc)
						X1=Xb, Y1=Yb, Z1=Zb, X2=Xa, Y2=Ya, Z2=Za, X3=Xc, Y3=Yc, Z3=Zc;
					else
						X1=Xb, Y1=Yb, Z1=Zb, X2=Xc, Y2=Yc, Z2=Zc, X3=Xa, Y3=Ya, Z3=Za;
				}
				else
					X1=Xc, Y1=Yc, Z1=Zc, X2=Xb, Y2=Yb, Z2=Zb, X3=Xa, Y3=Ya, Z3=Za;
				double X13, Y13, Z13;
				{
					double Zr=(Z2-Z1)/(Z3-Z1);
					X13=X1+(X3-X1)*Zr, Y13=Y1+(Y3-Y1)*Zr, Z13=Z2;
				}
				//for Z1 -> Z2
				for(double z=std::floor((Z1<Zstart?Zstart:Z1)/Zstep), zEnd=std::floor((Z2>Zend?Zend:Z2)/Zstep);z<=zEnd;++z)
				{
					double ZL=Zstep*z;
					if(Z1<=ZL&&ZL<Z2)
					{
						double M=(ZL-Z1)/(Z2-Z1);
						contour->operator[](int(z)).push_back(std::pair<Double_X_Y, Double_X_Y>(
							Double_X_Y(X1+M*(X2-X1), Y1+M*(Y2-Y1)),
							Double_X_Y(X1+M*(X13-X1), Y1+M*(Y13-Y1))
							));
					}
				}
				//for Z2 -> Z3
				for(double z=std::floor((Z2<Zstart?Zstart:Z2)/Zstep), zEnd=std::floor((Z3>Zend?Zend:Z3)/Zstep);z<=zEnd;++z)
				{
					double ZL=Zstep*z;
					if(Z2<=ZL&&ZL<Z3)
					{
						double M=(ZL-Z2)/(Z3-Z2);
						contour->operator[](int(z)).push_back(std::pair<Double_X_Y, Double_X_Y>(
							Double_X_Y(X2+M*(X3-X2), Y2+M*(Y3-Y2)),
							Double_X_Y(X13+M*(X3-X13), Y13+M*(Y3-Y13))
							));
					}
				}
			};
			double Xstart=solver.Xstart, Ystart=AR_Y*solver.Ystart;
			for(unsigned vy=0, vyEnd=Yplaces-1;vy<vyEnd;++vy)
			{
				for(unsigned vx=0, vxEnd=Xplaces-1;vx<vxEnd;++vx)
				{
					auto
						X00=Xstart+Xs* vx    , Y00=Ystart+Xs* vy    , &Z00=(&ndr[Xplaces* vy    +vx   ].r)[c],
						X01=Xstart+Xs* vx    , Y01=Ystart+Xs*(vy+1 ), &Z01=(&ndr[Xplaces*(vy+1 )+vx   ].r)[c],
						X10=Xstart+Xs*(vx+1 ), Y10=Ystart+Xs* vy    , &Z10=(&ndr[Xplaces* vy    +vx+1 ].r)[c],
						X11=Xstart+Xs*(vx+1 ), Y11=Ystart+Xs*(vy+1 ), &Z11=(&ndr[Xplaces*(vy+1 )+vx+1 ].r)[c],
						Xx =Xstart+Xs*(vx+.5), Yx =Ystart+Xs*(vy+.5),  Zx =.25*(Z00+Z01+Z10+Z11);
					cutTrgl(X00, Y00, Z00, Xx, Yx, Zx, X01, Y01, Z01);
					cutTrgl(X01, Y01, Z01, Xx, Yx, Zx, X11, Y11, Z11);
					cutTrgl(X11, Y11, Z11, Xx, Yx, Zx, X10, Y10, Z10);
					cutTrgl(X10, Y10, Z10, Xx, Yx, Zx, X00, Y00, Z00);
				}
			}
		}
		void doContour(unsigned e, double Xs, double Zstart, double Zend, double Zstep, unsigned nzSteps)
		{
			doContour_component(e, 0, Xs, Zstart, Zend, Zstep, nzSteps);
			doContour_component(e, 1, Xs, Zstart, Zend, Zstep, nzSteps);
			doContour_component(e, 2, Xs, Zstart, Zend, Zstep, nzSteps);
			doContour_component(e, 3, Xs, Zstart, Zend, Zstep, nzSteps);
		}

		void setDimentions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h, X0=bpx+bw/2, Y0=bpy+bh/2;
			_3d.setDimentions(x, y, w, h);
			double old_Zstep=Zstep;
			function1();
			if(!toSolve&&contourOn&&old_Zstep!=Zstep)
			{
				Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
				double Xs=DX/Xplaces, DZ=DX/AR_Z;
				doContour(cursorEx, Xs, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
			}
			ready=true;
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimentions(x, y, w, h);
			if(!time_variance&&!timer)
				a_draw();
		}
		void shiftNDR(double &DshiftPoint, double Dsample, double &DsamplePos, double &VD, int &Doffset, double ammount)
	//	void shiftNDR(double &DshiftPoint, double &Dsample, double &DsamplePos, double &VD, double AR_D, int &Doffset, double ammount)
		{
			double newDsamplePos=std::floor((DshiftPoint+=ammount)/Dsample);
		//	double newDsamplePos=std::floor((DshiftPoint+=ammount)/(AR_D*Dsample));
			if(newDsamplePos!=DsamplePos)
			{
				toSolve=true;
				if(shiftOnly)
					shiftOnly=1, Doffset+=int(newDsamplePos-DsamplePos);
				DsamplePos=newDsamplePos, VD=newDsamplePos*Dsample;
			//	DsamplePos=newDsamplePos, VD=newDsamplePos*AR_D*Dsample;
			}
			DsamplePos=newDsamplePos;
		}
		void shiftNDRupdate(double DshiftPoint, double Dsample, double &DsamplePos, double &VD)
	//	void shiftNDRupdate(double DshiftPoint, double Dsample, double &DsamplePos, double &VD, double AR_D)
		{
			double newDsamplePos=std::floor(DshiftPoint/Dsample);
		//	double newDsamplePos=std::floor(DshiftPoint/(AR_D*Dsample));
			if(newDsamplePos!=DsamplePos)
				DsamplePos=newDsamplePos, VD=newDsamplePos*Dsample;
			//	DsamplePos=newDsamplePos, VD=newDsamplePos*AR_D*Dsample;
		}
		void messageTimer()
		{
				 if(kb[VK_SHIFT	]){	 if(kb['W'])	_3d.moveForwardFast();
									 if(kb['A'])	_3d.moveLeftFast();
									 if(kb['S'])	_3d.moveBackFast();
									 if(kb['D'])	_3d.moveRightFast();
									 if(kb['T'])	_3d.camz+=10*_3d.dcam;
									 if(kb['G'])	_3d.camz-=10*_3d.dcam;}
			else				  {	 if(kb['W'])	_3d.moveForward();
									 if(kb['A'])	_3d.moveLeft();
									 if(kb['S'])	_3d.moveBack();
									 if(kb['D'])	_3d.moveRight();
									 if(kb['T'])	_3d.camz+=_3d.dcam;
									 if(kb['G'])	_3d.camz-=_3d.dcam;}
			double dVD=DX/100;
			if(kb['X'])
			{
				if(kb['Y'])
				{
					if(kb['Z'])
					{
					}
					else		//xy
					{
						if(kb[VK_UP])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, dVD), _3d.camy+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, -dVD), _3d.camy-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dVD), _3d.camx+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, -dVD), _3d.camx-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//xz
					{
						if(kb[VK_UP])	VZ+=DX/100, _3d.camz+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	VZ-=DX/100, _3d.camz-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, DX/100), _3d.camx+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, -DX/100), _3d.camx-=_3d_shift_move_cam*dVD;
					}
					else		//x
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, DX/100), _3d.camx+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, -DX/100), _3d.camx-=_3d_shift_move_cam*dVD;
					}
				}
			}
			else
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//yz
					{
						if(kb[VK_UP])	VZ+=DX/100, _3d.camz+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	VZ-=DX/100, _3d.camz-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, DX/100), _3d.camy+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, -DX/100), _3d.camy-=_3d_shift_move_cam*dVD;
					}
					else		//y
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, DX/100), _3d.camy+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, -DX/100), _3d.camy-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//z
					{
						if(kb[VK_UP]||kb[VK_RIGHT]){	VZ+=DX/100, _3d.camx+=_3d_shift_move_cam*dVD;	if(contourOn)toSolve=true, shiftOnly=0;}//just to update contour
						if(kb[VK_DOWN]||kb[VK_LEFT]){	VZ-=DX/100, _3d.camx-=_3d_shift_move_cam*dVD;	if(contourOn)toSolve=true, shiftOnly=0;}
					}
					else
					{
						if(kb[VK_UP])	_3d.rotateUp();
						if(kb[VK_DOWN])	_3d.rotateDown();
						if(kb[VK_RIGHT])_3d.rotateRight();
						if(kb[VK_LEFT])	_3d.rotateLeft();
					}
				}
			}
			if(kb[VK_ADD]||kb[VK_RETURN]||kb[VK_OEM_PLUS])
			{
				if(kb[VK_MENU])//alt+
				{
					if(_3d_zoom_move_cam)//zoom in
						DX/=1.1, _3d.camx=VX+(_3d.camx-VX)/1.1, _3d.camy=VY+(_3d.camy-VY)/1.1, _3d.camz=VZ+(_3d.camz-VZ)/1.1, _3d.dcam/=1.1;
					else//zoom out
						DX*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					toSolve=true, shiftOnly=0;
				/*	DX*=1.1, function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);//
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);//
					toSolve=true, shiftOnly=0;//*/
				}
				else if(kb['X'])//x+ stretch (zoom out (compress), stretch y, z)
				{
					if(_3d_stretch_move_cam)
					{
						double VX0=VX, VY0=VY;
						DX/=1.1;//zoom out
						function1();
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.camx=VX+(_3d.camx-VX0)/1.1, _3d.camy=VY+(_3d.camy-VY0)/1.1, _3d.camz=VZ+(_3d.camz-VZ)/1.1, _3d.dcam/=1.1;

						VY0=VY;//stretch y
						YshiftPoint/=1.1;
						AR_Y/=1.1, function1();
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.camy+=VY-VY0;

						_3d.camz-=VZ/11., VZ/=1.1;//stretch z
						AR_Z/=1.1, function1();
					}
					else
					{
						DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
						_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					}
					toSolve=true, shiftOnly=0;
				/*	DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					toSolve=true, shiftOnly=0;//*/
				}
				else if(kb['Y'])//y+ stretch
				{
					double VY0=VY;
					YshiftPoint*=1.1;//move cube
					AR_Y*=1.1, function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					if(_3d_stretch_move_cam)
						_3d.camy+=VY-VY0;
					toSolve=true, shiftOnly=0;
				/*	AR_Y*=1.1, function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					toSolve=true, shiftOnly=0;//*/
				}
				else if(kb['Z'])
				{
					if(_3d_stretch_move_cam)
						_3d.camz+=VZ*0.1;
					VZ*=1.1;//move cube
					AR_Z*=1.1, function1();
					if(contourOn)
						toSolve=true, shiftOnly=0;
				/*	AR_Z*=1.1, function1();
					if(contourOn)
						toSolve=true, shiftOnly=0;//*/
				}
				else if(!kb[VK_CONTROL])
					_3d.zoomIn();
			}
			if(kb[VK_SUBTRACT]||kb[VK_BACK]||kb[VK_OEM_MINUS])
			{
				if(kb[VK_MENU])//alt-
				{
					if(_3d_zoom_move_cam)//zoom out
						DX*=1.1, _3d.camx=VX+(_3d.camx-VX)*1.1, _3d.camy=VY+(_3d.camy-VY)*1.1, _3d.camz=VZ+(_3d.camz-VZ)*1.1, _3d.dcam*=1.1;
					else//zoom in
						DX/=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					toSolve=true, shiftOnly=0;
				/*	DX/=1.1, function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);//
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);//
					toSolve=true, shiftOnly=0;//*/
				}
				else if(kb['X'])
				{
					if(_3d_stretch_move_cam)
					{
						double VX0=VX, VY0=VY;
						DX*=1.1;//zoom in
						function1();
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.camx=VX+(_3d.camx-VX0)*1.1, _3d.camy=VY+(_3d.camy-VY0)*1.1, _3d.camz=VZ+(_3d.camz-VZ)*1.1, _3d.dcam*=1.1;
					
						VY0=VY;//compress y
						YshiftPoint*=1.1;
						AR_Y*=1.1, function1();
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.camy+=VY-VY0;
					
						_3d.camz+=VZ*0.1, VZ*=1.1;//compress z
						AR_Z*=1.1, function1();
					}
					else
					{
						DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
						_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					}
					toSolve=true, shiftOnly=0;
				/*	DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					toSolve=true, shiftOnly=0;//*/
				}
				else if(kb['Y'])
				{
					double VY0=VY;
					YshiftPoint/=1.1;//move cube
					AR_Y/=1.1, function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					if(_3d_stretch_move_cam)
						_3d.camy+=VY-VY0;
					toSolve=true, shiftOnly=0;
				/*	AR_Y/=1.1, function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					toSolve=true, shiftOnly=0;//*/
				}
				else if(kb['Z'])
				{
					if(_3d_stretch_move_cam)
						_3d.camz-=VZ/11.;
					VZ/=1.1;//move cube
					AR_Z/=1.1, function1();
					if(contourOn)
						toSolve=true, shiftOnly=0;
				/*	AR_Z/=1.1, function1();
					if(contourOn)
						toSolve=true, shiftOnly=0;//*/
				}
				else if(!kb[VK_CONTROL])
					_3d.zoomOut();
			}
		//		 if(kb[VK_MENU	]){		if(kb[VK_ADD		]||kb[VK_OEM_PLUS	])	DX*=1.1, DY*=1.1, function1(), toSolve=true, shiftOnly=0;
		//								if(kb[VK_SUBTRACT	]||kb[VK_OEM_MINUS	])	DX/=1.1, DY/=1.1, function1(), toSolve=true, shiftOnly=0;}
		//	else if(!kb[VK_CONTROL]){	if(kb[VK_ADD		]||kb[VK_OEM_PLUS	])	_3d.zoomIn();
		//								if(kb[VK_SUBTRACT	]||kb[VK_OEM_MINUS	])	_3d.zoomOut();}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				if(!shift)
				{
					ShowCursor(0);
					GetCursorPos(&mouseP0);
					SetCursorPos(centerP.x, centerP.y);
					SetCapture(ghWnd);
				}
				drag=1;
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(!m_bypass)
			{
				int dmx=((short*)&lParam)[0]-w/2, dmy=h/2-((short*)&lParam)[1];
				int draw=0;
				if(kb['X'])
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//xyz	mx my mw
						{
							double VX0=VX, VY0=VY;
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dmx*DX/w), _3d.camx+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, dmy*DX/w), _3d.camy+=(VY-VY0)*_3d_shift_move_cam;
						}
						else		//xy	mx my
						{
							double VX0=VX, VY0=VY;
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dmx*DX/w), _3d.camx+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, dmy*DX/w), _3d.camy+=(VY-VY0)*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//xz	mx my
						{
							double VX0=VX;
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, dmx*DX/w), _3d.camx+=(VX-VX0)*_3d_shift_move_cam;
							double dVZ=dmy*DX/w;
							VZ+=dVZ, _3d.camx+=dVZ*_3d_shift_move_cam;
						}
						else		//x		mx
						{
							double VX0=VX;
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, dmx*DX/w), _3d.camx+=(VX-VX0)*_3d_shift_move_cam;
						}
						draw=1;
					}
				}
				else
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//yz	mx my
						{
							double VY0=VY;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.camy+=(VY-VY0)*_3d_shift_move_cam;
							double dVZ=dmy*DX/w;
							VZ+=dVZ, _3d.camx+=dVZ*_3d_shift_move_cam;
						}
						else		//y		mx
						{
							double VY0=VY;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.camy+=(VY-VY0)*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//z		my
						{
							double dVZ=dmy*DX/w;
							VZ+=dVZ, _3d.camz+=dVZ*_3d_shift_move_cam;
							if(contourOn)
								toSolve=true, shiftOnly=0;//just to update contour
							draw=1;
						}
						else if(drag)
						{
							_3d.rotate(lParam);
							draw=1;
						}
					}
				}
				if(draw)
				{
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
			}
			m_bypass=!m_bypass;
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				if(!shift)
				{
					ReleaseCapture();
					SetCursorPos(mouseP0.x, mouseP0.y);
					ShowCursor(1);
				}
				drag=0;
			}
		}
		int inputMouseWheel(int wParam)
		{
			bool mw_forward=((short*)&wParam)[1]>0;
			if(kb['X']&&kb['Y']&&kb['Z'])
			{
				double dVD=DX/100;
					 if(mw_forward)	VZ+=dVD, _3d.camz+=dVD*_3d_shift_move_cam;
				else				VZ-=dVD, _3d.camz-=dVD*_3d_shift_move_cam;
			}
			else if(kb[VK_MENU])
			{
				double VX0=VX, VY0=VY;
					 if(mw_forward)	DX*=1.1;//, DY*=1.1;
				else				DX/=1.1;//, DY/=1.1;
				function1();
				shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);//
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);//
				if(_3d_zoom_move_cam)
				{
						 if(mw_forward)	_3d.camx=VX+(_3d.camx-VX0)*1.1, _3d.camy=VY+(_3d.camy-VY0)*1.1, _3d.camz=VZ+(_3d.camz-VZ)*1.1, _3d.dcam*=1.1;
					else				_3d.camx=VX+(_3d.camx-VX0)/1.1, _3d.camy=VY+(_3d.camy-VY0)/1.1, _3d.camz=VZ+(_3d.camz-VZ)/1.1, _3d.dcam/=1.1;
				}
				toSolve=true, shiftOnly=0;
			}
			else if(kb['X'])//x wheel
			{
				if(_3d_stretch_move_cam)
				{
					double VX0=VX, VY0=VY;
						 if(mw_forward)	DX/=1.1;//zoom out
					else				DX*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						 if(mw_forward)	_3d.camx=VX+(_3d.camx-VX0)/1.1, _3d.camy=VY+(_3d.camy-VY0)/1.1, _3d.camz=VZ+(_3d.camz-VZ)/1.1, _3d.dcam/=1.1;
					else				_3d.camx=VX+(_3d.camx-VX0)*1.1, _3d.camy=VY+(_3d.camy-VY0)*1.1, _3d.camz=VZ+(_3d.camz-VZ)*1.1, _3d.dcam*=1.1;

					VY0=VY;//stretch y
						 if(mw_forward)	AR_Y/=1.1,	YshiftPoint/=1.1;
					else				AR_Y*=1.1,	YshiftPoint*=1.1;
					function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					_3d.camy+=VY-VY0;

						 if(mw_forward)	_3d.camz-=VZ/11., AR_Z/=1.1,	VZ/=1.1;//stretch z
					else				_3d.camz+=VZ*0.1, AR_Z*=1.1,	VZ*=1.1;
					function1();
				}
				else
				{
						 if(mw_forward)	DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, _3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
					else				DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, _3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
				}
				toSolve=true, shiftOnly=0;
			/*	if(((short*)&wParam)[1]>0)
				{
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1;
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
				}
				else
				{
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1;
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
				}
				function1();
				shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
				toSolve=true, shiftOnly=0;//*/
			}
			else if(kb['Y'])//y wheel
			{
				double VY0=VY;
					 if(mw_forward)	AR_Y*=1.1,	YshiftPoint*=1.1;
				else				AR_Y/=1.1,	YshiftPoint/=1.1;
				function1();
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
				_3d.camy+=(VY-VY0)*_3d_stretch_move_cam;
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Z'])//z wheel
			{
					 if(mw_forward)	AR_Z*=1.1, _3d.camz+=VZ*0.1*_3d_stretch_move_cam,	VZ*=1.1;
				else				AR_Z/=1.1, _3d.camz-=VZ/11.*_3d_stretch_move_cam,	VZ/=1.1;
				function1();
				if(contourOn)//
					toSolve=true, shiftOnly=0;
			}
			else if(kb[VK_CONTROL])//ctrl wheel
			{
					 if(mw_forward)	_3d.faster();
				else				_3d.slower();
			}
			else if(kb[VK_SHIFT])//shift wheel
			{
				if(mw_forward)
					Yplaces=++Xplaces, toSolve=true, shiftOnly=0;
				else if(Xplaces>1)
					Yplaces=--Xplaces, toSolve=true, shiftOnly=0;
			}
			else//wheel
			{
					 if(mw_forward)	_3d.zoomIn();
				else				_3d.zoomOut();
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:case 'T':case 'G':
				if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_ADD:case VK_OEM_PLUS:case VK_RETURN:
				if(kb[VK_CONTROL])
					_3d.faster();
				else if(kb[VK_SHIFT])
				{
					Yplaces=++Xplaces, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_SUBTRACT:case VK_OEM_MINUS:case VK_BACK:
				if(kb[VK_CONTROL])
					_3d.slower();
				else if(kb[VK_SHIFT])
				{
					if(Xplaces>1)
						Yplaces=--Xplaces, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case 'X':case 'Y':case 'Z':
				if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case VK_OEM_3:
				if(contourOn)//was on
				{
					if(kb[VK_CONTROL])
					{
						//contour+surface
						//contour only
						//flat contour
						//flat+surface
						if(contourFlat)
						{
							if(contourOnly)
								contourOnly=false;//3: surface appears
							else
								contourFlat=false;//4: pops up
						}
						else
						{
							if(contourOnly)
								contourFlat=true;//2: gets flat
							else
								contourOnly=true;//1: surface disappears
						}
					}
					else
						contourOn=false, contourOnly=false, contourFlat=false;
				}
				else//was off
				{
					contourOn=true;
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						double Xs=DX/Xplaces, DZ=DX/AR_Z;
						doContour(cursorEx, Xs, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E'://reset axes scale
				{
					double r=20/DX;

					XshiftPoint*=r, YshiftPoint*=r, VZ*=r;
					_3d.camx*=r, _3d.camy*=r, _3d.camz*=r, _3d.dcam*=r;
					DX=20, AR_Y=1, AR_Z=1, function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
				//	VX*=r, VY*=r, VZ*=r;
				//	_3d.camx*=r, _3d.camy*=r, _3d.camz*=r, _3d.dcam*=r;
				//	DX=20, AR_Y=1, AR_Z=1, function1();
					toSolve=true, shiftOnly=0;
				}
				break;
			case 'R'://reset position and zoom,		ctrl: position only
				_3d.dcam=.04, _3d.tanfov=1;
				if(!kb[VK_CONTROL])
					DX=20, AR_Y=1, AR_Z=1, function1(), Xplaces=Yplaces=100;

				if(XshiftPoint!=0||YshiftPoint!=0||VZ!=0)
					XshiftPoint=0, YshiftPoint=0, VZ=0;
				shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
			//	if(VX!=0||VY!=0||VZ!=0)
			//		VX=VY=VZ=0;
				toSolve=true, shiftOnly=0;
				if(kb['X'])
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
				else if(kb['Y'])
					_3d.teleport_degrees(0, 20, 0, 270, 0, 1);
				else if(kb['Z'])
					_3d.teleport_degrees(0, 0, 20, 90, 270, 1);
				else
					_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
			/*	if(kb[VK_CONTROL])
				{
					DX=20, DY=20, function1();
					toSolve=true, shiftOnly=0;
				}
				if(VX!=0||VY!=0||VZ!=0)
				{
					VX=VY=VZ=0;
					toSolve=true, shiftOnly=0;
				}
				_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);//*/
				break;
			case VK_F6:
				if(!(lParam&1<<30))
				{
					kb_VK_F6_msg=true;
					if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_stretch_move_cam=true;
					else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_shift_move_cam=true;
					else if(!_3d_zoom_move_cam)
						_3d_zoom_move_cam=true;
					else
						_3d_stretch_move_cam=_3d_shift_move_cam=_3d_zoom_move_cam=false;
				}
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:case 'T':case 'G':
				if(kp>0)
					--kp;
				break;
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[VK_CONTROL]&&kp>0)
					--kp;
				return 0;
			case 'X':
				if(!kb['Y']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Y':
				if(!kb['X']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Z':
				if(!kb['X']&&!kb['Y']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
		/*	case 'X':case 'Y':case 'Z':
				if(shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;*/
			}
			return 0;
		}
		void function1(){derive_step_3D(DX, AR_Y, AR_Z, w, Xstep, Ystep, Zstep);}
		void draw()
		{
			double DY=DX/AR_Y, DZ=DX/AR_Z;
			auto &ex=expr[cursorEx];
			{
				bool changed=false;
				if(toSolve)
				{
					if(shiftOnly==1&&abs(Xoffset)<Xplaces&&abs(Yoffset)<Yplaces)
					{
						if(Xoffset||Yoffset)
						{
							solver.partial_bounds(VX, DX, VY/AR_Y, DY, Xoffset, Yoffset);
							solver.synchronize();
							(solver.*(ex.nITD?&Solve_2D_Disc::full:solver.partial))(ex);
						}
					}
					else
					{
						auto old_time_variance=time_variance;
						time_variance=false;
					//	std::fill(nExpr.begin(), nExpr.end(), 0);
					//	for(auto &ex:expr)
					//		++nExpr[ex.rmode[0]];
						labels.clear();
						solver.full_resize(VX, DX, VY/AR_Y, DY, Xplaces, Yplaces);
						XsamplePos=std::floor(XshiftPoint/solver.Xsample);
						YsamplePos=std::floor(YshiftPoint/solver.Ysample);
					//	solver.full_resize(VX, DX, VY/AR_Y, DY, Xplaces=100, Yplaces=100), KXplaces=Xplaces/100?Xplaces/100:1, KYplaces=Yplaces/100?Yplaces/100:1;
						time_variance|=ex.nITD;
						labels.fill(cursorEx);
						if(!paused)
							solver.synchronize();
						solver.full(ex);
						if(time_variance)
						{
							if(!paused)
								SetTimer(ghWnd, 0, 10, 0);
						}
						else if(old_time_variance&&!timer)
							KillTimer(ghWnd, 0);
					}
					changed=true;
					toSolve=false, shiftOnly=2, Xoffset=Yoffset=0;
				}
				else if(time_variance)
				{
					if(!paused)
						solver.synchronize();
					solver.full(ex);
					changed=true;
				}
				if(changed&&contourOn)
				{
					Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
					double Xs=DX/Xplaces, DZ=DX/AR_Z;
					doContour(cursorEx, Xs, VZ-DZ/2, VZ+DZ/2, Zstep, 10);
				}
			}

			_3dMode_FrameStart(_3d, VX, VY, VZ, DX, Xstep, Ystep, Zstep, AR_Y, AR_Z);
		//	_3dMode_FrameStart(_3d, VX, VY, VZ, DX, Xstep, AR_Y*Ystep, AR_Z*Zstep, AR_Y, AR_Z);
			double Xstart=solver.Xstart, Xsample=solver.Xsample, Ystart=AR_Y*solver.Ystart, Ysample=AR_Y*solver.Ysample;
			if(!contourOnly)//draw the surfaces
			{
				double Yend=VY+DY/2;
				auto &ndr=ex.n[0].ndr;
				int lColor[]={rColor, iColor, jColor, kColor};
				if(operations.size())
				{
					for(unsigned c=0;c<4;++c)
					{
						_3d.lineColor=lColor[c];
						for(int y=0;y<Yplaces;++y)
						{
							_3d.curve_start();
							for(int x=0;x<Xplaces;++x)
								_3d.curve_point(Xstart+x*Xsample, Ystart+y*Ysample, AR_Z*ndr[Xplaces*y+x]);
						}
						for(int x=0;x<Xplaces;++x)
						{
							_3d.curve_start();
							for(int y=0;y<Yplaces;++y)
								_3d.curve_point(Xstart+x*Xsample, Ystart+y*Ysample, AR_Z*ndr[Xplaces*y+x]);
						}
					}
					//auto ndrIT=ndr.begin();
					//std::function<double()> f[]=
					//{
					//	std::function<double()>([&]{return ndrIT->r;}),
					//	std::function<double()>([&]{return ndrIT->i;}),
					//	std::function<double()>([&]{return ndrIT->j;}),
					//	std::function<double()>([&]{return ndrIT->k;})
					//};
					//int c[]={rColor, iColor, jColor, kColor};
					//if(ndrIT!=ndr.end())
					//{
					//	for(int LOL_k=0, LOL_k_end=sizeof(f)/sizeof(f[0]);LOL_k<LOL_k_end;++LOL_k)
					//	{
					//		_3d.lineColor=c[LOL_k];
					//		ndrIT=ndr.begin();
					//		if(ndrIT!=ndr.end())
					//		{
					//			for(int y=0;y<Yplaces;++y)
					//			{
					//				_3d.curve_start();
					//				for(int x=0;x<Xplaces;++x, ++ndrIT)
					//					_3d.curve_point(Xstart+x*Xsample, Ystart+y*Ysample, f[LOL_k]());
					//			}
					//			for(int x=0;x<Xplaces;++x)
					//			{
					//				ndrIT=ndr.begin()+x;
					//				_3d.curve_start();
					//				for(int y=0;y<Yplaces;)
					//				{
					//					_3d.curve_point(Xstart+x*Xsample, Ystart+y*Ysample, f[LOL_k]());
					//					if(++y>=Yplaces)
					//						break;
					//					ndrIT+=Xplaces;
					//				}
					//			}
					//		}
					//	}
					//}
				}
				else
				{
					unsigned yDiscOffset=(Xplaces-1)*Yplaces;
				//	auto &Xdisc=solver.Xdiscs[cursorEx], &Ydisc=solver.Ydiscs[cursorEx];
					for(unsigned c=0;c<4;++c)
					{
						_3d.lineColor=lColor[c];
						for(int y=0;y<Yplaces;++y)
						{
							_3d.curve_start();
							for(int x=0;x<Xplaces-1;++x)
							{
								_3d.curve_point(Xstart+x*Xsample, Ystart+y*Ysample, AR_Z*(&ndr[Xplaces*y+x].r)[c]);
								if(ex.discontinuities[(Xplaces-1)*y+x])
									_3d.curve_start();
							}
							_3d.curve_point(Xstart+(Xplaces-1)*Xsample, Ystart+y*Ysample, AR_Z*(&ndr[Xplaces*y+(Xplaces-1)].r)[c]);
						}
						for(int x=0;x<Xplaces;++x)
						{
							_3d.curve_start();
							for(int y=0;y<Yplaces-1;++y)
							{
								_3d.curve_point(Xstart+x*Xsample, Ystart+y*Ysample, AR_Z*(&ndr[Xplaces*y+x].r)[c]);
								if(ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y])
									_3d.curve_start();
							}
							_3d.curve_point(Xstart+x*Xsample, Ystart+(Yplaces-1)*Ysample, AR_Z*(&ndr[Xplaces*(Yplaces-1)+x].r)[c]);
						}
					}
				}
				_3d.lineColor=0;
			}
			if(contourOn)//draw the contour
			{
				double Xstart=VX-DX/2;
				double Ystart=VY-DY/2;
				double Zstart=VZ-DX/2, Zend=VZ+DX/2;
				_3d.lineColor=rColor;
				for(auto &L:Rcontours[cursorEx])
				{
					double Z=contourFlat?VZ:L.first*Zstep;
					for(auto &p:L.second)
						_3d.line(p.first.x, p.first.y, AR_Z*Z, p.second.x, p.second.y, AR_Z*Z);
				}
				_3d.lineColor=iColor;
				for(auto &L:Icontours[cursorEx])
				{
					double Z=contourFlat?VZ:L.first*Zstep;
					for(auto &p:L.second)
						_3d.line(p.first.x, p.first.y, AR_Z*Z, p.second.x, p.second.y, AR_Z*Z);
				}
				_3d.lineColor=jColor;
				for(auto &L:Jcontours[cursorEx])
				{
					double Z=contourFlat?VZ:L.first*Zstep;
					for(auto &p:L.second)
						_3d.line(p.first.x, p.first.y, AR_Z*Z, p.second.x, p.second.y, AR_Z*Z);
				}
				_3d.lineColor=kColor;
				for(auto &L:Kcontours[cursorEx])
				{
					double Z=contourFlat?VZ:L.first*Zstep;
					for(auto &p:L.second)
						_3d.line(p.first.x, p.first.y, AR_Z*Z, p.second.x, p.second.y, AR_Z*Z);
				}
			}
			if(!clearScreen)
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, TRANSPARENT);
				for(double X=floor((VX-DX/2)/Xstep)*Xstep+Xstep, Xend=ceil((VX+DX/2)/Xstep)*Xstep;X<Xend;X+=Xstep)
					if(abs(X)>Xstep/2)
						_3d.label(X, VY, VZ, "%g", X);
				if(AR_Y==1)
				{
					for(double Y=floor((VY-DX/2)/Ystep)*Ystep+Ystep, Yend=ceil((VY+DX/2)/Ystep)*Ystep;Y<Yend;Y+=Ystep)
						if(Y<-Ystep/2||Y>Ystep/2)
							_3d.label(VX, Y, VZ, "%g", Y);
				}
				else
				{
					double aYstep=AR_Y*Ystep, Ycore=floor((VY-DX/2)/aYstep);
					for(double Y=Ycore*aYstep+aYstep, Yend=ceil((VY+DX/2)/aYstep)*aYstep, aY=Ycore*Ystep+Ystep;Y<Yend;Y+=aYstep, aY+=Ystep)
						if(Y<-aYstep/2||Y>aYstep/2)
							_3d.label(VX, Y, VZ, "%g", aY);
				}
				if(AR_Z==1)
				{
					for(double Z=floor((VZ-DX/2)/Zstep)*Zstep+Zstep, Zend=ceil((VZ+DX/2)/Zstep)*Zstep;Z<Zend;Z+=Zstep)
						if(Z<-Zstep/2||Z>Zstep/2)
							_3d.label(VX, VY, Z, "%g", Z);
				}
				else
				{
					double aZstep=AR_Z*Zstep, Zcore=floor((VZ-DX/2)/aZstep);
					for(double Z=Zcore*aZstep+aZstep, Zend=ceil((VZ+DX/2)/aZstep)*aZstep, aZ=Zcore*Zstep+Zstep;Z<Zend;Z+=aZstep, aZ+=Zstep)
						if(Z<-aZstep/2||Z>aZstep/2)
							_3d.label(VX, VY, Z, "%g", aZ);
				}
			/*	for(double x=floor((Xstart)/step)*step+step;x<ceil((VX+DX/2)/step)*step;x+=step)
					if(abs(x)>step/2)
						_3d.label(x, VY, VZ, "%g", x);
				for(double y=floor((VY-DX/2)/step)*step+step;y<ceil((VY+DX/2)/step)*step;y+=step)
					if(abs(y)>step/2)
						_3d.label(VX, y, VZ, "%g", y);
				for(double z=floor((VZ-DX/2)/step)*step+step;z<ceil((VZ+DX/2)/step)*step;z+=step)
					if(abs(z)>step/2)
						_3d.label(VX, VY, z, "%g", z);//*/
				_3d.arrowLabels(0, 0, 0, 1, 0, 0, labels.Xlabels);
				_3d.arrowLabels(0, 0, 0, 0, 1, 0, labels.Ylabels);
				char const *const OpLabels[]={"R()", "I()", "J()", "K()"};
				int const OpLabelColors[]={rColor, kColor, jColor, iColor};//bgr in windows API
				_3d.arrowLabelsColor(0, 0, 0, 0, 0, 1, OpLabels, OpLabelColors, sizeof(OpLabels)/sizeof(OpLabels[0]));
				{
					int Ys=0;
					for(auto &label:labels.Clabels)
					{
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					//	linelen=sprintf_s(line, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, line, linelen), Ys+=16;
					}
				}
				SetBkMode(ghMemDC, bkMode);
				_3d.text_show();
			}
				if(kb_VK_F6_msg||kb[VK_F6])
				{
					int kb_mode=SetBkMode(ghMemDC, OPAQUE);
					kb_VK_F6_msg=false;
					if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
						GUIPrint(ghMemDC, 0, h-18*3, "move cam: [-] scale, [-] shift, [-] zoom");
					else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
						GUIPrint(ghMemDC, 0, h-18*3, "move cam: [v] scale, [-] shift, [-] zoom");
					else if(!_3d_zoom_move_cam)
						GUIPrint(ghMemDC, 0, h-18*3, "move cam: [v] scale, [v] shift, [-] zoom");
					else
						GUIPrint(ghMemDC, 0, h-18*3, "move cam: [v] scale, [v] shift, [v] zoom");
					SetBkMode(ghMemDC, kb_mode);
				}
		}
		void i_draw();
		void a_draw();
	} t2d_h;
	void			Transverse_2D_H::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				std::copy(rgb, rgb+w*h, modeRGB);

			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, OPAQUE);
				itb.draw();
				SetBkMode(ghMemDC, bkMode);
			}
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			Performance(0, h-32);//
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		}
		else
		{
			std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Transverse_2D_H::a_draw()
	{
		Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(!clearScreen)
			Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
#if 0
	class		Implicit_3D:public Mode
	{
	public:
	//	int toSolve;
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		int Xoffset, Yoffset, Zoffset;
		int bpx, bpy, bh, bw, X0, Y0;

		int Xplaces, Yplaces, Zplaces;
		double XshiftPoint, YshiftPoint, ZshiftPoint;
		double XsamplePos, YsamplePos, ZsamplePos;
	//	int KXplaces, KYplaces, KZplaces;

		double VX, VY, VZ, DX, AR_Y, AR_Z, Xstep, Ystep, Zstep;
		int prec;
		Solve_3D solver;
		std::list<int> operations;

		bool contourOn, contourOnly, contourFlat;
		std::map<unsigned, std::unordered_map<int, std::list<_3D::Triangle>>>
			Rcontours,//contours[e]=contour, contour[r level (r/step)]=triangles, *triangles.begin()=triangle
			Icontours,//contours[e]=contour, contour[i level (i/step)]=triangles, *triangles.begin()=triangle
			Jcontours,//contours[e]=contour, contour[j level (j/step)]=triangles, *triangles.begin()=triangle
			Kcontours;//contours[e]=contour, contour[k level (k/step)]=triangles, *triangles.begin()=triangle
		std::map<unsigned, std::unordered_map<int, std::list<_3D::Stick>>>
			Rlines,//contours[e]=contour, contour[r level (r/step)]=sticks, *sticks.begin()=stick
			Ilines,//contours[e]=contour, contour[i level (i/step)]=sticks, *sticks.begin()=stick
			Jlines,//contours[e]=contour, contour[j level (j/step)]=sticks, *sticks.begin()=stick
			Klines;//contours[e]=contour, contour[k level (k/step)]=sticks, *sticks.begin()=stick
		
		bool clearScreen;
		Labels_3D labels;
		static const int rColor=0, iColor=0x00EF0000, jColor=0x0000EF00, kColor=0x000000EF;
		_3D _3d;
		int gridColor;
		
	//	char line[128];
	//	int linelen;
		bool timer, drag, m_bypass, shift;
		int kp;

		Implicit_3D():
			VX(0), VY(0), VZ(0), DX(20), AR_Y(1), AR_Z(1),
			Xplaces(10), Yplaces(10), Zplaces(10),
			XshiftPoint(0), YshiftPoint(0), ZshiftPoint(0),
			XsamplePos(0), YsamplePos(0), ZsamplePos(0),
		//	KXplaces(Xplaces/100?Xplaces/100:1), KYplaces(Yplaces/100?Yplaces/100:1), KZplaces(Zplaces/100?Zplaces/100:1),
			_3d(20, 20, 20, 225*G2::_pi/180, 324.7356103172454*G2::_pi/180, 1),
			gridColor(_3dGridColor),
			timer(false), drag(false), m_bypass(false), shift(false), kp(0),
			shiftOnly(2), Xoffset(0), Yoffset(0),
		//	toSolve(1), shiftOnly(2), Xoffset(0), Yoffset(0),
			contourOn(false), contourOnly(false), contourFlat(false),
			clearScreen(false)
		{}

		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
				drag=1;
			}
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
		//	kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]+kb[VK_ADD]+kb[VK_OEM_PLUS]+kb[VK_SUBTRACT]+kb[VK_OEM_MINUS];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag||shift)
			{
				drag=0, shift=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag||shift)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		
		void draw_contour(std::map<unsigned, std::unordered_map<int, std::list<_3D::Triangle>>> &contours, std::map<unsigned, std::unordered_map<int, std::list<_3D::Stick>>> &lines, unsigned lineColor)
		{
			for(auto &L:contours[cursorEx])
			{
				double RL=10*L.first*Xstep;
				int color=colorFunction_r(RL);
				if(!color)
					color=0x00D0D0D0;
				for(auto &p:L.second)
					_3d.triangle_halfTransparent(p, color);
			}
			_3d.lineColor=lineColor;
		/*	for(auto &L:contours[cursorEx])//contour mesh
			{
				for(auto &p:L.second)
				{
					_3d.line(p.X1, p.Y1, p.Z1, p.X2, p.Y2, p.Z2);
					_3d.line(p.X2, p.Y2, p.Z2, p.X3, p.Y3, p.Z3);
					_3d.line(p.X3, p.Y3, p.Z3, p.X1, p.Y1, p.Z1);
				}
			}//*/
			for(auto &Vlevel:lines[cursorEx])
				for(auto &s:Vlevel.second)
					_3d.line(s.X1, s.Y1, s.Z1, s.X2, s.Y2, s.Z2);
		}
		void draw_contourGrid(double Xs)
		{
			unsigned e=cursorEx, c=0;
			using namespace contour;
			auto &ndr=expr[e].n[0].ndr;
			_3d.lineColor=0x00D0D0D0;

			double X0, X1, Y0, Y1, Z0, Z1, V000, V001, V010, V011, V100, V101, V110, V111;
			auto interpolate=[&](double Xa, double Ya, double Za)
			{
				double dX0=Xa-X0, dX1=X1-Xa, dY0=(Ya-Y0), dY1=(Y1-Ya);
				return
					(	(Z1-Za)*	(	dY1*	(	dX1*V000+
													dX0*V001	)+
										dY0*	(	dX1*V010+
													dX0*V011	))+
						(Za-Z0)*	(	dY1*	(	dX1*V100+
													dX0*V101	)+
										dY0*	(	dX1*V110+
													dX0*V111	))
					)/(Z1-Z0)/(Y1-Y0)/(X1-X0);
			};

			auto cutTrap=[&](Double_X_Y_Z_V &A, Double_X_Y_Z_V &B, Double_X_Y_Z_V &C, Double_X_Y_Z_V &D)
			{
				_3d.line(A.X, A.Y, A.Z, B.X, B.Y, B.Z);
				_3d.line(B.X, B.Y, B.Z, C.X, C.Y, C.Z);
				_3d.line(C.X, C.Y, C.Z, D.X, D.Y, D.Z);
				_3d.line(D.X, D.Y, D.Z, A.X, A.Y, A.Z);
			};
			auto print=[&](Double_X_Y_Z_V &P){_3d.textIn3D(P.X, P.Y, P.Z, OPAQUE, "%g", P.V);};
			for(unsigned vz=0, vzEnd=Zplaces-1;vz<vzEnd;++vz)
			{
				for(unsigned vy=0, vyEnd=Yplaces-1;vy<vyEnd;++vy)
				{
					for(unsigned vx=0, vxEnd=Xplaces-1;vx<vxEnd;++vx)
					{
						X0=solver.Xstart+Xs*vx, X1=solver.Xstart+Xs*(vx+1);
						Y0=solver.Ystart+Xs*vy, Y1=solver.Ystart+Xs*(vy+1);
						Z0=solver.Zstart+Xs*vz, Z1=solver.Zstart+Xs*(vz+1);
						double Xm=solver.Xstart+Xs*(vx+.5), Ym=solver.Ystart+Xs*(vy+.5), Zm=solver.Zstart+Xs*(vz+.5);
							
						Double_X_Y_Z_V
							P000(X0, Y0, Z0, V000=(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]),
							P001(X1, Y0, Z0, V001=(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx+1].r)[c]),
							P010(X0, Y1, Z0, V010=(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ].r)[c]),
							P011(X1, Y1, Z0, V011=(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx+1].r)[c]),
							P100(X0, Y0, Z1, V100=(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ].r)[c]),
							P101(X1, Y0, Z1, V101=(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx+1].r)[c]),
							P110(X0, Y1, Z1, V110=(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx  ].r)[c]),
							P111(X1, Y1, Z1, V111=(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx+1].r)[c]),

							P00m(Xm, Y0, Z0, interpolate(Xm, Y0, Z0)),
							P01m(Xm, Y1, Z0, interpolate(Xm, Y1, Z0)),
							P10m(Xm, Y0, Z1, interpolate(Xm, Y0, Z1)),
							P11m(Xm, Y1, Z1, interpolate(Xm, Y1, Z1)),

							P0m0(X0, Ym, Z0, interpolate(X0, Ym, Z0)),
							P0m1(X1, Ym, Z0, interpolate(X1, Ym, Z0)),
							P1m0(X0, Ym, Z1, interpolate(X0, Ym, Z1)),
							P1m1(X1, Ym, Z1, interpolate(X1, Ym, Z1)),

							Pm00(X0, Y0, Zm, interpolate(X0, Y0, Zm)),
							Pm01(X1, Y0, Zm, interpolate(X1, Y0, Zm)),
							Pm10(X0, Y1, Zm, interpolate(X0, Y1, Zm)),
							Pm11(X1, Y1, Zm, interpolate(X1, Y1, Zm)),

							P0mm(Xm, Ym, Z0, interpolate(Xm, Ym, Z0)),
							P1mm(Xm, Ym, Z1, interpolate(Xm, Ym, Z1)),

							Pm0m(Xm, Y0, Zm, interpolate(Xm, Y0, Zm)),
							Pm1m(Xm, Y1, Zm, interpolate(Xm, Y1, Zm)),

							Pmm0(X0, Ym, Zm, interpolate(X0, Ym, Zm)),
							Pmm1(X1, Ym, Zm, interpolate(X1, Ym, Zm)),

							Pmmm(Xm, Ym, Zm, interpolate(Xm, Ym, Zm));
						
						print(P00m), print(P01m), print(P10m), print(P11m);
						print(P0m0), print(P0m1), print(P1m0), print(P1m1);
						print(Pm00), print(Pm01), print(Pm10), print(Pm11);
						print(P0mm), print(P1mm);
						print(Pm0m), print(Pm1m);
						print(Pmm0), print(Pmm1);
						print(Pmmm);
						
						cutTrap(Pm00, Pm0m, P000, Pmmm);
						cutTrap(Pm0m, P00m, P000, Pmmm);
						cutTrap(P00m, P0mm, P000, Pmmm);
						cutTrap(P0mm, P0m0, P000, Pmmm);
						cutTrap(P0m0, Pmm0, P000, Pmmm);
						cutTrap(Pmm0, Pm00, P000, Pmmm);
						
						cutTrap(Pm01, Pm0m, P001, Pmmm);
						cutTrap(Pm0m, P00m, P001, Pmmm);
						cutTrap(P00m, P0mm, P001, Pmmm);
						cutTrap(P0mm, P0m1, P001, Pmmm);
						cutTrap(P0m1, Pmm1, P001, Pmmm);
						cutTrap(Pmm1, Pm01, P001, Pmmm);
						
						cutTrap(Pm10, Pm1m, P010, Pmmm);
						cutTrap(Pm1m, P01m, P010, Pmmm);
						cutTrap(P01m, P0mm, P010, Pmmm);
						cutTrap(P0mm, P0m0, P010, Pmmm);
						cutTrap(P0m0, Pmm0, P010, Pmmm);
						cutTrap(Pmm0, Pm10, P010, Pmmm);
						
						cutTrap(Pm11, Pm1m, P011, Pmmm);
						cutTrap(Pm1m, P01m, P011, Pmmm);
						cutTrap(P01m, P0mm, P011, Pmmm);
						cutTrap(P0mm, P0m1, P011, Pmmm);
						cutTrap(P0m1, Pmm1, P011, Pmmm);
						cutTrap(Pmm1, Pm11, P011, Pmmm);
						
						cutTrap(Pm00, Pm0m, P100, Pmmm);
						cutTrap(Pm0m, P10m, P100, Pmmm);
						cutTrap(P10m, P1mm, P100, Pmmm);
						cutTrap(P1mm, P1m0, P100, Pmmm);
						cutTrap(P1m0, Pmm0, P100, Pmmm);
						cutTrap(Pmm0, Pm00, P100, Pmmm);
						
						cutTrap(Pm01, Pm0m, P101, Pmmm);
						cutTrap(Pm0m, P10m, P101, Pmmm);
						cutTrap(P10m, P1mm, P101, Pmmm);
						cutTrap(P1mm, P1m1, P101, Pmmm);
						cutTrap(P1m1, Pmm1, P101, Pmmm);
						cutTrap(Pmm1, Pm01, P101, Pmmm);
						
						cutTrap(Pm10, Pm1m, P110, Pmmm);
						cutTrap(Pm1m, P11m, P110, Pmmm);
						cutTrap(P11m, P1mm, P110, Pmmm);
						cutTrap(P1mm, P1m0, P110, Pmmm);
						cutTrap(P1m0, Pmm0, P110, Pmmm);
						cutTrap(Pmm0, Pm10, P110, Pmmm);
						
						cutTrap(Pm11, Pm1m, P111, Pmmm);
						cutTrap(Pm1m, P11m, P111, Pmmm);
						cutTrap(P11m, P1mm, P111, Pmmm);
						cutTrap(P1mm, P1m1, P111, Pmmm);
						cutTrap(P1m1, Pmm1, P111, Pmmm);
						cutTrap(Pmm1, Pm11, P111, Pmmm);
					}
				}
			}
		}
		void doContour_component(unsigned e, unsigned c, double Xs, double Vstart, double Vend, double Vstep, unsigned nvSteps)//cursorEx, comp, DX/Xplaces, -DX/2, +DX/2, Xstep, 2
		{
			using namespace contour;
			auto &ndr=expr[e].n[0].ndr;
			decltype(&Rcontours[e]) contour=0;
			switch(c)
			{
			case 0:contour=&Rcontours[e];break;
			case 1:contour=&Icontours[e];break;
			case 2:contour=&Jcontours[e];break;
			case 3:contour=&Kcontours[e];break;
			}
			double X0, X1, Y0, Y1, Z0, Z1, V000, V001, V010, V011, V100, V101, V110, V111;
			auto getPos=[&](double &t, double Vx, Double_X_Y_Z_V &A, Double_X_Y_Z_V &B)
			{
				double
					Xd=B.X-A.X, X1a=X1-A.X, Xa0=A.X-X0,
					Yd=B.Y-A.Y, Y1a=Y1-A.Y, Ya0=A.Y-Y0,
					Zd=B.Z-A.Z, Z1a=Z1-A.Z, Za0=A.Z-Z0,
					
					A00=(V001-V000)*Xd, B00=X1a*V000+Xa0*V001,
					A01=(V011-V010)*Xd, B01=X1a*V010+Xa0*V011,
					A10=(V101-V100)*Xd, B10=X1a*V100+Xa0*V101,
					A11=(V111-V110)*Xd, B11=X1a*V110+Xa0*V111,
					
					C0=(A01-A00)*Yd, D0=(B01-B00)*Yd+Y1a*A00+Ya0*A01, E0=Y1a*B00+Ya0*B01,
					C1=(A11-A10)*Yd, D1=(B11-B10)*Yd+Y1a*A10+Ya0*A11, E1=Y1a*B10+Ya0*B11,
					
					a=(C1-C0)*Zd, b=(D1-D0)*Zd+Z1a*C0+Za0*C1, c=(E1-E0)*Zd+Z1a*D0+Za0*D1, d=Z1a*E0+Za0*E1-(X1-X0)*(Y1-Y0)*(Z1-Z0)*Vx;

			//	if(A.Z==Z0&&B.Z==Z0)
			//		int LOL_1=0;
				if(a==0&&b==0&&c==0)
				{
					t=(Vx-A.V)/(B.V-A.V);
					return true;
				}
				double r1;
				std::complex<double> r2, r3;
				solve_cubic(a, b, c, d, r1, r2, r3);
				if(r1>=0&&r1<=1)
				{
					t=r1;
					return true;
				}
				if(r2.real()>=0&&r2.real()<=1)//what
				{
					t=r2.real();
					return true;
				}
				if(r3.real()>=0&&r3.real()<=1)
				{
					t=r3.real();
					return true;
				}
				if(r1>=-1e-5&&r1<=1+1e-5)
				{
					t=r1;
					return true;
				}
				if(r2.real()>=-1e-5&&r2.real()<=1+1e-5)//what
				{
					t=r2.real();
					return true;
				}
				if(r3.real()>=-1e-5&&r3.real()<=1+1e-5)
				{
					t=r3.real();
					return true;
				}
				if(r1>=-1e-1&&r1<=1+1e-1)
				{
					t=r1;
					return true;
				}
				if(r2.real()>=-1e-1&&r2.real()<=1+1e-1)//what
				{
					t=r2.real();
					return true;
				}
				if(r3.real()>=-1e-1&&r3.real()<=1+1e-1)
				{
					t=r3.real();
					return true;
				}
				return false;
			};
			auto cutTrap=[&](Double_X_Y_Z_V &A, Double_X_Y_Z_V &B, Double_X_Y_Z_V &C, Double_X_Y_Z_V &D)
			{
				Double_X_Y_Z_V *_1, *_2, *_3, *_4;//sorted by V in ascending order
				if(A.V<B.V)//ab
				{
					if(B.V<C.V)//abc
					{
							 if(C.V<D.V)	_1=&A, _2=&B, _3=&C, _4=&D;
						else if(B.V<D.V)	_1=&A, _2=&B, _3=&D, _4=&C;
						else if(A.V<D.V)	_1=&A, _2=&D, _3=&B, _4=&C;
						else				_1=&D, _2=&A, _3=&B, _4=&C;
					}
					else if(A.V<C.V)//acb
					{
							 if(B.V<D.V)	_1=&A, _2=&C, _3=&B, _4=&D;
						else if(C.V<D.V)	_1=&A, _2=&C, _3=&D, _4=&B;
						else if(A.V<D.V)	_1=&A, _2=&D, _3=&C, _4=&B;
						else				_1=&D, _2=&A, _3=&C, _4=&B;
					}
					else//cab
					{
							 if(B.V<D.V)	_1=&C, _2=&A, _3=&B, _4=&D;
						else if(A.V<D.V)	_1=&C, _2=&A, _3=&D, _4=&B;
						else if(C.V<D.V)	_1=&C, _2=&D, _3=&A, _4=&B;
						else				_1=&D, _2=&C, _3=&A, _4=&B;
					}
				}
				else//ba
				{
					if(A.V<C.V)//bac
					{
							 if(C.V<D.V)	_1=&B, _2=&A, _3=&C, _4=&D;
						else if(A.V<D.V)	_1=&B, _2=&A, _3=&D, _4=&C;
						else if(B.V<D.V)	_1=&B, _2=&D, _3=&A, _4=&C;
						else				_1=&D, _2=&B, _3=&A, _4=&C;
					}
					else if(B.V<C.V)//bca
					{
							 if(A.V<D.V)	_1=&B, _2=&C, _3=&A, _4=&D;
						else if(C.V<D.V)	_1=&B, _2=&C, _3=&D, _4=&A;
						else if(B.V<D.V)	_1=&B, _2=&D, _3=&C, _4=&A;
						else				_1=&D, _2=&B, _3=&C, _4=&A;
					}
					else//cba
					{
							 if(A.V<D.V)	_1=&C, _2=&B, _3=&A, _4=&D;
						else if(B.V<D.V)	_1=&C, _2=&B, _3=&D, _4=&A;
						else if(C.V<D.V)	_1=&C, _2=&D, _3=&B, _4=&A;
						else				_1=&D, _2=&C, _3=&B, _4=&A;
					}
				}
				for(double v=std::floor((_1->V<Vstart?Vstart:_1->V)/Vstep), vEnd=std::floor((_2->V>Vend?Vend:_2->V)/Vstep);v<=vEnd;++v)
				{
					double VL=Vstep*v;
					if(_1->V<=VL&&VL<_2->V)
					{
						double M12, M13, M14;
						if(getPos(M12, VL, *_1, *_2)&&getPos(M13, VL, *_1, *_3)&&getPos(M14, VL, *_1, *_4))
						{
							contour->operator[](int(v)).push_back(_3D::Triangle(
								_1->X+M12*(_2->X-_1->X), _1->Y+M12*(_2->Y-_1->Y), _1->Z+M12*(_2->Z-_1->Z),
								_1->X+M13*(_3->X-_1->X), _1->Y+M13*(_3->Y-_1->Y), _1->Z+M13*(_3->Z-_1->Z),
								_1->X+M14*(_4->X-_1->X), _1->Y+M14*(_4->Y-_1->Y), _1->Z+M14*(_4->Z-_1->Z)
								));
						}
					}
				}
				for(double v=std::floor((_2->V<Vstart?Vstart:_2->V)/Vstep), vEnd=std::floor((_3->V>Vend?Vend:_3->V)/Vstep);v<=vEnd;++v)
				{
					double VL=Vstep*v;
					if(_2->V<=VL&&VL<_3->V)
					{
						double M13, M23, M24, M14;
						if(getPos(M13, VL, *_1, *_3)&&getPos(M23, VL, *_2, *_3)&&getPos(M24, VL, *_2, *_4)&&getPos(M14, VL, *_1, *_4))
						{
							double
								X13=_1->X+M13*(_3->X-_1->X), Y13=_1->Y+M13*(_3->Y-_1->Y), Z13=_1->Z+M13*(_3->Z-_1->Z),
								X23=_2->X+M23*(_3->X-_2->X), Y23=_2->Y+M23*(_3->Y-_2->Y), Z23=_2->Z+M23*(_3->Z-_2->Z),
								X24=_2->X+M24*(_4->X-_2->X), Y24=_2->Y+M24*(_4->Y-_2->Y), Z24=_2->Z+M24*(_4->Z-_2->Z),
								X14=_1->X+M14*(_4->X-_1->X), Y14=_1->Y+M14*(_4->Y-_1->Y), Z14=_1->Z+M14*(_4->Z-_1->Z);
							contour->operator[](int(v)).push_back(_3D::Triangle(X13, Y13, Z13, X23, Y23, Z23, X24, Y24, Z24));
							contour->operator[](int(v)).push_back(_3D::Triangle(X13, Y13, Z13, X14, Y14, Z14, X24, Y24, Z24));
						}
					}
				}
				for(double v=std::floor((_3->V<Vstart?Vstart:_3->V)/Vstep), vEnd=std::floor((_4->V>Vend?Vend:_4->V)/Vstep);v<=vEnd;++v)
				{
					double VL=Vstep*v;
					if(_3->V<=VL&&VL<_4->V)
					{
						double M14, M24, M34;
						if(getPos(M14, VL, *_1, *_4)&&getPos(M24, VL, *_2, *_4)&&getPos(M34, VL, *_3, *_4))
						{
							contour->operator[](int(v)).push_back(_3D::Triangle(
								_1->X+M14*(_4->X-_1->X), _1->Y+M14*(_4->Y-_1->Y), _1->Z+M14*(_4->Z-_1->Z),
								_2->X+M24*(_4->X-_2->X), _2->Y+M24*(_4->Y-_2->Y), _2->Z+M24*(_4->Z-_2->Z),
								_3->X+M34*(_4->X-_3->X), _3->Y+M34*(_4->Y-_3->Y), _3->Z+M34*(_4->Z-_3->Z)
								));
						}
					}
				}
			};
			double dispYstart=AR_Y*solver.Ystart, dispZstart=AR_Z*solver.Zstart;
			for(unsigned vz=0, vzEnd=Zplaces-1;vz<vzEnd;++vz)
			{
				for(unsigned vy=0, vyEnd=Yplaces-1;vy<vyEnd;++vy)
				{
					for(unsigned vx=0, vxEnd=Xplaces-1;vx<vxEnd;++vx)
					{
						X0=solver.Xstart+Xs*vx, X1=solver.Xstart+Xs*(vx+1);
						Y0=   dispYstart+Xs*vy, Y1=   dispYstart+Xs*(vy+1);
						Z0=   dispZstart+Xs*vz, Z1=   dispZstart+Xs*(vz+1);
						double Xm=solver.Xstart+Xs*(vx+.5), Ym=dispYstart+Xs*(vy+.5), Zm=dispZstart+Xs*(vz+.5);		//display env units		faster

					//	X0=solver.Xstart+Xs*vx, X1=solver.Xstart+Xs*(vx+1);
					//	Y0=AR_Y*solver.Ystart+Xs*vy, Y1=AR_Y*solver.Ystart+Xs*(vy+1);
					//	Z0=AR_Z*solver.Zstart+Xs*vz, Z1=AR_Z*solver.Zstart+Xs*(vz+1);
					//	double Xm=solver.Xstart+Xs*(vx+.5), Ym=AR_Y*solver.Ystart+Xs*(vy+.5), Zm=AR_Z*solver.Zstart+Xs*(vz+.5);		//display env units		faster

					//	X0=solver.Xstart+Xs*vx, X1=solver.Xstart+Xs*(vx+1);
					//	Y0=solver.Ystart+Xs/AR_Y*vy, Y1=solver.Ystart+Xs/AR_Y*(vy+1);
					//	Z0=solver.Zstart+Xs/AR_Z*vz, Z1=solver.Zstart+Xs/AR_Z*(vz+1);
					//	double Xm=solver.Xstart+Xs*(vx+.5), Ym=solver.Ystart+Xs/AR_Y*(vy+.5), Zm=solver.Zstart+Xs/AR_Z*(vz+.5);		//math env units		multiply by gain at draw
							
						Double_X_Y_Z_V//zyx matrix notation
							P000(X0, Y0, Z0, V000=(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]),
							P001(X1, Y0, Z0, V001=(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx+1].r)[c]),
							P010(X0, Y1, Z0, V010=(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ].r)[c]),
							P011(X1, Y1, Z0, V011=(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx+1].r)[c]),
							P100(X0, Y0, Z1, V100=(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ].r)[c]),
							P101(X1, Y0, Z1, V101=(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx+1].r)[c]),
							P110(X0, Y1, Z1, V110=(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx  ].r)[c]),
							P111(X1, Y1, Z1, V111=(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx+1].r)[c]),
							
							P00m(Xm, Y0, Z0, .5*(V000+V001)),
							P01m(Xm, Y1, Z0, .5*(V010+V011)),
							P10m(Xm, Y0, Z1, .5*(V100+V101)),
							P11m(Xm, Y1, Z1, .5*(V110+V111)),

							P0m0(X0, Ym, Z0, .5*(V000+V010)),
							P0m1(X1, Ym, Z0, .5*(V001+V011)),
							P1m0(X0, Ym, Z1, .5*(V100+V110)),
							P1m1(X1, Ym, Z1, .5*(V101+V111)),

							Pm00(X0, Y0, Zm, .5*(V000+V100)),
							Pm01(X1, Y0, Zm, .5*(V001+V101)),
							Pm10(X0, Y1, Zm, .5*(V010+V110)),
							Pm11(X1, Y1, Zm, .5*(V011+V111)),

							P0mm(Xm, Ym, Z0, .25*(V000+V001+V010+V011)),
							P1mm(Xm, Ym, Z1, .25*(V100+V101+V110+V111)),

							Pm0m(Xm, Y0, Zm, .25*(V000+V001+V100+V101)),
							Pm1m(Xm, Y1, Zm, .25*(V010+V011+V110+V111)),

							Pmm0(X0, Ym, Zm, .25*(V000+V010+V100+V110)),
							Pmm1(X1, Ym, Zm, .25*(V001+V011+V101+V111)),

							Pmmm(Xm, Ym, Zm, .125*(V000+V001+V010+V011+V100+V101+V110+V111));

						cutTrap(Pm00, Pm0m, P000, Pmmm);
						cutTrap(Pm0m, P00m, P000, Pmmm);
						cutTrap(P00m, P0mm, P000, Pmmm);
						cutTrap(P0mm, P0m0, P000, Pmmm);
						cutTrap(P0m0, Pmm0, P000, Pmmm);
						cutTrap(Pmm0, Pm00, P000, Pmmm);
						
						cutTrap(Pm01, Pm0m, P001, Pmmm);
						cutTrap(Pm0m, P00m, P001, Pmmm);
						cutTrap(P00m, P0mm, P001, Pmmm);
						cutTrap(P0mm, P0m1, P001, Pmmm);
						cutTrap(P0m1, Pmm1, P001, Pmmm);
						cutTrap(Pmm1, Pm01, P001, Pmmm);
						
						cutTrap(Pm10, Pm1m, P010, Pmmm);
						cutTrap(Pm1m, P01m, P010, Pmmm);
						cutTrap(P01m, P0mm, P010, Pmmm);
						cutTrap(P0mm, P0m0, P010, Pmmm);
						cutTrap(P0m0, Pmm0, P010, Pmmm);
						cutTrap(Pmm0, Pm10, P010, Pmmm);
						
						cutTrap(Pm11, Pm1m, P011, Pmmm);
						cutTrap(Pm1m, P01m, P011, Pmmm);
						cutTrap(P01m, P0mm, P011, Pmmm);
						cutTrap(P0mm, P0m1, P011, Pmmm);
						cutTrap(P0m1, Pmm1, P011, Pmmm);
						cutTrap(Pmm1, Pm11, P011, Pmmm);
						
						cutTrap(Pm00, Pm0m, P100, Pmmm);
						cutTrap(Pm0m, P10m, P100, Pmmm);
						cutTrap(P10m, P1mm, P100, Pmmm);
						cutTrap(P1mm, P1m0, P100, Pmmm);
						cutTrap(P1m0, Pmm0, P100, Pmmm);
						cutTrap(Pmm0, Pm00, P100, Pmmm);
						
						cutTrap(Pm01, Pm0m, P101, Pmmm);
						cutTrap(Pm0m, P10m, P101, Pmmm);
						cutTrap(P10m, P1mm, P101, Pmmm);
						cutTrap(P1mm, P1m1, P101, Pmmm);
						cutTrap(P1m1, Pmm1, P101, Pmmm);
						cutTrap(Pmm1, Pm01, P101, Pmmm);
						
						cutTrap(Pm10, Pm1m, P110, Pmmm);
						cutTrap(Pm1m, P11m, P110, Pmmm);
						cutTrap(P11m, P1mm, P110, Pmmm);
						cutTrap(P1mm, P1m0, P110, Pmmm);
						cutTrap(P1m0, Pmm0, P110, Pmmm);
						cutTrap(Pmm0, Pm10, P110, Pmmm);
						
						cutTrap(Pm11, Pm1m, P111, Pmmm);
						cutTrap(Pm1m, P11m, P111, Pmmm);
						cutTrap(P11m, P1mm, P111, Pmmm);
						cutTrap(P1mm, P1m1, P111, Pmmm);
						cutTrap(P1m1, Pmm1, P111, Pmmm);
						cutTrap(Pmm1, Pm11, P111, Pmmm);
					}
				}
			}
			decltype(&Rlines[e]) lines=0;
			switch(e)
			{
			case 0:lines=&Rlines[e];break;
			case 1:lines=&Ilines[e];break;
			case 2:lines=&Jlines[e];break;
			case 3:lines=&Klines[e];break;
			}
			for(auto &level:*contour)
			{
				for(auto &T:level.second)
				{
					double *X1, *Y1, *V1, *X2, *Y2, *V2, *X3, *Y3, *V3;
					if(T.Z1<T.Z2)//12
					{
							 if(T.Z2<T.Z3)	X1=&T.X1, Y1=&T.Y1, V1=&T.Z1, X2=&T.X2, Y2=&T.Y2, V2=&T.Z2, X3=&T.X3, Y3=&T.Y3, V3=&T.Z3;
						else if(T.Z1<T.Z3)	X1=&T.X1, Y1=&T.Y1, V1=&T.Z1, X2=&T.X3, Y2=&T.Y3, V2=&T.Z3, X3=&T.X2, Y3=&T.Y2, V3=&T.Z2;
						else				X1=&T.X3, Y1=&T.Y3, V1=&T.Z3, X2=&T.X1, Y2=&T.Y1, V2=&T.Z1, X3=&T.X2, Y3=&T.Y2, V3=&T.Z2;
					}
					else//21
					{
							 if(T.Z1<T.Z3)	X1=&T.X2, Y1=&T.Y2, V1=&T.Z2, X2=&T.X1, Y2=&T.Y1, V2=&T.Z1, X3=&T.X3, Y3=&T.Y3, V3=&T.Z3;
						else if(T.Z2<T.Z3)	X1=&T.X2, Y1=&T.Y2, V1=&T.Z2, X2=&T.X3, Y2=&T.Y3, V2=&T.Z3, X3=&T.X1, Y3=&T.Y1, V3=&T.Z1;
						else				X1=&T.X3, Y1=&T.Y3, V1=&T.Z3, X2=&T.X2, Y2=&T.Y2, V2=&T.Z2, X3=&T.X1, Y3=&T.Y1, V3=&T.Z1;
					}
					double X13, Y13;
					{
						double Zr=(*V2-*V1)/(*V3-*V1);
						X13=*X1+Zr*(*X3-*X1), Y13=*Y1+Zr*(*Y3-*Y1);//V13=V2;
					}
					//for V1 -> V2
					for(double v=std::floor((*V1<Vstart?Vstart:*V1)/Vstep), zEnd=std::floor((*V2>Vend?Vend:*V2)/Vstep);v<=zEnd;++v)
					{
						double ZL=Vstep*v;
						if(*V1<=ZL&&ZL<*V2)
						{
							double M=(ZL-*V1)/(*V2-*V1);
							lines->operator[](level.first).push_back(_3D::Stick(*X1+M*(*X2-*X1), *Y1+M*(*Y2-*Y1), ZL, *X1+M*(X13-*X1), *Y1+M*(Y13-*Y1), ZL));
						}
					}
					//for V2 -> V3
					for(double v=std::floor((*V2<Vstart?Vstart:*V2)/Vstep), zEnd=std::floor((*V3>Vend?Vend:*V3)/Vstep);v<=zEnd;++v)
					{
						double ZL=Vstep*v;
						if(*V2<=ZL&&ZL<*V3)
						{
							double M=(ZL-*V2)/(*V3-*V2);
							lines->operator[](level.first).push_back(_3D::Stick(*X2+M*(*X3-*X2), *Y2+M*(*Y3-*Y2), ZL, X13+M*(*X3-X13), Y13+M*(*Y3-Y13), ZL));
						}
					}
				}
			}
		/*	double Zstart=VZ-DZ/2, Zend=VZ+DZ/2;
			for(auto &level:*contour)
			{
				for(auto &T:level.second)
				{
					double *X1, *Y1, *Z1, *X2, *Y2, *Z2, *X3, *Y3, *Z3;
					if(T.Z1<T.Z2)//12
					{
							 if(T.Z2<T.Z3)	X1=&T.X1, Y1=&T.Y1, Z1=&T.Z1, X2=&T.X2, Y2=&T.Y2, Z2=&T.Z2, X3=&T.X3, Y3=&T.Y3, Z3=&T.Z3;
						else if(T.Z1<T.Z3)	X1=&T.X1, Y1=&T.Y1, Z1=&T.Z1, X2=&T.X3, Y2=&T.Y3, Z2=&T.Z3, X3=&T.X2, Y3=&T.Y2, Z3=&T.Z2;
						else				X1=&T.X3, Y1=&T.Y3, Z1=&T.Z3, X2=&T.X1, Y2=&T.Y1, Z2=&T.Z1, X3=&T.X2, Y3=&T.Y2, Z3=&T.Z2;
					}
					else//21
					{
							 if(T.Z1<T.Z3)	X1=&T.X2, Y1=&T.Y2, Z1=&T.Z2, X2=&T.X1, Y2=&T.Y1, Z2=&T.Z1, X3=&T.X3, Y3=&T.Y3, Z3=&T.Z3;
						else if(T.Z2<T.Z3)	X1=&T.X2, Y1=&T.Y2, Z1=&T.Z2, X2=&T.X3, Y2=&T.Y3, Z2=&T.Z3, X3=&T.X1, Y3=&T.Y1, Z3=&T.Z1;
						else				X1=&T.X3, Y1=&T.Y3, Z1=&T.Z3, X2=&T.X2, Y2=&T.Y2, Z2=&T.Z2, X3=&T.X1, Y3=&T.Y1, Z3=&T.Z1;
					}
					double X13, Y13;
				//	{
						double Zr=(*Z2-*Z1)/(*Z3-*Z1);
						X13=*X1+Zr*(*X3-*X1), Y13=*Y1+Zr*(*Y3-*Y1);//Z13=Z2;
				//	}
					//for Z1 -> Z2
					for(double z=std::floor((*Z1<Zstart?Zstart:*Z1)/step), zEnd=std::floor((*Z2>Zend?Zend:*Z2)/step);z<=zEnd;++z)
					{
						double ZL=step*z;
					//	ZL=std::floor(Zstart/step)+11;//
						if(*Z1<=ZL&&ZL<*Z2)
						{
							double M=(ZL-*Z1)/(*Z2-*Z1);
							lines->operator[](level.first).push_back(_3D::Stick(*X1+M*(*X2-*X1), *Y1+M*(*Y2-*Y1), ZL, *X1+M*(X13-*X1), *Y1+M*(Y13-*Y1), ZL));
						//	if(std::abs(lines->operator[](level.first).rbegin()->X2-lines->operator[](level.first).rbegin()->X1)>5)
						//		int LOL_2=0;
						}
					//	break;//
					}
					//for V2 -> V3
					for(double z=std::floor((*Z2<Zstart?Zstart:*Z2)/step), zEnd=std::floor((*Z3>Zend?Zend:*Z3)/step);z<=zEnd;++z)
					{
						double ZL=step*z;
					//	ZL=std::floor(Zstart/step)+11;//
						if(*Z2<=ZL&&ZL<*Z3)
						{
							double M=(ZL-*Z2)/(*Z3-*Z2);
							lines->operator[](level.first).push_back(_3D::Stick(*X2+M*(*X3-*X2), *Y2+M*(*Y3-*Y2), ZL, X13+M*(*X3-X13), Y13+M*(*Y3-Y13), ZL));
						//	if(std::abs(lines->operator[](level.first).rbegin()->X2-lines->operator[](level.first).rbegin()->X1)>5)
						//		int LOL_2=0;
						}
					//	break;//
					}
				}
			}//*/
		/*	for(auto &level:*contour)
			{
				auto &lines_l=lines->operator[](level.first);
				for(auto &T:level.second)
				{
					double *X1, *Y1, *Z1, *X2, *Y2, *Z2, *X3, *Y3, *Z3;
					if(T.Z1<T.Z2)//12
					{
							 if(T.Z2<T.Z3)	X1=&T.X1, Y1=&T.Y1, Z1=&T.Z1, X2=&T.X2, Y2=&T.Y2, Z2=&T.Z2, X3=&T.X3, Y3=&T.Y3, Z3=&T.Z3;
						else if(T.Z1<T.Z3)	X1=&T.X1, Y1=&T.Y1, Z1=&T.Z1, X2=&T.X3, Y2=&T.Y3, Z2=&T.Z3, X3=&T.X2, Y3=&T.Y2, Z3=&T.Z2;
						else				X1=&T.X3, Y1=&T.Y3, Z1=&T.Z3, X2=&T.X1, Y2=&T.Y1, Z2=&T.Z1, X3=&T.X2, Y3=&T.Y2, Z3=&T.Z2;
					}
					else//21
					{
							 if(T.Z2<T.Z3)	X1=&T.X1, Y1=&T.Y1, Z1=&T.Z1, X2=&T.X2, Y2=&T.Y2, Z2=&T.Z2, X3=&T.X3, Y3=&T.Y3, Z3=&T.Z3;
						else if(T.Z1<T.Z3)	X1=&T.X1, Y1=&T.Y1, Z1=&T.Z1, X2=&T.X3, Y2=&T.Y3, Z2=&T.Z3, X3=&T.X2, Y3=&T.Y2, Z3=&T.Z2;
						else				X1=&T.X3, Y1=&T.Y3, Z1=&T.Z3, X2=&T.X1, Y2=&T.Y1, Z2=&T.Z1, X3=&T.X2, Y3=&T.Y2, Z3=&T.Z2;
					}
					double X13, Y13;
					{
						double Zr=(*Z2-*Z1)/(*Z3-*Z1);
						X13=*X1+Zr*(*X3-*X1), Y13=*Y1+Zr*(*Y3-*Y1);//Z13=Z2;
					}
					//for Z1 -> Z2
					for(double z=std::floor((*Z1<Vstart?Vstart:*Z1)/Vstep), zEnd=std::floor((*Z2>Vend?Vend:*Z2)/Vstep);z<=zEnd;++z)
					{
						double VL=Vstep*z;
						if(*Z1<=VL&&VL<*Z2)
						{
							double M=(VL-*Z1)/(*Z2-*Z1);
							lines_l[level.first].push_back(H_Stick(*X1+M*(*X2-*X1), *Y1+M*(*Y2-*Y1), *X1+M*(X13-*X1), *Y1+M*(Y13-*Y1)));
						}
					}
					//for V2 -> V3
					for(double z=std::floor((*Z2<Vstart?Vstart:*Z2)/Vstep), zEnd=std::floor((*Z3>Vend?Vend:*Z3)/Vstep);z<=zEnd;++z)
					{
						double VL=Vstep*z;
						if(*Z2<=VL&&VL<*Z3)
						{
							double M=(VL-*Z2)/(*Z3-*Z2);
							lines_l[level.first].push_back(H_Stick(*X2+M*(*X3-*X2), *Y2+M*(*Y3-*Y2), X13+M*(*X3-X13), Y13+M*(*Y3-Y13)));
						}
					}
				}
			}//*/
		}
		void doContour(unsigned e, double Xs, double Vstart, double Vend, double Vstep, unsigned nvSteps)
		{
			Vstep*=10;//
			switch(expr[e].resultMathSet)
		//	switch(expr[e].n[0].mathSet)
			{
			case 'r':
		//	case 'R':
				doContour_component(e, 0, Xs, Vstart, Vend, Vstep, nvSteps);
				break;
			case 'c':
		//	case 'C':
				doContour_component(e, 0, Xs, Vstart, Vend, Vstep, nvSteps);
				doContour_component(e, 1, Xs, Vstart, Vend, Vstep, nvSteps);
				break;
			case 'H':
				doContour_component(e, 0, Xs, Vstart, Vend, Vstep, nvSteps);
				doContour_component(e, 1, Xs, Vstart, Vend, Vstep, nvSteps);
				doContour_component(e, 2, Xs, Vstart, Vend, Vstep, nvSteps);
				doContour_component(e, 3, Xs, Vstart, Vend, Vstep, nvSteps);
				break;
			}
		}
		fftw_complex *fft_in, *fft_out;
		fftw_plan fft_p, ifft_p;
		unsigned fft_N0, fft_N1, fft_N2;
		double fft_sqrt_N;
		void discreteFourrierTransform			(std::vector<Value> &ndr)
		{
			int ndrSize=Xplaces*Yplaces*Zplaces;
			if(fft_N0!=Zplaces||fft_N1!=Yplaces||fft_N2!=Xplaces)
			{
				if(fft_N0||fft_N1||fft_N2)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_N0=Zplaces, fft_N1=Yplaces, fft_N2=Xplaces;
				fft_in=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt(ndrSize);
				fft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE);
				ifft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
			for(int k=0;k<ndrSize;++k)
			{
				unsigned x=k%Xplaces, y=k%Zplaces/Xplaces, z=k/Xplaces/Zplaces;
				int sign=1-((x%2^y%2^z%2)<<1);
				fft_in[k][0]=ndr[k].r*sign, fft_in[k][1]=ndr[k].i*sign;
			}
			fftw_execute(fft_p);
			for(int k=0;k<ndrSize;++k)
				ndr[k].r=fft_out[k][0]/fft_sqrt_N, ndr[k].i=fft_out[k][1]/fft_sqrt_N;
		}
		void inverseDiscreteFourrierTransform	(std::vector<Value> &ndr)
		{
			int ndrSize=Xplaces*Yplaces;
			if(fft_N0!=Zplaces||fft_N1!=Yplaces||fft_N2!=Xplaces)
			{
				if(fft_N0||fft_N1||fft_N2)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_N0=Zplaces, fft_N1=Yplaces, fft_N2=Xplaces;
				fft_in=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt(ndrSize);
				fft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE);
				ifft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
			for(int k=0;k<ndrSize;++k)
				fft_in[k][0]=ndr[k].r, fft_in[k][1]=ndr[k].i;
			fftw_execute(ifft_p);
			for(int k=0;k<ndrSize;++k)
			{
				unsigned x=k%Xplaces, y=k%Zplaces/Xplaces, z=k/Xplaces/Zplaces;
				double gain=(1-((x%2^y%2^z%2)<<1))/fft_sqrt_N;
				ndr[k].r=fft_out[k][0]*gain, ndr[k].i=fft_out[k][1]*gain;
			}
		}
		void lowPassFilter_xyz					(std::vector<Value> &ndr)
		{
			int nComponents=0;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			std::vector<Value> t_ndr(ndr.size());
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* 0   +0  )+0  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces* 0   +0  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0+1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0+1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+0+1].r)[c]
				)/27;
			for(int vx=1;vx<Xplaces-1;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +0  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0+1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+vx+1].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* 0   +0  )+Xplaces-1  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces* 0   +0  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0+1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+Xplaces-1  ].r)[c]
				)/27;
			for(int vy=1;vy<Yplaces-1;++vy)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +vy  )+0  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +vy-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy+1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+0+1].r)[c]
					)/27;
				for(int vx=1;vx<Xplaces-1;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* 0   +vy  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces* 0   +vy-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy+1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+vx+1].r)[c]
						)/27;
				}
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +vy  )+Xplaces-1  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +vy-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+Xplaces-1  ].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+0  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+0+1].r)[c]
				)/27;
			for(int vx=1;vx<Xplaces-1;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+vx+1].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+Xplaces-1  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1+1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1+1)+Xplaces-1  ].r)[c]
				)/27;
			for(int vz=1;vz<Zplaces-1;++vz)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* vz   +0  )+0  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0+1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+0+1].r)[c]
					)/27;
				for(int vx=1;vx<Xplaces-1;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +0  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0+1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+vx+1].r)[c]
						)/27;
				}
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* vz   +0  )+Xplaces-1  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+Xplaces-1  ].r)[c]
					)/27;
				for(int vy=1;vy<Yplaces-1;++vy)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +vy  )+0  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy-1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy-1)+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy  )+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy  )+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy+1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy+1)+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+0+1].r)[c]
						)/27;
					for(int vx=1;vx<Xplaces-1;++vx)
					{
						for(int c=0;c<nComponents;++c)
							(&t_ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]=
							(
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy-1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy-1)+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx+1].r)[c]
							)/27;
					}
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +vy  )+Xplaces-1  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy-1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy-1)+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy  )+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy  )+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy+1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy+1)+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+Xplaces-1  ].r)[c]
						)/27;
				}
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+0  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+0+1].r)[c]
					)/27;
				for(int vx=1;vx<Xplaces-1;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx+1].r)[c]
						)/27;
				}
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+Xplaces-1  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1+1)+Xplaces-1  ].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+0  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+0+1].r)[c]
				)/27;
			for(int vx=1;vx<Xplaces-1;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx+1].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+Xplaces-1  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+Xplaces-1  ].r)[c]
				)/27;
			for(int vy=1;vy<Yplaces-1;++vy)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+0  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+0+1].r)[c]
					)/27;
				for(int vx=1;vx<Xplaces-1;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+vx+1].r)[c]
						)/27;
				}
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+Xplaces-1  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+Xplaces-1  ].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0+1].r)[c]
				)/27;
			for(int vx=1;vx<Xplaces-1;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx+1].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+Xplaces-1  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1+1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1+1)+Xplaces-1  ].r)[c]
				)/27;
		}
		void lowPassFilter_x					(std::vector<Value> &ndr)
		{
			int nComponents=0;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			std::vector<Value> t_ndr(ndr.size());
			for(int vx=0;vx<Xplaces;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +0  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+vx  ].r)[c]
					)/27;
			}
			for(int vy=1;vy<Yplaces-1;++vy)
			{
				for(int vx=0;vx<Xplaces;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* 0   +vy  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces* 0   +vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+vx  ].r)[c]
						)/27;
				}
			}
			for(int vx=0;vx<Xplaces;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+vx  ].r)[c]
					)/27;
			}
			for(int vz=1;vz<Zplaces-1;++vz)
			{
				for(int vx=0;vx<Xplaces;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +0  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+vx  ].r)[c]
						)/27;
				}
				for(int vy=1;vy<Yplaces-1;++vy)
				{
					for(int vx=0;vx<Xplaces;++vx)
					{
						for(int c=0;c<nComponents;++c)
							(&t_ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]=
							(
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx  ].r)[c]
							)/27;
					}
				}
				for(int vx=0;vx<Xplaces;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx+1].r)[c]
						)/27;
				}
			}
			for(int vx=0;vx<Xplaces;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx+1].r)[c]
					)/27;
			}
			for(int vy=1;vy<Yplaces-1;++vy)
			{
				for(int vx=0;vx<Xplaces;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+vx  ].r)[c]
						)/27;
				}
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0+1].r)[c]
				)/27;
			for(int vx=0;vx<Xplaces;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx  ].r)[c]
					)/27;
			}
		}
		void lowPassFilter_y					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void lowPassFilter_z					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void lowPassFilter_xy					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void lowPassFilter_yz					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void lowPassFilter_xz					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_xyz					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_x					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_y					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_z					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_xy					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_yz					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_xz					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}

		void setDimentions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h, X0=bpx+bw/2, Y0=bpy+bh/2;
			_3d.setDimentions(x, y, w, h);
			double old_Xstep=Xstep;
			function1();
			if(!toSolve&&contourOn&&old_Xstep!=Xstep)
			{
				Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
				Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
				doContour(cursorEx, DX/Xplaces, -DX/2, +DX/2, Xstep, 2);
			}
			ready=true;
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimentions(x, y, w, h);
			if(!time_variance&&!timer)
				a_draw();
		}
		void shiftNDR(double &DshiftPoint, double &Dsample, double &DsamplePos, int &Doffset, double &VD, double ammount)
		{
			double newDsamplePos=std::floor((DshiftPoint+=ammount)/Dsample);
			if(newDsamplePos!=DsamplePos)
			{
				toSolve=true;
				if(shiftOnly)
					shiftOnly=1, Doffset+=int(newDsamplePos-DsamplePos);
				DsamplePos=newDsamplePos, VD=newDsamplePos*Dsample;
			}
			DsamplePos=newDsamplePos;
		}
		void messageTimer()
		{
				 if(kb[VK_SHIFT	]){	 if(kb['W'])	_3d.moveForwardFast();
									 if(kb['A'])	_3d.moveLeftFast();
									 if(kb['S'])	_3d.moveBackFast();
									 if(kb['D'])	_3d.moveRightFast();}
			else				  {	 if(kb['W'])	_3d.moveForward();
									 if(kb['A'])	_3d.moveLeft();
									 if(kb['S'])	_3d.moveBack();
									 if(kb['D'])	_3d.moveRight();}
			if(kb['X'])
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//xyz
					{
					}
					else		//xy
					{
						if(kb[VK_UP])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, Yoffset, VY, DX/100);
						if(kb[VK_DOWN])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, Yoffset, VY, -DX/100);
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, Xoffset, VX, DX/100);
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, Xoffset, VX, -DX/100);
					//	if(kb[VK_UP]){		VY+=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset+=KYplaces;}
					//	if(kb[VK_DOWN]){	VY-=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset-=KYplaces;}
					//	if(kb[VK_RIGHT]){	VX+=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
					//	if(kb[VK_LEFT]){	VX-=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
				}
				else
				{
					if(kb['Z'])	//xz
					{
						if(kb[VK_UP])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z,	ZsamplePos, Zoffset, VZ, DX/100);
						if(kb[VK_DOWN])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z,	ZsamplePos, Zoffset, VZ, -DX/100);
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, Xoffset, VX, DX/100);
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, Xoffset, VX, -DX/100);
					//	if(kb[VK_UP]){		VZ+=KZplaces*DX/Zplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Zoffset+=KZplaces;}
					//	if(kb[VK_DOWN]){	VZ-=KZplaces*DX/Zplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Zoffset-=KZplaces;}
					//	if(kb[VK_RIGHT]){	VX+=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
					//	if(kb[VK_LEFT]){	VX-=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
					else		//x
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, DX/100);
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, -DX/100);
					//	if(kb[VK_UP]||kb[VK_RIGHT]){	VX+=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
					//	if(kb[VK_DOWN]||kb[VK_LEFT]){	VX-=KXplaces*DX/Xplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
				}
			}
			else
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//yz
					{
						if(kb[VK_UP])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, Zoffset, VZ, DX/100);
						if(kb[VK_DOWN])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, Zoffset, VZ, -DX/100);
						if(kb[VK_RIGHT])shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, Yoffset, VY, DX/100);
						if(kb[VK_LEFT])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, Yoffset, VY, -DX/100);
					//	if(kb[VK_UP]){		VZ+=KZplaces*DX/Zplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Zoffset+=KZplaces;}
					//	if(kb[VK_DOWN]){	VZ-=KZplaces*DX/Zplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Zoffset-=KZplaces;}
					//	if(kb[VK_RIGHT]){	VY+=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset+=KYplaces;}
					//	if(kb[VK_LEFT]){	VY-=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset-=KYplaces;}
					}
					else		//y
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, Yoffset, VY, DX/100);
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, Yoffset, VY, -DX/100);
					//	if(kb[VK_UP]||kb[VK_RIGHT]){	VY+=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset+=KYplaces;}
					//	if(kb[VK_DOWN]||kb[VK_LEFT]){	VY-=KYplaces*DX/Yplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Yoffset-=KYplaces;}
					}
				}
				else
				{
					if(kb['Z'])	//z
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, Zoffset, VZ, DX/100);
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, Zoffset, VZ, -DX/100);
					//	if(kb[VK_UP]||kb[VK_RIGHT]){	VZ+=KZplaces*DX/Zplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Zoffset+=KZplaces;}
					//	if(kb[VK_DOWN]||kb[VK_LEFT]){	VZ-=KZplaces*DX/Zplaces, toSolve=true;	if(shiftOnly)shiftOnly=1, Zoffset-=KZplaces;}
					}
					else
					{
						if(kb[VK_UP])	_3d.rotateUp();
						if(kb[VK_DOWN])	_3d.rotateDown();
						if(kb[VK_RIGHT])_3d.rotateRight();
						if(kb[VK_LEFT])	_3d.rotateLeft();
					}
				}
			}
			if(kb[VK_ADD]||kb[VK_RETURN]||kb[VK_OEM_PLUS])
			{
				if(kb[VK_MENU])
					DX*=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['X'])
				{
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])
					AR_Y*=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['Z'])
					AR_Z*=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(!(kb[VK_CONTROL]||kb[VK_SHIFT]))
					_3d.zoomIn();
			}
			if(kb[VK_SUBTRACT]||kb[VK_BACK]||kb[VK_OEM_MINUS])
			{
				if(kb[VK_MENU])
					DX/=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['X'])
				{
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])
					AR_Y/=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['Z'])
					AR_Z/=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(!(kb[VK_CONTROL]||kb[VK_SHIFT]))
					_3d.zoomOut();
			}
		//		 if(kb[VK_MENU	]){		if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	DX*=1.1, DY*=1.1, DZ*=1.1, function1(), toSolve=true, shiftOnly=0;
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	DX/=1.1, DY/=1.1, DZ/=1.1, function1(), toSolve=true, shiftOnly=0;}
		//	else if(!kb[VK_CONTROL]){	if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	_3d.zoomIn();
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	_3d.zoomOut();}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				if(!shift)
				{
					ShowCursor(0);
					GetCursorPos(&mouseP0);
					SetCursorPos(centerP.x, centerP.y);
					SetCapture(ghWnd);
				}
				drag=1;
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(!m_bypass)
			{
				int draw=0;
				if(kb['X'])
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//xyz	mx my mw
						{
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, Yoffset, VY, (h/2-((short*)&lParam)[1])*DX/w);
						//	int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
						//	VX+=(mx-w/2)*DX/Xplaces, VY+=(h/2-my)*DX/Xplaces;
						//	toSolve=true;
						//	if(shiftOnly)
						//		shiftOnly=1, Xoffset+=mx-w/2, Yoffset+=h/2-my;
						//	draw=1;
						}
						else		//xy	mx my
						{
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, Yoffset, VY, (h/2-((short*)&lParam)[1])*DX/w);
							//int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
							//VX+=(mx-w/2)*DX/Xplaces, VY+=(h/2-my)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Xoffset+=mx-w/2, Yoffset+=h/2-my;
							//draw=1;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//xz	mx my
						{
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
							shiftNDR(ZshiftPoint, solver.Zsample*AR_Z,	ZsamplePos, Zoffset, VZ, (h/2-((short*)&lParam)[1])*DX/w);
							//int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
							//VX+=(mx-w/2)*DX/Xplaces, VZ+=(h/2-my)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Xoffset+=mx-w/2, Zoffset+=h/2-my;
						}
						else		//x		mx
						{
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
							//int mx=((short*)&lParam)[0];
							//VX+=(mx-w/2)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Xoffset+=mx-w/2;
						}
						draw=1;
					}
				}
				else
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//yz	mx my
						{
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, Yoffset, VY, (((short*)&lParam)[0]-w/2)*DX/w);
							shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, Zoffset, VZ, (h/2-((short*)&lParam)[1])*DX/w);
							//int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
							//VY+=(mx-w/2)*DX/Xplaces, VZ+=(h/2-my)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Yoffset+=mx-w/2, Zoffset+=h/2-my;
						}
						else		//y		mx
						{
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, Yoffset, VY, (((short*)&lParam)[0]-w/2)*DX/w);
							//int mx=((short*)&lParam)[0];
							//VY+=(mx-w/2)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Yoffset+=mx-w/2;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//z		my
						{
							shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, Zoffset, VZ, (h/2-((short*)&lParam)[1])*DX/w);
							//int my=((short*)&lParam)[1];
							//VZ+=(h/2-my)*DX/Xplaces;
							//toSolve=true;
							//if(shiftOnly)
							//	shiftOnly=1, Zoffset+=h/2-my;
							draw=1;
						}
						else if(drag)
						{
							_3d.rotate(lParam);
							draw=1;
						}
					}
				}
				if(draw)
				{
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
			}
			m_bypass=!m_bypass;
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				if(!shift)
				{
					ReleaseCapture();
					SetCursorPos(mouseP0.x, mouseP0.y);
					ShowCursor(1);
				}
				drag=0;
			}
		}
		int inputMouseWheel(int wParam)
		{
			if(kb['X']&&kb['Y']&&kb['Z'])
			{
				shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, Zoffset, VZ,
					((short*)&wParam)[1]>0	?	DX/100
											:	-DX/100);
			//		 if(((short*)&wParam)[1]>0)	VZ+=KXplaces*DX/Xplaces;
			//	else							VZ-=KXplaces*DX/Xplaces;
			}
			else if(kb[VK_MENU])
			{
					 if(((short*)&wParam)[1]>0)	DX*=1.1;//, DY*=1.1, DZ*=1.1;
				else							DX/=1.1;//, DY/=1.1, DZ/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['X'])
			{
				if(((short*)&wParam)[1]>0)
				{
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1;
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
				}
				else
				{
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1;
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
				}
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Y'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Y*=1.1;
				else							AR_Y/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Z'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Z*=1.1;
				else							AR_Z/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb[VK_CONTROL])
			{
					 if(((short*)&wParam)[1]>0)	_3d.faster();
				else							_3d.slower();
			}
			else if(kb[VK_SHIFT])
			{
					 if(((short*)&wParam)[1]>0)
				{
					Zplaces=Yplaces=++Xplaces, toSolve=true, shiftOnly=0;
					//int oldXplaces=Xplaces;
					//Xplaces=int(1.5*Xplaces);
					//if(Xplaces==oldXplaces)
					//	++Xplaces;
					//Zplaces=Yplaces=Xplaces;
					//toSolve=true, shiftOnly=0;
				}
				else
				{
					if(Xplaces>1)
						Zplaces=Yplaces=--Xplaces, toSolve=true, shiftOnly=0;
					//int oldXplaces=Xplaces;
					//Xplaces=int(Xplaces/1.5);
					//if(Xplaces==oldXplaces&&Xplaces!=1)
					//	--Xplaces;
					//Zplaces=Yplaces=Xplaces;
					//toSolve=true, shiftOnly=0;
				}
			}
			else
			{
					 if(((short*)&wParam)[1]>0)	_3d.zoomIn();
				else							_3d.zoomOut();
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
				if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_ADD:case VK_OEM_PLUS:case VK_RETURN:
				if(kb[VK_CONTROL])
					_3d.faster();
				else if(kb[VK_SHIFT])//increase resolution
				{
					Zplaces=Yplaces=++Xplaces, toSolve=true, shiftOnly=0;
					//int oldXplaces=Xplaces;
					//Xplaces=int(1.5*Xplaces);
					//if(Xplaces==oldXplaces)
					//	++Xplaces;
					//Zplaces=Yplaces=Xplaces;
					//toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_SUBTRACT:case VK_OEM_MINUS:case VK_BACK:
				if(kb[VK_CONTROL])
					_3d.slower();
				else if(kb[VK_SHIFT])//decrease resolution
				{
					if(Xplaces>1)
						Zplaces=Yplaces=--Xplaces, toSolve=true, shiftOnly=0;
					//int oldXplaces=Xplaces;
					//Xplaces=int(Xplaces/1.5);
					//if(Xplaces==oldXplaces&&Xplaces!=1)
					//	--Xplaces;
					//Zplaces=Yplaces=Xplaces;
					//toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case 'X':case 'Y':case 'Z':
				if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case VK_OEM_3:
				if(contourOn)//was on
				{
					if(kb[VK_CONTROL])
					{
						//contour+surface
						//contour only
						//flat contour
						//flat+surface
						if(contourFlat)
						{
							if(contourOnly)
								contourOnly=false;//3: surface appears
							else
								contourFlat=false;//4: pops up
						}
						else
						{
							if(contourOnly)
								contourFlat=true;//2: gets flat
							else
								contourOnly=true;//1: surface disappears
						}
					}
					else
						contourOn=false, contourOnly=false, contourFlat=false;
				}
				else//was off
				{
					contourOn=true;
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
						doContour(cursorEx, DX/Xplaces, -DX/2, +DX/2, Xstep, 2);
					}
				}
				break;
			case '0':case VK_NUMPAD0:
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
			case '7':case VK_NUMPAD7:
			case '8':case VK_NUMPAD8:
				{
					auto op=&Implicit_3D::differentiate_xyz;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back( 1), op=&Implicit_3D::differentiate_xyz;
																else			operations.push_back( 5), op=&Implicit_3D::differentiate_xy;}
											else			{		 if(kb['Z'])operations.push_back( 7), op=&Implicit_3D::differentiate_xz;
																else			operations.push_back( 2), op=&Implicit_3D::differentiate_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back( 6), op=&Implicit_3D::differentiate_yz;
																else			operations.push_back( 3), op=&Implicit_3D::differentiate_y;}
											else			{		 if(kb['Z'])operations.push_back( 4), op=&Implicit_3D::differentiate_z;
																else			operations.push_back( 1), op=&Implicit_3D::differentiate_xyz;}}
						break;
					case '2':case VK_NUMPAD2:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back( 8), op=&Implicit_3D::integrate_xyz;
																else			operations.push_back(12), op=&Implicit_3D::integrate_xy;}
											else			{		 if(kb['Z'])operations.push_back(14), op=&Implicit_3D::integrate_xz;
																else			operations.push_back( 9), op=&Implicit_3D::integrate_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back(13), op=&Implicit_3D::integrate_yz;
																else			operations.push_back(10), op=&Implicit_3D::integrate_y;}
											else			{		 if(kb['Z'])operations.push_back(11), op=&Implicit_3D::integrate_z;
																else			operations.push_back( 8), op=&Implicit_3D::integrate_xyz;}}
						break;
					case '3':case VK_NUMPAD3:	operations.push_back(15), op=&Implicit_3D::discreteFourrierTransform;			break;
					case '4':case VK_NUMPAD4:	operations.push_back(16), op=&Implicit_3D::inverseDiscreteFourrierTransform;	break;
					case '5':case VK_NUMPAD5:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back(17), op=&Implicit_3D::lowPassFilter_xyz;
																else			operations.push_back(21), op=&Implicit_3D::lowPassFilter_xy;}
											else			{		 if(kb['Z'])operations.push_back(23), op=&Implicit_3D::lowPassFilter_xz;
																else			operations.push_back(18), op=&Implicit_3D::lowPassFilter_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back(22), op=&Implicit_3D::lowPassFilter_yz;
																else			operations.push_back(19), op=&Implicit_3D::lowPassFilter_y;}
											else			{		 if(kb['Z'])operations.push_back(20), op=&Implicit_3D::lowPassFilter_z;
																else			operations.push_back(17), op=&Implicit_3D::lowPassFilter_xyz;}}
						break;
					case '6':case VK_NUMPAD6:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back(24), op=&Implicit_3D::highPassFilter_xyz;
																else			operations.push_back(28), op=&Implicit_3D::highPassFilter_xy;}
											else			{		 if(kb['Z'])operations.push_back(30), op=&Implicit_3D::highPassFilter_xz;
																else			operations.push_back(25), op=&Implicit_3D::highPassFilter_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back(29), op=&Implicit_3D::highPassFilter_yz;
																else			operations.push_back(26), op=&Implicit_3D::highPassFilter_y;}
											else			{		 if(kb['Z'])operations.push_back(27), op=&Implicit_3D::highPassFilter_z;
																else			operations.push_back(24), op=&Implicit_3D::highPassFilter_xyz;}}
						break;
					}
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
						(this->*op)(expr[cursorEx].n[0].ndr);
						if(contourOn)
							doContour(cursorEx, DX/Xplaces, -DX/2, +DX/2, Xstep, 2);
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				{
					double r=20/DX;
					VX*=r, VY*=r, VZ*=r;
					_3d.camx*=r, _3d.camy*=r, _3d.camz*=r, _3d.dcam*=r;
					DX=20, AR_Y=1, AR_Z=1, function1();
					toSolve=true, shiftOnly=0;
				}
				break;
			case 'R':
				_3d.dcam=.04;
				if(!kb[VK_CONTROL])
					DX=20, AR_Y=1, AR_Z=1, function1(), Xplaces=Yplaces=Zplaces=10;
				if(VX!=0||VY!=0||VZ!=0)
					VX=VY=VZ=0;
				toSolve=true, shiftOnly=0;
				if(kb['X'])
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
				else if(kb['Y'])
					_3d.teleport_degrees(0, 20, 0, 270, 0, 1);
				else if(kb['Z'])
					_3d.teleport_degrees(0, 0, 20, 90, 270, 1);
				else
					_3d.teleport_degrees(20, 20, 20, 225, 324.7356103172454, 1);
				//	_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
			/*	if(kb[VK_CONTROL])
				{
					DX=20, DY=20, DZ=20, function1();
					toSolve=true, shiftOnly=0;
				}
				if(VX!=0||VY!=0||VZ!=0)
				{
					VX=VY=VZ=0;
					toSolve=true, shiftOnly=0;
				}
				_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);//*/
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
				if(kp>0)
					--kp;
				break;
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[VK_CONTROL]&&kp>0)
					--kp;
				return 0;
			case 'X':
				if(!kb['Y']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Y':
				if(!kb['X']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Z':
				if(!kb['X']&&!kb['Y']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
		/*	case 'X':case 'Y':case 'Z':
				if(shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;*/
			}
			return 0;
		}
		void function1()
		{
			double t=100*DX/w;
			Xstep=exp(floor(log10(t))*log(10));
			switch(int(t/Xstep))
			{
			case 1:Xstep*=1;break;
			case 2:Xstep*=2;break;
			case 3:Xstep*=2;break;
			case 4:Xstep*=2;break;
			case 5:Xstep*=5;break;
			case 6:Xstep*=5;break;
			case 7:Xstep*=5;break;
			case 8:Xstep*=5;break;
			case 9:Xstep*=5;break;
			default:Xstep*=6;break;
			}
			if(AR_Y==1)
				Ystep=Xstep;
			else
			{
				double t=100*DX/(w*AR_Y);
				Ystep=exp(floor(log10(t))*log(10));
				switch(int(t/Ystep))
				{
				case 1:Ystep*=1;break;
				case 2:Ystep*=2;break;
				case 3:Ystep*=2;break;
				case 4:Ystep*=2;break;
				case 5:Ystep*=5;break;
				case 6:Ystep*=5;break;
				case 7:Ystep*=5;break;
				case 8:Ystep*=5;break;
				case 9:Ystep*=5;break;
				default:Ystep*=6;break;
				}
			}
			if(AR_Z==1)
				Zstep=Xstep;
			else
			{
				double t=100*DX/(w*AR_Z);
				Zstep=exp(floor(log10(t))*log(10));
				switch(int(t/Zstep))
				{
				case 1:Zstep*=1;break;
				case 2:Zstep*=2;break;
				case 3:Zstep*=2;break;
				case 4:Zstep*=2;break;
				case 5:Zstep*=5;break;
				case 6:Zstep*=5;break;
				case 7:Zstep*=5;break;
				case 8:Zstep*=5;break;
				case 9:Zstep*=5;break;
				default:Zstep*=6;break;
				}
			}
		/*	double t=100*DX/w;
			step=exp(floor(log10(t))*log(10));
			switch(int(t/step))
			{
			case 1:step*=1;break;
			case 2:step*=2;break;
			case 3:step*=2;break;
			case 4:step*=2;break;
			case 5:step*=5;break;
			case 6:step*=5;break;
			case 7:step*=5;break;
			case 8:step*=5;break;
			case 9:step*=5;break;
			default:step*=6;break;
			}//*/
		}
		void draw()
		{
			double DY=DX/AR_Y, DZ=DX/AR_Z;
			auto &ex=expr[cursorEx];
			{
				bool changed=false;
				if(toSolve)
				{
					if(!operations.size()&&shiftOnly==1&&abs(Xoffset)<Xplaces&&abs(Yoffset)<Yplaces&&abs(Zoffset)<Zplaces)
					{
						solver.partial_bounds(VX, DX, VY/AR_Y, DY, VZ/AR_Z, DZ, Xoffset, Yoffset, Zoffset);
						solver.synchronize();
						(solver.*(ex.nITD?&Solve_3D::full:solver.partial))(ex);
					}
					else
					{
						auto old_time_variance=time_variance;
						time_variance=false;
					//	std::fill(nExpr.begin(), nExpr.end(), 0);
					//	for(auto &ex:expr)
					//		++nExpr[ex.rmode[0]];
						labels.clear();
					//	Xplaces=Yplaces=Zplaces=
					//		50//2//4//8//10//50
					//		;
						solver.full_resize(VX, DX, VY/AR_Y, DY, VZ/AR_Z, DZ, Xplaces, Yplaces, Zplaces);
						XsamplePos=std::floor(XshiftPoint/solver.Xsample);
						YsamplePos=std::floor(YshiftPoint/solver.Ysample);
						ZsamplePos=std::floor(ZshiftPoint/solver.Zsample);

					//	KXplaces=Xplaces/100?Xplaces/100:1, KYplaces=Yplaces/100?Yplaces/100:1, KZplaces=Zplaces/100?Zplaces/100:1;
						time_variance|=ex.nITD;
						labels.fill(cursorEx);
						if(!paused)
							solver.synchronize();
						solver.full(ex);
						doOperations(ex.n[0].ndr);
						if(time_variance)
						{
							if(!paused)
								SetTimer(ghWnd, 0, 10, 0);
						}
						else if(old_time_variance&&!timer)
							KillTimer(ghWnd, 0);
					}
					toSolve=false, shiftOnly=2, Xoffset=Yoffset=Zoffset=0;
					changed=true;
				}
				else if(time_variance)
				{
					if(!paused)
						solver.synchronize();
					solver.full(ex);
					doOperations(ex.n[0].ndr);
					changed=true;
				}
				if(changed)
				{
					solver.updateRGB(ex);
				//	solver.updateRGB(ex.n[0]);
					if(contourOn)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
						doContour(cursorEx, DX/Xplaces, -DX/2, +DX/2, Xstep, 2);
					}
				}
			}
			
			_3d.newFrame();
			if(!clearScreen)
				_3dMode_DrawGridNAxes(_3d, VX, VY, VZ, DX, Xstep, AR_Y*Ystep, AR_Z*Zstep, AR_Y, AR_Z);
			if(!contourOnly)//draw the points
			{
				double Xstart=VX-DX/2, Xr=DX/Xplaces, Ystart=VY-DX/2, Ysample=DX/Yplaces, Zstart=VZ-DX/2, Zr=DX/Zplaces;
				auto ndrIT=ex.n[0].ndr.begin();
				unsigned v=0;
				switch(ex.resultMathSet)
			//	switch(ex.n[0].mathSet)
			//	switch(ex.n[0].ndrMathType)
				{
				case 'r':case 'c':
			//	case 'R':case 'C':
					for(int k=0;k<Zplaces;++k)
						for(int k2=0;k2<Yplaces;++k2)
							for(int k3=0;k3<Xplaces;++k3, ++ndrIT, ++v)
								_3d.point(Xstart+Xr*k3, Ystart+Ysample*k2, Zstart+Zr*k, solver.ndr_rgb[v]);
							//	_3d.textIn3D(Xstart+Xr*k3, Ystart+Ysample*k2, Zstart+Zr*k, OPAQUE, "%g", ndrIT->r);
					break;
				case 'H':
					for(int k=0;k<Zplaces;++k)
						for(int k2=0;k2<Yplaces;++k2)
							for(int k3=0;k3<Xplaces;++k3, ++ndrIT, ++v)
								_3d.point(Xstart+Xr*k3, Ystart+Ysample*k2, Zstart+Zr*k, solver.ndr_rgb[v], solver.ndr_rgb_i[v], solver.ndr_rgb_j[v], solver.ndr_rgb_k[v]);
					break;
				}
			}
			if(contourOn)//draw the contour
			{
			//	draw_contourGrid(DX/Xplaces);
				switch(ex.resultMathSet)
			//	switch(ex.n[0].mathSet)
			//	switch(ex.n[0].ndrMathType)
				{
				case 'r':
			//	case 'R':
					draw_contour(Rcontours, Rlines, rColor);
					break;
				case 'c':
			//	case 'C':
					draw_contour(Rcontours, Rlines, rColor);
					draw_contour(Icontours, Ilines, iColor);
					break;
				case 'H':
					draw_contour(Rcontours, Rlines, rColor);
					draw_contour(Icontours, Ilines, iColor);
					draw_contour(Icontours, Ilines, jColor);
					draw_contour(Icontours, Ilines, kColor);
					break;
				}
			}
			if(!clearScreen)
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, TRANSPARENT);
					for(double X=floor((VX-DX/2)/Xstep)*Xstep+Xstep, Xend=ceil((VX+DX/2)/Xstep)*Xstep;X<Xend;X+=Xstep)
						if(abs(X)>Xstep/2)
							_3d.label(X, VY, VZ, "%g", X);
					if(AR_Y==1)
					{
						for(double Y=floor((VY-DX/2)/Ystep)*Ystep+Ystep, Yend=ceil((VY+DX/2)/Ystep)*Ystep;Y<Yend;Y+=Ystep)
							if(Y<-Ystep/2||Y>Ystep/2)
								_3d.label(VX, Y, VZ, "%g", Y);
					}
					else
					{
						double aYstep=AR_Y*Ystep, Ycore=floor((VY-DX/2)/aYstep);
						for(double Y=Ycore*aYstep+aYstep, Yend=ceil((VY+DX/2)/aYstep)*aYstep, aY=Ycore*Ystep+Ystep;Y<Yend;Y+=aYstep, aY+=Ystep)
							if(Y<-aYstep/2||Y>aYstep/2)
								_3d.label(VX, Y, VZ, "%g", aY);
					}
					if(AR_Z==1)
					{
						for(double Z=floor((VZ-DX/2)/Zstep)*Zstep+Zstep, Zend=ceil((VZ+DX/2)/Zstep)*Zstep;Z<Zend;Z+=Zstep)
							if(Z<-Zstep/2||Z>Zstep/2)
								_3d.label(VX, VY, Z, "%g", Z);
					}
					else
					{
						double aZstep=AR_Z*Zstep, Zcore=floor((VZ-DX/2)/aZstep);
						for(double Z=Zcore*aZstep+aZstep, Zend=ceil((VZ+DX/2)/aZstep)*aZstep, aZ=Zcore*Zstep+Zstep;Z<Zend;Z+=aZstep, aZ+=Zstep)
							if(Z<-aZstep/2||Z>aZstep/2)
								_3d.label(VX, VY, Z, "%g", aZ);
					}
			/*	for(double x=floor((VX-DX/2)/step)*step+step;x<ceil((VX+DX/2)/step)*step;x+=step)
					if(abs(x)>step/2)
						_3d.label(x, VY, VZ, "%g", x);
				for(double y=floor((VY-DX/2)/step)*step+step;y<ceil((VY+DX/2)/step)*step;y+=step)
					if(abs(y)>step/2)
						_3d.label(VX, y, VZ, "%g", y);
				for(double z=floor((VZ-DX/2)/step)*step+step;z<ceil((VZ+DX/2)/step)*step;z+=step)
					if(abs(z)>step/2)
						_3d.label(VX, VY, z, "%g", z);//*/
				_3d.arrowLabels(0, 0, 0, 1, 0, 0, labels.Xlabels);
				_3d.arrowLabels(0, 0, 0, 0, 1, 0, labels.Ylabels);
				_3d.arrowLabels(0, 0, 0, 0, 0, 1, labels.Zlabels);
				{
					int Ys=0;
					for(auto &label:labels.Clabels)
					{
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					//	linelen=sprintf_s(line, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, line, linelen), Ys+=16;
					}
				}
				{
					int k=0, Y=h-operations.size()*16;
					for(auto operation:operations)
					{
						char const *a=0;
						switch(operation)
						{
						case  1:a="%d: Differentiate XYZ";	break;
						case  2:a="%d: Differentiate X";	break;
						case  3:a="%d: Differentiate Y";	break;
						case  4:a="%d: Differentiate Z";	break;
						case  5:a="%d: Differentiate XY";	break;
						case  6:a="%d: Differentiate YZ";	break;
						case  7:a="%d: Differentiate XZ";	break;
						case  8:a="%d: Integrate XYZ";		break;
						case  9:a="%d: Integrate X";		break;
						case 10:a="%d: Integrate Y";		break;
						case 11:a="%d: Integrate Z";		break;
						case 12:a="%d: Integrate XY";		break;
						case 13:a="%d: Integrate YZ";		break;
						case 14:a="%d: Integrate XZ";		break;
						case 15:a="%d: DFT";				break;
						case 16:a="%d: IDFT";				break;
						case 17:a="%d: LPF";				break;
						case 18:a="%d: LPF X";				break;
						case 19:a="%d: LPF Y";				break;
						case 20:a="%d: LPF Z";				break;
						case 21:a="%d: LPF XY";				break;
						case 22:a="%d: LPF YZ";				break;
						case 23:a="%d: LPF XZ";				break;
						case 24:a="%d: HPF";				break;
						case 25:a="%d: HPF X";				break;
						case 26:a="%d: HPF Y";				break;
						case 27:a="%d: HPF Z";				break;
						case 28:a="%d: HPF XY";				break;
						case 29:a="%d: HPF YZ";				break;
						case 30:a="%d: HPF XZ";				break;
						}
						_3d.textIn2D(w-const_label_offset_X, Y, OPAQUE, a, k);
						++k, Y+=16;
					}
				}
				SetBkMode(ghMemDC, bkMode);
				_3d.text_show();
			}
			else
				_3d.text_show();
			//	_3d.text_dump();
		}
		void i_draw();
		void a_draw();
	} ti3d;
	void			Implicit_3D::i_draw()
	{
		draw();
		
		font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
		{
			int bkMode=GetBkMode(ghMemDC);
			SetBkMode(ghMemDC, OPAQUE);
			itb.draw();
			SetBkMode(ghMemDC, bkMode);
		}
		font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
		Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
	void			Implicit_3D::a_draw()
	{
		Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(!clearScreen)
			Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
#endif
	namespace contour
	{
		struct Double_X_Y_Z_V
		{
			double X, Y, Z, V;
			Double_X_Y_Z_V(){}
			Double_X_Y_Z_V(double X, double Y, double Z, double V):X(X), Y(Y), Z(Z), V(V){}
			void operator()(double X, double Y, double Z, double V){this->X=X, this->Y=Y, this->Z=Z, this->V=V;}
		};
		struct Double_X_Y_Z
		{
			double X, Y, Z;
			Double_X_Y_Z(double X, double Y, double Z):X(X), Y(Y), Z(Z){}
		};
		void solve_cubic(double a, double b, double c, double d, double &r1, std::complex<double> &r2, std::complex<double> &r3)
		{
			//http://easycalculation.com/algebra/learn-cubic-equation.php
			//http://stackoverflow.com/questions/13328676/c-solving-cubic-equations
			if(a==0)
			{
				r1=_HUGE;
				solve_quadratic(b, c, d, r2, r3);
			}
			else if(d==0)
			{
				r1=0;
				solve_quadratic(a, b, c, r2, r3);
			}
			else
			{
				b/=a, c/=a, d/=a;
				double disc, q, r, dum1, s, t, term1, r13;
				q=(3.0*c-(b*b))/9.0;
				r=-(27.0*d)+b*(9.0*c-2.0*(b*b));
				r/=54.0;
				disc=q*q*q+r*r;
				term1=b/3;
				if(disc>0)
				{
					s=r+std::sqrt(disc);
					s=s<0?-std::pow(-s, 1./3):std::pow(s, 1./3);
					t=r-std::sqrt(disc);
					t=t<0?-std::pow(-t, 1./3):std::pow(t, 1./3);
					r1=-term1+s+t;//The first root is always real
					term1+=(s+t)/2;
					double term2=std::sqrt(3)*(-t+s)/2;
					r2=std::complex<double>(-term1, term2);
					r3=std::complex<double>(-term1, -term2);
				}
				else if(disc==0)//The remaining options are all real
				{
					r13=r<0?-std::pow(-r, 1./3):std::pow(r, 1./3);
					r1=-term1+2*r13;
					r3=r2=-(r13+term1);//at least two are equal
				}
				else//Only option left is that all roots are real and unequal (to get here, q < 0)
				{
					q = -q;
					dum1 = q*q*q;
					dum1 = std::acos(r/std::sqrt(dum1));
					r13 = 2.0*std::sqrt(q);
					r1=-term1+r13*std::cos(dum1/3);
					r2=-term1+r13*std::cos((dum1+2*G2::_pi)/3);
					r3=-term1+r13*std::cos((dum1+4*G2::_pi)/3);
				}
			}
		}
		/*struct H_Stick
		{
			double X1, Y1, X2, Y2;
			H_Stick(double X1, double Y1, double X2, double Y2):X1(X1), Y1(Y1), X2(X2), Y2(Y2){}
		};//*/
	}
	class		Color_3D:public Mode
	{
	public:
	//	int toSolve;
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		int Xoffset, Yoffset, Zoffset;
		int X0, Y0;
	//	int bpx, bpy, bh, bw, X0, Y0;

		int Xplaces, Yplaces, Zplaces;
		double XshiftPoint, YshiftPoint, ZshiftPoint;
		double XsamplePos, YsamplePos, ZsamplePos;
	//	int KXplaces, KYplaces, KZplaces;

		double VX, VY, VZ, DX, AR_Y, AR_Z, Xstep, Ystep, Zstep;
		int prec;
		Solve_3D solver;
		std::list<int> operations;

		bool contourOn, contourOnly, contourFlat;
		std::map<unsigned, std::unordered_map<int, std::list<_3D::Triangle>>>
			Rcontours,//contours[e]=contour, contour[r level (r/step)]=triangles, *triangles.begin()=triangle
			Icontours,//contours[e]=contour, contour[i level (i/step)]=triangles, *triangles.begin()=triangle
			Jcontours,//contours[e]=contour, contour[j level (j/step)]=triangles, *triangles.begin()=triangle
			Kcontours;//contours[e]=contour, contour[k level (k/step)]=triangles, *triangles.begin()=triangle
		std::map<unsigned, std::unordered_map<int, std::list<_3D::Stick>>>
			Rlines,//contours[e]=contour, contour[r level (r/step)]=sticks, *sticks.begin()=stick
			Ilines,//contours[e]=contour, contour[i level (i/step)]=sticks, *sticks.begin()=stick
			Jlines,//contours[e]=contour, contour[j level (j/step)]=sticks, *sticks.begin()=stick
			Klines;//contours[e]=contour, contour[k level (k/step)]=sticks, *sticks.begin()=stick
		
		bool clearScreen, kb_VK_F6_msg;
		Labels_3D labels;
		static const int rColor=0, iColor=0x00EF0000, jColor=0x0000EF00, kColor=0x000000EF;
		_3D _3d;
		int gridColor;
		
	//	char line[128];
	//	int linelen;
		bool timer, drag, m_bypass, shift;
		int kp;

		Color_3D():
			VX(0), VY(0), VZ(0), DX(20), AR_Y(1), AR_Z(1),
			Xplaces(10), Yplaces(10), Zplaces(10),
			XshiftPoint(0), YshiftPoint(0), ZshiftPoint(0),
			XsamplePos(0), YsamplePos(0), ZsamplePos(0),
		//	KXplaces(Xplaces/100?Xplaces/100:1), KYplaces(Yplaces/100?Yplaces/100:1), KZplaces(Zplaces/100?Zplaces/100:1),
			_3d(20, 20, 20, 225*G2::_pi/180, 324.7356103172454*G2::_pi/180, 1),
			gridColor(_3dGridColor),
			timer(false), drag(false), m_bypass(false), shift(false), kp(0),
			shiftOnly(2), Xoffset(0), Yoffset(0),
		//	toSolve(1), shiftOnly(2), Xoffset(0), Yoffset(0),
			contourOn(false), contourOnly(false), contourFlat(false),
			clearScreen(false), kb_VK_F6_msg(false)
		{}

		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
				drag=1;
			}
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
		//	kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]+kb[VK_ADD]+kb[VK_OEM_PLUS]+kb[VK_SUBTRACT]+kb[VK_OEM_MINUS];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag||shift)
			{
				drag=0, shift=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag||shift)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		
		void draw_contour(std::map<unsigned, std::unordered_map<int, std::list<_3D::Triangle>>> &contours, std::map<unsigned, std::unordered_map<int, std::list<_3D::Stick>>> &lines, unsigned lineColor)
		{
			for(auto &L:contours[cursorEx])
			{
				double RL=10*L.first*Xstep;
				int color=colorFunction_r(RL);
				if(!color)
					color=0x00D0D0D0;
				for(auto &p:L.second)
					_3d.triangle_halfTransparent(p, color);
			}
			_3d.lineColor=lineColor;
		/*	for(auto &L:contours[cursorEx])//contour mesh
			{
				for(auto &p:L.second)
				{
					_3d.line(p.X1, p.Y1, p.Z1, p.X2, p.Y2, p.Z2);
					_3d.line(p.X2, p.Y2, p.Z2, p.X3, p.Y3, p.Z3);
					_3d.line(p.X3, p.Y3, p.Z3, p.X1, p.Y1, p.Z1);
				}
			}//*/
			for(auto &Vlevel:lines[cursorEx])
				for(auto &s:Vlevel.second)
					_3d.line(s.X1, s.Y1, s.Z1, s.X2, s.Y2, s.Z2);
		}
		void draw_contourGrid(double Xs)
		{
			unsigned e=cursorEx, c=0;
			using namespace contour;
			auto &ndr=expr[e].n[0].ndr;
			_3d.lineColor=0x00D0D0D0;

			double X0, X1, Y0, Y1, Z0, Z1, V000, V001, V010, V011, V100, V101, V110, V111;
			auto interpolate=[&](double Xa, double Ya, double Za)
			{
				double dX0=Xa-X0, dX1=X1-Xa, dY0=(Ya-Y0), dY1=(Y1-Ya);
				return
					(	(Z1-Za)*	(	dY1*	(	dX1*V000+
													dX0*V001	)+
										dY0*	(	dX1*V010+
													dX0*V011	))+
						(Za-Z0)*	(	dY1*	(	dX1*V100+
													dX0*V101	)+
										dY0*	(	dX1*V110+
													dX0*V111	))
					)/(Z1-Z0)/(Y1-Y0)/(X1-X0);
			};

			auto cutTrap=[&](Double_X_Y_Z_V &A, Double_X_Y_Z_V &B, Double_X_Y_Z_V &C, Double_X_Y_Z_V &D)
			{
				_3d.line(A.X, A.Y, A.Z, B.X, B.Y, B.Z);
				_3d.line(B.X, B.Y, B.Z, C.X, C.Y, C.Z);
				_3d.line(C.X, C.Y, C.Z, D.X, D.Y, D.Z);
				_3d.line(D.X, D.Y, D.Z, A.X, A.Y, A.Z);
			};
			auto print=[&](Double_X_Y_Z_V &P){_3d.textIn3D(P.X, P.Y, P.Z, OPAQUE, "%g", P.V);};
			for(unsigned vz=0, vzEnd=Zplaces-1;vz<vzEnd;++vz)
			{
				for(unsigned vy=0, vyEnd=Yplaces-1;vy<vyEnd;++vy)
				{
					for(unsigned vx=0, vxEnd=Xplaces-1;vx<vxEnd;++vx)
					{
						X0=solver.Xstart+Xs*vx, X1=solver.Xstart+Xs*(vx+1);
						Y0=solver.Ystart+Xs*vy, Y1=solver.Ystart+Xs*(vy+1);
						Z0=solver.Zstart+Xs*vz, Z1=solver.Zstart+Xs*(vz+1);
						double Xm=solver.Xstart+Xs*(vx+.5), Ym=solver.Ystart+Xs*(vy+.5), Zm=solver.Zstart+Xs*(vz+.5);
							
						Double_X_Y_Z_V
							P000(X0, Y0, Z0, V000=(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]),
							P001(X1, Y0, Z0, V001=(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx+1].r)[c]),
							P010(X0, Y1, Z0, V010=(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ].r)[c]),
							P011(X1, Y1, Z0, V011=(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx+1].r)[c]),
							P100(X0, Y0, Z1, V100=(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ].r)[c]),
							P101(X1, Y0, Z1, V101=(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx+1].r)[c]),
							P110(X0, Y1, Z1, V110=(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx  ].r)[c]),
							P111(X1, Y1, Z1, V111=(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx+1].r)[c]),

							P00m(Xm, Y0, Z0, interpolate(Xm, Y0, Z0)),
							P01m(Xm, Y1, Z0, interpolate(Xm, Y1, Z0)),
							P10m(Xm, Y0, Z1, interpolate(Xm, Y0, Z1)),
							P11m(Xm, Y1, Z1, interpolate(Xm, Y1, Z1)),

							P0m0(X0, Ym, Z0, interpolate(X0, Ym, Z0)),
							P0m1(X1, Ym, Z0, interpolate(X1, Ym, Z0)),
							P1m0(X0, Ym, Z1, interpolate(X0, Ym, Z1)),
							P1m1(X1, Ym, Z1, interpolate(X1, Ym, Z1)),

							Pm00(X0, Y0, Zm, interpolate(X0, Y0, Zm)),
							Pm01(X1, Y0, Zm, interpolate(X1, Y0, Zm)),
							Pm10(X0, Y1, Zm, interpolate(X0, Y1, Zm)),
							Pm11(X1, Y1, Zm, interpolate(X1, Y1, Zm)),

							P0mm(Xm, Ym, Z0, interpolate(Xm, Ym, Z0)),
							P1mm(Xm, Ym, Z1, interpolate(Xm, Ym, Z1)),

							Pm0m(Xm, Y0, Zm, interpolate(Xm, Y0, Zm)),
							Pm1m(Xm, Y1, Zm, interpolate(Xm, Y1, Zm)),

							Pmm0(X0, Ym, Zm, interpolate(X0, Ym, Zm)),
							Pmm1(X1, Ym, Zm, interpolate(X1, Ym, Zm)),

							Pmmm(Xm, Ym, Zm, interpolate(Xm, Ym, Zm));
						
						print(P00m), print(P01m), print(P10m), print(P11m);
						print(P0m0), print(P0m1), print(P1m0), print(P1m1);
						print(Pm00), print(Pm01), print(Pm10), print(Pm11);
						print(P0mm), print(P1mm);
						print(Pm0m), print(Pm1m);
						print(Pmm0), print(Pmm1);
						print(Pmmm);
						
						cutTrap(Pm00, Pm0m, P000, Pmmm);
						cutTrap(Pm0m, P00m, P000, Pmmm);
						cutTrap(P00m, P0mm, P000, Pmmm);
						cutTrap(P0mm, P0m0, P000, Pmmm);
						cutTrap(P0m0, Pmm0, P000, Pmmm);
						cutTrap(Pmm0, Pm00, P000, Pmmm);
						
						cutTrap(Pm01, Pm0m, P001, Pmmm);
						cutTrap(Pm0m, P00m, P001, Pmmm);
						cutTrap(P00m, P0mm, P001, Pmmm);
						cutTrap(P0mm, P0m1, P001, Pmmm);
						cutTrap(P0m1, Pmm1, P001, Pmmm);
						cutTrap(Pmm1, Pm01, P001, Pmmm);
						
						cutTrap(Pm10, Pm1m, P010, Pmmm);
						cutTrap(Pm1m, P01m, P010, Pmmm);
						cutTrap(P01m, P0mm, P010, Pmmm);
						cutTrap(P0mm, P0m0, P010, Pmmm);
						cutTrap(P0m0, Pmm0, P010, Pmmm);
						cutTrap(Pmm0, Pm10, P010, Pmmm);
						
						cutTrap(Pm11, Pm1m, P011, Pmmm);
						cutTrap(Pm1m, P01m, P011, Pmmm);
						cutTrap(P01m, P0mm, P011, Pmmm);
						cutTrap(P0mm, P0m1, P011, Pmmm);
						cutTrap(P0m1, Pmm1, P011, Pmmm);
						cutTrap(Pmm1, Pm11, P011, Pmmm);
						
						cutTrap(Pm00, Pm0m, P100, Pmmm);
						cutTrap(Pm0m, P10m, P100, Pmmm);
						cutTrap(P10m, P1mm, P100, Pmmm);
						cutTrap(P1mm, P1m0, P100, Pmmm);
						cutTrap(P1m0, Pmm0, P100, Pmmm);
						cutTrap(Pmm0, Pm00, P100, Pmmm);
						
						cutTrap(Pm01, Pm0m, P101, Pmmm);
						cutTrap(Pm0m, P10m, P101, Pmmm);
						cutTrap(P10m, P1mm, P101, Pmmm);
						cutTrap(P1mm, P1m1, P101, Pmmm);
						cutTrap(P1m1, Pmm1, P101, Pmmm);
						cutTrap(Pmm1, Pm01, P101, Pmmm);
						
						cutTrap(Pm10, Pm1m, P110, Pmmm);
						cutTrap(Pm1m, P11m, P110, Pmmm);
						cutTrap(P11m, P1mm, P110, Pmmm);
						cutTrap(P1mm, P1m0, P110, Pmmm);
						cutTrap(P1m0, Pmm0, P110, Pmmm);
						cutTrap(Pmm0, Pm10, P110, Pmmm);
						
						cutTrap(Pm11, Pm1m, P111, Pmmm);
						cutTrap(Pm1m, P11m, P111, Pmmm);
						cutTrap(P11m, P1mm, P111, Pmmm);
						cutTrap(P1mm, P1m1, P111, Pmmm);
						cutTrap(P1m1, Pmm1, P111, Pmmm);
						cutTrap(Pmm1, Pm11, P111, Pmmm);
					}
				}
			}
		}
		void doContour_component(unsigned e, unsigned c, double Xs, double Vstart, double Vend, double Vstep, unsigned nvSteps)//cursorEx, comp, DX/Xplaces, -DX/2, +DX/2, Xstep, 2
		{
			using namespace contour;
			auto &ndr=expr[e].n[0].ndr;
			decltype(&Rcontours[e]) contour=0;
			switch(c)
			{
			case 0:contour=&Rcontours[e];break;
			case 1:contour=&Icontours[e];break;
			case 2:contour=&Jcontours[e];break;
			case 3:contour=&Kcontours[e];break;
			}
			double X0, X1, Y0, Y1, Z0, Z1, V000, V001, V010, V011, V100, V101, V110, V111;
			auto getPos=[&](double &t, double Vx, Double_X_Y_Z_V &A, Double_X_Y_Z_V &B)
			{
				double
					Xd=B.X-A.X, X1a=X1-A.X, Xa0=A.X-X0,
					Yd=B.Y-A.Y, Y1a=Y1-A.Y, Ya0=A.Y-Y0,
					Zd=B.Z-A.Z, Z1a=Z1-A.Z, Za0=A.Z-Z0,
					
					A00=(V001-V000)*Xd, B00=X1a*V000+Xa0*V001,
					A01=(V011-V010)*Xd, B01=X1a*V010+Xa0*V011,
					A10=(V101-V100)*Xd, B10=X1a*V100+Xa0*V101,
					A11=(V111-V110)*Xd, B11=X1a*V110+Xa0*V111,
					
					C0=(A01-A00)*Yd, D0=(B01-B00)*Yd+Y1a*A00+Ya0*A01, E0=Y1a*B00+Ya0*B01,
					C1=(A11-A10)*Yd, D1=(B11-B10)*Yd+Y1a*A10+Ya0*A11, E1=Y1a*B10+Ya0*B11,
					
					a=(C1-C0)*Zd, b=(D1-D0)*Zd+Z1a*C0+Za0*C1, c=(E1-E0)*Zd+Z1a*D0+Za0*D1, d=Z1a*E0+Za0*E1-(X1-X0)*(Y1-Y0)*(Z1-Z0)*Vx;

			//	if(A.Z==Z0&&B.Z==Z0)
			//		int LOL_1=0;
				if(a==0&&b==0&&c==0)
				{
					t=(Vx-A.V)/(B.V-A.V);
					return true;
				}
				double r1;
				std::complex<double> r2, r3;
				solve_cubic(a, b, c, d, r1, r2, r3);
				if(r1>=0&&r1<=1)
				{
					t=r1;
					return true;
				}
				if(r2.real()>=0&&r2.real()<=1)//what
				{
					t=r2.real();
					return true;
				}
				if(r3.real()>=0&&r3.real()<=1)
				{
					t=r3.real();
					return true;
				}
				if(r1>=-1e-5&&r1<=1+1e-5)
				{
					t=r1;
					return true;
				}
				if(r2.real()>=-1e-5&&r2.real()<=1+1e-5)//what
				{
					t=r2.real();
					return true;
				}
				if(r3.real()>=-1e-5&&r3.real()<=1+1e-5)
				{
					t=r3.real();
					return true;
				}
				if(r1>=-1e-1&&r1<=1+1e-1)
				{
					t=r1;
					return true;
				}
				if(r2.real()>=-1e-1&&r2.real()<=1+1e-1)//what
				{
					t=r2.real();
					return true;
				}
				if(r3.real()>=-1e-1&&r3.real()<=1+1e-1)
				{
					t=r3.real();
					return true;
				}
				return false;
			};
			auto cutTrap=[&](Double_X_Y_Z_V &A, Double_X_Y_Z_V &B, Double_X_Y_Z_V &C, Double_X_Y_Z_V &D)
			{
				Double_X_Y_Z_V *_1, *_2, *_3, *_4;//sorted by V in ascending order
				if(A.V<B.V)//ab
				{
					if(B.V<C.V)//abc
					{
							 if(C.V<D.V)	_1=&A, _2=&B, _3=&C, _4=&D;
						else if(B.V<D.V)	_1=&A, _2=&B, _3=&D, _4=&C;
						else if(A.V<D.V)	_1=&A, _2=&D, _3=&B, _4=&C;
						else				_1=&D, _2=&A, _3=&B, _4=&C;
					}
					else if(A.V<C.V)//acb
					{
							 if(B.V<D.V)	_1=&A, _2=&C, _3=&B, _4=&D;
						else if(C.V<D.V)	_1=&A, _2=&C, _3=&D, _4=&B;
						else if(A.V<D.V)	_1=&A, _2=&D, _3=&C, _4=&B;
						else				_1=&D, _2=&A, _3=&C, _4=&B;
					}
					else//cab
					{
							 if(B.V<D.V)	_1=&C, _2=&A, _3=&B, _4=&D;
						else if(A.V<D.V)	_1=&C, _2=&A, _3=&D, _4=&B;
						else if(C.V<D.V)	_1=&C, _2=&D, _3=&A, _4=&B;
						else				_1=&D, _2=&C, _3=&A, _4=&B;
					}
				}
				else//ba
				{
					if(A.V<C.V)//bac
					{
							 if(C.V<D.V)	_1=&B, _2=&A, _3=&C, _4=&D;
						else if(A.V<D.V)	_1=&B, _2=&A, _3=&D, _4=&C;
						else if(B.V<D.V)	_1=&B, _2=&D, _3=&A, _4=&C;
						else				_1=&D, _2=&B, _3=&A, _4=&C;
					}
					else if(B.V<C.V)//bca
					{
							 if(A.V<D.V)	_1=&B, _2=&C, _3=&A, _4=&D;
						else if(C.V<D.V)	_1=&B, _2=&C, _3=&D, _4=&A;
						else if(B.V<D.V)	_1=&B, _2=&D, _3=&C, _4=&A;
						else				_1=&D, _2=&B, _3=&C, _4=&A;
					}
					else//cba
					{
							 if(A.V<D.V)	_1=&C, _2=&B, _3=&A, _4=&D;
						else if(B.V<D.V)	_1=&C, _2=&B, _3=&D, _4=&A;
						else if(C.V<D.V)	_1=&C, _2=&D, _3=&B, _4=&A;
						else				_1=&D, _2=&C, _3=&B, _4=&A;
					}
				}
				for(double v=std::floor((_1->V<Vstart?Vstart:_1->V)/Vstep), vEnd=std::floor((_2->V>Vend?Vend:_2->V)/Vstep);v<=vEnd;++v)
				{
					double VL=Vstep*v;
					if(_1->V<=VL&&VL<_2->V)
					{
						double M12, M13, M14;
						if(getPos(M12, VL, *_1, *_2)&&getPos(M13, VL, *_1, *_3)&&getPos(M14, VL, *_1, *_4))
						{
							contour->operator[](int(v)).push_back(_3D::Triangle(
								_1->X+M12*(_2->X-_1->X), _1->Y+M12*(_2->Y-_1->Y), _1->Z+M12*(_2->Z-_1->Z),
								_1->X+M13*(_3->X-_1->X), _1->Y+M13*(_3->Y-_1->Y), _1->Z+M13*(_3->Z-_1->Z),
								_1->X+M14*(_4->X-_1->X), _1->Y+M14*(_4->Y-_1->Y), _1->Z+M14*(_4->Z-_1->Z)
								));
						}
					}
				}
				for(double v=std::floor((_2->V<Vstart?Vstart:_2->V)/Vstep), vEnd=std::floor((_3->V>Vend?Vend:_3->V)/Vstep);v<=vEnd;++v)
				{
					double VL=Vstep*v;
					if(_2->V<=VL&&VL<_3->V)
					{
						double M13, M23, M24, M14;
						if(getPos(M13, VL, *_1, *_3)&&getPos(M23, VL, *_2, *_3)&&getPos(M24, VL, *_2, *_4)&&getPos(M14, VL, *_1, *_4))
						{
							double
								X13=_1->X+M13*(_3->X-_1->X), Y13=_1->Y+M13*(_3->Y-_1->Y), Z13=_1->Z+M13*(_3->Z-_1->Z),
								X23=_2->X+M23*(_3->X-_2->X), Y23=_2->Y+M23*(_3->Y-_2->Y), Z23=_2->Z+M23*(_3->Z-_2->Z),
								X24=_2->X+M24*(_4->X-_2->X), Y24=_2->Y+M24*(_4->Y-_2->Y), Z24=_2->Z+M24*(_4->Z-_2->Z),
								X14=_1->X+M14*(_4->X-_1->X), Y14=_1->Y+M14*(_4->Y-_1->Y), Z14=_1->Z+M14*(_4->Z-_1->Z);
							contour->operator[](int(v)).push_back(_3D::Triangle(X13, Y13, Z13, X23, Y23, Z23, X24, Y24, Z24));
							contour->operator[](int(v)).push_back(_3D::Triangle(X13, Y13, Z13, X14, Y14, Z14, X24, Y24, Z24));
						}
					}
				}
				for(double v=std::floor((_3->V<Vstart?Vstart:_3->V)/Vstep), vEnd=std::floor((_4->V>Vend?Vend:_4->V)/Vstep);v<=vEnd;++v)
				{
					double VL=Vstep*v;
					if(_3->V<=VL&&VL<_4->V)
					{
						double M14, M24, M34;
						if(getPos(M14, VL, *_1, *_4)&&getPos(M24, VL, *_2, *_4)&&getPos(M34, VL, *_3, *_4))
						{
							contour->operator[](int(v)).push_back(_3D::Triangle(
								_1->X+M14*(_4->X-_1->X), _1->Y+M14*(_4->Y-_1->Y), _1->Z+M14*(_4->Z-_1->Z),
								_2->X+M24*(_4->X-_2->X), _2->Y+M24*(_4->Y-_2->Y), _2->Z+M24*(_4->Z-_2->Z),
								_3->X+M34*(_4->X-_3->X), _3->Y+M34*(_4->Y-_3->Y), _3->Z+M34*(_4->Z-_3->Z)
								));
						}
					}
				}
			};
			double dispYstart=AR_Y*solver.Ystart, dispZstart=AR_Z*solver.Zstart;
			for(unsigned vz=0, vzEnd=Zplaces-1;vz<vzEnd;++vz)
			{
				for(unsigned vy=0, vyEnd=Yplaces-1;vy<vyEnd;++vy)
				{
					for(unsigned vx=0, vxEnd=Xplaces-1;vx<vxEnd;++vx)
					{
						X0=solver.Xstart+Xs*vx, X1=solver.Xstart+Xs*(vx+1);
						Y0=   dispYstart+Xs*vy, Y1=   dispYstart+Xs*(vy+1);
						Z0=   dispZstart+Xs*vz, Z1=   dispZstart+Xs*(vz+1);
						double Xm=solver.Xstart+Xs*(vx+.5), Ym=dispYstart+Xs*(vy+.5), Zm=dispZstart+Xs*(vz+.5);		//display env units		faster

					//	X0=solver.Xstart+Xs*vx, X1=solver.Xstart+Xs*(vx+1);
					//	Y0=AR_Y*solver.Ystart+Xs*vy, Y1=AR_Y*solver.Ystart+Xs*(vy+1);
					//	Z0=AR_Z*solver.Zstart+Xs*vz, Z1=AR_Z*solver.Zstart+Xs*(vz+1);
					//	double Xm=solver.Xstart+Xs*(vx+.5), Ym=AR_Y*solver.Ystart+Xs*(vy+.5), Zm=AR_Z*solver.Zstart+Xs*(vz+.5);		//display env units		faster

					//	X0=solver.Xstart+Xs*vx, X1=solver.Xstart+Xs*(vx+1);
					//	Y0=solver.Ystart+Xs/AR_Y*vy, Y1=solver.Ystart+Xs/AR_Y*(vy+1);
					//	Z0=solver.Zstart+Xs/AR_Z*vz, Z1=solver.Zstart+Xs/AR_Z*(vz+1);
					//	double Xm=solver.Xstart+Xs*(vx+.5), Ym=solver.Ystart+Xs/AR_Y*(vy+.5), Zm=solver.Zstart+Xs/AR_Z*(vz+.5);		//math env units		multiply by gain at draw
							
						Double_X_Y_Z_V//zyx matrix notation
							P000(X0, Y0, Z0, V000=(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]),
							P001(X1, Y0, Z0, V001=(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx+1].r)[c]),
							P010(X0, Y1, Z0, V010=(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ].r)[c]),
							P011(X1, Y1, Z0, V011=(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx+1].r)[c]),
							P100(X0, Y0, Z1, V100=(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ].r)[c]),
							P101(X1, Y0, Z1, V101=(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx+1].r)[c]),
							P110(X0, Y1, Z1, V110=(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx  ].r)[c]),
							P111(X1, Y1, Z1, V111=(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx+1].r)[c]),
							
							P00m(Xm, Y0, Z0, .5*(V000+V001)),
							P01m(Xm, Y1, Z0, .5*(V010+V011)),
							P10m(Xm, Y0, Z1, .5*(V100+V101)),
							P11m(Xm, Y1, Z1, .5*(V110+V111)),

							P0m0(X0, Ym, Z0, .5*(V000+V010)),
							P0m1(X1, Ym, Z0, .5*(V001+V011)),
							P1m0(X0, Ym, Z1, .5*(V100+V110)),
							P1m1(X1, Ym, Z1, .5*(V101+V111)),

							Pm00(X0, Y0, Zm, .5*(V000+V100)),
							Pm01(X1, Y0, Zm, .5*(V001+V101)),
							Pm10(X0, Y1, Zm, .5*(V010+V110)),
							Pm11(X1, Y1, Zm, .5*(V011+V111)),

							P0mm(Xm, Ym, Z0, .25*(V000+V001+V010+V011)),
							P1mm(Xm, Ym, Z1, .25*(V100+V101+V110+V111)),

							Pm0m(Xm, Y0, Zm, .25*(V000+V001+V100+V101)),
							Pm1m(Xm, Y1, Zm, .25*(V010+V011+V110+V111)),

							Pmm0(X0, Ym, Zm, .25*(V000+V010+V100+V110)),
							Pmm1(X1, Ym, Zm, .25*(V001+V011+V101+V111)),

							Pmmm(Xm, Ym, Zm, .125*(V000+V001+V010+V011+V100+V101+V110+V111));

						cutTrap(Pm00, Pm0m, P000, Pmmm);
						cutTrap(Pm0m, P00m, P000, Pmmm);
						cutTrap(P00m, P0mm, P000, Pmmm);
						cutTrap(P0mm, P0m0, P000, Pmmm);
						cutTrap(P0m0, Pmm0, P000, Pmmm);
						cutTrap(Pmm0, Pm00, P000, Pmmm);
						
						cutTrap(Pm01, Pm0m, P001, Pmmm);
						cutTrap(Pm0m, P00m, P001, Pmmm);
						cutTrap(P00m, P0mm, P001, Pmmm);
						cutTrap(P0mm, P0m1, P001, Pmmm);
						cutTrap(P0m1, Pmm1, P001, Pmmm);
						cutTrap(Pmm1, Pm01, P001, Pmmm);
						
						cutTrap(Pm10, Pm1m, P010, Pmmm);
						cutTrap(Pm1m, P01m, P010, Pmmm);
						cutTrap(P01m, P0mm, P010, Pmmm);
						cutTrap(P0mm, P0m0, P010, Pmmm);
						cutTrap(P0m0, Pmm0, P010, Pmmm);
						cutTrap(Pmm0, Pm10, P010, Pmmm);
						
						cutTrap(Pm11, Pm1m, P011, Pmmm);
						cutTrap(Pm1m, P01m, P011, Pmmm);
						cutTrap(P01m, P0mm, P011, Pmmm);
						cutTrap(P0mm, P0m1, P011, Pmmm);
						cutTrap(P0m1, Pmm1, P011, Pmmm);
						cutTrap(Pmm1, Pm11, P011, Pmmm);
						
						cutTrap(Pm00, Pm0m, P100, Pmmm);
						cutTrap(Pm0m, P10m, P100, Pmmm);
						cutTrap(P10m, P1mm, P100, Pmmm);
						cutTrap(P1mm, P1m0, P100, Pmmm);
						cutTrap(P1m0, Pmm0, P100, Pmmm);
						cutTrap(Pmm0, Pm00, P100, Pmmm);
						
						cutTrap(Pm01, Pm0m, P101, Pmmm);
						cutTrap(Pm0m, P10m, P101, Pmmm);
						cutTrap(P10m, P1mm, P101, Pmmm);
						cutTrap(P1mm, P1m1, P101, Pmmm);
						cutTrap(P1m1, Pmm1, P101, Pmmm);
						cutTrap(Pmm1, Pm01, P101, Pmmm);
						
						cutTrap(Pm10, Pm1m, P110, Pmmm);
						cutTrap(Pm1m, P11m, P110, Pmmm);
						cutTrap(P11m, P1mm, P110, Pmmm);
						cutTrap(P1mm, P1m0, P110, Pmmm);
						cutTrap(P1m0, Pmm0, P110, Pmmm);
						cutTrap(Pmm0, Pm10, P110, Pmmm);
						
						cutTrap(Pm11, Pm1m, P111, Pmmm);
						cutTrap(Pm1m, P11m, P111, Pmmm);
						cutTrap(P11m, P1mm, P111, Pmmm);
						cutTrap(P1mm, P1m1, P111, Pmmm);
						cutTrap(P1m1, Pmm1, P111, Pmmm);
						cutTrap(Pmm1, Pm11, P111, Pmmm);
					}
				}
			}
			decltype(&Rlines[e]) lines=0;
			switch(e)
			{
			case 0:lines=&Rlines[e];break;
			case 1:lines=&Ilines[e];break;
			case 2:lines=&Jlines[e];break;
			case 3:lines=&Klines[e];break;
			}
			for(auto &level:*contour)
			{
				for(auto &T:level.second)
				{
					double *X1, *Y1, *V1, *X2, *Y2, *V2, *X3, *Y3, *V3;
					if(T.Z1<T.Z2)//12
					{
							 if(T.Z2<T.Z3)	X1=&T.X1, Y1=&T.Y1, V1=&T.Z1, X2=&T.X2, Y2=&T.Y2, V2=&T.Z2, X3=&T.X3, Y3=&T.Y3, V3=&T.Z3;
						else if(T.Z1<T.Z3)	X1=&T.X1, Y1=&T.Y1, V1=&T.Z1, X2=&T.X3, Y2=&T.Y3, V2=&T.Z3, X3=&T.X2, Y3=&T.Y2, V3=&T.Z2;
						else				X1=&T.X3, Y1=&T.Y3, V1=&T.Z3, X2=&T.X1, Y2=&T.Y1, V2=&T.Z1, X3=&T.X2, Y3=&T.Y2, V3=&T.Z2;
					}
					else//21
					{
							 if(T.Z1<T.Z3)	X1=&T.X2, Y1=&T.Y2, V1=&T.Z2, X2=&T.X1, Y2=&T.Y1, V2=&T.Z1, X3=&T.X3, Y3=&T.Y3, V3=&T.Z3;
						else if(T.Z2<T.Z3)	X1=&T.X2, Y1=&T.Y2, V1=&T.Z2, X2=&T.X3, Y2=&T.Y3, V2=&T.Z3, X3=&T.X1, Y3=&T.Y1, V3=&T.Z1;
						else				X1=&T.X3, Y1=&T.Y3, V1=&T.Z3, X2=&T.X2, Y2=&T.Y2, V2=&T.Z2, X3=&T.X1, Y3=&T.Y1, V3=&T.Z1;
					}
					double X13, Y13;
					{
						double Zr=(*V2-*V1)/(*V3-*V1);
						X13=*X1+Zr*(*X3-*X1), Y13=*Y1+Zr*(*Y3-*Y1);//V13=V2;
					}
					//for V1 -> V2
					for(double v=std::floor((*V1<Vstart?Vstart:*V1)/Vstep), zEnd=std::floor((*V2>Vend?Vend:*V2)/Vstep);v<=zEnd;++v)
					{
						double ZL=Vstep*v;
						if(*V1<=ZL&&ZL<*V2)
						{
							double M=(ZL-*V1)/(*V2-*V1);
							lines->operator[](level.first).push_back(_3D::Stick(*X1+M*(*X2-*X1), *Y1+M*(*Y2-*Y1), ZL, *X1+M*(X13-*X1), *Y1+M*(Y13-*Y1), ZL));
						}
					}
					//for V2 -> V3
					for(double v=std::floor((*V2<Vstart?Vstart:*V2)/Vstep), zEnd=std::floor((*V3>Vend?Vend:*V3)/Vstep);v<=zEnd;++v)
					{
						double ZL=Vstep*v;
						if(*V2<=ZL&&ZL<*V3)
						{
							double M=(ZL-*V2)/(*V3-*V2);
							lines->operator[](level.first).push_back(_3D::Stick(*X2+M*(*X3-*X2), *Y2+M*(*Y3-*Y2), ZL, X13+M*(*X3-X13), Y13+M*(*Y3-Y13), ZL));
						}
					}
				}
			}
		/*	double Zstart=VZ-DZ/2, Zend=VZ+DZ/2;
			for(auto &level:*contour)
			{
				for(auto &T:level.second)
				{
					double *X1, *Y1, *Z1, *X2, *Y2, *Z2, *X3, *Y3, *Z3;
					if(T.Z1<T.Z2)//12
					{
							 if(T.Z2<T.Z3)	X1=&T.X1, Y1=&T.Y1, Z1=&T.Z1, X2=&T.X2, Y2=&T.Y2, Z2=&T.Z2, X3=&T.X3, Y3=&T.Y3, Z3=&T.Z3;
						else if(T.Z1<T.Z3)	X1=&T.X1, Y1=&T.Y1, Z1=&T.Z1, X2=&T.X3, Y2=&T.Y3, Z2=&T.Z3, X3=&T.X2, Y3=&T.Y2, Z3=&T.Z2;
						else				X1=&T.X3, Y1=&T.Y3, Z1=&T.Z3, X2=&T.X1, Y2=&T.Y1, Z2=&T.Z1, X3=&T.X2, Y3=&T.Y2, Z3=&T.Z2;
					}
					else//21
					{
							 if(T.Z1<T.Z3)	X1=&T.X2, Y1=&T.Y2, Z1=&T.Z2, X2=&T.X1, Y2=&T.Y1, Z2=&T.Z1, X3=&T.X3, Y3=&T.Y3, Z3=&T.Z3;
						else if(T.Z2<T.Z3)	X1=&T.X2, Y1=&T.Y2, Z1=&T.Z2, X2=&T.X3, Y2=&T.Y3, Z2=&T.Z3, X3=&T.X1, Y3=&T.Y1, Z3=&T.Z1;
						else				X1=&T.X3, Y1=&T.Y3, Z1=&T.Z3, X2=&T.X2, Y2=&T.Y2, Z2=&T.Z2, X3=&T.X1, Y3=&T.Y1, Z3=&T.Z1;
					}
					double X13, Y13;
				//	{
						double Zr=(*Z2-*Z1)/(*Z3-*Z1);
						X13=*X1+Zr*(*X3-*X1), Y13=*Y1+Zr*(*Y3-*Y1);//Z13=Z2;
				//	}
					//for Z1 -> Z2
					for(double z=std::floor((*Z1<Zstart?Zstart:*Z1)/step), zEnd=std::floor((*Z2>Zend?Zend:*Z2)/step);z<=zEnd;++z)
					{
						double ZL=step*z;
					//	ZL=std::floor(Zstart/step)+11;//
						if(*Z1<=ZL&&ZL<*Z2)
						{
							double M=(ZL-*Z1)/(*Z2-*Z1);
							lines->operator[](level.first).push_back(_3D::Stick(*X1+M*(*X2-*X1), *Y1+M*(*Y2-*Y1), ZL, *X1+M*(X13-*X1), *Y1+M*(Y13-*Y1), ZL));
						//	if(std::abs(lines->operator[](level.first).rbegin()->X2-lines->operator[](level.first).rbegin()->X1)>5)
						//		int LOL_2=0;
						}
					//	break;//
					}
					//for V2 -> V3
					for(double z=std::floor((*Z2<Zstart?Zstart:*Z2)/step), zEnd=std::floor((*Z3>Zend?Zend:*Z3)/step);z<=zEnd;++z)
					{
						double ZL=step*z;
					//	ZL=std::floor(Zstart/step)+11;//
						if(*Z2<=ZL&&ZL<*Z3)
						{
							double M=(ZL-*Z2)/(*Z3-*Z2);
							lines->operator[](level.first).push_back(_3D::Stick(*X2+M*(*X3-*X2), *Y2+M*(*Y3-*Y2), ZL, X13+M*(*X3-X13), Y13+M*(*Y3-Y13), ZL));
						//	if(std::abs(lines->operator[](level.first).rbegin()->X2-lines->operator[](level.first).rbegin()->X1)>5)
						//		int LOL_2=0;
						}
					//	break;//
					}
				}
			}//*/
		/*	for(auto &level:*contour)
			{
				auto &lines_l=lines->operator[](level.first);
				for(auto &T:level.second)
				{
					double *X1, *Y1, *Z1, *X2, *Y2, *Z2, *X3, *Y3, *Z3;
					if(T.Z1<T.Z2)//12
					{
							 if(T.Z2<T.Z3)	X1=&T.X1, Y1=&T.Y1, Z1=&T.Z1, X2=&T.X2, Y2=&T.Y2, Z2=&T.Z2, X3=&T.X3, Y3=&T.Y3, Z3=&T.Z3;
						else if(T.Z1<T.Z3)	X1=&T.X1, Y1=&T.Y1, Z1=&T.Z1, X2=&T.X3, Y2=&T.Y3, Z2=&T.Z3, X3=&T.X2, Y3=&T.Y2, Z3=&T.Z2;
						else				X1=&T.X3, Y1=&T.Y3, Z1=&T.Z3, X2=&T.X1, Y2=&T.Y1, Z2=&T.Z1, X3=&T.X2, Y3=&T.Y2, Z3=&T.Z2;
					}
					else//21
					{
							 if(T.Z2<T.Z3)	X1=&T.X1, Y1=&T.Y1, Z1=&T.Z1, X2=&T.X2, Y2=&T.Y2, Z2=&T.Z2, X3=&T.X3, Y3=&T.Y3, Z3=&T.Z3;
						else if(T.Z1<T.Z3)	X1=&T.X1, Y1=&T.Y1, Z1=&T.Z1, X2=&T.X3, Y2=&T.Y3, Z2=&T.Z3, X3=&T.X2, Y3=&T.Y2, Z3=&T.Z2;
						else				X1=&T.X3, Y1=&T.Y3, Z1=&T.Z3, X2=&T.X1, Y2=&T.Y1, Z2=&T.Z1, X3=&T.X2, Y3=&T.Y2, Z3=&T.Z2;
					}
					double X13, Y13;
					{
						double Zr=(*Z2-*Z1)/(*Z3-*Z1);
						X13=*X1+Zr*(*X3-*X1), Y13=*Y1+Zr*(*Y3-*Y1);//Z13=Z2;
					}
					//for Z1 -> Z2
					for(double z=std::floor((*Z1<Vstart?Vstart:*Z1)/Vstep), zEnd=std::floor((*Z2>Vend?Vend:*Z2)/Vstep);z<=zEnd;++z)
					{
						double VL=Vstep*z;
						if(*Z1<=VL&&VL<*Z2)
						{
							double M=(VL-*Z1)/(*Z2-*Z1);
							lines_l[level.first].push_back(H_Stick(*X1+M*(*X2-*X1), *Y1+M*(*Y2-*Y1), *X1+M*(X13-*X1), *Y1+M*(Y13-*Y1)));
						}
					}
					//for V2 -> V3
					for(double z=std::floor((*Z2<Vstart?Vstart:*Z2)/Vstep), zEnd=std::floor((*Z3>Vend?Vend:*Z3)/Vstep);z<=zEnd;++z)
					{
						double VL=Vstep*z;
						if(*Z2<=VL&&VL<*Z3)
						{
							double M=(VL-*Z2)/(*Z3-*Z2);
							lines_l[level.first].push_back(H_Stick(*X2+M*(*X3-*X2), *Y2+M*(*Y3-*Y2), X13+M*(*X3-X13), Y13+M*(*Y3-Y13)));
						}
					}
				}
			}//*/
		}
		void doContour(unsigned e, double Xs, double Vstart, double Vend, double Vstep, unsigned nvSteps)
		{
			Vstep*=10;//
			switch(expr[e].resultMathSet)
		//	switch(expr[e].n[0].mathSet)
			{
			case 'r':
		//	case 'R':
				doContour_component(e, 0, Xs, Vstart, Vend, Vstep, nvSteps);
				break;
			case 'c':
		//	case 'C':
				doContour_component(e, 0, Xs, Vstart, Vend, Vstep, nvSteps);
				doContour_component(e, 1, Xs, Vstart, Vend, Vstep, nvSteps);
				break;
			case 'H':
				doContour_component(e, 0, Xs, Vstart, Vend, Vstep, nvSteps);
				doContour_component(e, 1, Xs, Vstart, Vend, Vstep, nvSteps);
				doContour_component(e, 2, Xs, Vstart, Vend, Vstep, nvSteps);
				doContour_component(e, 3, Xs, Vstart, Vend, Vstep, nvSteps);
				break;
			}
		}
		void doOperations						(std::vector<Value> &ndr)
		{
			for(auto &op:operations)
			{
				switch(op)
				{
				case  1:differentiate_xyz					(ndr);break;
				case  2:differentiate_x						(ndr);break;
				case  3:differentiate_y						(ndr);break;
				case  4:differentiate_z						(ndr);break;
				case  5:differentiate_xy					(ndr);break;
				case  6:differentiate_yz					(ndr);break;
				case  7:differentiate_xz					(ndr);break;
				case  8:integrate_xyz						(ndr);break;
				case  9:integrate_x							(ndr);break;
				case 10:integrate_y							(ndr);break;
				case 11:integrate_z							(ndr);break;
				case 12:integrate_xy						(ndr);break;
				case 13:integrate_yz						(ndr);break;
				case 14:integrate_xz						(ndr);break;
				case 15:discreteFourrierTransform			(ndr);break;
				case 16:inverseDiscreteFourrierTransform	(ndr);break;
				case 17:lowPassFilter_xyz					(ndr);break;
				case 18:lowPassFilter_x						(ndr);break;
				case 19:lowPassFilter_y						(ndr);break;
				case 20:lowPassFilter_z						(ndr);break;
				case 21:lowPassFilter_xy					(ndr);break;
				case 22:lowPassFilter_yz					(ndr);break;
				case 23:lowPassFilter_xz					(ndr);break;
				case 24:highPassFilter_xyz					(ndr);break;
				case 25:highPassFilter_x					(ndr);break;
				case 26:highPassFilter_y					(ndr);break;
				case 27:highPassFilter_z					(ndr);break;
				case 28:highPassFilter_xy					(ndr);break;
				case 29:highPassFilter_yz					(ndr);break;
				case 30:highPassFilter_xz					(ndr);break;
				}
			}
		}
		void differentiate_xyz					(std::vector<Value> &ndr)
		{
			int nComponents=0;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			double step=DX/Xplaces;
			for(int vz=0;vz<Zplaces-1;++vz)
			{
				for(int vy=0;vy<Yplaces-1;++vy)
				{
					for(int vx=0;vx<Xplaces-1;++vx)
					{
						auto
							&V000=ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ],
							&V001=ndr[Xplaces*(Yplaces* vz   +vy  )+vx+1],
							&V010=ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ],
							&V100=ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ];
						for(int c=0;c<nComponents;++c)
							(&V000.r)[c]=((&V001.r)[c]+(&V010.r)[c]+(&V100.r)[c]-3*(&V000.r)[c])/step;
					}
					auto
						&V000=ndr[Xplaces*(Yplaces* vz   +vy  )+Xplaces-1],
						&V010=ndr[Xplaces*(Yplaces* vz   +vy+1)+Xplaces-1],
						&V100=ndr[Xplaces*(Yplaces*(vz+1)+vy  )+Xplaces-1];
					for(int c=0;c<nComponents;++c)
						(&V000.r)[c]=((&V010.r)[c]+(&V100.r)[c]-3*(&V000.r)[c])/step;
				}
				for(int vx=0;vx<Xplaces-1;++vx)
				{
					auto
						&V000=ndr[Xplaces*(Yplaces* vz   +Yplaces-1)+vx  ],
						&V001=ndr[Xplaces*(Yplaces* vz   +Yplaces-1)+vx+1],
						&V100=ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1)+vx  ];
					for(int c=0;c<nComponents;++c)
						(&V000.r)[c]=((&V001.r)[c]+(&V100.r)[c]-3*(&V000.r)[c])/step;
				}
				auto
					&V000=ndr[Xplaces*(Yplaces* vz   +Yplaces-1)+Xplaces-1],
					&V100=ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1)+Xplaces-1];
				for(int c=0;c<nComponents;++c)
					(&V000.r)[c]=((&V100.r)[c]-3*(&V000.r)[c])/step;
			}
			for(int vy=0;vy<Yplaces-1;++vy)
			{
				for(int vx=0;vx<Xplaces-1;++vx)
				{
					auto
						&V000=ndr[Xplaces*(Yplaces*(Zplaces-1)+vy  )+vx  ],
						&V001=ndr[Xplaces*(Yplaces*(Zplaces-1)+vy  )+vx+1],
						&V010=ndr[Xplaces*(Yplaces*(Zplaces-1)+vy+1)+vx  ];
					for(int c=0;c<nComponents;++c)
						(&V000.r)[c]=((&V001.r)[c]+(&V010.r)[c]-3*(&V000.r)[c])/step;
				}
				auto
					&V000=ndr[Xplaces*(Yplaces*(Zplaces-1)+vy  )+Xplaces-1],
					&V010=ndr[Xplaces*(Yplaces*(Zplaces-1)+vy+1)+Xplaces-1];
				for(int c=0;c<nComponents;++c)
					(&V000.r)[c]=((&V010.r)[c]-3*(&V000.r)[c])/step;
			}
			auto &V000=*ndr.rbegin();
			for(int c=0;c<nComponents;++c)
				(&V000.r)[c]*=-3/step;
		}
		void differentiate_x					(std::vector<Value> &ndr)
		{
			int nComponents=0;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			double step=DX/Xplaces;
			for(int vz=0;vz<Zplaces;++vz)
			{
				for(int vy=0;vy<Yplaces;++vy)
				{
					for(int vx=0;vx<Xplaces-1;++vx)
					{
						auto
							&V000=ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ],
							&V001=ndr[Xplaces*(Yplaces* vz   +vy  )+vx+1];
						for(int c=0;c<nComponents;++c)
							(&V000.r)[c]=((&V001.r)[c]-(&V000.r)[c])/step;
					}
					auto
						&V000=ndr[Xplaces*(Yplaces* vz   +vy  )+Xplaces-1];
					for(int c=0;c<nComponents;++c)
						(&V000.r)[c]/=-step;
				}
			}
		}
		void differentiate_y					(std::vector<Value> &ndr)
		{
			int nComponents=0;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			double step=DX/Xplaces;
			for(int vz=0;vz<Zplaces;++vz)
			{
				for(int vy=0;vy<Yplaces-1;++vy)
				{
					for(int vx=0;vx<Xplaces;++vx)
					{
						auto
							&V000=ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ],
							&V010=ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ];
						for(int c=0;c<nComponents;++c)
							(&V000.r)[c]=((&V010.r)[c]-(&V000.r)[c])/step;
					}
				}
				for(int vx=0;vx<Xplaces;++vx)
				{
					auto
						&V000=ndr[Xplaces*(Yplaces* vz   +Yplaces-1)+vx  ];
					for(int c=0;c<nComponents;++c)
						(&V000.r)[c]/=-step;
				}
			}
		}
		void differentiate_z					(std::vector<Value> &ndr)
		{
			int nComponents=0;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			double step=DX/Xplaces;
			for(int vz=0;vz<Zplaces-1;++vz)
			{
				for(int vy=0;vy<Yplaces;++vy)
				{
					for(int vx=0;vx<Xplaces;++vx)
					{
						auto
							&V000=ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ],
							&V100=ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ];
						for(int c=0;c<nComponents;++c)
							(&V000.r)[c]=((&V100.r)[c]-(&V000.r)[c])/step;
					}
				}
			}
			for(int vy=0;vy<Yplaces;++vy)
			{
				for(int vx=0;vx<Xplaces;++vx)
				{
					auto
						&V000=ndr[Xplaces*(Yplaces*(Zplaces-1)+vy  )+vx  ];
					for(int c=0;c<nComponents;++c)
						(&V000.r)[c]/=-step;
				}
			}
		}
		void differentiate_xy					(std::vector<Value> &ndr)
		{
			int nComponents=0;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			double step=DX/Xplaces;
			for(int vz=0;vz<Zplaces;++vz)
			{
				for(int vy=0;vy<Yplaces-1;++vy)
				{
					for(int vx=0;vx<Xplaces-1;++vx)
					{
						auto
							&V000=ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ],
							&V001=ndr[Xplaces*(Yplaces* vz   +vy  )+vx+1],
							&V010=ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ];
						for(int c=0;c<nComponents;++c)
							(&V000.r)[c]=((&V001.r)[c]+(&V010.r)[c]-2*(&V000.r)[c])/step;
					}
					auto
						&V000=ndr[Xplaces*(Yplaces* vz   +vy  )+Xplaces-1],
						&V010=ndr[Xplaces*(Yplaces* vz   +vy+1)+Xplaces-1];
					for(int c=0;c<nComponents;++c)
						(&V000.r)[c]=((&V010.r)[c]-2*(&V000.r)[c])/step;
				}
				for(int vx=0;vx<Xplaces-1;++vx)
				{
					auto
						&V000=ndr[Xplaces*(Yplaces* vz   +Yplaces-1)+vx  ],
						&V001=ndr[Xplaces*(Yplaces* vz   +Yplaces-1)+vx+1];
					for(int c=0;c<nComponents;++c)
						(&V000.r)[c]=((&V001.r)[c]-2*(&V000.r)[c])/step;
				}
				auto
					&V000=ndr[Xplaces*(Yplaces* vz   +Yplaces-1)+Xplaces-1];
				for(int c=0;c<nComponents;++c)
					(&V000.r)[c]*=-2/step;
			}
		}
		void differentiate_yz					(std::vector<Value> &ndr)
		{
			int nComponents=0;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			double step=DX/Xplaces;
			for(int vz=0;vz<Zplaces-1;++vz)
			{
				for(int vy=0;vy<Yplaces-1;++vy)
				{
					for(int vx=0;vx<Xplaces;++vx)
					{
						auto
							&V000=ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ],
							&V010=ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ],
							&V100=ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ];
						for(int c=0;c<nComponents;++c)
							(&V000.r)[c]=((&V010.r)[c]+(&V100.r)[c]-2*(&V000.r)[c])/step;
					}
				}
				for(int vx=0;vx<Xplaces;++vx)
				{
					auto
						&V000=ndr[Xplaces*(Yplaces* vz   +Yplaces-1)+vx  ],
						&V100=ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1)+vx  ];
					for(int c=0;c<nComponents;++c)
						(&V000.r)[c]=((&V100.r)[c]-2*(&V000.r)[c])/step;
				}
			}
			for(int vy=0;vy<Yplaces-1;++vy)
			{
				for(int vx=0;vx<Xplaces;++vx)
				{
					auto
						&V000=ndr[Xplaces*(Yplaces*(Zplaces-1)+vy  )+vx  ],
						&V010=ndr[Xplaces*(Yplaces*(Zplaces-1)+vy+1)+vx  ];
					for(int c=0;c<nComponents;++c)
						(&V000.r)[c]=((&V010.r)[c]-2*(&V000.r)[c])/step;
				}
			}
			auto &V000=*ndr.rbegin();
			for(int c=0;c<nComponents;++c)
				(&V000.r)[c]*=-2/step;
		}
		void differentiate_xz					(std::vector<Value> &ndr)
		{
			int nComponents=0;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			double step=DX/Xplaces;
			for(int vz=0;vz<Zplaces-1;++vz)
			{
				for(int vy=0;vy<Yplaces;++vy)
				{
					for(int vx=0;vx<Xplaces-1;++vx)
					{
						auto
							&V000=ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ],
							&V001=ndr[Xplaces*(Yplaces* vz   +vy  )+vx+1],
							&V100=ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ];
						for(int c=0;c<nComponents;++c)
							(&V000.r)[c]=((&V001.r)[c]+(&V100.r)[c]-2*(&V000.r)[c])/step;
					}
					auto
						&V000=ndr[Xplaces*(Yplaces* vz   +vy  )+Xplaces-1],
						&V100=ndr[Xplaces*(Yplaces*(vz+1)+vy  )+Xplaces-1];
					for(int c=0;c<nComponents;++c)
						(&V000.r)[c]=((&V100.r)[c]-2*(&V000.r)[c])/step;
				}
			}
			for(int vy=0;vy<Yplaces;++vy)
			{
				for(int vx=0;vx<Xplaces-1;++vx)
				{
					auto
						&V000=ndr[Xplaces*(Yplaces*(Zplaces-1)+vy  )+vx  ],
						&V001=ndr[Xplaces*(Yplaces*(Zplaces-1)+vy  )+vx+1];
					for(int c=0;c<nComponents;++c)
						(&V000.r)[c]=((&V001.r)[c]-2*(&V000.r)[c])/step;
				}
				auto
					&V000=ndr[Xplaces*(Yplaces*(Zplaces-1)+vy  )+Xplaces-1];
				for(int c=0;c<nComponents;++c)
					(&V000.r)[c]*=-2/step;
			}
		}
		void integrate_xyz						(std::vector<Value> &ndr)
		{
			int nComponents=0;
			std::vector<double> Zsum[4], ZYsum[4];
			double ZYXsum[4]={0};
			int ZsumSize=Xplaces*Yplaces;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			for(int c=0;c<nComponents;++c)
				Zsum[c].resize(ZsumSize), ZYsum[c].resize(Xplaces);
			double step=DX/Xplaces;
			for(int vz=0;vz<Zplaces;++vz)
			{
				for(int vy=0;vy<Yplaces;++vy)
				{
					for(int vx=0;vx<Xplaces;++vx)
					{
						auto &V000=ndr[Xplaces*(Yplaces*vz+vy)+vx];
						for(int c=0;c<nComponents;++c)
							(&V000.r)[c]=(ZYXsum[c]+=ZYsum[c][vx]+=Zsum[c][Xplaces*vy+vx]+=(&V000.r)[c])*step;
					}
					for(int c=0;c<nComponents;++c)
						ZYXsum[c]=0;
				}
				for(int c=0;c<nComponents;++c)
					std::fill(ZYsum[c].begin(), ZYsum[c].end(), 0);
			}
		}
		void integrate_x						(std::vector<Value> &ndr)
		{
			int nComponents=0;
			double Xsum[4]={0};
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			double step=DX/Xplaces;
			for(int vz=0;vz<Zplaces;++vz)
			{
				for(int vy=0;vy<Yplaces;++vy)
				{
					for(int vx=0;vx<Xplaces;++vx)
					{
						auto &V000=ndr[Xplaces*(Yplaces*vz+vy)+vx];
						for(int c=0;c<nComponents;++c)
							(&V000.r)[c]=(Xsum[c]+=(&V000.r)[c])*step;
					}
					for(int c=0;c<nComponents;++c)
						Xsum[c]=0;
				}
			}
		}
		void integrate_y						(std::vector<Value> &ndr)
		{
			int nComponents=0;
			std::vector<double> Ysum[4];
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			for(int c=0;c<nComponents;++c)
				Ysum[c].resize(Xplaces);
			double step=DX/Xplaces;
			for(int vz=0;vz<Zplaces;++vz)
			{
				for(int vy=0;vy<Yplaces;++vy)
				{
					for(int vx=0;vx<Xplaces;++vx)
					{
						auto &V000=ndr[Xplaces*(Yplaces*vz+vy)+vx];
						for(int c=0;c<nComponents;++c)
							(&V000.r)[c]=(Ysum[c][vx]+=(&V000.r)[c])*step;
					}
				}
				for(int c=0;c<nComponents;++c)
					std::fill(Ysum[c].begin(), Ysum[c].end(), 0);
			}
		}
		void integrate_z						(std::vector<Value> &ndr)
		{
			int nComponents=0;
			std::vector<double> Zsum[4];
			int ZsumSize=Xplaces*Yplaces;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			for(int c=0;c<nComponents;++c)
				Zsum[c].resize(ZsumSize);
			double step=DX/Xplaces;
			for(int vz=0;vz<Zplaces;++vz)
			{
				for(int vy=0;vy<Yplaces;++vy)
				{
					for(int vx=0;vx<Xplaces;++vx)
					{
						auto &V000=ndr[Xplaces*(Yplaces*vz+vy)+vx];
						for(int c=0;c<nComponents;++c)
							(&V000.r)[c]=(Zsum[c][Xplaces*vy+vx]+=(&V000.r)[c])*step;
					}
				}
			}
		}
		void integrate_xy						(std::vector<Value> &ndr)
		{
			int nComponents=0;
			std::vector<double> Ysum[4];
			double YXsum[4]={0};
			int ZsumSize=Xplaces*Yplaces;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			for(int c=0;c<nComponents;++c)
				Ysum[c].resize(Xplaces);
			double step=DX/Xplaces;
			for(int vz=0;vz<Zplaces;++vz)
			{
				for(int vy=0;vy<Yplaces;++vy)
				{
					for(int vx=0;vx<Xplaces;++vx)
					{
						auto &V000=ndr[Xplaces*(Yplaces*vz+vy)+vx];
						for(int c=0;c<nComponents;++c)
							(&V000.r)[c]=(YXsum[c]+=Ysum[c][vx]+=(&V000.r)[c])*step;
					}
					for(int c=0;c<nComponents;++c)
						YXsum[c]=0;
				}
				for(int c=0;c<nComponents;++c)
					std::fill(Ysum[c].begin(), Ysum[c].end(), 0);
			}
		}
		void integrate_yz						(std::vector<Value> &ndr)
		{
			int nComponents=0;
			std::vector<double> Zsum[4], ZYsum[4];
			int ZsumSize=Xplaces*Yplaces;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			for(int c=0;c<nComponents;++c)
				Zsum[c].resize(ZsumSize), ZYsum[c].resize(Xplaces);
			double step=DX/Xplaces;
			for(int vz=0;vz<Zplaces;++vz)
			{
				for(int vy=0;vy<Yplaces;++vy)
				{
					for(int vx=0;vx<Xplaces;++vx)
					{
						auto &V000=ndr[Xplaces*(Yplaces*vz+vy)+vx];
						for(int c=0;c<nComponents;++c)
							(&V000.r)[c]=(ZYsum[c][vx]+=Zsum[c][Xplaces*vy+vx]+=(&V000.r)[c])*step;
					}
				}
				for(int c=0;c<nComponents;++c)
					std::fill(ZYsum[c].begin(), ZYsum[c].end(), 0);
			}
		}
		void integrate_xz						(std::vector<Value> &ndr)
		{
			int nComponents=0;
			std::vector<double> Zsum[4];
			double ZXsum[4]={0};
			int ZsumSize=Xplaces*Yplaces;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			for(int c=0;c<nComponents;++c)
				Zsum[c].resize(ZsumSize);
			double step=DX/Xplaces;
			for(int vz=0;vz<Zplaces;++vz)
			{
				for(int vy=0;vy<Yplaces;++vy)
				{
					for(int vx=0;vx<Xplaces;++vx)
					{
						auto &V000=ndr[Xplaces*(Yplaces*vz+vy)+vx];
						for(int c=0;c<nComponents;++c)
							(&V000.r)[c]=(ZXsum[c]+=Zsum[c][Xplaces*vy+vx]+=(&V000.r)[c])*step;
					}
					for(int c=0;c<nComponents;++c)
						ZXsum[c]=0;
				}
			}
		}
		fftw_complex *fft_in, *fft_out;
		fftw_plan fft_p, ifft_p;
		unsigned fft_N0, fft_N1, fft_N2;
		double fft_sqrt_N;
		void discreteFourrierTransform			(std::vector<Value> &ndr)
		{
			int ndrSize=Xplaces*Yplaces*Zplaces;
			if(fft_N0!=Zplaces||fft_N1!=Yplaces||fft_N2!=Xplaces)
			{
				if(fft_N0||fft_N1||fft_N2)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_N0=Zplaces, fft_N1=Yplaces, fft_N2=Xplaces;
				fft_in=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt(ndrSize);
				fft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE);
				ifft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
			for(int k=0;k<ndrSize;++k)
			{
				unsigned x=k%Xplaces, y=k%Zplaces/Xplaces, z=k/Xplaces/Zplaces;
				int sign=1-((x%2^y%2^z%2)<<1);
				fft_in[k][0]=ndr[k].r*sign, fft_in[k][1]=ndr[k].i*sign;
			}
			fftw_execute(fft_p);
			for(int k=0;k<ndrSize;++k)
				ndr[k].r=fft_out[k][0]/fft_sqrt_N, ndr[k].i=fft_out[k][1]/fft_sqrt_N;
		}
		void inverseDiscreteFourrierTransform	(std::vector<Value> &ndr)
		{
			int ndrSize=Xplaces*Yplaces;
			if(fft_N0!=Zplaces||fft_N1!=Yplaces||fft_N2!=Xplaces)
			{
				if(fft_N0||fft_N1||fft_N2)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_N0=Zplaces, fft_N1=Yplaces, fft_N2=Xplaces;
				fft_in=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt(ndrSize);
				fft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE);
				ifft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
			for(int k=0;k<ndrSize;++k)
				fft_in[k][0]=ndr[k].r, fft_in[k][1]=ndr[k].i;
			fftw_execute(ifft_p);
			for(int k=0;k<ndrSize;++k)
			{
				unsigned x=k%Xplaces, y=k%Zplaces/Xplaces, z=k/Xplaces/Zplaces;
				double gain=(1-((x%2^y%2^z%2)<<1))/fft_sqrt_N;
				ndr[k].r=fft_out[k][0]*gain, ndr[k].i=fft_out[k][1]*gain;
			}
		}
		void lowPassFilter_xyz					(std::vector<Value> &ndr)
		{
			int nComponents=0;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			std::vector<Value> t_ndr(ndr.size());
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* 0   +0  )+0  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces* 0   +0  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0+1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0+1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+0+1].r)[c]
				)/27;
			for(int vx=1;vx<Xplaces-1;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +0  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0+1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+vx+1].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* 0   +0  )+Xplaces-1  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces* 0   +0  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0+1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+Xplaces-1  ].r)[c]
				)/27;
			for(int vy=1;vy<Yplaces-1;++vy)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +vy  )+0  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +vy-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy+1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+0+1].r)[c]
					)/27;
				for(int vx=1;vx<Xplaces-1;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* 0   +vy  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces* 0   +vy-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy+1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+vx+1].r)[c]
						)/27;
				}
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +vy  )+Xplaces-1  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +vy-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+Xplaces-1  ].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+0  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+0+1].r)[c]
				)/27;
			for(int vx=1;vx<Xplaces-1;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+vx+1].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+Xplaces-1  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1+1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1+1)+Xplaces-1  ].r)[c]
				)/27;
			for(int vz=1;vz<Zplaces-1;++vz)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* vz   +0  )+0  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0+1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+0+1].r)[c]
					)/27;
				for(int vx=1;vx<Xplaces-1;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +0  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0+1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+vx+1].r)[c]
						)/27;
				}
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* vz   +0  )+Xplaces-1  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+Xplaces-1  ].r)[c]
					)/27;
				for(int vy=1;vy<Yplaces-1;++vy)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +vy  )+0  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy-1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy-1)+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy  )+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy  )+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy+1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy+1)+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+0+1].r)[c]
						)/27;
					for(int vx=1;vx<Xplaces-1;++vx)
					{
						for(int c=0;c<nComponents;++c)
							(&t_ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]=
							(
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy-1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy-1)+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx+1].r)[c]
							)/27;
					}
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +vy  )+Xplaces-1  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy-1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy-1)+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy  )+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy  )+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy+1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy+1)+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+Xplaces-1  ].r)[c]
						)/27;
				}
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+0  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+0+1].r)[c]
					)/27;
				for(int vx=1;vx<Xplaces-1;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx+1].r)[c]
						)/27;
				}
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+Xplaces-1  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1+1)+Xplaces-1  ].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+0  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+0+1].r)[c]
				)/27;
			for(int vx=1;vx<Xplaces-1;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx+1].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+Xplaces-1  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+Xplaces-1  ].r)[c]
				)/27;
			for(int vy=1;vy<Yplaces-1;++vy)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+0  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+0+1].r)[c]
					)/27;
				for(int vx=1;vx<Xplaces-1;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+vx+1].r)[c]
						)/27;
				}
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+Xplaces-1  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+Xplaces-1  ].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0+1].r)[c]
				)/27;
			for(int vx=1;vx<Xplaces-1;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx+1].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+Xplaces-1  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1+1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1+1)+Xplaces-1  ].r)[c]
				)/27;
		}
		void lowPassFilter_x					(std::vector<Value> &ndr)
		{
			int nComponents=0;
			switch(expr[cursorEx].resultMathSet)
		//	switch(expr[cursorEx].n[0].mathSet)
			{
			case 'r':nComponents=1;break;
			case 'c':nComponents=2;break;
		//	case 'R':nComponents=1;break;
		//	case 'C':nComponents=2;break;
			case 'H':nComponents=4;break;
			}
			std::vector<Value> t_ndr(ndr.size());
			for(int vx=0;vx<Xplaces;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +0  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+vx  ].r)[c]
					)/27;
			}
			for(int vy=1;vy<Yplaces-1;++vy)
			{
				for(int vx=0;vx<Xplaces;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* 0   +vy  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces* 0   +vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+vx  ].r)[c]
						)/27;
				}
			}
			for(int vx=0;vx<Xplaces;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+vx  ].r)[c]
					)/27;
			}
			for(int vz=1;vz<Zplaces-1;++vz)
			{
				for(int vx=0;vx<Xplaces;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +0  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+vx  ].r)[c]
						)/27;
				}
				for(int vy=1;vy<Yplaces-1;++vy)
				{
					for(int vx=0;vx<Xplaces;++vx)
					{
						for(int c=0;c<nComponents;++c)
							(&t_ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]=
							(
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx  ].r)[c]
							)/27;
					}
				}
				for(int vx=0;vx<Xplaces;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx+1].r)[c]
						)/27;
				}
			}
			for(int vx=0;vx<Xplaces;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx+1].r)[c]
					)/27;
			}
			for(int vy=1;vy<Yplaces-1;++vy)
			{
				for(int vx=0;vx<Xplaces;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+vx  ].r)[c]
						)/27;
				}
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0+1].r)[c]
				)/27;
			for(int vx=0;vx<Xplaces;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx  ].r)[c]
					)/27;
			}
		}
		void lowPassFilter_y					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void lowPassFilter_z					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void lowPassFilter_xy					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void lowPassFilter_yz					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void lowPassFilter_xz					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_xyz					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_x					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_y					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_z					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_xy					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_yz					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_xz					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}

		void setDimentions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h, X0=bpx+bw/2, Y0=bpy+bh/2;
			_3d.setDimentions(x, y, w, h);
			double old_Xstep=Xstep;
			function1();
			if(!toSolve&&contourOn&&old_Xstep!=Xstep)
			{
				Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
				Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
				doContour(cursorEx, DX/Xplaces, -DX/2, +DX/2, Xstep, 2);
			}
			ready=true;
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimentions(x, y, w, h);
			if(!time_variance&&!timer)
				a_draw();
		}
		void shiftNDR(double &DshiftPoint, double Dsample, double &DsamplePos, double &VD, int &Doffset, double ammount)
	//	void shiftNDR(double &DshiftPoint, double &Dsample, double &DsamplePos, double &VD, double AR_D, int &Doffset, double ammount)
		{
			double newDsamplePos=std::floor((DshiftPoint+=ammount)/Dsample);
		//	double newDsamplePos=std::floor((DshiftPoint+=ammount)/(AR_D*Dsample));
			if(newDsamplePos!=DsamplePos)
			{
				toSolve=true;
				if(shiftOnly)
					shiftOnly=1, Doffset+=int(newDsamplePos-DsamplePos);
				DsamplePos=newDsamplePos, VD=newDsamplePos*Dsample;
			//	DsamplePos=newDsamplePos, VD=newDsamplePos*AR_D*Dsample;
			}
			DsamplePos=newDsamplePos;
		}
		void shiftNDRupdate(double DshiftPoint, double Dsample, double &DsamplePos, double &VD)
	//	void shiftNDRupdate(double DshiftPoint, double Dsample, double &DsamplePos, double &VD, double AR_D)
		{
			double newDsamplePos=std::floor(DshiftPoint/Dsample);
		//	double newDsamplePos=std::floor(DshiftPoint/(AR_D*Dsample));
			if(newDsamplePos!=DsamplePos)
				DsamplePos=newDsamplePos, VD=newDsamplePos*Dsample;
			//	DsamplePos=newDsamplePos, VD=newDsamplePos*AR_D*Dsample;
		}
		void messageTimer()
		{
				 if(kb[VK_SHIFT	]){	 if(kb['W'])	_3d.moveForwardFast();
									 if(kb['A'])	_3d.moveLeftFast();
									 if(kb['S'])	_3d.moveBackFast();
									 if(kb['D'])	_3d.moveRightFast();
									 if(kb['T'])	_3d.camz+=10*_3d.dcam;
									 if(kb['G'])	_3d.camz-=10*_3d.dcam;}
			else				  {	 if(kb['W'])	_3d.moveForward();
									 if(kb['A'])	_3d.moveLeft();
									 if(kb['S'])	_3d.moveBack();
									 if(kb['D'])	_3d.moveRight();
									 if(kb['T'])	_3d.camz+=_3d.dcam;
									 if(kb['G'])	_3d.camz-=_3d.dcam;}
			double dVD=DX/100;
			if(kb['X'])
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//xyz
					{
					}
					else		//xy
					{
						if(kb[VK_UP])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, dVD), _3d.camy+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, -dVD), _3d.camy-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dVD), _3d.camx+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, -dVD), _3d.camx-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//xz
					{
						if(kb[VK_UP])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z,	ZsamplePos, VZ, Zoffset, dVD), _3d.camz+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z,	ZsamplePos, VZ, Zoffset, -dVD), _3d.camz-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dVD), _3d.camx+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, -dVD), _3d.camx-=_3d_shift_move_cam*dVD;
					}
					else		//x
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, dVD), _3d.camx+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, -dVD), _3d.camx-=_3d_shift_move_cam*dVD;
					}
				}
			}
			else
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//yz
					{
						if(kb[VK_UP])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, VZ, Zoffset, dVD), _3d.camz+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, VZ, Zoffset, -dVD), _3d.camz-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dVD), _3d.camy+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, -dVD), _3d.camy-=_3d_shift_move_cam*dVD;
					}
					else		//y
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dVD), _3d.camy+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, -dVD), _3d.camy-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//z
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, VZ, Zoffset, dVD), _3d.camx+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, VZ, Zoffset, -dVD), _3d.camx-=_3d_shift_move_cam*dVD;
					}
					else
					{
						if(kb[VK_UP])	_3d.rotateUp();
						if(kb[VK_DOWN])	_3d.rotateDown();
						if(kb[VK_RIGHT])_3d.rotateRight();
						if(kb[VK_LEFT])	_3d.rotateLeft();
					}
				}
			}
			if(kb[VK_ADD]||kb[VK_RETURN]||kb[VK_OEM_PLUS])
			{
				if(kb[VK_MENU])//alt+
				{
					if(_3d_zoom_move_cam)//zoom in
						DX/=1.1, _3d.camx=VX+(_3d.camx-VX)/1.1, _3d.camy=VY+(_3d.camy-VY)/1.1, _3d.camz=VZ+(_3d.camz-VZ)/1.1, _3d.dcam/=1.1;
					else//zoom out
						DX*=1.1;
					function1();
				//	DX*=1.1, function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);//
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);//
					shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);//
					toSolve=true, shiftOnly=0;
				}
				else if(kb['X'])//x+ stretch (zoom out (compress), stretch y, z)
				{
					if(_3d_stretch_move_cam)
					{
						double VX0=VX, VY0=VY, VZ0=VZ;
						DX/=1.1;//zoom out
						function1();
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
						_3d.camx=VX+(_3d.camx-VX0)/1.1, _3d.camy=VY+(_3d.camy-VY0)/1.1, _3d.camz=VZ+(_3d.camz-VZ0)/1.1, _3d.dcam/=1.1;

						VY0=VY;//stretch y
						YshiftPoint/=1.1;
						AR_Y/=1.1, function1();
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.camy+=VY-VY0;
						
						VZ0=VZ;//stretch z
						ZshiftPoint/=1.1;
						AR_Z/=1.1, function1();
						shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
						_3d.camz+=VZ-VZ0;
					//	_3d.camz-=VZ/11., VZ/=1.1;//stretch z
					//	AR_Z/=1.1, function1();
					}
					else
					{
						DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
						_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					}
					toSolve=true, shiftOnly=0;
				/*	DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					toSolve=true, shiftOnly=0;//*/
				}
				else if(kb['Y'])//y+ stretch
				{
					double VY0=VY;
					YshiftPoint*=1.1;//move cube
					AR_Y*=1.1, function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					if(_3d_stretch_move_cam)
						_3d.camy+=VY-VY0;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Z'])//z+ stretch
				{
					double VZ0=VZ;
					ZshiftPoint*=1.1;//move cube
					AR_Z*=1.1, function1();
					shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
					if(_3d_stretch_move_cam)
						_3d.camz+=VZ-VZ0;
					toSolve=true, shiftOnly=0;
				}
				else if(!(kb[VK_CONTROL]||kb[VK_SHIFT]))
					_3d.zoomIn();
			}
			if(kb[VK_SUBTRACT]||kb[VK_BACK]||kb[VK_OEM_MINUS])
			{
				if(kb[VK_MENU])//alt-
				{
					if(_3d_zoom_move_cam)//zoom out
						DX*=1.1, _3d.camx=VX+(_3d.camx-VX)*1.1, _3d.camy=VY+(_3d.camy-VY)*1.1, _3d.camz=VZ+(_3d.camz-VZ)*1.1, _3d.dcam*=1.1;
					else//zoom in
						DX/=1.1;
				//	DX/=1.1, function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);//
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);//
					shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);//
					toSolve=true, shiftOnly=0;
				}
				else if(kb['X'])//x- compress (zoom in (stretch), compress y z)
				{
					if(_3d_stretch_move_cam)
					{
						double VX0=VX, VY0=VY, VZ0=VZ;
						DX*=1.1;//zoom in
						function1();
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
						_3d.camx=VX+(_3d.camx-VX0)*1.1, _3d.camy=VY+(_3d.camy-VY0)*1.1, _3d.camz=VZ+(_3d.camz-VZ0)*1.1, _3d.dcam*=1.1;
					
						VY0=VY;//compress y
						YshiftPoint*=1.1;
						AR_Y*=1.1, function1();
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.camy+=VY-VY0;
					
						VZ0=VZ;//compress z
						ZshiftPoint*=1.1;
						AR_Z*=1.1, function1();
						shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
						_3d.camz+=VZ-VZ0;
					}
					else
					{
						DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
						_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					}
					toSolve=true, shiftOnly=0;
				/*	DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					toSolve=true, shiftOnly=0;//*/
				}
				else if(kb['Y'])//y- compress
				{
					double VY0=VY;
					YshiftPoint/=1.1;//move cube
					AR_Y/=1.1, function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					if(_3d_stretch_move_cam)
						_3d.camy+=VY-VY0;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Z'])//z- compress
				{
					double VZ0=VZ;
					ZshiftPoint/=1.1;
					AR_Z/=1.1, function1();
					shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
					if(_3d_stretch_move_cam)
						_3d.camz+=VZ-VZ0;
					toSolve=true, shiftOnly=0;
				}
				else if(!(kb[VK_CONTROL]||kb[VK_SHIFT]))
					_3d.zoomOut();
			}
		//		 if(kb[VK_MENU	]){		if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	DX*=1.1, DY*=1.1, DZ*=1.1, function1(), toSolve=true, shiftOnly=0;
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	DX/=1.1, DY/=1.1, DZ/=1.1, function1(), toSolve=true, shiftOnly=0;}
		//	else if(!kb[VK_CONTROL]){	if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	_3d.zoomIn();
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	_3d.zoomOut();}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				if(!shift)
				{
					ShowCursor(0);
					GetCursorPos(&mouseP0);
					SetCursorPos(centerP.x, centerP.y);
					SetCapture(ghWnd);
				}
				drag=1;
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(!m_bypass)
			{
				int draw=0;
				int dmx=((short*)&lParam)[0]-w/2, dmy=h/2-((short*)&lParam)[1];
				if(kb['X'])
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//xyz	mx my mw
						{
							double VX0=VX, VY0=VY;
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dmx*DX/w), _3d.camx+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, dmy*DX/w), _3d.camy+=(VY-VY0)*_3d_shift_move_cam;
						}
						else		//xy	mx my
						{
							double VX0=VX, VY0=VY;
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dmx*DX/w), _3d.camx+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, dmy*DX/w), _3d.camy+=(VY-VY0)*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//xz	mx my
						{
							double VX0=VX, VZ0=VZ;
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dmx*DX/w), _3d.camx+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(ZshiftPoint, solver.Zsample*AR_Z,	ZsamplePos, VZ, Zoffset, dmy*DX/w), _3d.camx+=(VZ-VZ0)*_3d_shift_move_cam;
						}
						else		//x		mx
						{
							double VX0=VX;
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, dmx*DX/w), _3d.camx+=(VX-VX0)*_3d_shift_move_cam;
						}
						draw=1;
					}
				}
				else
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//yz	mx my
						{
							double VY0=VY, VZ0=VZ;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.camy+=(VY-VY0)*_3d_shift_move_cam;
							shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, VZ, Zoffset, dmy*DX/w), _3d.camz+=(VZ-VZ0)*_3d_shift_move_cam;
						}
						else		//y		mx
						{
							double VY0=VY;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.camy+=(VY-VY0)*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//z		my
						{
							double VZ0=VZ;
							shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, VZ, Zoffset, dmy), _3d.camz+=(VZ-VZ0)*_3d_shift_move_cam;
							draw=1;
						}
						else if(drag)
						{
							_3d.rotate(lParam);
							draw=1;
						}
					}
				}
				if(draw)
				{
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
			}
			m_bypass=!m_bypass;
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				if(!shift)
				{
					ReleaseCapture();
					SetCursorPos(mouseP0.x, mouseP0.y);
					ShowCursor(1);
				}
				drag=0;
			}
		}
		int inputMouseWheel(int wParam)
		{
			bool mw_forward=((short*)&wParam)[1]>0;
			if(kb['X']&&kb['Y']&&kb['Z'])
				shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, VZ, Zoffset, (mw_forward-!mw_forward)*DX/100);
		/*	{
				double dVD=DX/100;
				shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, VZ, Zoffset,
					(mw_forward	?	dVD
								:	-dVD);
			}//*/
			else if(kb[VK_MENU])//alt wheel
			{
				double zoom_signed=double(mw_forward)/1.1+!mw_forward*1.1;
			//	double zoom_signed=mw_forward/1.1+!mw_forward*1.1;//warning C4804 unsafe use of type 'bool' in operation
				double VX0=VX, VY0=VY, VZ0=VZ;
				DX*=zoom_signed;
			//		 if(((short*)&wParam)[1]>0)	DX*=1.1;//, DY*=1.1, DZ*=1.1;
			//	else							DX/=1.1;//, DY/=1.1, DZ/=1.1;
				function1();
				shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);//
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);//
				shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);//
				if(_3d_zoom_move_cam)
				{
					_3d.camx=VX+(_3d.camx-VX0)*zoom_signed, _3d.camy=VY+(_3d.camy-VY0)*zoom_signed, _3d.camz=VZ+(_3d.camz-VZ0)*zoom_signed, _3d.dcam*=zoom_signed;
			//			 if(mw_forward)	_3d.camx=VX+(_3d.camx-VX0)*1.1, _3d.camy=VY+(_3d.camy-VY0)*1.1, _3d.camz=VZ+(_3d.camz-VZ0)*1.1, _3d.dcam*=1.1;
			//		else				_3d.camx=VX+(_3d.camx-VX0)/1.1, _3d.camy=VY+(_3d.camy-VY0)/1.1, _3d.camz=VZ+(_3d.camz-VZ0)/1.1, _3d.dcam/=1.1;
				}
				toSolve=true, shiftOnly=0;
			}
			else if(kb['X'])//x wheel
			{
				double zoom_signed=double(mw_forward)/1.1+!mw_forward*1.1;
				if(_3d_stretch_move_cam)
				{
					double VX0=VX, VY0=VY;
					DX*=zoom_signed;
				//		 if(mw_forward)	DX/=1.1;//zoom out
				//	else				DX*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					_3d.camx=VX+(_3d.camx-VX0)*zoom_signed, _3d.camy=VY+(_3d.camy-VY0)*zoom_signed, _3d.camz=VZ+(_3d.camz-VZ)*zoom_signed, _3d.dcam*=zoom_signed;
				//		 if(mw_forward)	_3d.camx=VX+(_3d.camx-VX0)/1.1, _3d.camy=VY+(_3d.camy-VY0)/1.1, _3d.camz=VZ+(_3d.camz-VZ)/1.1, _3d.dcam/=1.1;
				//	else				_3d.camx=VX+(_3d.camx-VX0)*1.1, _3d.camy=VY+(_3d.camy-VY0)*1.1, _3d.camz=VZ+(_3d.camz-VZ)*1.1, _3d.dcam*=1.1;

					VY0=VY;//stretch y
					AR_Y*=zoom_signed,	YshiftPoint*=zoom_signed;
				//		 if(mw_forward)	AR_Y/=1.1,	YshiftPoint/=1.1;
				//	else				AR_Y*=1.1,	YshiftPoint*=1.1;
					function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					_3d.camy+=VY-VY0;


					double VZ0=VZ;//stretch y
					AR_Z*=zoom_signed,	ZshiftPoint*=zoom_signed;
					function1();
					shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
					_3d.camz+=VZ-VZ0;
				/*		 if(mw_forward)	_3d.camz-=VZ/11., AR_Z/=1.1,	VZ/=1.1;//stretch z
					else				_3d.camz+=VZ*0.1, AR_Z*=1.1,	VZ*=1.1;
					function1();//*/
				}
				else
				{
						 if(mw_forward)	DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, _3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
					else				DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, _3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
				}
				toSolve=true, shiftOnly=0;
			/*	if(((short*)&wParam)[1]>0)
				{
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1;
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.camx/=1.1, _3d.camy/=1.1, _3d.camz/=1.1, _3d.dcam/=1.1;
				}
				else
				{
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1;
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.camx*=1.1, _3d.camy*=1.1, _3d.camz*=1.1, _3d.dcam*=1.1;
				}
				function1();
				shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
				toSolve=true, shiftOnly=0;//*/
			}
			else if(kb['Y'])//y wheel
			{
				double VY0=VY;
					 if(mw_forward)	AR_Y*=1.1,	YshiftPoint*=1.1;
				else				AR_Y/=1.1,	YshiftPoint/=1.1;
				function1();
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
				_3d.camy+=(VY-VY0)*_3d_stretch_move_cam;
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Z'])//z wheel
			{
				double VZ0=VZ;
					 if(mw_forward)	AR_Z*=1.1,	ZshiftPoint*=1.1;
				else				AR_Z/=1.1,	ZshiftPoint/=1.1;
				function1();
				shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
				_3d.camz+=(VZ-VZ0)*_3d_stretch_move_cam;
				toSolve=true, shiftOnly=0;
			}
			else if(kb[VK_CONTROL])//ctrl wheel
			{
					 if(mw_forward)	_3d.faster();
				else				_3d.slower();
			}
			else if(kb[VK_SHIFT])//shift wheel
			{
					 if(mw_forward)
				{
					Zplaces=Yplaces=++Xplaces, toSolve=true, shiftOnly=0;
					//int oldXplaces=Xplaces;
					//Xplaces=int(1.5*Xplaces);
					//if(Xplaces==oldXplaces)
					//	++Xplaces;
					//Zplaces=Yplaces=Xplaces;
					//toSolve=true, shiftOnly=0;
				}
				else
				{
					if(Xplaces>1)
						Zplaces=Yplaces=--Xplaces, toSolve=true, shiftOnly=0;
					//int oldXplaces=Xplaces;
					//Xplaces=int(Xplaces/1.5);
					//if(Xplaces==oldXplaces&&Xplaces!=1)
					//	--Xplaces;
					//Zplaces=Yplaces=Xplaces;
					//toSolve=true, shiftOnly=0;
				}
			}
			else//wheel
			{
					 if(mw_forward)	_3d.zoomIn();
				else				_3d.zoomOut();
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:case 'T':case 'G':
				if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_ADD:case VK_OEM_PLUS:case VK_RETURN:
				if(kb[VK_CONTROL])
					_3d.faster();
				else if(kb[VK_SHIFT])//increase resolution
				{
					Zplaces=Yplaces=++Xplaces, toSolve=true, shiftOnly=0;
					//int oldXplaces=Xplaces;
					//Xplaces=int(1.5*Xplaces);
					//if(Xplaces==oldXplaces)
					//	++Xplaces;
					//Zplaces=Yplaces=Xplaces;
					//toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_SUBTRACT:case VK_OEM_MINUS:case VK_BACK:
				if(kb[VK_CONTROL])
					_3d.slower();
				else if(kb[VK_SHIFT])//decrease resolution
				{
					if(Xplaces>1)
						Zplaces=Yplaces=--Xplaces, toSolve=true, shiftOnly=0;
					//int oldXplaces=Xplaces;
					//Xplaces=int(Xplaces/1.5);
					//if(Xplaces==oldXplaces&&Xplaces!=1)
					//	--Xplaces;
					//Zplaces=Yplaces=Xplaces;
					//toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case 'X':case 'Y':case 'Z':
				if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case VK_OEM_3:
				if(contourOn)//was on
				{
					if(kb[VK_CONTROL])
					{
						//contour+surface
						//contour only
						//flat contour
						//flat+surface
						if(contourFlat)
						{
							if(contourOnly)
								contourOnly=false;//3: surface appears
							else
								contourFlat=false;//4: pops up
						}
						else
						{
							if(contourOnly)
								contourFlat=true;//2: gets flat
							else
								contourOnly=true;//1: surface disappears
						}
					}
					else
						contourOn=false, contourOnly=false, contourFlat=false;
				}
				else//was off
				{
					contourOn=true;
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
						doContour(cursorEx, DX/Xplaces, -DX/2, +DX/2, Xstep, 2);
					}
				}
				break;
			case '0':case VK_NUMPAD0:
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
			case '7':case VK_NUMPAD7:
			case '8':case VK_NUMPAD8:
				{
					auto op=&Color_3D::differentiate_xyz;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back( 1), op=&Color_3D::differentiate_xyz;
																else			operations.push_back( 5), op=&Color_3D::differentiate_xy;}
											else			{		 if(kb['Z'])operations.push_back( 7), op=&Color_3D::differentiate_xz;
																else			operations.push_back( 2), op=&Color_3D::differentiate_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back( 6), op=&Color_3D::differentiate_yz;
																else			operations.push_back( 3), op=&Color_3D::differentiate_y;}
											else			{		 if(kb['Z'])operations.push_back( 4), op=&Color_3D::differentiate_z;
																else			operations.push_back( 1), op=&Color_3D::differentiate_xyz;}}
						break;
					case '2':case VK_NUMPAD2:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back( 8), op=&Color_3D::integrate_xyz;
																else			operations.push_back(12), op=&Color_3D::integrate_xy;}
											else			{		 if(kb['Z'])operations.push_back(14), op=&Color_3D::integrate_xz;
																else			operations.push_back( 9), op=&Color_3D::integrate_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back(13), op=&Color_3D::integrate_yz;
																else			operations.push_back(10), op=&Color_3D::integrate_y;}
											else			{		 if(kb['Z'])operations.push_back(11), op=&Color_3D::integrate_z;
																else			operations.push_back( 8), op=&Color_3D::integrate_xyz;}}
						break;
					case '3':case VK_NUMPAD3:	operations.push_back(15), op=&Color_3D::discreteFourrierTransform;			break;
					case '4':case VK_NUMPAD4:	operations.push_back(16), op=&Color_3D::inverseDiscreteFourrierTransform;	break;
					case '5':case VK_NUMPAD5:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back(17), op=&Color_3D::lowPassFilter_xyz;
																else			operations.push_back(21), op=&Color_3D::lowPassFilter_xy;}
											else			{		 if(kb['Z'])operations.push_back(23), op=&Color_3D::lowPassFilter_xz;
																else			operations.push_back(18), op=&Color_3D::lowPassFilter_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back(22), op=&Color_3D::lowPassFilter_yz;
																else			operations.push_back(19), op=&Color_3D::lowPassFilter_y;}
											else			{		 if(kb['Z'])operations.push_back(20), op=&Color_3D::lowPassFilter_z;
																else			operations.push_back(17), op=&Color_3D::lowPassFilter_xyz;}}
						break;
					case '6':case VK_NUMPAD6:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back(24), op=&Color_3D::highPassFilter_xyz;
																else			operations.push_back(28), op=&Color_3D::highPassFilter_xy;}
											else			{		 if(kb['Z'])operations.push_back(30), op=&Color_3D::highPassFilter_xz;
																else			operations.push_back(25), op=&Color_3D::highPassFilter_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back(29), op=&Color_3D::highPassFilter_yz;
																else			operations.push_back(26), op=&Color_3D::highPassFilter_y;}
											else			{		 if(kb['Z'])operations.push_back(27), op=&Color_3D::highPassFilter_z;
																else			operations.push_back(24), op=&Color_3D::highPassFilter_xyz;}}
						break;
					}
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
						(this->*op)(expr[cursorEx].n[0].ndr);
						if(contourOn)
							doContour(cursorEx, DX/Xplaces, -DX/2, +DX/2, Xstep, 2);
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				{
					double r=20/DX;

					XshiftPoint*=r, YshiftPoint*=r, ZshiftPoint*=r;
					_3d.camx*=r, _3d.camy*=r, _3d.camz*=r, _3d.dcam*=r;
					DX=20, AR_Y=1, AR_Z=1, function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
				//	VX*=r, VY*=r, VZ*=r;
				//	_3d.camx*=r, _3d.camy*=r, _3d.camz*=r, _3d.dcam*=r;
				//	DX=20, AR_Y=1, AR_Z=1, function1();
					toSolve=true, shiftOnly=0;
				}
				break;
			case 'R':
				_3d.dcam=.04, _3d.tanfov=1;
				if(!kb[VK_CONTROL])
					DX=20, AR_Y=1, AR_Z=1, function1(), Xplaces=Yplaces=Zplaces=10;

				if(XshiftPoint!=0||YshiftPoint!=0||VZ!=0)
					XshiftPoint=0, YshiftPoint=0, VZ=0;
				shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
			//	if(VX!=0||VY!=0||VZ!=0)
			//		VX=VY=VZ=0;
				toSolve=true, shiftOnly=0;
				if(kb['X'])
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
				else if(kb['Y'])
					_3d.teleport_degrees(0, 20, 0, 270, 0, 1);
				else if(kb['Z'])
					_3d.teleport_degrees(0, 0, 20, 90, 270, 1);
				else
					_3d.teleport_degrees(20, 20, 20, 225, 324.7356103172454, 1);
				//	_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
			/*	if(kb[VK_CONTROL])
				{
					DX=20, DY=20, DZ=20, function1();
					toSolve=true, shiftOnly=0;
				}
				if(VX!=0||VY!=0||VZ!=0)
				{
					VX=VY=VZ=0;
					toSolve=true, shiftOnly=0;
				}
				_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);//*/
				break;
			case VK_F6:
				if(!(lParam&1<<30))
				{
					kb_VK_F6_msg=true;
					if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_stretch_move_cam=true;
					else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_shift_move_cam=true;
					else if(!_3d_zoom_move_cam)
						_3d_zoom_move_cam=true;
					else
						_3d_stretch_move_cam=_3d_shift_move_cam=_3d_zoom_move_cam=false;
				}
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:case 'T':case 'G':
				if(kp>0)
					--kp;
				break;
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[VK_CONTROL]&&kp>0)
					--kp;
				return 0;
			case 'X':
				if(!kb['Y']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Y':
				if(!kb['X']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Z':
				if(!kb['X']&&!kb['Y']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
		/*	case 'X':case 'Y':case 'Z':
				if(shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;*/
			}
			return 0;
		}
		void function1(){derive_step_3D(DX, AR_Y, AR_Z, w, Xstep, Ystep, Zstep);}
		void draw()
		{
			double DY=DX/AR_Y, DZ=DX/AR_Z;
			auto &ex=expr[cursorEx];
			{
				bool changed=false;
				if(toSolve)
				{
					if(!operations.size()&&shiftOnly==1&&abs(Xoffset)<Xplaces&&abs(Yoffset)<Yplaces&&abs(Zoffset)<Zplaces)
					{
						solver.partial_bounds(VX, DX, VY/AR_Y, DY, VZ/AR_Z, DZ, Xoffset, Yoffset, Zoffset);
						solver.synchronize();
						(solver.*(ex.nITD?&Solve_3D::full:solver.partial))(ex);
					}
					else
					{
						auto old_time_variance=time_variance;
						time_variance=false;
					//	std::fill(nExpr.begin(), nExpr.end(), 0);
					//	for(auto &ex:expr)
					//		++nExpr[ex.rmode[0]];
						labels.clear();
					//	Xplaces=Yplaces=Zplaces=
					//		50//2//4//8//10//50
					//		;
						solver.full_resize(VX, DX, VY/AR_Y, DY, VZ/AR_Z, DZ, Xplaces, Yplaces, Zplaces);
						XsamplePos=std::floor(XshiftPoint/solver.Xsample);
						YsamplePos=std::floor(YshiftPoint/solver.Ysample);
						ZsamplePos=std::floor(ZshiftPoint/solver.Zsample);

					//	KXplaces=Xplaces/100?Xplaces/100:1, KYplaces=Yplaces/100?Yplaces/100:1, KZplaces=Zplaces/100?Zplaces/100:1;
						time_variance|=ex.nITD;
						labels.fill(cursorEx);
						if(!paused)
							solver.synchronize();
						solver.full(ex);
						doOperations(ex.n[0].ndr);
						if(time_variance)
						{
							if(!paused)
								SetTimer(ghWnd, 0, 10, 0);
						}
						else if(old_time_variance&&!timer)
							KillTimer(ghWnd, 0);
					}
					toSolve=false, shiftOnly=2, Xoffset=Yoffset=Zoffset=0;
					changed=true;
				}
				else if(time_variance)
				{
					if(!paused)
						solver.synchronize();
					solver.full(ex);
					doOperations(ex.n[0].ndr);
					changed=true;
				}
				if(changed)
				{
					solver.updateRGB(ex);
				//	solver.updateRGB(ex.n[0]);
					if(contourOn)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
						doContour(cursorEx, DX/Xplaces, -DX/2, +DX/2, Xstep, 2);
					}
				}
			}
			
			_3d.newFrame();
			if(!clearScreen)
				_3dMode_DrawGridNAxes(_3d, VX, VY, VZ, DX, Xstep, AR_Y*Ystep, AR_Z*Zstep, AR_Y, AR_Z);
			if(!contourOnly)//draw the points
			{
				double Xstart=VX-DX/2, Xr=DX/Xplaces, Ystart=VY-DX/2, Ysample=DX/Yplaces, Zstart=VZ-DX/2, Zr=DX/Zplaces;
				auto ndrIT=ex.n[0].ndr.begin();
				unsigned v=0;
				switch(ex.resultMathSet)
			//	switch(ex.n[0].mathSet)
				{
				case 'r':case 'c':
			//	case 'R':case 'C':
					for(int k=0;k<Zplaces;++k)
						for(int k2=0;k2<Yplaces;++k2)
							for(int k3=0;k3<Xplaces;++k3, ++ndrIT, ++v)
								_3d.point(Xstart+Xr*k3, Ystart+Ysample*k2, Zstart+Zr*k, solver.ndr_rgb[v]);
							//	_3d.textIn3D(Xstart+Xr*k3, Ystart+Ysample*k2, Zstart+Zr*k, OPAQUE, "%g", ndrIT->r);
					break;
				case 'H':
					for(int k=0;k<Zplaces;++k)
						for(int k2=0;k2<Yplaces;++k2)
							for(int k3=0;k3<Xplaces;++k3, ++ndrIT, ++v)
								_3d.point(Xstart+Xr*k3, Ystart+Ysample*k2, Zstart+Zr*k, solver.ndr_rgb[v], solver.ndr_rgb_i[v], solver.ndr_rgb_j[v], solver.ndr_rgb_k[v]);
					break;
				}
			}
			if(contourOn)//draw the contour
			{
			//	draw_contourGrid(DX/Xplaces);
				switch(ex.resultMathSet)
			//	switch(ex.n[0].mathSet)
				{
				case 'r':
			//	case 'R':
					draw_contour(Rcontours, Rlines, rColor);
					break;
				case 'c':
			//	case 'C':
					draw_contour(Rcontours, Rlines, rColor);
					draw_contour(Icontours, Ilines, iColor);
					break;
				case 'H':
					draw_contour(Rcontours, Rlines, rColor);
					draw_contour(Icontours, Ilines, iColor);
					draw_contour(Icontours, Ilines, jColor);
					draw_contour(Icontours, Ilines, kColor);
					break;
				}
			}
			if(!clearScreen)
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, TRANSPARENT);
				for(double X=floor((VX-DX/2)/Xstep)*Xstep+Xstep, Xend=ceil((VX+DX/2)/Xstep)*Xstep;X<Xend;X+=Xstep)
					if(abs(X)>Xstep/2)
						_3d.label(X, VY, VZ, "%g", X);
				if(AR_Y==1)
				{
					for(double Y=floor((VY-DX/2)/Ystep)*Ystep+Ystep, Yend=ceil((VY+DX/2)/Ystep)*Ystep;Y<Yend;Y+=Ystep)
						if(Y<-Ystep/2||Y>Ystep/2)
							_3d.label(VX, Y, VZ, "%g", Y);
				}
				else
				{
					double aYstep=AR_Y*Ystep, Ycore=floor((VY-DX/2)/aYstep);
					for(double Y=Ycore*aYstep+aYstep, Yend=ceil((VY+DX/2)/aYstep)*aYstep, aY=Ycore*Ystep+Ystep;Y<Yend;Y+=aYstep, aY+=Ystep)
						if(Y<-aYstep/2||Y>aYstep/2)
							_3d.label(VX, Y, VZ, "%g", aY);
				}
				if(AR_Z==1)
				{
					for(double Z=floor((VZ-DX/2)/Zstep)*Zstep+Zstep, Zend=ceil((VZ+DX/2)/Zstep)*Zstep;Z<Zend;Z+=Zstep)
						if(Z<-Zstep/2||Z>Zstep/2)
							_3d.label(VX, VY, Z, "%g", Z);
				}
				else
				{
					double aZstep=AR_Z*Zstep, Zcore=floor((VZ-DX/2)/aZstep);
					for(double Z=Zcore*aZstep+aZstep, Zend=ceil((VZ+DX/2)/aZstep)*aZstep, aZ=Zcore*Zstep+Zstep;Z<Zend;Z+=aZstep, aZ+=Zstep)
						if(Z<-aZstep/2||Z>aZstep/2)
							_3d.label(VX, VY, Z, "%g", aZ);
				}
			/*	for(double x=floor((VX-DX/2)/step)*step+step;x<ceil((VX+DX/2)/step)*step;x+=step)
					if(abs(x)>step/2)
						_3d.label(x, VY, VZ, "%g", x);
				for(double y=floor((VY-DX/2)/step)*step+step;y<ceil((VY+DX/2)/step)*step;y+=step)
					if(abs(y)>step/2)
						_3d.label(VX, y, VZ, "%g", y);
				for(double z=floor((VZ-DX/2)/step)*step+step;z<ceil((VZ+DX/2)/step)*step;z+=step)
					if(abs(z)>step/2)
						_3d.label(VX, VY, z, "%g", z);//*/
				_3d.arrowLabels(0, 0, 0, 1, 0, 0, labels.Xlabels);
				_3d.arrowLabels(0, 0, 0, 0, 1, 0, labels.Ylabels);
				_3d.arrowLabels(0, 0, 0, 0, 0, 1, labels.Zlabels);
				{
					int Ys=0;
					for(auto &label:labels.Clabels)
					{
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					//	linelen=sprintf_s(line, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, line, linelen), Ys+=16;
					}
				}
				{
					int k=0, Y=h-operations.size()*16;
					for(auto operation:operations)
					{
						char const *a=0;
						switch(operation)
						{
						case  1:a="%d: Differentiate XYZ";	break;
						case  2:a="%d: Differentiate X";	break;
						case  3:a="%d: Differentiate Y";	break;
						case  4:a="%d: Differentiate Z";	break;
						case  5:a="%d: Differentiate XY";	break;
						case  6:a="%d: Differentiate YZ";	break;
						case  7:a="%d: Differentiate XZ";	break;
						case  8:a="%d: Integrate XYZ";		break;
						case  9:a="%d: Integrate X";		break;
						case 10:a="%d: Integrate Y";		break;
						case 11:a="%d: Integrate Z";		break;
						case 12:a="%d: Integrate XY";		break;
						case 13:a="%d: Integrate YZ";		break;
						case 14:a="%d: Integrate XZ";		break;
						case 15:a="%d: DFT";				break;
						case 16:a="%d: IDFT";				break;
						case 17:a="%d: LPF";				break;
						case 18:a="%d: LPF X";				break;
						case 19:a="%d: LPF Y";				break;
						case 20:a="%d: LPF Z";				break;
						case 21:a="%d: LPF XY";				break;
						case 22:a="%d: LPF YZ";				break;
						case 23:a="%d: LPF XZ";				break;
						case 24:a="%d: HPF";				break;
						case 25:a="%d: HPF X";				break;
						case 26:a="%d: HPF Y";				break;
						case 27:a="%d: HPF Z";				break;
						case 28:a="%d: HPF XY";				break;
						case 29:a="%d: HPF YZ";				break;
						case 30:a="%d: HPF XZ";				break;
						}
						_3d.textIn2D(w-const_label_offset_X, Y, OPAQUE, a, k);
						++k, Y+=16;
					}
				}
				SetBkMode(ghMemDC, bkMode);
				_3d.text_show();
			}
			else
				_3d.text_show();
			//	_3d.text_dump();
			if(kb_VK_F6_msg||kb[VK_F6])
			{
				int kb_mode=SetBkMode(ghMemDC, OPAQUE);
				kb_VK_F6_msg=false;
				if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
					GUIPrint(ghMemDC, 0, h-18*3, "move cam: [-] scale, [-] shift, [-] zoom");
				else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
					GUIPrint(ghMemDC, 0, h-18*3, "move cam: [v] scale, [-] shift, [-] zoom");
				else if(!_3d_zoom_move_cam)
					GUIPrint(ghMemDC, 0, h-18*3, "move cam: [v] scale, [v] shift, [-] zoom");
				else
					GUIPrint(ghMemDC, 0, h-18*3, "move cam: [v] scale, [v] shift, [v] zoom");
				SetBkMode(ghMemDC, kb_mode);
			}
		}
		void i_draw();
		void a_draw();
	} c3d;
	void			Color_3D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				std::copy(rgb, rgb+w*h, modeRGB);

			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, OPAQUE);
				itb.draw();
				SetBkMode(ghMemDC, bkMode);
			}
			font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		}
		else
		{
			std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Color_3D::a_draw()
	{
		Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}

	void (*paint)();
	void paint_0()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_n0d()
	{
		modes::n0d.setDimentions(0, 0, w, h);
		
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_t1d()
	{
		modes::n0d.ready=false;

		modes::t1d.setDimentions(0, 0, w, h);
		
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_t1d_c()
	{
		modes::n0d.ready=false;
		modes::t1d.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;

		modes::t1d_c.setDimentions(0, 0, w, h);
		
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_t1d_h()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;

		modes::t1d_h.setDimentions(0, 0, w, h);
		
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_t2d()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;

		modes::t2d.setDimentions(0, 0, w, h);
		
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_c2d()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;

		modes::c2d.setDimentions(0, 0, w, h);
		
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_l2d()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;

		modes::l2d.setDimentions(0, 0, w, h);

		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_t2d_h()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;

		modes::t2d_h.setDimentions(0, 0, w, h);

		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_c3d()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;

		modes::c3d.setDimentions(0, 0, w, h);
		
		modes::ti1d.ready=false;
		modes::ti2d.ready=false;
	}
	void paint_ti1d()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;

		modes::ti1d.setDimentions(0, 0, w, h);

		modes::ti2d.ready=false;
	}
	void paint_ti2d()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;

		modes::ti2d.setDimentions(0, 0, w, h);
	}
}
int inactiveLMBDown=0;
int copy_text_with_n0d_results(int wParam)//friend InputTextBox
{
#if 1
	if(itb.cursor!=itb.selcur)
	{
		auto &text=itb.text;
		auto &textlen=itb.textlen;
		int selStart=itb.cursor<itb.selcur?itb.cursor:itb.selcur, selEnd=itb.cursor>itb.selcur?itb.cursor:itb.selcur;
		int nBounds=bounds.size();
		int startBound=0, startEx=0;
		for(int k=0, bound=0, e=0;;++k)
		{
			if(bound<nBounds&&k==bounds[bound].first)
			{
				++bound;
				if(bound<nBounds&&bounds[bound].second=='e')
					++e;
			}
			if(k==selStart)
			{
				startBound=bound, startEx=e;
				break;
			}
		}
		int maxlen=0;
		for(int k=selStart, e=startEx, linelen=0;;++k)
	//	for(int k=selStart, linelen=0;k<selEnd;++k)
		{
			if(k>=selEnd)
			{
				if(expr[e].rmode[0]==1&&maxlen<linelen)
					maxlen=linelen;
				break;
			}
			if(text[k]=='\r')
			{
				if(expr[e].rmode[0]==1&&maxlen<linelen)
			//	if(maxlen<linelen)
					maxlen=linelen;
				linelen=0;
				if(text[k+1]=='\n')
					++k;
				++e;
			}
			else
				++linelen;
		}
		int tabsize=8;
		int offset=maxlen-maxlen%tabsize+tabsize;
		std::string str(text+selStart, text+selEnd);
		for(int k=selStart, k2=0, linelen=0, oldlinelen=0, bound=startBound, e=startEx;;++k, ++k2)
		{
			if(k==selEnd)
			{
				auto &ex=expr[e];
				if(ex.rmode[0]==1)//n0d
				{
					int nTabs=(offset-linelen)/tabsize+1;
					int buf_off=0;
					ex.data[0].print(g_buf, buf_off, ex.resultMathSet, modes::n0d.base);
					str.insert(k2, std::string(nTabs, '\t')+g_buf);
				}
				break;
			}
			if(bound<nBounds&&k==bounds[bound].first)
			{
				auto &ex=expr[e];
				if(ex.rmode[0]==1)//n0d
				{
					char &ch=text[bounds[bound].first-1];
					int k2_rewind=(ch=='\n'||ch=='\r')*(1+(ch=='\n'&&(bounds[bound].first-2<0||text[bounds[bound].first-2]=='\r')));
					k2-=k2_rewind;
					if(k2_rewind)
						linelen=oldlinelen;
				//	bool newline=ch=='\n'||ch=='\r';
				//	if(newline)
				//		k2-=1+(ch=='\n'&&(bounds[bound].first-2<0||text[bounds[bound].first-2]=='\r')
					int nTabs=(offset-linelen)/tabsize+1;
					int buf_off=0;
					ex.data[0].print(g_buf, buf_off, ex.resultMathSet, modes::n0d.base);
					str.insert(k2, std::string(nTabs, '\t')+g_buf);
					k2+=k2_rewind;
					if(k2_rewind)
						linelen=1;
					k2+=nTabs+buf_off;
				}
				++bound;
				if(bound<nBounds&&bounds[bound].second=='e')
					++e;
			}
			if(text[k]=='\r')
			{
				oldlinelen=linelen;
				linelen=0;
				if(text[k+1]=='\n')
					++k, ++k2;
			}
			++linelen;
		}
	/*	int startLine=-1, endLine=0, startBound=0, endBound=0, startEx=0, endEx=0;
		int maxlen=0;
		for(int k=0, line=0, bound=0, e=0, linelen=0;;++k)
		{
			if(bound<nBounds&&k==bounds[bound].first)
			{
				++bound;
				if(bound<nBounds&&bounds[bound].second=='e')
					++e;
			}
			if(k==selStart)
				startLine=line, startBound=bound, startEx=e;
			if(k==selEnd)
			{
				endLine=line, endBound=bound, endEx=e;
				break;
			}
			if(text[k]=='\r')
			{
				if(maxlen<linelen)
					maxlen=linelen;
				linelen=0;
				++line;
			}
		}
		int tabsize=8;
		int offset=maxlen-maxlen%tabsize+tabsize;
		std::string str(text+selStart, text+selEnd);
		for(int k=selStart, k2=0, linelen=0, line=startLine, bound=startBound, e=startEx;;++k, ++k2)
		{
			if(k==selEnd)
			{
				auto &ex=expr[e];
				if(ex.rmode[0]==1)//n0d
				{
					int nTabs=(offset-linelen)/tabsize+1;
					int buf_off=0;
					ex.data[0].print(g_buf, buf_off, ex.resultMathSet, modes::n0d.base);
					str.insert(k2, std::string(nTabs, '\t')+g_buf);
				}
				break;
			}
			if(bound<nBounds&&k==bounds[bound].first)
			{
				auto &ex=expr[e];
				if(ex.rmode[0]==1)//n0d
				{
					int nTabs=(offset-linelen)/tabsize+1;
					int buf_off=0;
					ex.data[0].print(g_buf, buf_off, ex.resultMathSet, modes::n0d.base);
					str.insert(k2, std::string(nTabs, '\t')+g_buf);
					k2+=nTabs+buf_off;
				}
				++bound;
				if(bound<nBounds&&bounds[bound].second=='e')
					++e;
			}
			if(text[k]=='\r')
			{
				++line;//, ++k, ++k2;
				linelen=0;
			}
			++linelen;
		}//*/
		char *clipboard=(char*)LocalAlloc(LMEM_FIXED, (str.size()+1)*sizeof(char));
		memcpy(clipboard, str.c_str(), (str.size()+1)*sizeof(char));
		clipboard[str.size()]='\0';
		OpenClipboard(ghWnd), EmptyClipboard(), SetClipboardData(CF_OEMTEXT, (void*)clipboard), CloseClipboard();
		if(wParam=='X')
		{
			itb.removeText(selStart, selEnd);
			return 2;
		}
	}
	return 0;
#endif
#if 0
	if(itb.cursor!=itb.selcur)
	{
		auto &text=itb.text;
		auto &textlen=itb.textlen;
		int selStart=itb.cursor<itb.selcur?itb.cursor:itb.selcur, selEnd=itb.cursor>itb.selcur?itb.cursor:itb.selcur;
		int nBounds=bounds.size();
		int startLine=-1, endLine=0, startBound=0, endBound=0, startEx=0, endEx=0, startUF=0, endUF=0;
		int maxlen=0;
		for(int k=0, line=0, bound=0, e=0, func=0, linelen=0;;++k)
		{
			if(bound<nBounds&&k==bounds[bound].first)
			{
				++bound;
				if(bound<nBounds)
				{
					if(bounds[bound].second=='e')
						++e;
					else
						++func;
				}
			}
			if(k==selStart)
				startLine=line, startBound=bound, startEx=e, startUF=func;
			if(k==selEnd)
			{
				endLine=line, endBound=bound, endEx=e, endUF=func;
				break;
			}
			if(text[k]=='\r')
			{
				if(maxlen<linelen)
					maxlen=linelen;
				linelen=0;
				++line;
			}
		}
		int tabsize=8;
		int offset=maxlen-maxlen%tabsize+tabsize;
		std::string str(text+selStart, text+selEnd);
		for(int k=selStart, k2=0, linelen=0, line=startLine, bound=startBound, e=startEx;;++k, ++k2)
		{
			if(k==selEnd)
			{
				auto &ex=expr[e];
				if(ex.rmode[0]==1)//n0d
				{
					int nTabs=(offset-linelen)/tabsize+1;
					int buf_off=0;
					ex.data[0].print(g_buf, buf_off, ex.resultMathSet, modes::n0d.base);
					str.insert(k2, std::string(nTabs, '\t')+g_buf);
				}
				break;
			}
			if(bound<nBounds&&k==bounds[bound].first)
			{
				auto &ex=expr[e];
				if(ex.rmode[0]==1)//n0d
				{
					int nTabs=(offset-linelen)/tabsize+1;
					int buf_off=0;
					ex.data[0].print(g_buf, buf_off, ex.resultMathSet, modes::n0d.base);
					str.insert(k2, std::string(nTabs, '\t')+g_buf);
					k2+=nTabs+buf_off;
				}
				++bound;
				if(bound<nBounds&&bounds[bound].second=='e')
					++e;
			}
			if(text[k]=='\r')
			{
				++line;//, ++k, ++k2;
				linelen=0;
			}
			++linelen;
		}
		char *clipboard=(char*)LocalAlloc(LMEM_FIXED, (str.size()+1)*sizeof(char));
		memcpy(clipboard, str.c_str(), (str.size()+1)*sizeof(char));
		clipboard[str.size()]='\0';
		OpenClipboard(ghWnd), EmptyClipboard(), SetClipboardData(CF_OEMTEXT, (void*)clipboard), CloseClipboard();
		if(wParam=='X')
		{
			itb.removeText(selStart, selEnd);
			return 2;
		}
	}
	return 0;
#endif
#if 0
	if(itb.cursor!=itb.selcur)
	{
		auto &text=itb.text;
		auto &textlen=itb.textlen;
		const int aSize=1024;
		char a[aSize];
		int first=itb.cursor<itb.selcur?itb.cursor:itb.selcur, second=itb.cursor>itb.selcur?itb.cursor:itb.selcur;
		int firstLine=-1, secondLine=0, firstEx=0, secondEx=0;
		int maxlen=0;
		for(int k=0, line=0, ex=0, linelen=0;;++k)
		{
			if(k==first)
				firstLine=line, firstEx=ex;
			if(k==second)
			{
				secondLine=line, secondEx=ex;
				break;
			}
			if(text[k]=='\r')
			{
				if(maxlen<linelen)
					maxlen=linelen;
				linelen=0;
				++line;//, ++k, ++k2;
				if(k<2||text[k-2]!='\\')
					++ex;
			}
			if(firstLine!=-1)
				++linelen;
		}
		int tabsize=8;
		int offset=maxlen-maxlen%tabsize+tabsize;
		std::string str(text+first, text+second);
		for(int k=first, k2=0, linelen=0, line=firstLine, line2=0, ex=firstEx, ex2=0;;++k, ++k2)
		{
			if(k==second)
			{
				auto &exp=expr[ex];
				if(exp.rmode[0]==1)//n0d
				{
					int dk=offset-linelen;
					int alen=0;
					exp.data[0].print(a, alen, exp.resultMathSet, modes::n0d.base);
				//	exp.n[0].val.print(a, alen, exp.resultMathSet, modes::n0d.base);
				//	exp.n[0].val.print(a, alen, exp.n[0].mathSet, modes::n0d.base);
					str.insert(k2, std::string(dk/tabsize+1, '\t')+a);
				}
				break;
			}
			if(text[k]=='\r')
			{
				if(k<1||text[k-1]!='\\')
				{
					auto &exp=expr[ex];
					if(exp.rmode[0]==1)//n0d
					{
						int dk=(offset-linelen)/tabsize+1;
						int alen=0;
						exp.data[0].print(a, alen, exp.resultMathSet, modes::n0d.base);
					//	exp.n[0].val.print(a, alen, exp.resultMathSet, modes::n0d.base);
					//	exp.n[0].val.print(a, alen, exp.n[0].mathSet, modes::n0d.base);
						str.insert(k2, std::string(dk, '\t')+a);
						k2+=dk+alen;
					}
					++ex;
				}
				++line;//, ++k, ++k2;
				linelen=0;
			}
			++linelen;
		}
		char *clipboard=(char*)LocalAlloc(LMEM_FIXED, (str.size()+1)*sizeof(char));
		memcpy(clipboard, str.c_str(), (str.size()+1)*sizeof(char));
		clipboard[str.size()]='\0';
		OpenClipboard(ghWnd), EmptyClipboard(), SetClipboardData(CF_OEMTEXT, (void*)clipboard), CloseClipboard();
		if(wParam=='X')
		{
			itb.removeText(first, second);
			return 2;
		}
	}
	return 0;
#endif
}
long		__stdcall WndProc(HWND__ *hWnd, unsigned message, unsigned wParam, long lParam)
{
	switch(message)
	{
	case WM_PAINT:
		GetClientRect(hWnd, &R);
		if(h!=R.bottom-R.top||w!=R.right-R.left)
		{
			h=R.bottom-R.top, w=R.right-R.left, centerP.x=w/2, centerP.y=h/2;
			ClientToScreen(hWnd, &centerP);
			DeleteObject((HBITMAP)SelectObject(ghMemDC, ghBitmap));
			BITMAPINFO bmpInfo={{sizeof(BITMAPINFOHEADER), w, -h, 1, 32, BI_RGB, 0, 0, 0, 0, 0}};
			ghBitmap=(HBITMAP)SelectObject(ghMemDC, CreateDIBSection(0, &bmpInfo, DIB_RGB_COLORS, (void**)&rgb, 0, 0));
			modeRGB=(int*)realloc(modeRGB, w*h*sizeof(int));
			memset(modeRGB, 0xFF, w*h*sizeof(int));
			if(modes::active)
				modes::mode->messagePaint(0, 0, w, h);
			else
			{
				itb.setDimensions(0, 0, w, h);
				if(modes::paint)
					modes::paint();
				render();
			}
		}
		else
		{
			if(modes::active)
				modes::mode->a_draw();
			else
				render();
		}
		break;
	case WM_EXITSIZEMOVE:
		centerP.x=w/2, centerP.y=h/2;
		ClientToScreen(ghWnd, &centerP);
		return 0;
	case WM_ACTIVATE:
		switch(wParam)
		{
		case WA_ACTIVE:
		case WA_CLICKACTIVE:
			caps_lock=char(GetKeyState(VK_CAPITAL)), num_lock=char(GetKeyState(VK_NUMLOCK));
			for(int k=0;k<256;++k)
				kb[k]=(GetKeyState(k)&0x8000)!=0;
			kb[VK_LBUTTON]=0;
			if(modes::ready)
				modes::mode->appActivate();
			break;
		case WA_INACTIVE:
			if(modes::ready)
				modes::mode->appDeactivate();
			else if(inactiveLMBDown)
			{
				ReleaseCapture();
				itb.inputLButtonUp();
				inactiveLMBDown=0;
			}
			break;
		}
		break;
	case WM_TIMER:
		if(modes::active)
			modes::mode->messageTimer();
		else
			render();
		return 0;
	case WM_LBUTTONDOWN:
		kb[VK_LBUTTON]=1;
		if(modes::active)
			modes::mode->inputLButtonDown(lParam);
		else
		{
			SetCapture(hWnd), inactiveLMBDown=1;
			if(itb.inputLButtonDown(lParam))
				render();
		}
		oldMouse=lParam;
		return 0;
	case WM_MOUSELEAVE:
		break;
	case WM_MOUSEMOVE:
		if(modes::active)
			modes::mode->inputMouseMove(lParam);
		else
		{
			if(itb.inputMouseMove(lParam))
				render();
		}
		oldMouse=lParam;
		return 0;
	case WM_LBUTTONUP:
		if(kb[VK_LBUTTON])//double click title bar crash
		{
			kb[VK_LBUTTON]=0;
			if(inactiveLMBDown)
			{
				ReleaseCapture();
				itb.inputLButtonUp();
				inactiveLMBDown=0;
			}
			else
				modes::mode->inputLButtonUp(lParam);
		}
		return 0;
	case WM_MOUSEWHEEL:
		if(modes::active)
			modes::mode->inputMouseWheel(wParam);
		else
		{
			int draw=0;
			if(kb[VK_CONTROL])
			{
				double A=font.change(wParam);
				if(A!=1)
				{
					itb.changeFont(A);
					draw|=1;
				}
			}
			else
				draw|=itb.inputMouseWheel(wParam);
			if(draw)
				render();
		}
		return 0;
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		switch(wParam)//global commands
		{
		case VK_ESCAPE:
			if(modes::active)
			{
				modes::active=false, modes::mode->exit();
				itb.setDimensions(0, 0, w, h);
				if(kb[VK_LBUTTON])
					inactiveLMBDown=1, itb.switchToWithMouseOn(oldMouse);
				render();
				return 0;
			}
			else if(modes::ready)
			{
				if(kb[VK_LBUTTON])
					inactiveLMBDown=0, itb.inputLButtonUp();
				modes::active=true, modes::mode->enter();
			}
			break;
		case VK_F1://toggle context help
			break;
		case VK_F4:
			if(kb[VK_MENU])
				PostQuitMessage(0);
			return 0;
	//	case VK_F6://3D mode move cam
		case VK_F7:
			showBenchmark=!showBenchmark;
			if(!modes::active)
				render();
			break;
		case VK_F8://toggle 2d drag convention
			_2d_drag_graph_not_window=!_2d_drag_graph_not_window;
			break;
		case VK_F9://l2d shift is not dangerous
			_dangerous_code=!_dangerous_code;
			break;
		case VK_F10://last mode vs blank on idle
			showLastModeOnIdle=!showLastModeOnIdle;
			break;
		case VK_F11://fullscreen
			if(fullscreen)//exit fullscreen
			{
				SetWindowLongA(hWnd, GWL_STYLE, WS_CAPTION|WS_SYSMENU|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX|WS_CLIPCHILDREN);
				SetWindowPos(hWnd, HWND_TOP, oldWindowSize.left, oldWindowSize.top, oldWindowSize.right-oldWindowSize.left, oldWindowSize.bottom-oldWindowSize.top, SWP_SHOWWINDOW);
			}
			else//enter fullscreen
			{
				GetWindowRect(ghWnd, &oldWindowSize);
				SetWindowLongA(hWnd, GWL_STYLE, WS_OVERLAPPED);
				SetWindowPos(hWnd, HWND_TOP, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN), SWP_SHOWWINDOW);
			}
			fullscreen=!fullscreen;
			break;
		case VK_CAPITAL:
			caps_lock=!caps_lock;
			return 0;
		case VK_NUMLOCK:
			num_lock=!num_lock;
			return 0;
		case VK_ADD:case VK_OEM_PLUS:
			if(!modes::active&&kb[VK_CONTROL])
			{
				double A=font.larger();
				if(A!=1)
				{
					itb.changeFont(A);
					render();
				}
				return 0;
			}
			break;
		case VK_SUBTRACT:case VK_OEM_MINUS:
			if(!modes::active&&kb[VK_CONTROL])
			{
				double A=font.smaller();
				if(A!=1)
				{
					itb.changeFont(A);
					render();
				}
				return 0;
			}
			break;
		case '0':case VK_NUMPAD0:
			if(!modes::active&&kb[VK_CONTROL])
			{
				double A=font.assign(3);
				if(A!=1)
				{
					itb.changeFont(A);
					render();
				}
				return 0;
			}
			break;
		}
		if(modes::active)
		{
			modes::mode->inputKeyDown(wParam, lParam);
			kb[wParam]=1;
		}
		else
		{
			kb[wParam]=1;
			int action=0;
			if(modes::nExpr[1]&&kb[VK_CONTROL]&&kb[VK_SHIFT]&&(wParam=='C'||wParam=='X'))
		//	if(modes::nExpr[1]&&kb[VK_CONTROL]&&!kb[VK_SHIFT]&&(wParam=='C'||wParam=='X'))
				action=copy_text_with_n0d_results(wParam);
			else
				action=itb.inputKeyDown(wParam, lParam);

			if(exprRemoveEnd<exprInsertEnd)
				expr.insert(expr.begin()+exprRemoveEnd, exprInsertEnd-exprRemoveEnd, Expression());
			else if(exprRemoveEnd>exprInsertEnd)
				expr.erase(expr.begin()+exprInsertEnd, expr.begin()+exprRemoveEnd);
			if(functionRemoveEnd<functionInsertEnd)
				userFunctionDefinitions.insert(userFunctionDefinitions.begin()+functionRemoveEnd, functionInsertEnd-functionRemoveEnd, Expression());
			else if(functionRemoveEnd>functionInsertEnd)
				userFunctionDefinitions.erase(userFunctionDefinitions.begin()+functionInsertEnd, userFunctionDefinitions.begin()+functionRemoveEnd);
		//	if(boundRemoveEnd<boundInsertEnd)
		//		expr.insert(expr.begin()+boundRemoveEnd, boundInsertEnd-boundRemoveEnd, Expression());
		//	else if(boundRemoveEnd>boundInsertEnd)
		//		expr.erase(expr.begin()+boundInsertEnd, expr.begin()+boundRemoveEnd);
		//	if(action==2&&(exprChangeStart<exprInsertEnd||functionChangeStart<functionInsertEnd))//new expressions/functions were inserted
			if(action==2&&boundChangeStart<boundInsertEnd)
			{
				char const			// 0				   1				   2				   3				   4				   5				   6				   7				   8				   9				   10				   11				   12
									// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7
									//																   s ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ del
					*isAlphanumeric	="\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\1\1\1\1\1\1\1\1\1\0\0\0\0\0\0\0\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\0\0\0\1\0\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\0\0\0\0",
					*isLetter		="\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\0\0\0\1\0\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\0\0\0\0",
					*isHexadecimal	="\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\1\1\1\1\1\1\1\1\1\0\0\0\0\0\0\0\1\1\1\1\1\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\1\1\1\1\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
				itb.text=(char*)realloc(itb.text, (itb.textlen+1+10)*sizeof(char));
				memset(&itb.text[itb.textlen+1], ' ', 10*sizeof(char));
				auto text=itb.text;
#if 1
				int kStart=boundChangeStart==0?0:bounds[boundChangeStart-1].first;
				int comment=0;
/*nobreak?*/	for(;comment!=allComments.size()&&allComments[comment].first<kStart;++comment);
				int lineNo=lineChangeStart=itb.getLineNo(0, 0, kStart);

				std::vector<UFVariableName> ufVarNames;
				std::stack<char> scopeLevel;//'{', 'f' for, '(' for(, ')' for()
				int forHeaderPLevel=0;//no alibi
			//	int forHeaderPLevel;
			//	int scopeLevel=0;
				
				user_trigered_seed();
				int e=exprChangeStart, function=functionChangeStart;
				for(int bound=boundChangeStart;bound<boundInsertEnd;++bound)
			//	for(int bound=boundChangeStart, e=exprChangeStart, function=functionChangeStart;bound<boundInsertEnd;++bound)
				{
					int kStart=bound?bounds[bound-1].first:0, kEnd=bounds[bound].first;
					bool exprBound=bounds[bound].second=='e';
					int old_rmode;
					Expression *it;
					if(exprBound)
					{
						it=&expr[e];
						old_rmode=it->rmode[0];
						*it=Expression();
					}
					else
					{
						it=&userFunctionDefinitions[function];
						*it=Expression();
					//	scopeLevel=0;
						ufVarNames.clear();

						//parse function header		correct header syntax checked by profiler
						bool unnamed=true;
						char state='f', mathSet='r';//'f' looking for function name, 'a' reading arg names, 's' arg mathSet specifier
					//	char state='f', mathSet='R';
						int i=-1, f=-1;
						for(int k=kStart, kcEnd=comment!=allComments.size()?allComments[comment].first:kEnd;k<kEnd;++k)
						{
							if(k>=kcEnd)//skip comments
							{
								lineNo=itb.getLineNo(allComments[comment].first, lineNo, allComments[comment].second);
								k=allComments[comment].second-1;
								++comment;
								kcEnd=comment!=allComments.size()?allComments[comment].first:itb.textlen;
								continue;
							}
							if(isLetter[text[k]])
						//	if(text[k]>='A'&&(text[k]<='Z'||text[k]>='a'&&text[k]<='z'||text[k]=='_'))
							{
								for(int k2=(i=k)+1;;++k2)
								{
									if(!isAlphanumeric[text[k2]])
								//	if(text[k2]<'0'||text[k2]>'9'&&(text[k2]<'A'||text[k2]>'Z'&&(text[k2]!='_'&&text[k2]<'a'||text[k2]>'z')))
									{
										if(state=='f')
										{
											it->name_id=userFunctionNames.addName(text, i, k2)->name_id;
											unnamed=false;
										}
										else if(state=='a'||state=='s')
										{
											f=k2;
											if(state!='s'&&k2-i==1&&(text[i]=='r'||text[i]=='R'||text[i]=='c'||text[i]=='C'||text[i]=='h'||text[i]=='H'||text[i]=='q'||text[i]=='Q'))
											{
												switch(text[i])
												{
												case 'r':case 'R':mathSet='r';break;
												case 'c':case 'C':mathSet='c';break;
											//	case 'r':case 'R':mathSet='R';break;
											//	case 'c':case 'C':mathSet='C';break;
												case 'h':case 'H':
												case 'q':case 'Q':mathSet='H';break;
												}
												state='s';
											}
											else
											{
												ufVarNames.push_back(UFVariableName(text+i, f-i, 0, it->data.size()));
												it->insertFVar(mathSet);
											//	it->insertData(mathSet, Value());
												++it->nArgs;
												mathSet='r';
											//	mathSet='R';
											}
										}
										k=k2-1;
										break;
									}
								}
							}
							else if(text[k]=='(')
								state='a';
							else if(text[k]==',')
							{
								if(state=='a')
									continue;
								else if(state=='s')//not a specifier but a variable
								{
									ufVarNames.push_back(UFVariableName(text+i, f-i, 0, it->data.size()));
									it->insertFVar(mathSet);
								//	it->insertData(mathSet, 0);
									continue;
								}
								else if(state=='f')//unreachable
									break;
							}
							else if(text[k]==')')//header end
							{
								for(++k;text[k]!='{';++k)
								{
									bool newline=text[k]=='\r';
									lineNo+=newline||text[k]=='\n', k+=newline&&text[k+1]=='\n';//robust
								}
								//	lineNo+=text[k]=='\r';
								kStart=k;//definition lexing starts with { or CRASH
							//	kStart=k+1;
								break;
							}
							else if(text[k]=='{')//header end
							{
								kStart=k;
							//	--k;
								break;
							}
							else if(text[k]!=' '&&text[k]!='\t')//unreachable
								break;
						}
						if(unnamed)
							it->name_id=-1;
					}
					it->lineNo=lineNo, it->boundNo=bound;
					bool notForLoopHeaderScope=true;
					for(int k=kStart, kcEnd=comment!=allComments.size()?allComments[comment].first:kEnd;k<kEnd;++k)//lexer loop
					{
						if(k>=kcEnd)//skip comments
						{
							lineNo=itb.getLineNo(allComments[comment].first, lineNo, allComments[comment].second);
							k=allComments[comment].second-1;
							++comment;
							kcEnd=comment!=allComments.size()?allComments[comment].first:itb.textlen;
							continue;
						}
						{//user function call
							NameTreeNode* node=nullptr;
							int nameEnd;
							if(exprBound)
								node=userFunctionNames.matchName_free(text, k, kEnd, nameEnd);
							else//user function bound, get token call identifier
							{
								if((k-1<0||!isAlphanumeric[text[k-1]])&&isLetter[text[k]])
							//	if((k-1<0||text[k-1]<'0'||text[k-1]>'9'&&text[k-1]<'A'||text[k-1]>'Z'&&text[k-1]!='_'&&text[k-1]<'a'||text[k-1]>'z')&&text[k]>='A'&&(text[k]<='Z'||text[k]>='a'&&text[k]<='z'||text[k]=='_'))
							//	if(text[k]>='A'&&text[k]<='Z'||text[k]>='a'&&text[k]<='z'||text[k]=='_')
								{
									for(int f=k+1;f<=kEnd;++f)
									{
										if(!isAlphanumeric[text[f]])
									//	if(text[f]<'0'||text[f]>'9'&&text[f]<'A'||text[f]>'Z'&&text[f]!='_'&&text[f]<'a'||text[f]>'z')
										{
											node=userFunctionNames.matchName(text, k, f, nameEnd);
											break;
										}
									}
								}
							}
							if(node)
							{
								bool match=false;
								for(int d=0, dEnd=userFunctionDefinitions.size();d<dEnd;++d)
								{
									auto &definition=userFunctionDefinitions[d];
									if(definition.m.size()&&definition.m.rbegin()->pos>k)
										break;
									if(definition.name_id==node->name_id)
									{
										match=true;
										break;
									}
								}//*/
							/*	for(int d=0, dEnd=userFunctionDefinitions.size();d<dEnd&&userFunctionDefinitions[d].lineNo<=lineNo;++d)
								{
									if(userFunctionDefinitions[d].name_id==node->name_id)
									{
										match=true;
										break;
									}
								}//*/
								if(match)
								{
									it->insertMap(k, nameEnd-k, G2::M_USER_FUNCTION, node->name_id);
									k=nameEnd-1;
									continue;
								}
								else
									userFunctionNames.removeName(text, k, nameEnd);
							/*	it->insertMap(k, nameEnd-k, G2::M_USER_FUNCTION, node->name_id);
							//	it->insertMap(G2::M_USER_FUNCTION, node->name_id);
								k=nameEnd-1;
								continue;//*/
							}
						}
						using namespace G2;
						switch(text[k])
						{
						case '(':
							if(!exprBound)
							{
								auto &scope=scopeLevel.top();
								if(scope=='f')
									scope='(', forHeaderPLevel=1;
								else if(scope=='(')
									++forHeaderPLevel;
							}
							it->insertMap(k, 1, M_LPR);
						//	it->insertMap(M_LPR);
							continue;
						//	it->insertMap(M_LPR);
						//	continue;
						case ')':
							if(!exprBound)
							{
								auto &scope=scopeLevel.top();
								if(scope=='(')
								{
									--forHeaderPLevel;
									if(!forHeaderPLevel)
										scope=')';
								}
							}
							it->insertMap(k, 1, M_RPR);
						//	it->insertMap(M_RPR);
							continue;
						//	it->insertMap(M_RPR);
						//	continue;
						case '{':
							if(!exprBound)
							{
								if(!scopeLevel.size()||scopeLevel.top()=='{')
									scopeLevel.push('{');
								else
									scopeLevel.top()='{';
								it->insertMap(k, 1, M_LBRACE);
							//	it->insertMap(M_LBRACE);
								continue;
							}
							continue;//exprBound
						//	break;
						/*	if(!exprBound)
							{
								if(notForLoopHeaderScope)
									++scopeLevel;
								notForLoopHeaderScope=true;
								it->insertMap(M_LBRACE);
								continue;
							}
							break;//*/
						/*	if(!exprBound&&notForLoopHeaderScope)
								++scopeLevel;
							notForLoopHeaderScope=true;
							it->insertMap(M_LBRACE);
							continue;//*/
						case '}':
							if(!exprBound)
							{
								scopeLevel.pop();
								for(;scopeLevel.size()&&scopeLevel.top()==')';)
									scopeLevel.pop();
								if(ufVarNames.size())
								{
									int level=scopeLevel.size();
									for(int n=ufVarNames.size()-1;;--n)
									{
										if(n<0||ufVarNames[n].scopeLevel<=level)
										{
											ufVarNames.erase(ufVarNames.begin()+n+1, ufVarNames.end());
											break;
										}
									}
								}
								it->insertMap(k, 1, M_RBRACE);
							//	it->insertMap(M_RBRACE);
								continue;
							}
							continue;//exprBound
						//	break;//*/
						/*	if(!exprBound)
							{
								--scopeLevel;
								if(ufVarNames.size())
								{
									for(int n=ufVarNames.size()-1;;--n)
									{
										if(n<0||ufVarNames[n].scopeLevel==scopeLevel)
										{
											ufVarNames.erase(ufVarNames.begin()+n+1, ufVarNames.end());
											break;
										}
									}
								}
								it->insertMap(M_RBRACE);
								continue;
							}
							break;//*/
						case ',':
							it->insertMap(k, 1, M_COMMA);
						//	it->insertMap(M_COMMA);
							continue;
						case ';':
							if(!exprBound)
							{
								auto &scope=scopeLevel.top();
								if(scope==')'||scope=='f')
								{
									scopeLevel.pop();
									for(;scopeLevel.size()&&scopeLevel.top()==')';)
										scopeLevel.pop();
									if(ufVarNames.size())
									{
										int level=scopeLevel.size();
										for(int n=ufVarNames.size()-1;;--n)
										{
											if(n<0||ufVarNames[n].scopeLevel<=level)
											{
												ufVarNames.erase(ufVarNames.begin()+n+1, ufVarNames.end());
												break;
											}
										}
									}
								}
								it->insertMap(k, 1, M_SEMICOLON);
							//	it->insertMap(M_SEMICOLON);
								continue;
							}
						/*	if(!exprBound)
							{
								it->insertMap(M_SEMICOLON);
								continue;
							}//*/
							continue;//exprBound
						//	break;
						case '0':
							if((text[k+1]=='x'||text[k+1]=='X')&&(isHexadecimal[text[k+2]]||text[k+2]=='.'))
						//	if((text[k+1]=='x'||text[k+1]=='X')&&(text[k+2]>='0'&&text[k+2]<='9'||text[k+2]>='a'&&text[k+2]<='f'||text[k+2]>='A'&&text[k+2]<='F'||text[k+2]=='.'))
							{
								bool number=false;
								for(int k2=k+2;k2<=itb.textlen;++k2)
								{
									if(isHexadecimal[text[k2]])
								//	if(text[k2]>='0'&&text[k2]<='9'||text[k2]>='a'&&text[k2]<='f'||text[k2]>='A'&&text[k2]<='F')
										number=true;
									else if(text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))
									{
										if(number&&(exprBound||!isAlphanumeric[text[k2]]))
									//	if(number)
										{
											bool E_notation=(text[k2]=='p'||text[k2]=='P')//p notation	c99, java5
												&&(isHexadecimal[text[k2+1]]||text[k2+1]=='.'
													||(text[k2+1]=='+'||text[k2+1]=='-')&&(isHexadecimal[text[k2+2]]||text[k2+2]=='.'));
											//	&&(text[k2+1]>='0'&&text[k2+1]<='9'||text[k2+1]>='a'&&text[k2+1]<='f'||text[k2+1]>='A'&&text[k2+1]<='F'||text[k2+1]=='.'
											//		||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='9'||text[k2+2]>='a'&&text[k2+2]<='f'||text[k2+2]>='A'&&text[k2+2]<='F'||text[k2+2]=='.'));
											if(!E_notation)
												for(;text[k2-1]==',';--k2);
											double p=1;
											for(int k4=k+2;k4<k2;++k4)
											{
												if(text[k4]=='.')
												{
													for(int k5=k4+1;k5<k2;++k5)
														if(text[k5]!='.'&&text[k5]!=',')
															p/=16;
													break;
												}
											}
											double val=0;
											for(int k4=k2-1;k4>=k+2;--k4)
											{
												switch(text[k4])
												{
												case '0':						break;
												case '1':			val+=   p;	break;
												case '2':			val+= 2*p;	break;
												case '3':			val+= 3*p;	break;
												case '4':			val+= 4*p;	break;
												case '5':			val+= 5*p;	break;
												case '6':			val+= 6*p;	break;
												case '7':			val+= 7*p;	break;
												case '8':			val+= 8*p;	break;
												case '9':			val+= 9*p;	break;
												case 'a':case 'A':	val+=10*p;	break;
												case 'b':case 'B':	val+=11*p;	break;
												case 'c':case 'C':	val+=12*p;	break;
												case 'd':case 'D':	val+=13*p;	break;
												case 'e':case 'E':	val+=14*p;	break;
												case 'f':case 'F':	val+=15*p;	break;
												default:						continue;
												}
												p*=16;
											}
											if(E_notation)
											{
												int sign=text[k2+1]=='-'?-1:1;
												bool number=false;
												for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)
												{
													if(isHexadecimal[text[k4]])
												//	if(text[k4]>='0'&&text[k4]<='9'||text[k4]>='a'&&text[k4]<='f'||text[k4]>='A'&&text[k4]<='F')
														number=true;
													else if(text[k4]!='.')
													{
														if(number)
														{
															double p=1;
															for(int k5=k3;k5<k4;++k5)
															{
																if(text[k5]=='.')
																{
																	for(int k6=k5+1;k6<k4;++k6)
																		if(text[k6]!='.')
																			p/=16;
																	break;
																}
															}
															double val2=0;
															for(int k5=k4-1;k5>=k3;--k5)
															{
																if(text[k5]!='.')
																{
																	switch(text[k5])
																	{
																	case '0':						break;
																	case '1':			val2+=   p;	break;
																	case '2':			val2+= 2*p;	break;
																	case '3':			val2+= 3*p;	break;
																	case '4':			val2+= 4*p;	break;
																	case '5':			val2+= 5*p;	break;
																	case '6':			val2+= 6*p;	break;
																	case '7':			val2+= 7*p;	break;
																	case '8':			val2+= 8*p;	break;
																	case '9':			val2+= 9*p;	break;
																	case 'a':case 'A':	val2+=10*p;	break;
																	case 'b':case 'B':	val2+=11*p;	break;
																	case 'c':case 'C':	val2+=12*p;	break;
																	case 'd':case 'D':	val2+=13*p;	break;
																	case 'e':case 'E':	val2+=14*p;	break;
																	case 'f':case 'F':	val2+=15*p;	break;
																	default:						continue;
																	}
																	p*=16;
																}
															}
															const double logBase=std::log(2.);//power of 2		c99
															val*=std::exp(sign*val2*logBase);
															k2=k4;
														}
														break;
													}
												}
											}
											it->insertMapData(k, k2-k, 'r', val);
										//	it->insertMapData('r', val);
										//	it->insertData('R', val);
											k=k2-1;
										}
										break;
									}
								}
								continue;
							}
							else if(text[k+1]>='0'&&text[k+1]<='7')
							{
								for(int k2=k+2;k2<=itb.textlen;++k2)
								{
									if(text[k2]=='8'||text[k2]=='9')//default to decimal
										break;
									if((text[k2]<'0'||text[k2]>'7')&&text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))
									{
										if(exprBound||!isAlphanumeric[text[k2]])
										{
											bool E_notation=(text[k2]=='e'||text[k2]=='E')
												&&(text[k2+1]>='0'&&text[k2+1]<='7'||text[k2+1]=='.'
													||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='7'||text[k2+2]=='.'));
											if(!E_notation)
												for(;text[k2-1]==',';--k2);
													double p=1;
											for(int k4=k+1;k4<k2;++k4)
											{
												if(text[k4]=='.')
												{
													for(int k5=k4+1;k5<k2;++k5)
														if(text[k5]>='0'&&text[k5]<='7')
															p/=8;
													break;
												}
											}
											double val=0;
											for(int k4=k2-1;k4>=k+1;--k4)
												if(text[k4]>='0'&&text[k4]<='7')
													val+=(text[k4]-'0')*p, p*=8;
											if(E_notation)
											{
												int sign=text[k2+1]=='-'?-1:1;
												bool number=false;
												for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)
												{
													if(text[k4]>='0'&&text[k4]<='7')
														number=true;
													else if(text[k4]!='.')
													{
														if(number)
														{
															double p=1;
															for(int k5=k3;k5<k4;++k5)
															{
																if(text[k5]=='.')
																{
																	for(int k6=k5+1;k6<k4;++k6)
																		if(text[k6]!='.')
																			p/=8;
																		//	p/=10;
																	break;
																}
															}
															double val2=0;
															for(int k5=k4-1;k5>=k3;--k5)
																if(text[k5]!='.')
																	val2+=(text[k5]-'0')*p, p*=8;
																//	val2+=(text[k5]-'0')*p, p*=10;
															const double logBase=std::log(8.);
															val*=std::exp(sign*val2*logBase);
															k2=k4;
														}
														break;
													}
												}
											}
											it->insertMapData(k, k2-k, 'r', val);
										//	it->insertMapData('r', val);
										//	it->insertData('R', val);
											k=k2-1;
										}
										break;
									}
								}
								continue;
							}
						case '1':case '2':case '3':case '4':case '5':case '6':case '7':case '8':case '9':case '.':
							{
								bool number=false;
								for(int k2=k;k2<=itb.textlen;++k2)
								{
									if(text[k2]>='0'&&text[k2]<='9')
										number=true;
									else if(text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))
									{
										if(number&&(exprBound||!isAlphanumeric[text[k2]]))
									//	if(number)
										{
											bool E_notation=(text[k2]=='e'||text[k2]=='E')
												&&(text[k2+1]>='0'&&text[k2+1]<='9'||text[k2+1]=='.'
													||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='9'||text[k2+2]=='.'));
											if(!E_notation)
												for(;text[k2-1]==',';--k2);
											double p=1;
											for(int k4=k;k4<k2;++k4)
											{
												if(text[k4]=='.')
												{
													for(int k5=k4+1;k5<k2;++k5)
														if(text[k5]>='0'&&text[k5]<='9')
															p/=10;
													break;
												}
											}
											double val=0;
											for(int k4=k2-1;k4>=k;--k4)
												if(text[k4]>='0'&&text[k4]<='9')
													val+=(text[k4]-'0')*p, p*=10;
											if(E_notation)
											{
												int sign=text[k2+1]=='-'?-1:1;
												number=false;
												for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)
												{
													if(text[k4]>='0'&&text[k4]<='9')
														number=true;
													else if(text[k4]!='.')
													{
														if(number)
														{
															double p=1;
															for(int k5=k3;k5<k4;++k5)
															{
																if(text[k5]=='.')
																{
																	for(int k6=k5+1;k6<k4;++k6)
																		if(text[k6]!='.')
																			p/=10;
																	break;
																}
															}
															double val2=0;
															for(int k5=k4-1;k5>=k3;--k5)
																if(text[k5]!='.')
																	val2+=(text[k5]-'0')*p, p*=10;
															const double logBase=std::log(10.);
															val*=std::exp(sign*val2*logBase);
															k2=k4;
														}
														break;
													}
												}
											}
											it->insertMapData(k, k2-k, 'r', val);
										//	it->insertMapData('r', val);
										//	it->insertData('R', val);
											k=k2-1;
										}
										break;
									}
								}
							}
							continue;
						case '_':			 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='t'||text[k+2]=='T'){		 if(text[k+3]=='m'||text[k+3]=='M'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMapData	(k, 4, 'r', _atm				);	k+=3;	continue;}	   }}}
										else if(text[k+1]=='b'||text[k+1]=='B'){		 if(text[k+2]=='b'||text[k+2]=='B'){		 if(text[k+3]=='r'||text[k+3]=='R'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMapData	(k, 4, 'r', _bbr				);	k+=3;	continue;}	   }}}
										else if(text[k+1]=='c'||text[k+1]=='C'){																																																																																																				if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMapData	(k, 2, 'r', _c					);	++k;	continue;}	     }
										else if(text[k+1]=='e'||text[k+1]=='E'){		 if((text[k+2]=='l'||text[k+2]=='L')		&&(text[k+3]=='e'||text[k+3]=='E')){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMapData	(k, 4, 'r', _ele				);	k+=3;	continue;}	    }
																					else								   {																																																																																									if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMapData	(k, 2, 'r', _e					);	++k;	continue;}	    }}
										else if(text[k+1]=='g'				  ){																																																																																																				if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMapData	(k, 2, 'r', _g					);	++k;	continue;}	     }
										else if(text[k+1]=='G'				  ){																																																																																																				if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMapData	(k, 2, 'r', _G					);	++k;	continue;}	     }
										else if(text[k+1]=='h'||text[k+1]=='H'){																																																																																																				if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMapData	(k, 2, 'r', _h					);	++k;	continue;}	     }
										else if(text[k+1]=='m'				  ){		 if(text[k+2]=='a'||text[k+2]=='A'){		 if(text[k+3]=='g'||text[k+3]=='G'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMapData	(k, 4, 'r', _mag				);	k+=3;	continue;}	   }}
																					else if(text[k+2]=='e'||text[k+2]=='E'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMapData	(k, 3, 'r', _me					);	k+=2;	continue;}	    }
																					else if(text[k+2]=='n'||text[k+2]=='N'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMapData	(k, 3, 'r', _mn					);	k+=2;	continue;}	    }
																					else if(text[k+2]=='p'||text[k+2]=='P'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMapData	(k, 3, 'r', _mp					);	k+=2;	continue;}	    }}
										else if(				text[k+1]=='M'){		 if(text[k+2]=='a'||text[k+2]=='A'){		 if(text[k+3]=='g'||text[k+3]=='G'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMapData	(k, 4, 'r', _mag				);	k+=3;	continue;}	   }}
																					else if(text[k+2]=='e'||text[k+2]=='E'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMapData	(k, 3, 'r', _Me					);	k+=2;	continue;}	    }
																					else if(text[k+2]=='n'||text[k+2]=='N'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMapData	(k, 3, 'r', _mn					);	k+=2;	continue;}	    }
																					else if(text[k+2]=='p'||text[k+2]=='P'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMapData	(k, 3, 'r', _mp					);	k+=2;	continue;}	    }
																					else if(text[k+2]=='s'||text[k+2]=='S'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMapData	(k, 3, 'r', _Ms					);	k+=2;	continue;}	    }}
										else if(text[k+1]=='n'||text[k+1]=='N'){		 if(text[k+2]=='a'||text[k+2]=='A'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMapData	(k, 3, 'r', _Na					);	k+=2;	continue;}	    }}
										else if(text[k+1]=='p'||text[k+1]=='P'){		 if(text[k+2]=='h'||text[k+2]=='H'){		 if(text[k+3]=='i'||text[k+3]=='I'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMapData	(k, 4, 'r', _phi				);	k+=3;	continue;}	   }}
																					else if(text[k+2]=='i'||text[k+2]=='I'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMapData	(k, 3, 'r', _pi					);	k+=2;	continue;}	    }}
										else if(text[k+1]=='q'||text[k+1]=='Q'){																																																																																																				if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMapData	(k, 2, 'r', _q					);	++k;	continue;}	     }
										else if(text[k+1]=='r'||text[k+1]=='R'){		 if((text[k+2]=='a'||text[k+2]=='A')		&&(text[k+3]=='n'||text[k+3]=='N')			&&(text[k+4]=='d'||text[k+4]=='D')){																																																																			if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMapData	(k, 2, 'r', rand()				);	++k;	continue;}	    }
																					else								   {																																																																																									if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMapData	(k, 2, 'r', _R					);	++k;	continue;}	    }}	break;
						case 'i':			 if(text[k+1]=='f'&&!exprBound	  ){																																																																																																															it->insertMap		(k, 2, M_IF						);	++k;	continue;		 }
										else if(text[k+1]=='m'||text[k+1]=='M'){																																																																																																				if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMap		(k, 2, M_IMAG					);	++k;	continue;}		 }
										else if(text[k+1]=='n'||text[k+1]=='N'){		 if(text[k+2]=='d'||text[k+2]=='D'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMapData	(k, 3, 'r', _qnan				);	k+=2;	continue;}		 }
																					else if(text[k+2]=='f'||text[k+2]=='F'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMapData	(k, 3, 'r', _HUGE				);	k+=2;	continue;}		 }
																					else if((text[k+2]=='v'||text[k+2]=='V')		&&(text[k+3]=='s'||text[k+3]=='S')			&&(text[k+4]=='q'||text[k+4]=='Q')			&&(text[k+5]=='r'||text[k+5]=='R')			&&(text[k+6]=='t'||text[k+6]=='T')){																																													if(exprBound||!isAlphanumeric[text[k+7]]){	it->insertMap		(k, 7, M_INVSQRT				);	k+=6;	continue;}		}}
										else								   {																																																																																																				if(exprBound||!isAlphanumeric[text[k+1]]){	it->insertMapData	(k, 1, 'c', 0, 1				);			continue;}		 }	break;
								 case 'I':	 if(text[k+1]=='m'||text[k+1]=='M'){																																																																																																				if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMap		(k, 2, M_IMAG					);	++k;	continue;}		 }
										else if(text[k+1]=='n'||text[k+1]=='N'){		 if(text[k+2]=='d'||text[k+2]=='D'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMapData	(k, 3, 'r', _qnan				);	k+=2;	continue;}		 }
																					else if(text[k+2]=='f'||text[k+2]=='F'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMapData	(k, 3, 'r', _HUGE				);	k+=2;	continue;}		 }
																					else if((text[k+2]=='v'||text[k+2]=='V')			&&(text[k+3]=='s'||text[k+3]=='S')			&&(text[k+4]=='q'||text[k+4]=='Q')			&&(text[k+5]=='r'||text[k+5]=='R')			&&(text[k+6]=='t'||text[k+6]=='T')){																																												if(exprBound||!isAlphanumeric[text[k+7]]){	it->insertMap		(k, 7, M_INVSQRT				);	k+=6;	continue;}		 }}	break;
						case 'j':																																																																																																																if(exprBound||!isAlphanumeric[text[k+1]]){	it->insertMapData	(k, 1, 'H', 0, 0, 1				);			continue;}			break;
								 case 'J':																																																																																																														if(exprBound||!isAlphanumeric[text[k+1]]){	it->insertMap		(k, 1, M_BESSEL					);			continue;}			break;
						case 'k':																																																																																																																if(exprBound||!isAlphanumeric[text[k+1]]){	it->insertMapData	(k, 1, 'H', 0, 0, 0, 1			);			continue;}
						case 'x':			 if(exprBound)						{																																																																																																															it->insertRVar		(k, 1, &text[k], 's'			);			continue;		  }	break;
						case 'y':			 if(exprBound)						{																																																																																																															it->insertRVar		(k, 1, &text[k], 's'			);			continue;		  }	break;
						case 'Y':																																																																																																																if(exprBound||!isAlphanumeric[text[k+1]]){	it->insertMap		(k, 1, M_NEUMANN				);}			continue;
						case 'z':			 if((text[k+1]=='e'||text[k+1]=='E')		&&(text[k+2]=='t'||text[k+2]=='T')			&&(text[k+3]=='a'||text[k+3]=='A')){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_ZETA					);	k+=3;	continue;}		  }
										else if(exprBound)					   {																																																																																																															it->insertRVar		(k, 1, &text[k], 's'			);			continue;		  }	break;
						case 'Z':			 if((text[k+1]=='e'||text[k+1]=='E')		&&(text[k+2]=='t'||text[k+2]=='T')			&&(text[k+3]=='a'||text[k+3]=='A')){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_ZETA					);	k+=3;	continue;}		  }
										else if(exprBound)					   {																																																																																																															it->insertCVar		(k, 1, &text[k]					);			continue;		  }	break;
						case '\'':
							if(exprBound)
							{
								bool hit=false;
								for(int k2=k+1;k2<=itb.textlen;++k2)
								{
									if(!isAlphanumeric[text[k2]])
								//	if((text[k2]<'a'||text[k2]>'z')&&(text[k2]<'A'||text[k2]>'Z')&&(text[k2]<'0'||text[k2]>'9')&&text[k2]!='_')
									{
										it->insertRVar(k+1, k2-(k+1), &text[k+1], 's');
									//	it->insertRVar(&text[k+1], k2-(k+1), 's');
										k=text[k2]=='\''?k2:k2-1;
										hit=true;
										break;
									}
								}
								if(hit)
									continue;
							}
							break;
						case 'Q':			 if(exprBound)						{																																																																																																															it->insertHVar		(k, 1, &text[k]					);			continue;		 }	break;
						case '+':			 if(text[k+1]=='='&&!exprBound	  ){																																																																																																															it->insertMap		(k, 1, M_ASSIGN_PLUS			);	++k;	continue;		 }
										else if(text[k+1]=='+'&&!exprBound	  ){																																																																																																															it->insertMap		(k, 2, M_INCREMENT				);	++k;	continue;		 }
										else								   {																																																																																																															it->insertMap		(k, 1, M_PLUS					);			continue;		 }	break;
						case '-':			 if(text[k+1]=='='&&!exprBound	  ){																																																																																																															it->insertMap		(k, 2, M_ASSIGN_MINUS			);	++k;	continue;		 }
										else if(text[k+1]=='-'&&!exprBound	  ){																																																																																																															it->insertMap		(k, 2, M_DECREMENT				);	++k;	continue;		 }
										else								   {																																																																																																															it->insertMap		(k, 1, M_MINUS					);			continue;		 }	break;
						case '*':			 if(text[k+1]=='='&&!exprBound	  ){																																																																																																															it->insertMap		(k, 2, M_ASSIGN_MULTIPLY		);	++k;	continue;		 }
										else								   {																																																																																																															it->insertMap		(k, 1, M_MULTIPLY				);			continue;		 }	break;
						case '/':			 if(text[k+1]=='='&&!exprBound	  ){																																																																																																															it->insertMap		(k, 2, M_ASSIGN_DIVIDE			);	++k;	continue;		 }
										else								   {																																																																																																															it->insertMap		(k, 1, M_DIVIDE					);			continue;		 }	break;
						case '%':			 if(text[k+1]=='='&&!exprBound	  ){																																																																																																															it->insertMap		(k, 2, M_ASSIGN_MOD				);	++k;	continue;		 }
										else								   {									   																																																																																																						it->insertMap		(k, 1, M_MODULO_PERCENT			);			continue;		 }	break;
						case '@':																					   																																																																																																						it->insertMap		(k, 1, M_LOGIC_DIVIDES			);			continue;
						case '^':			 if(text[k+1]=='^'				  ){		 if(text[k+2]=='^'				  ){																																																																																																				it->insertMap		(k, 3, M_PENTATE				);	k+=2;	continue;	    }
																					else								   {																																																																																																				it->insertMap		(k, 2, M_TETRATE				);	++k;	continue;	    }}
										else if(text[k+1]=='~'				  ){																																																																																																															it->insertMap		(k, 2, M_BITWISE_XNOR			);	++k;	continue;	     }
										else								   {																																																																																																															it->insertMap		(k, 1, M_POWER					);			continue;	     }	break;
						case '!':			 if(text[k+1]=='='				  ){																																																																																																															it->insertMap		(k, 2, M_LOGIC_NOT_EQUAL		);	++k;	continue;		 }
										else								   {																																																																																																															it->insertMap		(k, 1, M_FACTORIAL_LOGIC_NOT	);			continue;		 }	break;
						case '~':			 if(text[k+1]=='&'				  ){																																																																																																															it->insertMap		(k, 2, M_BITWISE_NAND			);	++k;	continue;		 }
										else if(text[k+1]=='#'				  ){																																																																																																															it->insertMap		(k, 2, M_BITWISE_XNOR			);	++k;	continue;		 }
										else if(text[k+1]=='|'				  ){																																																																																																															it->insertMap		(k, 2, M_BITWISE_NOR			);	++k;	continue;		 }
										else								   {																																																																																																															it->insertMap		(k, 1, M_BITWISE_NOT			);			continue;		 }	break;
						case '&':			 if(text[k+1]=='&'				  ){																																																																																																															it->insertMap		(k, 2, M_LOGIC_AND				);	++k;	continue;	     }
										else if(text[k+1]=='~'				  ){																																																																																																															it->insertMap		(k, 2, M_BITWISE_NOR			);	++k;	continue;	     }
										else if(text[k+1]=='='&&!exprBound	  ){																																																																																																															it->insertMap		(k, 2, M_ASSIGN_AND				);	++k;	continue;	     }
										else								   {																																																																																																															it->insertMap		(k, 1, M_BITWISE_AND			);			continue;		 }	break;
						case '#':			 if(text[k+1]=='#'				  ){																																																																																																															it->insertMap		(k, 2, M_LOGIC_XOR				);	++k;	continue;	     }
										else if(text[k+1]=='~'				  ){																																																																																																															it->insertMap		(k, 2, M_BITWISE_XNOR			);	++k;	continue;	     }
										else if(text[k+1]=='='&&!exprBound	  ){																																																																																																															it->insertMap		(k, 2, M_ASSIGN_XOR				);	++k;	continue;	     }
										else								   {																																																																																																															it->insertMap		(k, 1, M_BITWISE_XOR			);			continue;		 }	break;
						case '|':			 if(text[k+1]=='|'				  ){																																																																																																															it->insertMap		(k, 2, M_LOGIC_OR				);	++k;	continue;	     }
										else if(text[k+1]=='~'				  ){																																																																																																															it->insertMap		(k, 2, M_BITWISE_NAND			);	++k;	continue;	     }
										else if(text[k+1]=='='&&!exprBound	  ){																																																																																																															it->insertMap		(k, 2, M_ASSIGN_OR				);	++k;	continue;	     }
										else								   {																																																																																																															it->insertMap		(k, 1, M_VERTICAL_BAR			);			continue;	     }	break;
						case '<':			 if(text[k+1]=='<'				  ){		 if(text[k+2]=='='&&!exprBound	  ){																																																																																																				it->insertMap		(k, 3, M_ASSIGN_LEFT			);	k+=2;	continue;		}
																					else								   {																																																																																																				it->insertMap		(k, 2, M_BITWISE_SHIFT_LEFT		);	++k;	continue;	    }}
										else if(text[k+1]=='='				  ){																																																																																																															it->insertMap		(k, 2, M_LOGIC_LESS_EQUAL		);	++k;	continue;	     }
										else								   {																																																																																																															it->insertMap		(k, 1, M_LOGIC_LESS				);			continue;	     }	break;
						case '>':			 if(text[k+1]=='>'				  ){		 if(text[k+2]=='='&&!exprBound	  ){																																																																																																				it->insertMap		(k, 3, M_ASSIGN_RIGHT			);	k+=2;	continue;		}
																					else								   {																																																																																																				it->insertMap		(k, 2, M_BITWISE_SHIFT_RIGHT	);	++k;	continue;	    }}
										else if(text[k+1]=='='				  ){																																																																																																															it->insertMap		(k, 2, M_LOGIC_GREATER_EQUAL	);	++k;	continue;	     }
										else								   {																																																																																																															it->insertMap		(k, 1, M_LOGIC_GREATER			);			continue;	     }	break;
						case '=':			 if(text[k+1]=='='				  ){																																																																																																															it->insertMap		(k, 2, M_LOGIC_EQUAL			);	++k;	continue;	     }
										else if(!exprBound					  ){																																																																																																															it->insertMap		(k, 1, M_ASSIGN					);			continue;		 }	break;
						case '?':			 if(text[k+1]=='?'				  ){																																																																																																															it->insertMap		(k, 2, M_LOGIC_CONDITION_ZERO	);	++k;	continue;		 }
										else																																																																																																																								it->insertMap		(k, 1, M_QUESTION_MARK			);			continue;			break;
						case ':':																																																																																																																											it->insertMap		(k, 1, M_COLON					);			continue;
						case 'a':case 'A':	 if(text[k+1]=='b'||text[k+1]=='B'){		 if(text[k+2]=='s'||text[k+2]=='S'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_ABS					);	k+=2;	continue;}		}}
										else if(text[k+1]=='c'||text[k+1]=='C'){		 if(text[k+2]=='h'||text[k+2]=='H'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_ACOSH					);	k+=2;	continue;}	    }
																					else if(text[k+2]=='o'||text[k+2]=='O'){		 if(text[k+3]=='s'||text[k+3]=='S'){		 if(text[k+4]=='e'||text[k+4]=='E'){		 if(text[k+5]=='c'||text[k+5]=='C'){		 if(text[k+6]=='h'||text[k+6]=='H'){																																													if(exprBound||!isAlphanumeric[text[k+7]]){	it->insertMap		(k, 7, M_ACSCH					);	k+=6;	continue;}	}
																																																																	else								   {																																													if(exprBound||!isAlphanumeric[text[k+6]]){	it->insertMap		(k, 6, M_ACSC					);	k+=5;	continue;}	}}}
																																											else if(text[k+4]=='h'||text[k+4]=='H'){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_ACOSH					);	k+=4;	continue;}	  }
																																											else								   {																																																																			if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_ACOS					);	k+=3;	continue;}	  }}
																																	 if(text[k+3]=='t'||text[k+3]=='T'){		 if(text[k+4]=='h'||text[k+4]=='H'){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_ACOTH					);	k+=4;	continue;}	  }
																																											else								   {																																																																			if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_ACOT					);	k+=3;	continue;}	  }}}
																					else if(text[k+2]=='s'||text[k+2]=='S'){		 if(text[k+3]=='c'||text[k+3]=='C'){		 if(text[k+4]=='h'||text[k+4]=='H'){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_ACSCH					);	k+=4;	continue;}	  }
																																											else								   {																																																																			if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_ACSC					);	k+=3;	continue;}	  }}}}
										else if(text[k+1]=='r'||text[k+1]=='R'){		 if(text[k+2]=='g'||text[k+2]=='G'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_ARG					);	k+=2;	continue;}	    }}
										else if(text[k+1]=='s'||text[k+1]=='S'){		 if(text[k+2]=='e'||text[k+2]=='E'){		 if(text[k+3]=='c'||text[k+3]=='C'){		 if(text[k+4]=='h'||text[k+4]=='H'){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_ASECH					);	k+=4;	continue;}	  }
																																											else								   {																																																																			if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_ASEC					);	k+=3;	continue;}	  }}}
																					else if(text[k+2]=='h'||text[k+2]=='H'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_ASINH					);	k+=2;	continue;}	    }
																					else if(text[k+2]=='i'||text[k+2]=='I'){		 if(text[k+3]=='n'||text[k+3]=='N'){		 if(text[k+4]=='h'||text[k+4]=='H'){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_ASINH					);	k+=4;	continue;}	  }
																																											else								   {																																																																			if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_ASIN					);	k+=3;	continue;}	  }}}}
										else if(text[k+1]=='t'||text[k+1]=='T'){		 if(text[k+2]=='a'||text[k+2]=='A'){		 if(text[k+3]=='n'||text[k+3]=='N'){		 if(text[k+4]=='h'||text[k+4]=='H'){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_ATANH					);	k+=4;	continue;}	  }
																																											else								   {																																																																			if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_ATAN					);	k+=3;	continue;}	  }}}
																					else if(text[k+2]=='h'||text[k+2]=='H'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_ATANH					);	k+=2;	continue;}	    }}	break;
						case 'b':			 if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='s'||text[k+2]=='S'){		 if(text[k+3]=='s'||text[k+3]=='S'){		 if(text[k+4]=='e'||text[k+4]=='E'){		 if(text[k+5]=='l'||text[k+5]=='L'){																																																								if(exprBound||!isAlphanumeric[text[k+6]]){	it->insertMap		(k, 6, M_BESSEL					);	k+=5;	continue;}	 }}}}
																						 if(text[k+2]=='t'||text[k+2]=='T'){		 if(text[k+3]=='a'||text[k+3]=='A'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_BETA					);	k+=3;	continue;}	   }}}
										else if(text[k+1]=='r'				  ){		 if(text[k+2]=='e'				  ){		 if(text[k+3]=='a'				  ){		 if(text[k+4]=='k'&&!exprBound	  ){																																																																														it->insertMap		(k, 5, M_BREAK					);	k+=4;	continue;	  }}}}
							else if(text[k+1]=='0'||text[k+1]=='1'||text[k+1]=='.')
							{
								bool number=false;
								for(int k2=k+1;k2<=itb.textlen;++k2)
								{
									if(text[k2]>='2'&&text[k2]<='9')//default to decimal
										break;
									if(text[k2]=='0'||text[k2]=='1')
										number=true;
									else if(text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))
									{
										if(number&&(exprBound||!isAlphanumeric[text[k+3]]))
									//	if(number)
										{
											bool E_notation=(text[k2]=='e'||text[k2]=='E')
												&&(text[k2+1]>='0'&&text[k2+1]<='1'||text[k2+1]=='.'
													||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='1'||text[k2+2]=='.'));
											if(!E_notation)
												for(;text[k2-1]==',';--k2);
											double p=1;
											for(int k4=k+1;k4<k2;++k4)
											{
												if(text[k4]=='.')
												{
													for(int k5=k4+1;k5<k2;++k5)
														if(text[k5]>='0'&&text[k5]<='1')
															p/=2;
													break;
												}
											}
											double val=0;
											for(int k4=k2-1;k4>=k+1;--k4)
												if(text[k4]>='0'&&text[k4]<='1')
													val+=(text[k4]-'0')*p, p*=2;
											if(E_notation)
											{
												int sign=text[k2+1]=='-'?-1:1;
												number=false;
												for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)
												{
													if(text[k4]>='0'&&text[k4]<='1')
														number=true;
													else if(text[k4]!='.')
													{
														if(number)
														{
															double p=1;
															for(int k5=k3;k5<k4;++k5)
															{
																if(text[k5]=='.')
																{
																	for(int k6=k5+1;k6<k4;++k6)
																		if(text[k6]!='.')
																			p/=2;
																		//	p/=10;
																	break;
																}
															}
															double val2=0;
															for(int k5=k4-1;k5>=k3;--k5)
																if(text[k5]!='.')
																	val2+=(text[k5]-'0')*p, p*=2;
																//	val2+=(text[k5]-'0')*p, p*=10;
															const double logBase=std::log(2.);
															val*=std::exp(sign*val2*logBase);
															k2=k4;
														}
														break;
													}
												}
											}
											it->insertMapData(k, k2-k, 'r', val);
										//	it->insertMapData('r', val);
										//	it->insertData('R', val);
											k=k2-1;
										}
										break;
									}
								}
								continue;
							}
							break;
								 case 'B':	 if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='s'||text[k+2]=='S'){		 if(text[k+3]=='s'||text[k+3]=='S'){		 if(text[k+4]=='e'||text[k+4]=='E'){		 if(text[k+5]=='l'||text[k+5]=='L'){																																																								if(exprBound||!isAlphanumeric[text[k+6]]){	it->insertMap		(k, 6, M_BESSEL					);	k+=5;	continue;}	 }}}}
																						 if(text[k+2]=='t'||text[k+2]=='T'){		 if(text[k+3]=='a'||text[k+3]=='A'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_BETA					);	k+=3;	continue;}	   }}}
							else if(text[k+1]=='0'||text[k+1]=='1'||text[k+1]=='.')
							{
								bool number=false;
								for(int k2=k+1;k2<=itb.textlen;++k2)
								{
									if(text[k2]>='2'&&text[k2]<='9')//default to decimal
										break;
									if(text[k2]=='0'||text[k2]=='1')
										number=true;
									else if(text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))
									{
										if(number&&(exprBound||!isAlphanumeric[text[k+3]]))
									//	if(number)
										{
											bool E_notation=(text[k2]=='e'||text[k2]=='E')
												&&(text[k2+1]>='0'&&text[k2+1]<='1'||text[k2+1]=='.'
													||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='1'||text[k2+2]=='.'));
											if(!E_notation)
												for(;text[k2-1]==',';--k2);
											double p=1;
											for(int k4=k+1;k4<k2;++k4)
											{
												if(text[k4]=='.')
												{
													for(int k5=k4+1;k5<k2;++k5)
														if(text[k5]>='0'&&text[k5]<='1')
															p/=2;
													break;
												}
											}
											double val=0;
											for(int k4=k2-1;k4>=k+1;--k4)
												if(text[k4]>='0'&&text[k4]<='1')
													val+=(text[k4]-'0')*p, p*=2;
											if(E_notation)
											{
												int sign=text[k2+1]=='-'?-1:1;
												number=false;
												for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)
												{
													if(text[k4]>='0'&&text[k4]<='1')
														number=true;
													else if(text[k4]!='.')
													{
														if(number)
														{
															double p=1;
															for(int k5=k3;k5<k4;++k5)
															{
																if(text[k5]=='.')
																{
																	for(int k6=k5+1;k6<k4;++k6)
																		if(text[k6]!='.')
																			p/=2;
																		//	p/=10;
																	break;
																}
															}
															double val2=0;
															for(int k5=k4-1;k5>=k3;--k5)
																if(text[k5]!='.')
																	val2+=(text[k5]-'0')*p, p*=2;
																//	val2+=(text[k5]-'0')*p, p*=10;
															const double logBase=std::log(2.);
															val*=std::exp(sign*val2*logBase);
															k2=k4;
														}
														break;
													}
												}
											}
											it->insertMapData(k, k2-k, 'r', val);
										//	it->insertMapData('r', val);
										//	it->insertData('R', val);
											k=k2-1;
										}
										break;
									}
								}
								continue;
							}
							break;
						case 'c':			 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='r'||text[k+2]=='R'){		 if(text[k+3]=='t'||text[k+3]=='T'){		 if(text[k+4]=='e'||text[k+4]=='E'){		 if(text[k+5]=='s'||text[k+5]=='S'){		 if(text[k+6]=='i'||text[k+6]=='I'){		 if(text[k+7]=='a'||text[k+7]=='A'){		 if(text[k+8]=='n'||text[k+8]=='N'){																							if(exprBound||!isAlphanumeric[text[k+9]]){	it->insertMap		(k, 9, M_CARTESIAN				);	k+=8;	continue;} }}}}}}}}
										else if(text[k+1]=='b'||text[k+1]=='B'){		 if(text[k+2]=='r'||text[k+2]=='R'){		 if(text[k+3]=='t'||text[k+3]=='T'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_CBRT					);	k+=3;	continue;}	   }}}
										else if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='i'||text[k+2]=='I'){		 if(text[k+3]=='l'||text[k+3]=='L'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_CEIL					);	k+=3;	continue;}	   }}}
										else if(text[k+1]=='h'||text[k+1]=='H'){																																																																																																				if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMap		(k, 2, M_COSH					);	++k;	continue;}	     }
										else if(text[k+1]=='o'				  ){		 if(text[k+2]=='m'||text[k+2]=='M'){		 if(text[k+3]=='b'||text[k+3]=='B'){		 if(text[k+4]=='i'||text[k+4]=='I'){		 if(text[k+5]=='n'||text[k+5]=='N'){		 if(text[k+6]=='a'||text[k+6]=='A'){		 if(text[k+7]=='t'||text[k+7]=='T'){		 if(text[k+8]=='i'||text[k+8]=='I'){		 if(text[k+9]=='o'||text[k+9]=='O'){		 if(text[k+10]=='n'||text[k+10]=='N'){	if(exprBound||!isAlphanumeric[text[k+11]]){	it->insertMap		(k, 11, M_COMBINATION			);	k+=10;	continue;}}}}}}}}}}
																					else if(text[k+2]=='n'				  ){		 if(text[k+3]=='j'||text[k+3]=='J'){		 if(text[k+4]=='u'||text[k+4]=='U'){		 if(text[k+5]=='g'||text[k+5]=='G'){		 if(text[k+6]=='a'||text[k+6]=='A'){		 if(text[k+7]=='t'||text[k+7]=='T'){		 if(text[k+8]=='e'||text[k+8]=='E'){																							if(exprBound||!isAlphanumeric[text[k+9]]){	it->insertMap		(k, 9, M_CONJUGATE				);	k+=8;	continue;} }}}}}}
																																else if(text[k+3]=='t'							 &&text[k+4]=='i'							 &&text[k+5]=='n'							 &&text[k+6]=='u'							 &&text[k+7]=='e'&&!exprBound	  ){																																													it->insertMap		(k, 8, M_CONTINUE				);	k+=7;	continue;     }}
																					else if(				text[k+2]=='N'){		 if(text[k+3]=='j'||text[k+3]=='J'){		 if(text[k+4]=='u'||text[k+4]=='U'){		 if(text[k+5]=='g'||text[k+5]=='G'){		 if(text[k+6]=='a'||text[k+6]=='A'){		 if(text[k+7]=='t'||text[k+7]=='T'){		 if(text[k+8]=='e'||text[k+8]=='E'){																							if(exprBound||!isAlphanumeric[text[k+9]]){	it->insertMap		(k, 9, M_CONJUGATE				);	k+=8;	continue;} }}}}}}}
																					else if(text[k+2]=='s'||text[k+2]=='S'){		 if(text[k+3]=='c'||text[k+3]=='C'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_COSC					);	k+=3;	continue;}	   }
																																else if(text[k+3]=='e'||text[k+3]=='E'){		 if(text[k+4]=='c'||text[k+4]=='C'){		 if(text[k+5]=='h'||text[k+5]=='H'){																																																								if(exprBound||!isAlphanumeric[text[k+6]]){	it->insertMap		(k, 6, M_CSCH					);	k+=5;	continue;}	 }
																																																						else								   {																																																								if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_CSC					);	k+=4;	continue;}	 }}}
																																else if(text[k+3]=='h'||text[k+3]=='H'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_COSH					);	k+=3;	continue;}	   }
																																else								   {																																																																														if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_COS					);	k+=2;	continue;}	   }}
																					else if(text[k+2]=='t'||text[k+2]=='T'){		 if(text[k+3]=='h'||text[k+3]=='H'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_COTH					);	k+=3;	continue;}	   }
																																else								   {																																																																														if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_COT					);	k+=2;	continue;}	   }}}
										else if(				text[k+1]=='O'){		 if(text[k+2]=='m'||text[k+2]=='M'){		 if(text[k+3]=='b'||text[k+3]=='B'){		 if(text[k+4]=='i'||text[k+4]=='I'){		 if(text[k+5]=='n'||text[k+5]=='N'){		 if(text[k+6]=='a'||text[k+6]=='A'){		 if(text[k+7]=='t'||text[k+7]=='T'){		 if(text[k+8]=='i'||text[k+8]=='I'){		 if(text[k+9]=='o'||text[k+9]=='O'){		 if(text[k+10]=='n'||text[k+10]=='N'){	if(exprBound||!isAlphanumeric[text[k+11]]){	it->insertMap		(k, 11, M_COMBINATION			);	k+=10;	continue;}}}}}}}}}}
																					else if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='j'||text[k+3]=='J'){		 if(text[k+4]=='u'||text[k+4]=='U'){		 if(text[k+5]=='g'||text[k+5]=='G'){		 if(text[k+6]=='a'||text[k+6]=='A'){		 if(text[k+7]=='t'||text[k+7]=='T'){		 if(text[k+8]=='e'||text[k+8]=='E'){																							if(exprBound||!isAlphanumeric[text[k+9]]){	it->insertMap		(k, 9, M_CONJUGATE				);	k+=8;	continue;} }}}}}}}
																					else if(text[k+2]=='s'||text[k+2]=='S'){		 if(text[k+3]=='c'||text[k+3]=='C'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_COSC					);	k+=3;	continue;}	   }
																																else if(text[k+3]=='e'||text[k+3]=='E'){		 if(text[k+4]=='c'||text[k+4]=='C'){		 if(text[k+5]=='h'||text[k+5]=='H'){																																																								if(exprBound||!isAlphanumeric[text[k+6]]){	it->insertMap		(k, 6, M_CSCH					);	k+=5;	continue;}	 }
																																																						else								   {																																																								if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_CSC					);	k+=4;	continue;}	 }}}
																																else if(text[k+3]=='h'||text[k+3]=='H'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_COSH					);	k+=3;	continue;}	   }
																																else								   {																																																																														if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_COS					);	k+=2;	continue;}	   }}
																					else if(text[k+2]=='t'||text[k+2]=='T'){		 if(text[k+3]=='h'||text[k+3]=='H'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_COTH					);	k+=3;	continue;}	   }
																																else								   {																																																																														if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_COT					);	k+=2;	continue;}	   }}}
										else if(text[k+1]=='s'||text[k+1]=='S'){		 if(text[k+2]=='c'||text[k+2]=='C'){		 if(text[k+3]=='h'||text[k+3]=='H'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_CSCH					);	k+=3;	continue;}	   }
																																else								   {																																																																														if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_CSC					);	k+=2;	continue;}	   }}}	break;
								 case 'C':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='r'||text[k+2]=='R'){		 if(text[k+3]=='t'||text[k+3]=='T'){		 if(text[k+4]=='e'||text[k+4]=='E'){		 if(text[k+5]=='s'||text[k+5]=='S'){		 if(text[k+6]=='i'||text[k+6]=='I'){		 if(text[k+7]=='a'||text[k+7]=='A'){		 if(text[k+8]=='n'||text[k+8]=='N'){																							if(exprBound||!isAlphanumeric[text[k+9]]){	it->insertMap		(k, 9, M_CARTESIAN				);	k+=8;	continue;} }}}}}}}}
										else if(text[k+1]=='b'||text[k+1]=='B'){		 if(text[k+2]=='r'||text[k+2]=='R'){		 if(text[k+3]=='t'||text[k+3]=='T'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_CBRT					);	k+=3;	continue;}	   }}}
										else if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='i'||text[k+2]=='I'){		 if(text[k+3]=='l'||text[k+3]=='L'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_CEIL					);	k+=3;	continue;}	   }}}
										else if(text[k+1]=='h'||text[k+1]=='H'){																																																																																																				if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMap		(k, 2, M_COSH					);	++k;	continue;}	     }
										else if(text[k+1]=='o'||text[k+1]=='O'){		 if(text[k+2]=='m'||text[k+2]=='M'){		 if(text[k+3]=='b'||text[k+3]=='B'){		 if(text[k+4]=='i'||text[k+4]=='I'){		 if(text[k+5]=='n'||text[k+5]=='N'){		 if(text[k+6]=='a'||text[k+6]=='A'){		 if(text[k+7]=='t'||text[k+7]=='T'){		 if(text[k+8]=='i'||text[k+8]=='I'){		 if(text[k+9]=='o'||text[k+9]=='O'){		 if(text[k+10]=='n'||text[k+10]=='N'){	if(exprBound||!isAlphanumeric[text[k+11]]){	it->insertMap		(k, 11, M_COMBINATION			);	k+=10;	continue;}}}}}}}}}}
																					else if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='j'||text[k+3]=='J'){		 if(text[k+4]=='u'||text[k+4]=='U'){		 if(text[k+5]=='g'||text[k+5]=='G'){		 if(text[k+6]=='a'||text[k+6]=='A'){		 if(text[k+7]=='t'||text[k+7]=='T'){		 if(text[k+8]=='e'||text[k+8]=='E'){																							if(exprBound||!isAlphanumeric[text[k+9]]){	it->insertMap		(k, 9, M_CONJUGATE				);	k+=8;	continue;} }}}}}}}
																					else if(text[k+2]=='s'||text[k+2]=='S'){		 if(text[k+3]=='c'||text[k+3]=='C'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_COSC					);	k+=3;	continue;}	   }
																																else if(text[k+3]=='e'||text[k+3]=='E'){		 if(text[k+4]=='c'||text[k+4]=='C'){		 if(text[k+5]=='h'||text[k+5]=='H'){																																																								if(exprBound||!isAlphanumeric[text[k+6]]){	it->insertMap		(k, 6, M_CSCH					);	k+=5;	continue;}	 }
																																																						else								   {																																																								if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_CSC					);	k+=4;	continue;}	 }}}
																																else if(text[k+3]=='h'||text[k+3]=='H'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_COSH					);	k+=3;	continue;}	   }
																																else								   {																																																																														if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_COS					);	k+=2;	continue;}	   }}
																					else if(text[k+2]=='t'||text[k+2]=='T'){		 if(text[k+3]=='h'||text[k+3]=='H'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_COTH					);	k+=3;	continue;}	   }
																																else								   {																																																																														if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_COT					);	k+=2;	continue;}	   }}}
										else if(text[k+1]=='s'||text[k+1]=='S'){		 if(text[k+2]=='c'||text[k+2]=='C'){		 if(text[k+3]=='h'||text[k+3]=='H'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_CSCH					);	k+=3;	continue;}	   }
																																else								   {																																																																														if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_CSC					);	k+=2;	continue;}	   }}}	break;
						case 'd':			 if(text[k+1]=='o'&&!exprBound	  ){																																																																																																															it->insertMap		(k, 2, M_DO						);	++k;	continue;		 }	break;
						case 'e':			 if(text[k+1]=='l'				  ){		 if(text[k+2]=='s'							 &&text[k+3]=='e'&&!exprBound){																																																																																											it->insertMap		(k, 4, M_ELSE					);	k+=3;	continue;	    }}
										else if(text[k+1]=='r'||text[k+1]=='R'){		 if(text[k+2]=='f'||text[k+2]=='F'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_ERF					);	k+=2;	continue;}	    }}
										else if((text[k+1]=='x'||text[k+1]=='X')		 &&(text[k+2]=='p'||text[k+2]=='P')){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_EXP					);	k+=2;	continue;}	     }
										else								   {																																																																																																				if(exprBound||!isAlphanumeric[text[k+1]]){	it->insertMapData	(k, 1, 'r', _e					);			continue;}		 }	break;
						case 'E':			 if(text[k+1]=='r'||text[k+1]=='R'){		 if(text[k+2]=='f'||text[k+2]=='F'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_ERF					);	k+=2;	continue;}	    }}
										else if((text[k+1]=='x'||text[k+1]=='X')		 &&(text[k+2]=='p'||text[k+2]=='P')){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_EXP					);	k+=2;	continue;}	     }
										else								   {																																																																																																				if(exprBound||!isAlphanumeric[text[k+1]]){	it->insertMapData	(k, 1, 'r', _e					);			continue;}		 }	break;
						case 'f':			 if(text[k+1]=='i'||text[k+1]=='I'){		 if(text[k+2]=='b'||text[k+2]=='B'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_FIB					);	k+=2;	continue;}		}}
											 if(text[k+1]=='a'&&!exprBound		){		 if(text[k+2]=='l'							 &&text[k+3]=='s'							 &&text[k+4]=='e'					)																																																																														it->insertMapData	(k, 5, 'r', 0					);	k+=4;	continue;		 }
										else if(text[k+1]=='l'||text[k+1]=='L'){		 if(text[k+2]=='o'||text[k+2]=='O'){		 if(text[k+3]=='o'||text[k+3]=='O'){		 if(text[k+4]=='r'||text[k+4]=='R'){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_FLOOR					);	k+=4;	continue;}	  }}}}
										else if(text[k+1]=='o'				  ){		 if(text[k+2]=='r'&&!exprBound	  ){
											auto &scope=scopeLevel.top();
											if(scope=='{'||scope==')')
												scopeLevel.push('f');
											it->insertMap(k, 3, M_FOR);
										//	it->insertMap(M_FOR);
											k+=2;
											continue;
										/*	it->insertMap(M_FOR);
											k+=2;
											if(!exprBound)
												++scopeLevel, notForLoopHeaderScope=false;
											continue;//*/
										}}
										break;
								 case 'F':	 if(text[k+1]=='i'||text[k+1]=='I'){		 if(text[k+2]=='b'||text[k+2]=='B'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_FIB					);	k+=2;	continue;}		}}
										else if(text[k+1]=='l'||text[k+1]=='L'){		 if(text[k+2]=='o'||text[k+2]=='O'){		 if(text[k+3]=='o'||text[k+3]=='O'){		 if(text[k+4]=='r'||text[k+4]=='R'){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_FLOOR					);	k+=4;	continue;}	  }}}}	break;
						case 'g':case 'G':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='m'||text[k+2]=='M'){		 if(text[k+3]=='m'||text[k+3]=='M'){		 if(text[k+4]=='a'||text[k+4]=='A'){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_GAMMA					);	k+=4;	continue;}	  }}}
																						 if(text[k+2]=='u'||text[k+2]=='U'){		 if(text[k+3]=='s'||text[k+3]=='S'){		 if(text[k+4]=='s'||text[k+4]=='S'){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_GAUSS					);	k+=4;	continue;}	  }}}}	break;
						case 'h':case 'H':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='k'||text[k+3]=='K'){		 if(text[k+4]=='e'||text[k+4]=='E'){		 if(text[k+5]=='l'||text[k+5]=='L'){																																																								if(exprBound||!isAlphanumeric[text[k+6]]){	it->insertMap		(k, 6, M_HANKEL1				);	k+=5;	continue;}	 }}}}}	break;
						case 'l':case 'L':	 if(text[k+1]=='n'||text[k+1]=='N'){		 if((text[k+2]=='g'||text[k+2]=='G')		 &&(text[k+3]=='a'||text[k+3]=='A')			 &&(text[k+4]=='m'||text[k+4]=='M')			 &&(text[k+5]=='m'||text[k+5]=='M')			 &&(text[k+6]=='a'||text[k+6]=='A')){																																													if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 7, M_LNGAMMA				);	k+=6;	continue;}	}
																					else								   {																																																																																									if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMap		(k, 2, M_LN						);	++k;	continue;}	    }}
										else if(text[k+1]=='o'||text[k+1]=='O'){		 if(text[k+2]=='g'||text[k+2]=='G'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_LOG					);	k+=2;	continue;}	    }}	break;
						case 'm':case 'M':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='g'||text[k+2]=='G'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_ABS					);	k+=2;	continue;}	    }
																					else if(text[k+2]=='x'||text[k+2]=='X'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_MAX					);	k+=2;	continue;}	    }}
										else if((text[k+1]=='i'||text[k+1]=='I')		 &&(text[k+2]=='n'||text[k+2]=='N')){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_MIN					);	k+=2;	continue;}	     }	break;
						case 'n':case 'N':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='n'||text[k+2]=='N'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMapData	(k, 3, 'r', _qnan				);	k+=2;	continue;}	    }}
										else if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='u'||text[k+2]=='U'){		 if(text[k+3]=='m'||text[k+3]=='M'){		 if(text[k+4]=='a'||text[k+4]=='A'){		 if(text[k+5]=='n'||text[k+5]=='N'){		 if(text[k+6]=='n'||text[k+6]=='N'){																																													if(exprBound||!isAlphanumeric[text[k+7]]){	it->insertMap		(k, 7, M_NEUMANN				);	k+=6;	continue;}	}}}}}}	break;
						case 'p':case 'P':	 if(text[k+1]=='e'||text[k+1]=='E'){		 if((text[k+2]=='r'||text[k+2]=='R')		 &&(text[k+3]=='m'||text[k+3]=='M')			 &&(text[k+4]=='u'||text[k+4]=='U')			 &&(text[k+5]=='t'||text[k+5]=='T')			 &&(text[k+6]=='a'||text[k+6]=='A')			 &&(text[k+7]=='t'||text[k+7]=='T')			 &&(text[k+8]=='i'||text[k+8]=='I')			 &&(text[k+9]=='o'||text[k+9]=='O')			 &&(text[k+10]=='n'||text[k+10]=='N')){	if(exprBound||!isAlphanumeric[text[k+10]]){	it->insertMap		(k, 11, M_PERMUTATION			);	k+=10;	continue;}		}}
										else if(text[k+1]=='i'||text[k+1]=='I'){																																																																																																				if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMapData	(k, 2, 'r', _pi					);	++k;	continue;}		 }
										else if(text[k+1]=='o'||text[k+1]=='O'){		 if(text[k+2]=='l'||text[k+2]=='L'){		 if(text[k+3]=='a'||text[k+3]=='A'){		 if(text[k+4]=='r'||text[k+4]=='R'){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_POLAR					);	k+=4;	continue;}	  }}}}	break;
						case 'r':			 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='d'||text[k+3]=='D'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_RAND					);	k+=3;	continue;}	   }}}
										else if(text[k+1]=='e'				  ){		 if((text[k+2]=='c'||text[k+2]=='C')		 &&(text[k+3]=='t'||text[k+3]=='T')){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_RECT					);	k+=3;	continue;}	    }
																					else if(text[k+2]=='t'							 &&text[k+3]=='u'							  &&text[k+4]=='r'							 &&text[k+5]=='n'&&!exprBound	  ){																																																																			it->insertMap		(k, 6, M_RETURN					);	k+=5;	continue;	    }
																					else								   {																																																																																									if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMap		(k, 2, M_REAL					);	++k;	continue;}	    }}
										else if(				text[k+1]=='E'){		 if((text[k+2]=='c'||text[k+2]=='C')		 &&(text[k+3]=='t'||text[k+3]=='T')){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_RECT					);	k+=3;	continue;}	    }
																					else								   {																																																																																									if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMap		(k, 2, M_REAL					);	++k;	continue;}	    }}
										else if(text[k+1]=='o'||text[k+1]=='O'){		 if(text[k+2]=='u'||text[k+2]=='U'){		 if(text[k+3]=='n'||text[k+3]=='N'){		 if(text[k+4]=='d'||text[k+4]=='D'){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_ROUND					);	k+=4;	continue;}	  }}}}	break;
								 case 'R':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='d'||text[k+3]=='D'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_RAND					);	k+=3;	continue;}	   }}}
										else if(text[k+1]=='e'||text[k+1]=='E'){		 if((text[k+2]=='c'||text[k+2]=='C')		 &&(text[k+3]=='t'||text[k+3]=='T')){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_RECT					);	k+=3;	continue;}	    }
																					else								   {																																																																																									if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMap		(k, 2, M_REAL					);	++k;	continue;}	    }}
										else if(text[k+1]=='o'||text[k+1]=='O'){		 if(text[k+2]=='u'||text[k+2]=='U'){		 if(text[k+3]=='n'||text[k+3]=='N'){		 if(text[k+4]=='d'||text[k+4]=='D'){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_ROUND					);	k+=4;	continue;}	  }}}}	break;
						case 's':case 'S':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='w'||text[k+2]=='W'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_SAW					);	k+=2;	continue;}		}}
										else if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='c'||text[k+2]=='C'){		 if(text[k+3]=='h'||text[k+3]=='H'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_SECH					);	k+=3;	continue;}	   }
																																else								   {																																																																														if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_SEC					);	k+=2;	continue;}	   }}}
										else if(text[k+1]=='g'||text[k+1]=='G'){		 if(text[k+2]=='n'||text[k+2]=='N'){																																																																																									if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_SGN					);	k+=2;	continue;}		}}
										else if(text[k+1]=='h'||text[k+1]=='H'){																																																																																																				if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMap		(k, 2, M_SINH					);	++k;	continue;}	     }
										else if(text[k+1]=='i'||text[k+1]=='I'){		 if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='c'||text[k+3]=='C'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 3, M_SINC					);	k+=3;	continue;}	   }
																																else if(text[k+3]=='h'||text[k+3]=='H'){		 if(text[k+4]=='c'||text[k+4]=='C'){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_SINHC					);	k+=4;	continue;}	  }
																																											else								   {																																																																			if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_SINH					);	k+=3;	continue;}	  }}
																																else								   {																																																																														if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_SIN					);	k+=2;	continue;}	   }}}
										else if(text[k+1]=='q'||text[k+1]=='Q'){		 if(text[k+2]=='r'||text[k+2]=='R'){		 if(text[k+3]=='t'||text[k+3]=='T'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_SQRT					);	k+=3;	continue;}	   }}
																					else if(text[k+2]=='w'||text[k+2]=='W'){		 if(text[k+3]=='v'||text[k+3]=='V'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_SQWV					);	k+=3;	continue;}	   }}}
										else if(text[k+1]=='t'||text[k+1]=='T'){		 if(text[k+2]=='e'||text[k+2]=='E'){		 if(text[k+3]=='p'||text[k+3]=='P'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_STEP					);	k+=3;	continue;}	   }}}	break;
						case 't':			 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='c'||text[k+3]=='C'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_TANC					);	k+=3;	continue;}	   }
																																else if(text[k+3]=='h'||text[k+3]=='H'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_TANH					);	k+=3;	continue;}	   }
																																else								   {																																																																														if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_TAN					);	k+=2;	continue;}	   }}}
										else if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='c'||text[k+3]=='C'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_TANC					);	k+=3;	continue;}	   }
																																else if(text[k+3]=='h'||text[k+3]=='H'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_TANH					);	k+=3;	continue;}	   }
																																else								   {																																																																														if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_TAN					);	k+=2;	continue;}	   }}}
										else if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='t'||text[k+3]=='T'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_TENT					);	k+=3;	continue;}	   }}}
										else if(text[k+1]=='h'||text[k+1]=='H'){																																																																																																				if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMap		(k, 2, M_TANH					);	++k;	continue;}	     }
										else if(text[k+1]=='r'				  ){		 if(text[k+2]=='g'||text[k+2]=='G'){		 if(text[k+3]=='l'||text[k+3]=='L'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_TENT					);	k+=3;	continue;}	   }}
																					else if(text[k+2]=='u'&&!exprBound		){		 if(text[k+3]=='e'					)																																																																																									it->insertMapData	(k, 4, 'r', 1.					);	k+=3;	continue;	    }
																					else if(text[k+2]=='w'||text[k+2]=='W'){		 if(text[k+3]=='v'||text[k+3]=='V'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_TRWV					);	k+=3;	continue;}	   }}}
										else if(				text[k+1]=='R'){		 if(text[k+2]=='g'||text[k+2]=='G'){		 if(text[k+3]=='l'||text[k+3]=='L'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_TENT					);	k+=3;	continue;}	   }}
																					else if(text[k+2]=='w'||text[k+2]=='W'){		 if(text[k+3]=='v'||text[k+3]=='V'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_TRWV					);	k+=3;	continue;}	   }}}
										else if(exprBound)					   {																																																																																																															it->insertRVar		(k, 1, &text[k], 't'			);			continue;		 }	break;
								case 'T':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='c'||text[k+3]=='C'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_TANC					);	k+=3;	continue;}	   }
																																else if(text[k+3]=='h'||text[k+3]=='H'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_TANH					);	k+=3;	continue;}	   }
																																else								   {																																																																														if(exprBound||!isAlphanumeric[text[k+3]]){	it->insertMap		(k, 3, M_TAN					);	k+=2;	continue;}	   }}}
										else if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='t'||text[k+3]=='T'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_TENT					);	k+=3;	continue;}	   }}}
										else if(text[k+1]=='h'||text[k+1]=='H'){																																																																																																				if(exprBound||!isAlphanumeric[text[k+2]]){	it->insertMap		(k, 2, M_TANH					);	++k;	continue;}	     }
										else if(text[k+1]=='r'||text[k+1]=='R'){		 if(text[k+2]=='g'||text[k+2]=='G'){		 if(text[k+3]=='l'||text[k+3]=='L'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_TENT					);	k+=3;	continue;}	   }}
																					else if(text[k+2]=='w'||text[k+2]=='W'){		 if(text[k+3]=='v'||text[k+3]=='V'){																																																																														if(exprBound||!isAlphanumeric[text[k+4]]){	it->insertMap		(k, 4, M_TRWV					);	k+=3;	continue;}	   }}}
										else if(exprBound)					   {																																																																																																															it->insertRVar		(k, 1, &text[k], 't'			);			continue;		 }	break;
						case 'w':			 if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='b'||text[k+2]=='B'){		 if(text[k+3]=='e'||text[k+3]=='E'){		 if(text[k+4]=='r'||text[k+4]=='R'){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_NEUMANN				);	k+=4;	continue;}	  }}}}
										else if(text[k+1]=='h'				  ){		 if(text[k+2]=='i'				  ){		 if(text[k+3]=='l'				  ){		 if(text[k+4]=='e'&&!exprBound	  ){																																																																														it->insertMap		(k, 5, M_WHILE					);	k+=4;	continue;	  }}}}	break;
								 case 'W':	 if((text[k+1]=='e'||text[k+1]=='E')		&&(text[k+2]=='b'||text[k+2]=='B')			&&(text[k+3]=='e'||text[k+3]=='E')			&&(text[k+4]=='r'||text[k+4]=='R')){																																																																			if(exprBound||!isAlphanumeric[text[k+5]]){	it->insertMap		(k, 5, M_NEUMANN				);	k+=4;	continue;}	     }
										else if(exprBound)					   {																																																																																																															it->insertCVar		(k, 5, &text[k]					);			continue;		 }	break;
						case '\r':
							k+=text[k+1]=='\n';
							++lineNo;
							continue;
						case '\n'://robust	unix/mac
							++lineNo;
							continue;
						}
						if(!exprBound)//user function token variable names
						{
							if((k-1<0||!isAlphanumeric[text[k-1]])&&isAlphanumeric[text[k]])
						//	if((k-1<0||text[k-1]<'0'||text[k-1]>'9'&&text[k-1]<'A'||text[k-1]>'Z'&&text[k-1]!='_'&&text[k-1]<'a'||text[k-1]>'z')&&text[k]>='A'&&(text[k]<='Z'||text[k]>='a'&&text[k]<='z'||text[k]=='_'))
							{
								for(int f=k+1;f<=kEnd;++f)//match name
								{
									if(!isAlphanumeric[text[f]])
								//	if(text[f]<'0'||text[f]>'9'&&(text[f]<'A'||text[f]>'Z'&&(text[f]!='_'&&text[f]<'a'||text[f]>'z')))
									{
										bool noMatch=true;
										int nameLen=f-k;
										for(int n=0, nEnd=ufVarNames.size();n<nEnd;++n)
										{
											auto &name=ufVarNames[n].name;
											if(name.size()==nameLen&&!name.compare(0, name.size(), text+k, nameLen))//match, add reference
											{
												it->insertMap(k, f-k, G2::M_N, ufVarNames[n].data_idx);
											//	it->insertMap(G2::M_N, ufVarNames[n].data_idx);
												noMatch=false;
												break;
											}
										}
										if(noMatch)//add new name and repositry
										{
											ufVarNames.push_back(UFVariableName(text+k, nameLen, scopeLevel.size(), it->data.size()));
											it->insertFVar('r');
											it->insertMap(k, f-k, G2::M_N, ufVarNames.rbegin()->data_idx);
										//	it->insertMap(G2::M_N, ufVarNames.rbegin()->data_idx);
										//	it->insertFVar('R');
										//	it->insertData('R', 0);//variables are initialized with 0, mathSet is updated by values assigned
										}
										k=f-1;
										break;
									}
								}
							}
						}
					}
					it->endLineNo=lineNo-((bound==0?0:bounds[bound-1].first)<kEnd&&text[kEnd-1]=='\n');
					if(exprBound)
					{
						auto &map=it->m;
						if(map.size())
						{
							using namespace G2;
							{
								int min=0, end=0;
								for(unsigned k=0;k<map.size();++k)
								{
									if(map[k]._0==M_LPR)
										++end;
									else if(map[k]._0==M_RPR)
									{
										--end;
										if(min>end)
											min=end;
									}
								}
								if(min<0)
								{
									int pos=map[0].pos;
									int inc=-min;
									map.resize(map.size()+inc);
									for(int k=map.size()-1;k>=inc;--k)
										map[k]=map[k-inc];
									for(int k=0;k<inc;++k)
										map[k]=::Map(pos, 0, M_LPR);
									//	map[k]=::Map(M_LPR);
								}
								if(end-min>0)
								{
									int pos=map.rbegin()->pos+map.rbegin()->len;
									int inc=end-min;
									map.resize(map.size()+inc);
									for(unsigned k=map.size()-inc;k<map.size();++k)
										map[k]=::Map(pos, 0, M_RPR);
									//	map[k]=::Map(M_RPR);
								}
							}
						}
						if(map.size())
						{
							Compile::compile_expression_global(*it);
							if(!it->n.size())//no expression
								it->rmode[0]=0;
							else
							{
								it->resultMathSet=Compile::predictedMathSet;
								switch(it->nISD)
								{
								case 0://numeric 0d
									it->rmode[0]=1;
									modes::n0d.toSolve=true, modes::n0d.solver.reset();
									it->n[0].ndr.push_back(it->data[0]);
								//	it->n[0].ndr.push_back(it->n[0].val);
									it->setColor_random();
									break;
								case 1:
									if(it->i.size()&&(it->resultLogicType=Compile::expressionResultLogicType()))//transverse implicit 1d	//bool expr
									{
										it->rmode[0]=10;
										modes::ti1d.toSolve=true, modes::ti1d.shiftOnly=0, modes::ti1d.solver.reset();
										modes::ti1d.ready=false;
										it->setColor_random();
									}
									else
									{
										switch(Compile::predictedMathSet)
										{
										case 'r'://transverse 1d
									//	case 'R':
											it->rmode[0]=2;
											modes::t1d.toSolve=true, modes::t1d.shiftOnly=0, modes::t1d.solver.reset();
											modes::t1d.ready=false;
											it->setColor_random();
											break;
										case 'c'://transverse 1d complex
									//	case 'C':
											it->rmode[0]=3;
											modes::t1d_c.toSolve=true, modes::t1d_c.shiftOnly=0, modes::t1d_c.solver.reset();
											modes::t1d_c.ready=false;
											it->setColor_random();
											break;
										case 'H'://transverse 1d quaternion
											it->rmode[0]=4;
											it->rmode.push_back(0);
											modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0, modes::t1d_h.solver.reset();
											modes::t1d_h.ready=false;
											it->setColor_black();
											break;
										}
									}
									break;
								case 2:
									if(it->i.size()&&(it->resultLogicType=Compile::expressionResultLogicType()))//transverse implicit 2d
									{
										it->rmode[0]=11;
										modes::ti2d.toSolve=true, modes::ti2d.shiftOnly=0, modes::ti2d.solver.reset();
										modes::ti2d.ready=false;
										it->setColor_random();
									}
									else
									{
										switch(Compile::predictedMathSet)
										{
										case 'r'://transverse 2d
									//	case 'R':
											it->rmode[0]=5;
											modes::t2d.toSolve=true, modes::t2d.shiftOnly=0, modes::t2d.solver.reset();
											modes::t2d.ready=false;
											it->setColor_random();
											break;
										case 'c':
									//	case 'C':
											if(it->nZ==1)//longitudinal 2d
											{
												it->rmode[0]=7;
												modes::l2d.toSolve=true, modes::l2d.shiftOnly=0, modes::l2d.solver.reset();
												modes::l2d.ready=false;
												it->setColor_random();
											}
											else//color 2d
											{
												it->rmode[0]=6;
												it->rmode.push_back(0);
												modes::c2d.toSolve=true, modes::c2d.shiftOnly=0, modes::c2d.solver.reset();
												modes::c2d.ready=false;
												it->setColor_black();
											}
											break;
										case 'H'://transverse 2d quaternion
											it->rmode[0]=8;
											it->rmode.push_back(0);
											modes::t2d_h.toSolve=true, modes::t2d_h.shiftOnly=0, modes::t2d_h.solver.reset();
											modes::t2d_h.ready=false;
											it->setColor_black();
											break;
										}
									}
									break;
								case 3://color 3d
	#if 0
									if(it->i.size()&&(it->resultLogicType=Compile::expressionResultLogicType()))
									{
										it->rmode[0]=9;
										it->rmode.push_back(0);
										modes::c3d.toSolve=true, modes::c3d.shiftOnly=0, modes::c3d.solver.reset();
										modes::c3d.ready=false;
										it->setColor_black();
									}
									else
									{
	#endif
										it->rmode[0]=9;
										it->rmode.push_back(0);
										modes::c3d.toSolve=true, modes::c3d.shiftOnly=0, modes::c3d.solver.reset();
										modes::c3d.ready=false;
										it->setColor_black();
	#if 0
									}
	#endif
									break;
								}
							}
						}
						switch(old_rmode)//all modes showing multiple expressions except n0d
						{
						case  2:modes::t1d	.exprRemoved|=it->rmode[0]!=old_rmode;	break;
						case  3:modes::t1d_c.exprRemoved|=it->rmode[0]!=old_rmode;	break;
						case  5:modes::t2d	.exprRemoved|=it->rmode[0]!=old_rmode;	break;
						case  7:modes::l2d	.exprRemoved|=it->rmode[0]!=old_rmode;	break;
						case 10:modes::ti1d	.exprRemoved|=it->rmode[0]!=old_rmode;	break;
						case 11:modes::ti2d	.exprRemoved|=it->rmode[0]!=old_rmode;	break;
						}
						++e;
					}
					else
					{
						Compile::compile_function(*it);
						it->resultMathSet=Compile::predictedMathSet;
						++function;
					}
				}
				std::fill(modes::nExpr.begin(), modes::nExpr.end(), 0);
				for(auto &ex:expr)
					++modes::nExpr[ex.rmode[0]];

				int lineChange=lineInsertEnd-lineRemoveEnd;
				for(int b=boundInsertEnd, bEnd=bounds.size();b<bEnd;++b)
				{
					auto &bound=bounds[b];
					if(bound.second=='e')
						expr[e].lineNo+=lineChange, expr[e].endLineNo+=lineChange, ++e;
					else if(bound.second=='f')
						userFunctionDefinitions[function].lineNo+=lineChange, userFunctionDefinitions[function].endLineNo+=lineChange, ++function;
				}
#endif
#if 0
				int kStart=boundChangeStart==0?0:bounds[boundChangeStart-1].first;
				int comment=0;
/*nobreak?*/	for(;comment!=allComments.size()&&allComments[comment].first<kStart;++comment);
				int lineNo=lineChangeStart=itb.getLineNo(0, 0, kStart);
			//	auto it=expr.begin()+exprChangeStart;
			//	*it=Expression();
			//	it->lineNo=lineNo;
			//	auto ufIT=userFunctionDefinitions.begin()+functionChangeStart;

				std::vector<UFVariableName> ufVarNames;
				int scopeLevel=0;
				
				user_trigered_seed();
				for(int bound=boundChangeStart, e=exprChangeStart, function=functionChangeStart;bound<boundInsertEnd;++bound)
				{
					int kStart=bound?bounds[bound-1].first:0, kEnd=bounds[bound].first;
					bool exprBound=bounds[bound].second=='e';
					CodeBase *it;
					UserFunctionDefinition *uf;
					Expression *ex;
					if(exprBound)
					{
						it=ex=&expr[e], uf=nullptr;
						*ex=Expression();
					}
					else
					{
						it=uf=&userFunctionDefinitions[function], ex=nullptr;
						*uf=UserFunctionDefinition();
						scopeLevel=0, ufVarNames.clear();

						//parse function header		correct header syntax checked by profiler
						char state='f', mathSet='R';//'f' looking for function name, 'a' reading arg names, 's' arg mathSet specifier
						int i=-1, f=-1;
						for(int k=kStart, kcEnd=comment!=allComments.size()?allComments[comment].first:kEnd;k<kEnd;++k)
						{
							if(k>=kcEnd)
							{
								lineNo=itb.getLineNo(allComments[comment].first, lineNo, allComments[comment].second);
								k=allComments[comment].second-1;
								++comment;
								kcEnd=comment!=allComments.size()?allComments[comment].first:itb.textlen;
								continue;
							}
							if(text[k]>='A'&&(text[k]<='Z'||text[k]>='a'&&text[k]<='z'||text[k]=='_'))
							{
								for(i=k;;++k)
								{
									if(text[k]<'0'||text[k]>'9'&&(text[k]<'A'||text[k]>'Z'&&(text[k]!='_'&&text[k]<'a'||text[k]>'z')))
									{
										if(state=='f')
											uf->name_id=userFunctionNames.addName(text, i, k)->name_id;
										else if(state=='a')
										{
											if(k-i==1&&(text[i]=='r'||text[i]=='R'||text[i]=='c'||text[i]=='C'||text[i]=='h'||text[i]=='H'||text[i]=='q'||text[i]=='Q'))
											{
												f=k;
												state='s';
											}
											else
											{
												ufVarNames.push_back(UFVariableName(text+i, f-i, 0, uf->data.size()));
												uf->data.push_back(UFTerm(mathSet));
												mathSet='R';
											}
										}
										break;
									}
								}
							}
							else if(text[k]=='(')
								state='a';
							else if(text[k]==',')
							{
								if(state=='a')
									continue;
								else if(state=='s')//not a specifier but a variable
								{
									ufVarNames.push_back(UFVariableName(text+i, f-i, 0, uf->data.size()));
									uf->data.push_back(UFTerm(mathSet));
									continue;
								}
								else if(state=='f')//unreachable
									break;
							}
							else if(text[k]==')')//header end
							{
								break;
							}
							else if(text[k]=='{')//header end
							{
								--k;
								break;
							}
							else if(text[k]!=' '&&text[k]!='\t')//unreachable
								break;
						}
					}
					it->lineNo=lineNo, it->boundNo=bound;
				//	auto it=exprBound?(CodeBase*)&expr[ex]:(CodeBase*)&userFunctionDefinitions[function];
				//	Map *map=exprBound?&it->m:&ufIT->m;
				//	(exprBound?it->insertMap:ufIT->insertMap)(G2::M_LPR);//
					
					for(int k=kStart, kcEnd=comment!=allComments.size()?allComments[comment].first:kEnd;k<kEnd;++k)
					{
						if(k>=kcEnd)
						{
							lineNo=itb.getLineNo(allComments[comment].first, lineNo, allComments[comment].second);
							k=allComments[comment].second-1;
							++comment;
							kcEnd=comment!=allComments.size()?allComments[comment].first:itb.textlen;
							continue;
						}
						{
							NameTreeNode* node=nullptr;
							int nameEnd;
							if(exprBound)
								node=userFunctionNames.matchName_free(text, k, kEnd, nameEnd);
							else//user function bound, get token call identifier
							{
								if((k-1<0||text[k-1]<'0'||text[k-1]>'9'&&text[k-1]<'A'||text[k-1]>'Z'&&text[k-1]!='_'&&text[k-1]<'a'||text[k-1]>'z')&&text[k]>='A'&&(text[k]<='Z'||text[k]>='a'&&text[k]<='z'||text[k]=='_'))
							//	if(text[k]>='A'&&text[k]<='Z'||text[k]>='a'&&text[k]<='z'||text[k]=='_')
								{
									for(int f=k+1;f<=kEnd;++f)
									{
										if(text[f]<'0'||text[f]>'9'&&text[f]<'A'||text[f]>'Z'&&text[f]!='_'&&text[f]<'a'||text[f]>'z')
										{
											node=userFunctionNames.matchName(text, k, f, nameEnd);
											break;
										}
									}
								}
							}
							if(node)
							{
								it->insertMap(node->name_id);
								k=nameEnd-1;
								continue;
							}
						}
						using namespace G2;
						switch(text[k])
						{
						case '(':																																																																																																																it->insertMap(M_LPR					);					continue;
						case ')':																																																																																																																it->insertMap(M_RPR					);					continue;
						case '{':																																																																																																																it->insertMap(M_LBRACE				);					continue;
						case '}':	 if(exprBound)																																																																																																												it->insertMap(M_RBRACE				);
							else
							{
								--scopeLevel;
								for(int n=ufVarNames.size()-1;;--n)
								{
									if(n<0||ufVarNames[n].scopeLevel==scopeLevel)
									{
										ufVarNames.erase(ufVarNames.begin()+n+1, ufVarNames.end());
										break;
									}
								}
							}
							continue;
						case ',':																																																																																																																it->insertMap(M_COMMA				);					continue;
						case ';':																																																																																																																it->insertMap(M_SEMICOLON			);					continue;
						case '0':
							if((text[k+1]=='x'||text[k+1]=='X')&&(text[k+2]>='0'&&text[k+2]<='9'||text[k+2]>='a'&&text[k+2]<='f'||text[k+2]>='A'&&text[k+2]<='F'||text[k+2]=='.'))
							{
								bool number=false;
								for(int k2=k+2;k2<=itb.textlen;++k2)
								{
									if(text[k2]>='0'&&text[k2]<='9'||text[k2]>='a'&&text[k2]<='f'||text[k2]>='A'&&text[k2]<='F')
										number=true;
									else if(text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))
									{
										if(number)
										{
											bool E_notation=(text[k2]=='p'||text[k2]=='P')//p notation	c99, java5
												&&(text[k2+1]>='0'&&text[k2+1]<='9'||text[k2+1]>='a'&&text[k2+1]<='f'||text[k2+1]>='A'&&text[k2+1]<='F'||text[k2+1]=='.'
													||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='9'||text[k2+2]>='a'&&text[k2+2]<='f'||text[k2+2]>='A'&&text[k2+2]<='F'||text[k2+2]=='.'));
											if(!E_notation)
												for(;text[k2-1]==',';--k2);
											double p=1;
											for(int k4=k+2;k4<k2;++k4)
											{
												if(text[k4]=='.')
												{
													for(int k5=k4+1;k5<k2;++k5)
														if(text[k5]!='.'&&text[k5]!=',')
															p/=16;
													break;
												}
											}
											double val=0;
											for(int k4=k2-1;k4>=k+2;--k4)
											{
												switch(text[k4])
												{
												case '0':						break;
												case '1':			val+=   p;	break;
												case '2':			val+= 2*p;	break;
												case '3':			val+= 3*p;	break;
												case '4':			val+= 4*p;	break;
												case '5':			val+= 5*p;	break;
												case '6':			val+= 6*p;	break;
												case '7':			val+= 7*p;	break;
												case '8':			val+= 8*p;	break;
												case '9':			val+= 9*p;	break;
												case 'a':case 'A':	val+=10*p;	break;
												case 'b':case 'B':	val+=11*p;	break;
												case 'c':case 'C':	val+=12*p;	break;
												case 'd':case 'D':	val+=13*p;	break;
												case 'e':case 'E':	val+=14*p;	break;
												case 'f':case 'F':	val+=15*p;	break;
												default:						continue;
												}
												p*=16;
											}
											if(E_notation)
											{
												int sign=text[k2+1]=='-'?-1:1;
												bool number=false;
												for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)
												{
													if(text[k4]>='0'&&text[k4]<='9'||text[k4]>='a'&&text[k4]<='f'||text[k4]>='A'&&text[k4]<='F')
														number=true;
													else if(text[k4]!='.')
													{
														if(number)
														{
															double p=1;
															for(int k5=k3;k5<k4;++k5)
															{
																if(text[k5]=='.')
																{
																	for(int k6=k5+1;k6<k4;++k6)
																		if(text[k6]!='.')
																			p/=10;
																	break;
																}
															}
															double val2=0;
															for(int k5=k4-1;k5>=k3;--k5)
															{
																if(text[k5]!='.')
																{
																	switch(text[k4])
																	{
																	case '0':						break;
																	case '1':			val2+=   p;	break;
																	case '2':			val2+= 2*p;	break;
																	case '3':			val2+= 3*p;	break;
																	case '4':			val2+= 4*p;	break;
																	case '5':			val2+= 5*p;	break;
																	case '6':			val2+= 6*p;	break;
																	case '7':			val2+= 7*p;	break;
																	case '8':			val2+= 8*p;	break;
																	case '9':			val2+= 9*p;	break;
																	case 'a':case 'A':	val2+=10*p;	break;
																	case 'b':case 'B':	val2+=11*p;	break;
																	case 'c':case 'C':	val2+=12*p;	break;
																	case 'd':case 'D':	val2+=13*p;	break;
																	case 'e':case 'E':	val2+=14*p;	break;
																	case 'f':case 'F':	val2+=15*p;	break;
																	default:						continue;
																	}
																	p*=16;
																}
															}
															const double logBase=std::log(2.);//power of 2		c99
															val*=std::exp(sign*val2*logBase);
															k2=k4;
														}
														break;
													}
												}
											}
											it->insertData('R', val);
											k=k2-1;
										}
										break;
									}
								}
								continue;
							}
							else if(text[k+1]>='0'&&text[k+1]<='7')
							{
								for(int k2=k+2;k2<=itb.textlen;++k2)
								{
									if(text[k2]=='8'||text[k2]=='9')//default to decimal
										break;
									if((text[k2]<'0'||text[k2]>'7')&&text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))
									{
										bool E_notation=(text[k2]=='e'||text[k2]=='E')
											&&(text[k2+1]>='0'&&text[k2+1]<='7'||text[k2+1]=='.'
												||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='7'||text[k2+2]=='.'));
										if(!E_notation)
											for(;text[k2-1]==',';--k2);
												double p=1;
										for(int k4=k+1;k4<k2;++k4)
										{
											if(text[k4]=='.')
											{
												for(int k5=k4+1;k5<k2;++k5)
													if(text[k5]>='0'&&text[k5]<='7')
														p/=8;
												break;
											}
										}
										double val=0;
										for(int k4=k2-1;k4>=k+1;--k4)
											if(text[k4]>='0'&&text[k4]<='7')
												val+=(text[k4]-'0')*p, p*=8;
										if(E_notation)
										{
											int sign=text[k2+1]=='-'?-1:1;
											bool number=false;
											for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)
											{
												if(text[k4]>='0'&&text[k4]<='7')
													number=true;
												else if(text[k4]!='.')
												{
													if(number)
													{
														double p=1;
														for(int k5=k3;k5<k4;++k5)
														{
															if(text[k5]=='.')
															{
																for(int k6=k5+1;k6<k4;++k6)
																	if(text[k6]!='.')
																		p/=10;
																break;
															}
														}
														double val2=0;
														for(int k5=k4-1;k5>=k3;--k5)
															if(text[k5]!='.')
																val2+=(text[k5]-'0')*p, p*=10;
														const double logBase=std::log(8.);
														val*=std::exp(sign*val2*logBase);
														k2=k4;
													}
													break;
												}
											}
										}
										it->insertData('R', val);
										k=k2-1;
										break;
									}
								}
								continue;
							}
						case '1':case '2':case '3':case '4':case '5':case '6':case '7':case '8':case '9':case '.':
							{
								bool number=false;
								for(int k2=k;k2<=itb.textlen;++k2)
								{
									if(text[k2]>='0'&&text[k2]<='9')
										number=true;
									else if(text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))
									{
										if(number)
										{
											bool E_notation=(text[k2]=='e'||text[k2]=='E')
												&&(text[k2+1]>='0'&&text[k2+1]<='9'||text[k2+1]=='.'
													||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='9'||text[k2+2]=='.'));
											if(!E_notation)
												for(;text[k2-1]==',';--k2);
											double p=1;
											for(int k4=k;k4<k2;++k4)
											{
												if(text[k4]=='.')
												{
													for(int k5=k4+1;k5<k2;++k5)
														if(text[k5]>='0'&&text[k5]<='9')
															p/=10;
													break;
												}
											}
											double val=0;
											for(int k4=k2-1;k4>=k;--k4)
												if(text[k4]>='0'&&text[k4]<='9')
													val+=(text[k4]-'0')*p, p*=10;
											if(E_notation)
											{
												int sign=text[k2+1]=='-'?-1:1;
												number=false;
												for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)
												{
													if(text[k4]>='0'&&text[k4]<='9')
														number=true;
													else if(text[k4]!='.')
													{
														if(number)
														{
															double p=1;
															for(int k5=k3;k5<k4;++k5)
															{
																if(text[k5]=='.')
																{
																	for(int k6=k5+1;k6<k4;++k6)
																		if(text[k6]!='.')
																			p/=10;
																	break;
																}
															}
															double val2=0;
															for(int k5=k4-1;k5>=k3;--k5)
																if(text[k5]!='.')
																	val2+=(text[k5]-'0')*p, p*=10;
															const double logBase=std::log(10.);
															val*=std::exp(sign*val2*logBase);
															k2=k4;
														}
														break;
													}
												}
											}
											it->insertData('R', val);
											k=k2-1;
										}
										break;
									}
								}
							}
							continue;
						case '_':			 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='t'||text[k+2]=='T'){		 if(text[k+3]=='m'||text[k+3]=='M'){																																																																														it->insertData('R', _atm			);	k+=3;	   }}}
										else if(text[k+1]=='b'||text[k+1]=='B'){		 if(text[k+2]=='b'||text[k+2]=='B'){		 if(text[k+3]=='r'||text[k+3]=='R'){																																																																														it->insertData('R', _bbr			);	k+=3;	   }}}
										else if(text[k+1]=='c'||text[k+1]=='C'){																																																																																																				it->insertData('R', _c				);	++k;	     }
										else if(text[k+1]=='e'||text[k+1]=='E'){		 if((text[k+2]=='l'||text[k+2]=='L')		&&(text[k+3]=='e'||text[k+3]=='E')){																																																																														it->insertData('R', _ele			);	k+=3;	    }
																					else								   {																																																																																									it->insertData('R', _e				);	++k;	    }}
										else if(text[k+1]=='g'				  ){																																																																																																				it->insertData('R', _g				);	++k;	     }
										else if(text[k+1]=='G'				  ){																																																																																																				it->insertData('R', _G				);	++k;	     }
										else if(text[k+1]=='h'||text[k+1]=='H'){																																																																																																				it->insertData('R', _h				);	++k;	     }
										else if(text[k+1]=='m'				  ){		 if(text[k+2]=='a'||text[k+2]=='A'){		 if(text[k+3]=='g'||text[k+3]=='G'){																																																																														it->insertData('R', _mag			);	k+=3;	   }}
																					else if(text[k+2]=='e'||text[k+2]=='E'){																																																																																									it->insertData('R', _me				);	k+=2;	    }
																					else if(text[k+2]=='n'||text[k+2]=='N'){																																																																																									it->insertData('R', _mn				);	k+=2;	    }
																					else if(text[k+2]=='p'||text[k+2]=='P'){																																																																																									it->insertData('R', _mp				);	k+=2;	    }}
										else if(				text[k+1]=='M'){		 if(text[k+2]=='a'||text[k+2]=='A'){		 if(text[k+3]=='g'||text[k+3]=='G'){																																																																														it->insertData('R', _mag			);	k+=3;	   }}
																					else if(text[k+2]=='e'||text[k+2]=='E'){																																																																																									it->insertData('R', _Me				);	k+=2;	    }
																					else if(text[k+2]=='n'||text[k+2]=='N'){																																																																																									it->insertData('R', _mn				);	k+=2;	    }
																					else if(text[k+2]=='p'||text[k+2]=='P'){																																																																																									it->insertData('R', _mp				);	k+=2;	    }
																					else if(text[k+2]=='s'||text[k+2]=='S'){																																																																																									it->insertData('R', _Ms				);	k+=2;	    }}
										else if(text[k+1]=='n'||text[k+1]=='N'){		 if(text[k+2]=='a'||text[k+2]=='A'){																																																																																									it->insertData('R', _Na				);	k+=2;	    }}
										else if(text[k+1]=='p'||text[k+1]=='P'){		 if(text[k+2]=='h'||text[k+2]=='H'){		 if(text[k+3]=='i'||text[k+3]=='I'){																																																																														it->insertData('R', _phi			);	k+=3;	   }}
																					else if(text[k+2]=='i'||text[k+2]=='I'){																																																																																									it->insertData('R', _pi				);	k+=2;	    }}
										else if(text[k+1]=='q'||text[k+1]=='Q'){																																																																																																				it->insertData('R', _q				);	++k;	     }
										else if(text[k+1]=='r'||text[k+1]=='R'){		 if((text[k+2]=='a'||text[k+2]=='A')		&&(text[k+3]=='n'||text[k+3]=='N')			&&(text[k+4]=='d'||text[k+4]=='D')){																																																																			it->insertData('R', rand()			);	++k;	    }
																					else								   {																																																																																									it->insertData('R', _R				);	++k;	    }}	continue;
						case 'i':			 if(text[k+1]=='f'				  ){																																																																																																				it->insertMap(M_IF					);	++k;		 }
										else if(text[k+1]=='m'||text[k+1]=='M'){																																																																																																				it->insertMap(M_IMAG				);	++k;		 }
										else if(text[k+1]=='n'||text[k+1]=='N'){		 if(text[k+2]=='d'||text[k+2]=='D'){																																																																																									it->insertData('R', _qnan			);	k+=2;		 }
																					else if(text[k+2]=='f'||text[k+2]=='F'){																																																																																									it->insertData('R', _HUGE			);	k+=2;		 }
																					else if((text[k+2]=='v'||text[k+2]=='V')		&&(text[k+3]=='s'||text[k+3]=='S')			&&(text[k+4]=='q'||text[k+4]=='Q')			&&(text[k+5]=='r'||text[k+5]=='R')			&&(text[k+6]=='t'||text[k+6]=='T')){																																													it->insertMap(M_INVSQRT				);	k+=6;		}}
										else								   {																																																																																																				it->insertData('C', 0, 1			);				 }	continue;
								 case 'I':	 if(text[k+1]=='m'||text[k+1]=='M'){																																																																																																				it->insertMap(M_IMAG				);	++k;		 }
										else if(text[k+1]=='n'||text[k+1]=='N'){		 if(text[k+2]=='d'||text[k+2]=='D'){																																																																																									it->insertData('R', _qnan			);	k+=2;		 }
																					else if(text[k+2]=='f'||text[k+2]=='F'){																																																																																									it->insertData('R', _HUGE			);	k+=2;		 }
																					else if((text[k+2]=='v'||text[k+2]=='V')			&&(text[k+3]=='s'||text[k+3]=='S')			&&(text[k+4]=='q'||text[k+4]=='Q')			&&(text[k+5]=='r'||text[k+5]=='R')			&&(text[k+6]=='t'||text[k+6]=='T')){																																												it->insertMap(M_INVSQRT				);	k+=6;		 }}  continue;
						case 'j':																																																																																																																it->insertData('H', 0, 0, 1			);					continue;
								 case 'J':																																																																																																														it->insertMap(M_BESSEL				);					continue;
						case 'k':																																																																																																																it->insertData('H', 0, 0, 0, 1		);					continue;
						case 'x':			 if(exprBound)																																																																																																										ex->insertRVar(&text[k], 1, 's'		);					continue;
						case 'y':			 if(exprBound)																																																																																																										ex->insertRVar(&text[k], 1, 's'		);					continue;
						case 'Y':																																																																																																																it->insertMap(M_NEUMANN				);					continue;
						case 'z':			 if((text[k+1]=='e'||text[k+1]=='E')		&&(text[k+2]=='t'||text[k+2]=='T')			&&(text[k+3]=='a'||text[k+3]=='A')){																																																																														it->insertMap(M_ZETA				);	k+=3;		  }
										else if(exprBound)					   {																																																																																																				ex->insertRVar(&text[k], 1, 's'		);				  }	continue;
						case 'Z':			 if((text[k+1]=='e'||text[k+1]=='E')		&&(text[k+2]=='t'||text[k+2]=='T')			&&(text[k+3]=='a'||text[k+3]=='A')){																																																																														it->insertMap(M_ZETA				);	k+=3;		  }
										else if(exprBound)					   {																																																																																																				ex->insertCVar(&text[k], 1			);				  }	continue;
						case '\'':
							if(exprBound)
							{
								for(int k2=k+1;k2<=itb.textlen;++k2)
								{
									if((text[k2]<'a'||text[k2]>'z')&&(text[k2]<'A'||text[k2]>'Z')&&(text[k2]<'0'||text[k2]>'9')&&text[k2]!='_')
									{
										ex->insertRVar(&text[k+1], k2-(k+1), 's');
									//	((Expression*)it)->insertRVar(&text[k+1], k2-(k+1), 's');
									//	it->insertRVar(&text[k+1], k2-(k+1), 's');
										k=text[k2]=='\''?k2:k2-1;
										break;
									}
								}
							}
							continue;
						case 'Q':			 if(exprBound)																																																																																																										ex->insertHVar(&text[k], 1			);					continue;
						case '+':			 if(text[k+1]=='='				  ){																																																																																																				it->insertMap(M_ASSIGN_PLUS			);	++k;		 }
										 else								   {																																																																																																				it->insertMap(M_PLUS				);				 }	continue;
						case '-':			 if(text[k+1]=='='				  ){																																																																																																				it->insertMap(M_ASSIGN_MINUS		);	++k;		 }
										 else								   {																																																																																																				it->insertMap(M_MINUS				);				 }	continue;
						case '*':			 if(text[k+1]=='='				  ){																																																																																																				it->insertMap(M_ASSIGN_MULTIPLY		);	++k;		 }
										else								   {																																																																																																				it->insertMap(M_MULTIPLY			);				 }	continue;
						case '/':			 if(text[k+1]=='='				  ){																																																																																																				it->insertMap(M_ASSIGN_DIVIDE		);	++k;		 }
										else								   {																																																																																																				it->insertMap(M_DIVIDE				);				 }	continue;
						case '%':			 if(text[k+1]=='='				  ){																																																																																																				it->insertMap(M_ASSIGN_MOD			);	++k;		 }
										else								   {									   																																																																																											it->insertMap(M_MODULO_PERCENT		);				 }	continue;
						case '@':																					   																																																																																											it->insertMap(M_LOGIC_DIVIDES		);					continue;
						case '^':			 if(text[k+1]=='^'				  ){		 if(text[k+2]=='^'				  ){																																																																																									it->insertMap(M_PENTATE				);	k+=2;	    }
																					else								   {																																																																																									it->insertMap(M_TETRATE				);	++k;	    }}
										else if(text[k+1]=='~'				  ){																																																																																																				it->insertMap(M_BITWISE_XNOR		);	++k;	     }
										else								   {																																																																																																				it->insertMap(M_POWER				);			     }	continue;
						case '!':			 if(text[k+1]=='='				  ){																																																																																																				it->insertMap(M_LOGIC_NOT_EQUAL		);	++k;		 }
										else								   {																																																																																																				it->insertMap(M_FACTORIAL_LOGIC_NOT	);				 }	continue;
						case '~':			 if(text[k+1]=='&'				  ){																																																																																																				it->insertMap(M_BITWISE_NAND		);	++k;		 }
										else if(text[k+1]=='#'				  ){																																																																																																				it->insertMap(M_BITWISE_XNOR		);	++k;		 }
										else if(text[k+1]=='|'				  ){																																																																																																				it->insertMap(M_BITWISE_NOR			);	++k;		 }
										else								   {																																																																																																				it->insertMap(M_BITWISE_NOT			);				 }	continue;
						case '&':			 if(text[k+1]=='&'				  ){																																																																																																				it->insertMap(M_LOGIC_AND			);	++k;	     }
										else if(text[k+1]=='~'				  ){																																																																																																				it->insertMap(M_BITWISE_NOR			);	++k;	     }
										else if(text[k+1]=='='				  ){																																																																																																				it->insertMap(M_ASSIGN_AND			);	++k;	     }
										else								   {																																																																																																				it->insertMap(M_BITWISE_AND			);				 }	continue;
						case '#':			 if(text[k+1]=='#'				  ){																																																																																																				it->insertMap(M_LOGIC_XOR			);	++k;	     }
										else if(text[k+1]=='~'				  ){																																																																																																				it->insertMap(M_BITWISE_XNOR		);	++k;	     }
										else if(text[k+1]=='='				  ){																																																																																																				it->insertMap(M_ASSIGN_XOR			);	++k;	     }
										else								   {																																																																																																				it->insertMap(M_BITWISE_XOR			);				 }	continue;
						case '|':			 if(text[k+1]=='|'				  ){																																																																																																				it->insertMap(M_LOGIC_OR			);	++k;	     }
										else if(text[k+1]=='~'				  ){																																																																																																				it->insertMap(M_BITWISE_NAND		);	++k;	     }
										else if(text[k+1]=='='				  ){																																																																																																				it->insertMap(M_ASSIGN_OR			);	++k;	     }
										else								   {																																																																																																				it->insertMap(M_VERTICAL_BAR			);			     }	continue;
						case '<':			 if(text[k+1]=='<'				  ){		 if(text[k+2]=='='				  ){																																																																																									it->insertMap(M_ASSIGN_LEFT			);	k+=2;		}
																					else								   {																																																																																									it->insertMap(M_BITWISE_SHIFT_LEFT	);	++k;	    }}
										else if(text[k+1]=='='				  ){																																																																																																				it->insertMap(M_LOGIC_LESS_EQUAL	);	++k;	     }
										else								   {																																																																																																				it->insertMap(M_LOGIC_LESS			);			     }	continue;
						case '>':			 if(text[k+1]=='>'				  ){		 if(text[k+2]=='='				  ){																																																																																									it->insertMap(M_ASSIGN_RIGHT		);	k+=2;		}
																					else								   {																																																																																									it->insertMap(M_BITWISE_SHIFT_RIGHT	);	++k;	    }}
										else if(text[k+1]=='='				  ){																																																																																																				it->insertMap(M_LOGIC_GREATER_EQUAL	);	++k;	     }
										else								   {																																																																																																				it->insertMap(M_LOGIC_GREATER		);			     }	continue;
						case '=':			 if(text[k+1]=='='				  ){																																																																																																				it->insertMap(M_LOGIC_EQUAL			);	++k;	     }
										else								   {																																																																																																				it->insertMap(M_ASSIGN				);				 }	continue;
						case '?':			 if(text[k+1]=='?'				  ){																																																																																																				it->insertMap(M_LOGIC_CONDITION_ZERO);	++k;		 }
										else																																																																																																													it->insertMap(M_QUESTION_MARK		);					continue;
						case ':':																																																																																																																it->insertMap(M_COLON				);					continue;
						case 'a':case 'A':	 if(text[k+1]=='b'||text[k+1]=='B'){		 if(text[k+2]=='s'||text[k+2]=='S'){																																																																																									it->insertMap(M_ABS					);				}}
										else if(text[k+1]=='c'||text[k+1]=='C'){		 if(text[k+2]=='h'||text[k+2]=='H'){																																																																																									it->insertMap(M_ACOSH				);	k+=2;	    }
																					else if(text[k+2]=='o'||text[k+2]=='O'){		 if(text[k+3]=='s'||text[k+3]=='S'){		 if(text[k+4]=='e'||text[k+4]=='E'){		 if(text[k+5]=='c'||text[k+5]=='C'){		 if(text[k+6]=='h'||text[k+6]=='H'){																																													it->insertMap(M_ACSCH				);	k+=6;	}
																																																																	else								   {																																													it->insertMap(M_ACSC				);	k+=5;	}}}
																																											else if(text[k+4]=='h'||text[k+4]=='H'){																																																																			it->insertMap(M_ACOSH				);	k+=4;	  }
																																											else								   {																																																																			it->insertMap(M_ACOS				);	k+=3;	  }}
																																	 if(text[k+3]=='t'||text[k+3]=='T'){		 if(text[k+4]=='h'||text[k+4]=='H'){																																																																			it->insertMap(M_ACOTH				);	k+=4;	  }
																																											else								   {																																																																			it->insertMap(M_ACOT				);	k+=3;	  }}}
																					else if(text[k+2]=='s'||text[k+2]=='S'){		 if(text[k+3]=='c'||text[k+3]=='C'){		 if(text[k+4]=='h'||text[k+4]=='H'){																																																																			it->insertMap(M_ACSCH				);	k+=4;	  }
																																											else								   {																																																																			it->insertMap(M_ACSC				);	k+=3;	  }}}}
										else if(text[k+1]=='r'||text[k+1]=='R'){		 if(text[k+2]=='g'||text[k+2]=='G'){																																																																																									it->insertMap(M_ARG					);	k+=2;	    }}
										else if(text[k+1]=='s'||text[k+1]=='S'){		 if(text[k+2]=='e'||text[k+2]=='E'){		 if(text[k+3]=='c'||text[k+3]=='C'){		 if(text[k+4]=='h'||text[k+4]=='H'){																																																																			it->insertMap(M_ASECH				);	k+=4;	  }
																																											else								   {																																																																			it->insertMap(M_ASEC				);	k+=3;	  }}}
																					else if(text[k+2]=='h'||text[k+2]=='H'){																																																																																									it->insertMap(M_ASINH				);	k+=2;	    }
																					else if(text[k+2]=='i'||text[k+2]=='I'){		 if(text[k+3]=='n'||text[k+3]=='N'){		 if(text[k+4]=='h'||text[k+4]=='H'){																																																																			it->insertMap(M_ASINH				);	k+=4;	  }
																																											else								   {																																																																			it->insertMap(M_ASIN				);	k+=3;	  }}}}
										else if(text[k+1]=='t'||text[k+1]=='T'){		 if(text[k+2]=='a'||text[k+2]=='A'){		 if(text[k+3]=='n'||text[k+3]=='N'){		 if(text[k+4]=='h'||text[k+4]=='H'){																																																																			it->insertMap(M_ATANH				);	k+=4;	  }
																																											else								   {																																																																			it->insertMap(M_ATAN				);	k+=3;	  }}}
																					else if(text[k+2]=='h'||text[k+2]=='H'){																																																																																									it->insertMap(M_ATANH				);	k+=2;	    }}	continue;
						case 'b':			 if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='s'||text[k+2]=='S'){		 if(text[k+3]=='s'||text[k+3]=='S'){		 if(text[k+4]=='e'||text[k+4]=='E'){		 if(text[k+5]=='l'||text[k+5]=='L'){																																																								it->insertMap(M_BESSEL				);	k+=5;	 }}}}
																						 if(text[k+2]=='t'||text[k+2]=='T'){		 if(text[k+3]=='a'||text[k+3]=='A'){																																																																														it->insertMap(M_BETA				);	k+=3;	   }}}
										else if(text[k+1]=='r'				  ){		 if(text[k+2]=='e'				  ){		 if(text[k+3]=='a'				  ){		 if(text[k+4]=='k'				  ){																																																																			it->insertMap(M_BREAK				);	k+=4;	  }}}}
							else if(text[k+1]=='0'||text[k+1]=='1'||text[k+1]=='.')
							{
								bool number=false;
								for(int k2=k+1;k2<=itb.textlen;++k2)
								{
									if(text[k2]>='2'||text[k2]<='9')//default to decimal
										break;
									if(text[k2]=='0'||text[k2]=='1')
										number=true;
									else if(text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))
									{
										if(number)
										{
											bool E_notation=(text[k2]=='e'||text[k2]=='E')
												&&(text[k2+1]>='0'&&text[k2+1]<='1'||text[k2+1]=='.'
													||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='1'||text[k2+2]=='.'));
											if(!E_notation)
												for(;text[k2-1]==',';--k2);
											double p=1;
											for(int k4=k+1;k4<k2;++k4)
											{
												if(text[k4]=='.')
												{
													for(int k5=k4+1;k5<k2;++k5)
														if(text[k5]>='0'&&text[k5]<='1')
															p/=2;
													break;
												}
											}
											double val=0;
											for(int k4=k2-1;k4>=k+1;--k4)
												if(text[k4]>='0'&&text[k4]<='1')
													val+=(text[k4]-'0')*p, p*=2;
											if(E_notation)
											{
												int sign=text[k2+1]=='-'?-1:1;
												number=false;
												for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)
												{
													if(text[k4]>='0'&&text[k4]<='1')
														number=true;
													else if(text[k4]!='.')
													{
														if(number)
														{
															double p=1;
															for(int k5=k3;k5<k4;++k5)
															{
																if(text[k5]=='.')
																{
																	for(int k6=k5+1;k6<k4;++k6)
																		if(text[k6]!='.')
																			p/=10;
																	break;
																}
															}
															double val2=0;
															for(int k5=k4-1;k5>=k3;--k5)
																if(text[k5]!='.')
																	val2+=(text[k5]-'0')*p, p*=10;
															const double logBase=std::log(2.);
															val*=std::exp(sign*val2*logBase);
															k2=k4;
														}
														break;
													}
												}
											}
											it->insertData('R', val);
											k=k2-1;
										}
										break;
									}
								}
							}
							continue;
								 case 'B':	 if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='s'||text[k+2]=='S'){		 if(text[k+3]=='s'||text[k+3]=='S'){		 if(text[k+4]=='e'||text[k+4]=='E'){		 if(text[k+5]=='l'||text[k+5]=='L'){																																																								it->insertMap(M_BESSEL				);	k+=5;	 }}}}
																						 if(text[k+2]=='t'||text[k+2]=='T'){		 if(text[k+3]=='a'||text[k+3]=='A'){																																																																														it->insertMap(M_BETA				);	k+=3;	   }}}
							else if(text[k+1]=='0'||text[k+1]=='1'||text[k+1]=='.')
							{
								bool number=false;
								for(int k2=k+1;k2<=itb.textlen;++k2)
								{
									if(text[k2]>='2'||text[k2]<='9')//default to decimal
										break;
									if(text[k2]=='0'||text[k2]=='1')
										number=true;
									else if(text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))
									{
										if(number)
										{
											bool E_notation=(text[k2]=='e'||text[k2]=='E')
												&&(text[k2+1]>='0'&&text[k2+1]<='1'||text[k2+1]=='.'
													||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='1'||text[k2+2]=='.'));
											if(!E_notation)
												for(;text[k2-1]==',';--k2);
											double p=1;
											for(int k4=k+1;k4<k2;++k4)
											{
												if(text[k4]=='.')
												{
													for(int k5=k4+1;k5<k2;++k5)
														if(text[k5]>='0'&&text[k5]<='1')
															p/=2;
													break;
												}
											}
											double val=0;
											for(int k4=k2-1;k4>=k+1;--k4)
												if(text[k4]>='0'&&text[k4]<='1')
													val+=(text[k4]-'0')*p, p*=2;
											if(E_notation)
											{
												int sign=text[k2+1]=='-'?-1:1;
												number=false;
												for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)
												{
													if(text[k4]>='0'&&text[k4]<='1')
														number=true;
													else if(text[k4]!='.')
													{
														if(number)
														{
															double p=1;
															for(int k5=k3;k5<k4;++k5)
															{
																if(text[k5]=='.')
																{
																	for(int k6=k5+1;k6<k4;++k6)
																		if(text[k6]!='.')
																			p/=10;
																	break;
																}
															}
															double val2=0;
															for(int k5=k4-1;k5>=k3;--k5)
																if(text[k5]!='.')
																	val2+=(text[k5]-'0')*p, p*=10;
															const double logBase=std::log(2.);
															val*=std::exp(sign*val2*logBase);
															k2=k4;
														}
														break;
													}
												}
											}
											it->insertData('R', val);
											k=k2-1;
										}
										break;
									}
								}
							}
							continue;
						case 'c':			 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='r'||text[k+2]=='R'){		 if(text[k+3]=='t'||text[k+3]=='T'){		 if(text[k+4]=='e'||text[k+4]=='E'){		 if(text[k+5]=='s'||text[k+5]=='S'){		 if(text[k+6]=='i'||text[k+6]=='I'){		 if(text[k+7]=='a'||text[k+7]=='A'){		 if(text[k+8]=='n'||text[k+8]=='N'){																							it->insertMap(M_CARTESIAN			);	k+=8; }}}}}}}}
										else if(text[k+1]=='b'||text[k+1]=='B'){		 if(text[k+2]=='r'||text[k+2]=='R'){		 if(text[k+3]=='t'||text[k+3]=='T'){																																																																														it->insertMap(M_CBRT				);	k+=3;	   }}}
										else if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='i'||text[k+2]=='I'){		 if(text[k+3]=='l'||text[k+3]=='L'){																																																																														it->insertMap(M_CEIL				);	k+=3;	   }}}
										else if(text[k+1]=='h'||text[k+1]=='H'){																																																																																																				it->insertMap(M_COSH				);	++k;	     }
										else if(text[k+1]=='o'				  ){		 if(text[k+2]=='m'||text[k+2]=='M'){		 if(text[k+3]=='b'||text[k+3]=='B'){		 if(text[k+4]=='i'||text[k+4]=='I'){		 if(text[k+5]=='n'||text[k+5]=='N'){		 if(text[k+6]=='a'||text[k+6]=='A'){		 if(text[k+7]=='t'||text[k+7]=='T'){		 if(text[k+8]=='i'||text[k+8]=='I'){		 if(text[k+9]=='o'||text[k+9]=='O'){		 if(text[k+10]=='n'||text[k+10]=='N'){	it->insertMap(M_COMBINATION			);	k+=10;}}}}}}}}}
																					else if(text[k+2]=='n'				  ){		 if(text[k+3]=='j'||text[k+3]=='J'){		 if(text[k+4]=='u'||text[k+4]=='U'){		 if(text[k+5]=='g'||text[k+5]=='G'){		 if(text[k+6]=='a'||text[k+6]=='A'){		 if(text[k+7]=='t'||text[k+7]=='T'){		 if(text[k+8]=='e'||text[k+8]=='E'){																							it->insertMap(M_CONJUGATE			);	k+=8; }}}}}}
																																else if(text[k+3]=='t'							 &&text[k+4]=='i'							 &&text[k+5]=='n'							 &&text[k+6]=='u'							 &&text[k+7]=='e'				  ){																																		it->insertMap(M_CONTINUE			);	k+=7;     }}
																					else if(				text[k+2]=='N'){		 if(text[k+3]=='j'||text[k+3]=='J'){		 if(text[k+4]=='u'||text[k+4]=='U'){		 if(text[k+5]=='g'||text[k+5]=='G'){		 if(text[k+6]=='a'||text[k+6]=='A'){		 if(text[k+7]=='t'||text[k+7]=='T'){		 if(text[k+8]=='e'||text[k+8]=='E'){																							it->insertMap(M_CONJUGATE			);	k+=8; }}}}}}}
																					else if(text[k+2]=='s'||text[k+2]=='S'){		 if(text[k+3]=='c'||text[k+3]=='C'){																																																																														it->insertMap(M_COSC				);	k+=3;	   }
																																else if(text[k+3]=='e'||text[k+3]=='E'){		 if(text[k+4]=='c'||text[k+4]=='C'){		 if(text[k+5]=='h'||text[k+5]=='H'){																																																								it->insertMap(M_CSCH				);	k+=5;	 }
																																																						else								   {																																																								it->insertMap(M_CSC					);	k+=4;	 }}}
																																else if(text[k+3]=='h'||text[k+3]=='H'){																																																																														it->insertMap(M_COSH				);	k+=3;	   }
																																else								   {																																																																														it->insertMap(M_COS					);	k+=2;	   }}
																					else if(text[k+2]=='t'||text[k+2]=='T'){		 if(text[k+3]=='h'||text[k+3]=='H'){																																																																														it->insertMap(M_COTH				);	k+=3;	   }
																																else								   {																																																																														it->insertMap(M_COT					);	k+=2;	   }}}
										else if(				text[k+1]=='O'){		 if(text[k+2]=='m'||text[k+2]=='M'){		 if(text[k+3]=='b'||text[k+3]=='B'){		 if(text[k+4]=='i'||text[k+4]=='I'){		 if(text[k+5]=='n'||text[k+5]=='N'){		 if(text[k+6]=='a'||text[k+6]=='A'){		 if(text[k+7]=='t'||text[k+7]=='T'){		 if(text[k+8]=='i'||text[k+8]=='I'){		 if(text[k+9]=='o'||text[k+9]=='O'){		 if(text[k+10]=='n'||text[k+10]=='N'){	it->insertMap(M_COMBINATION			);	k+=10;}}}}}}}}}
																					else if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='j'||text[k+3]=='J'){		 if(text[k+4]=='u'||text[k+4]=='U'){		 if(text[k+5]=='g'||text[k+5]=='G'){		 if(text[k+6]=='a'||text[k+6]=='A'){		 if(text[k+7]=='t'||text[k+7]=='T'){		 if(text[k+8]=='e'||text[k+8]=='E'){																							it->insertMap(M_CONJUGATE			);	k+=8; }}}}}}}
																					else if(text[k+2]=='s'||text[k+2]=='S'){		 if(text[k+3]=='c'||text[k+3]=='C'){																																																																														it->insertMap(M_COSC				);	k+=3;	   }
																																else if(text[k+3]=='e'||text[k+3]=='E'){		 if(text[k+4]=='c'||text[k+4]=='C'){		 if(text[k+5]=='h'||text[k+5]=='H'){																																																								it->insertMap(M_CSCH				);	k+=5;	 }
																																																						else								   {																																																								it->insertMap(M_CSC					);	k+=4;	 }}}
																																else if(text[k+3]=='h'||text[k+3]=='H'){																																																																														it->insertMap(M_COSH				);	k+=3;	   }
																																else								   {																																																																														it->insertMap(M_COS					);	k+=2;	   }}
																					else if(text[k+2]=='t'||text[k+2]=='T'){		 if(text[k+3]=='h'||text[k+3]=='H'){																																																																														it->insertMap(M_COTH				);	k+=3;	   }
																																else								   {																																																																														it->insertMap(M_COT					);	k+=2;	   }}}
										else if(text[k+1]=='s'||text[k+1]=='S'){		 if(text[k+2]=='c'||text[k+2]=='C'){		 if(text[k+3]=='h'||text[k+3]=='H'){																																																																														it->insertMap(M_CSCH				);	k+=3;	   }
																																else								   {																																																																														it->insertMap(M_CSC					);	k+=2;	   }}}	continue;
								 case 'C':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='r'||text[k+2]=='R'){		 if(text[k+3]=='t'||text[k+3]=='T'){		 if(text[k+4]=='e'||text[k+4]=='E'){		 if(text[k+5]=='s'||text[k+5]=='S'){		 if(text[k+6]=='i'||text[k+6]=='I'){		 if(text[k+7]=='a'||text[k+7]=='A'){		 if(text[k+8]=='n'||text[k+8]=='N'){																							it->insertMap(M_CARTESIAN			);	k+=8; }}}}}}}}
										else if(text[k+1]=='b'||text[k+1]=='B'){		 if(text[k+2]=='r'||text[k+2]=='R'){		 if(text[k+3]=='t'||text[k+3]=='T'){																																																																														it->insertMap(M_CBRT				);	k+=3;	   }}}
										else if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='i'||text[k+2]=='I'){		 if(text[k+3]=='l'||text[k+3]=='L'){																																																																														it->insertMap(M_CEIL				);	k+=3;	   }}}
										else if(text[k+1]=='h'||text[k+1]=='H'){																																																																																																				it->insertMap(M_COSH				);	++k;	     }
										else if(text[k+1]=='o'||text[k+1]=='O'){		 if(text[k+2]=='m'||text[k+2]=='M'){		 if(text[k+3]=='b'||text[k+3]=='B'){		 if(text[k+4]=='i'||text[k+4]=='I'){		 if(text[k+5]=='n'||text[k+5]=='N'){		 if(text[k+6]=='a'||text[k+6]=='A'){		 if(text[k+7]=='t'||text[k+7]=='T'){		 if(text[k+8]=='i'||text[k+8]=='I'){		 if(text[k+9]=='o'||text[k+9]=='O'){		 if(text[k+10]=='n'||text[k+10]=='N'){	it->insertMap(M_COMBINATION			);	k+=10;}}}}}}}}}
																					else if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='j'||text[k+3]=='J'){		 if(text[k+4]=='u'||text[k+4]=='U'){		 if(text[k+5]=='g'||text[k+5]=='G'){		 if(text[k+6]=='a'||text[k+6]=='A'){		 if(text[k+7]=='t'||text[k+7]=='T'){		 if(text[k+8]=='e'||text[k+8]=='E'){																							it->insertMap(M_CONJUGATE			);	k+=8; }}}}}}}
																					else if(text[k+2]=='s'||text[k+2]=='S'){		 if(text[k+3]=='c'||text[k+3]=='C'){																																																																														it->insertMap(M_COSC				);	k+=3;	   }
																																else if(text[k+3]=='e'||text[k+3]=='E'){		 if(text[k+4]=='c'||text[k+4]=='C'){		 if(text[k+5]=='h'||text[k+5]=='H'){																																																								it->insertMap(M_CSCH				);	k+=5;	 }
																																																						else								   {																																																								it->insertMap(M_CSC					);	k+=4;	 }}}
																																else if(text[k+3]=='h'||text[k+3]=='H'){																																																																														it->insertMap(M_COSH				);	k+=3;	   }
																																else								   {																																																																														it->insertMap(M_COS					);	k+=2;	   }}
																					else if(text[k+2]=='t'||text[k+2]=='T'){		 if(text[k+3]=='h'||text[k+3]=='H'){																																																																														it->insertMap(M_COTH				);	k+=3;	   }
																																else								   {																																																																														it->insertMap(M_COT					);	k+=2;	   }}}
										else if(text[k+1]=='s'||text[k+1]=='S'){		 if(text[k+2]=='c'||text[k+2]=='C'){		 if(text[k+3]=='h'||text[k+3]=='H'){																																																																														it->insertMap(M_CSCH				);	k+=3;	   }
																																else								   {																																																																														it->insertMap(M_CSC					);	k+=2;	   }}}	continue;
						case 'd':			 if(text[k+1]=='o'				  ){																																																																																																				it->insertMap(M_ELSE				);	++k;		 }	continue;
						case 'e':			 if(text[k+1]=='l'				  ){		 if(text[k+2]=='s'							 &&text[k+3]=='e'){																																																																																			it->insertMap(M_ELSE				);	k+=3;	    }}
										else if(text[k+1]=='r'||text[k+1]=='R'){		 if(text[k+2]=='f'||text[k+2]=='F'){																																																																																									it->insertMap(M_ERF					);	k+=2;	    }}
										else if((text[k+1]=='x'||text[k+1]=='X')		 &&(text[k+2]=='p'||text[k+2]=='P')){																																																																																									it->insertMap(M_EXP					);	k+=2;	     }
										else								   {																																																																																																				it->insertData('R', _e				);				 }	continue;
						case 'E':			 if(text[k+1]=='r'||text[k+1]=='R'){		 if(text[k+2]=='f'||text[k+2]=='F'){																																																																																									it->insertMap(M_ERF					);	k+=2;	    }}
										else if((text[k+1]=='x'||text[k+1]=='X')		 &&(text[k+2]=='p'||text[k+2]=='P')){																																																																																									it->insertMap(M_EXP					);	k+=2;	     }
										else								   {																																																																																																				it->insertData('R', _e				);				 }	continue;
						case 'f':			 if(text[k+1]=='i'||text[k+1]=='I'){		 if(text[k+2]=='b'||text[k+2]=='B'){																																																																																									it->insertMap(M_FIB					);	k+=2;		}}
										else if(text[k+1]=='l'||text[k+1]=='L'){		 if(text[k+2]=='o'||text[k+2]=='O'){		 if(text[k+3]=='o'||text[k+3]=='O'){		 if(text[k+4]=='r'||text[k+4]=='R'){																																																																			it->insertMap(M_FLOOR				);	k+=4;	  }}}}
										else if(text[k+1]=='o'				  ){		 if(text[k+2]=='r'				  ){																																																																																									it->insertMap(M_FOR 				);	k+=2;	    }}	continue;
								 case 'F':	 if(text[k+1]=='i'||text[k+1]=='I'){		 if(text[k+2]=='b'||text[k+2]=='B'){																																																																																									it->insertMap(M_FIB					);	k+=2;		}}
										else if(text[k+1]=='l'||text[k+1]=='L'){		 if(text[k+2]=='o'||text[k+2]=='O'){		 if(text[k+3]=='o'||text[k+3]=='O'){		 if(text[k+4]=='r'||text[k+4]=='R'){																																																																			it->insertMap(M_FLOOR				);	k+=4;	  }}}}	continue;
						case 'g':case 'G':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='m'||text[k+2]=='M'){		 if(text[k+3]=='m'||text[k+3]=='M'){		 if(text[k+4]=='a'||text[k+4]=='A'){																																																																			it->insertMap(M_GAMMA				);	k+=4;	  }}}
																						 if(text[k+2]=='u'||text[k+2]=='U'){		 if(text[k+3]=='s'||text[k+3]=='S'){		 if(text[k+4]=='s'||text[k+4]=='S'){																																																																			it->insertMap(M_GAUSS				);	k+=4;	  }}}}	continue;
						case 'h':case 'H':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='k'||text[k+3]=='K'){		 if(text[k+4]=='e'||text[k+4]=='E'){		 if(text[k+5]=='l'||text[k+5]=='L'){																																																								it->insertMap(M_HANKEL1				);	k+=5;	 }}}}}	continue;
						case 'l':case 'L':	 if(text[k+1]=='n'||text[k+1]=='N'){																																																																																																				it->insertMap(M_LN					);	++k;	     }
										else if(text[k+1]=='o'||text[k+1]=='O'){		 if(text[k+2]=='g'||text[k+2]=='G'){																																																																																									it->insertMap(M_LOG					);	k+=2;	    }}	continue;
						case 'm':case 'M':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='g'||text[k+2]=='G'){																																																																																									it->insertMap(M_ABS					);	k+=2;	    }
																					else if(text[k+2]=='x'||text[k+2]=='X'){																																																																																									it->insertMap(M_MAX					);	k+=2;	    }}
										else if((text[k+1]=='i'||text[k+1]=='I')		 &&(text[k+2]=='n'||text[k+2]=='N')){																																																																																									it->insertMap(M_MIN					);	k+=2;	     }	continue;
						case 'n':case 'N':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='n'||text[k+2]=='N'){																																																																																									it->insertData('R', _qnan			);	k+=2;	    }}
										else if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='u'||text[k+2]=='U'){		 if(text[k+3]=='m'||text[k+3]=='M'){		 if(text[k+4]=='a'||text[k+4]=='A'){		 if(text[k+5]=='n'||text[k+5]=='N'){		 if(text[k+6]=='n'||text[k+6]=='N'){																																													it->insertMap(M_NEUMANN				);	k+=6;	}}}}}}	continue;
						case 'p':case 'P':	 if(text[k+1]=='e'||text[k+1]=='E'){		 if((text[k+2]=='r'||text[k+2]=='R')		 &&(text[k+3]=='m'||text[k+3]=='M')			 &&(text[k+4]=='u'||text[k+4]=='U')			 &&(text[k+5]=='t'||text[k+5]=='T')			 &&(text[k+6]=='a'||text[k+6]=='A')			 &&(text[k+7]=='t'||text[k+7]=='T')			 &&(text[k+8]=='i'||text[k+8]=='I')			 &&(text[k+9]=='o'||text[k+9]=='O')			 &&(text[k+10]=='n'||text[k+10]=='N')){	it->insertMap(M_PERMUTATION			);	k+=10;		}}
										else if(text[k+1]=='i'||text[k+1]=='I'){																																																																																																				it->insertData('R', _pi				);	++k;		 }
										else if(text[k+1]=='o'||text[k+1]=='O'){		 if(text[k+2]=='l'||text[k+2]=='L'){		 if(text[k+3]=='a'||text[k+3]=='A'){		 if(text[k+4]=='r'||text[k+4]=='R'){																																																																			it->insertMap(M_POLAR				);	k+=4;	  }}}}	continue;
						case 'r':			 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='d'||text[k+3]=='D'){																																																																														it->insertMap(M_RAND				);	k+=3;	   }}}
										else if(text[k+1]=='e'				  ){		 if((text[k+2]=='c'||text[k+2]=='C')		 &&(text[k+3]=='t'||text[k+3]=='T')){																																																																														it->insertMap(M_RECT				);	k+=3;	    }
																					else if(text[k+2]=='t'							 &&text[k+3]=='u'							  &&text[k+4]=='r'							 &&text[k+5]=='n'){																																																													it->insertMap(M_RETURN				);	k+=5;	    }
																					else								   {																																																																																									it->insertMap(M_REAL				);	++k;	    }}
										else if(				text[k+1]=='E'){		 if((text[k+2]=='c'||text[k+2]=='C')		 &&(text[k+3]=='t'||text[k+3]=='T')){																																																																														it->insertMap(M_RECT				);	k+=3;	    }
																					else								   {																																																																																									it->insertMap(M_REAL				);	++k;	    }}
										else if(text[k+1]=='o'||text[k+1]=='O'){		 if(text[k+2]=='u'||text[k+2]=='U'){		 if(text[k+3]=='n'||text[k+3]=='N'){		 if(text[k+4]=='d'||text[k+4]=='D'){																																																																			it->insertMap(M_ROUND				);	k+=4;	  }}}}	continue;
								 case 'R':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='d'||text[k+3]=='D'){																																																																														it->insertMap(M_RAND				);	k+=3;	   }}}
										else if(text[k+1]=='e'||text[k+1]=='E'){		 if((text[k+2]=='c'||text[k+2]=='C')		 &&(text[k+3]=='t'||text[k+3]=='T')){																																																																														it->insertMap(M_RECT				);	k+=3;	    }
																					else								   {																																																																																									it->insertMap(M_REAL				);	++k;	    }}
										else if(text[k+1]=='o'||text[k+1]=='O'){		 if(text[k+2]=='u'||text[k+2]=='U'){		 if(text[k+3]=='n'||text[k+3]=='N'){		 if(text[k+4]=='d'||text[k+4]=='D'){																																																																			it->insertMap(M_ROUND				);	k+=4;	  }}}}	continue;
						case 's':case 'S':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='w'||text[k+2]=='W'){																																																																																									it->insertMap(M_SAW					);	k+=2;		}}
										else if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='c'||text[k+2]=='C'){		 if(text[k+3]=='h'||text[k+3]=='H'){																																																																														it->insertMap(M_SECH				);	k+=3;	   }
																																else								   {																																																																														it->insertMap(M_SEC					);	k+=2;	   }}}
										else if(text[k+1]=='g'||text[k+1]=='G'){		 if(text[k+2]=='n'||text[k+2]=='N'){																																																																																									it->insertMap(M_SGN					);	k+=2;		}}
										else if(text[k+1]=='h'||text[k+1]=='H'){																																																																																																				it->insertMap(M_SINH				);	++k;	     }
										else if(text[k+1]=='i'||text[k+1]=='I'){		 if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='c'||text[k+3]=='C'){																																																																														it->insertMap(M_SINC				);	k+=3;	   }
																																else if(text[k+3]=='h'||text[k+3]=='H'){		 if(text[k+4]=='c'||text[k+4]=='C'){																																																																			it->insertMap(M_SINHC				);	k+=4;	  }
																																											else								   {																																																																			it->insertMap(M_SINH				);	k+=3;	  }}
																																else								   {																																																																														it->insertMap(M_SIN					);	k+=2;	   }}}
										else if(text[k+1]=='q'||text[k+1]=='Q'){		 if(text[k+2]=='r'||text[k+2]=='R'){		 if(text[k+3]=='t'||text[k+3]=='T'){																																																																														it->insertMap(M_SQRT				);	k+=3;	   }}
																					else if(text[k+2]=='w'||text[k+2]=='W'){		 if(text[k+3]=='v'||text[k+3]=='V'){																																																																														it->insertMap(M_SQWV				);	k+=3;	   }}}
										else if(text[k+1]=='t'||text[k+1]=='T'){		 if(text[k+2]=='e'||text[k+2]=='E'){		 if(text[k+3]=='p'||text[k+3]=='P'){																																																																														it->insertMap(M_STEP				);	k+=3;	   }}}	continue;
						case 't':case 'T':	 if(text[k+1]=='a'||text[k+1]=='A'){		 if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='c'||text[k+3]=='C'){																																																																														it->insertMap(M_TANC				);	k+=3;	   }
																																else if(text[k+3]=='h'||text[k+3]=='H'){																																																																														it->insertMap(M_TANH				);	k+=3;	   }
																																else								   {																																																																														it->insertMap(M_TAN					);	k+=2;	   }}}
										else if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='n'||text[k+2]=='N'){		 if(text[k+3]=='t'||text[k+3]=='T'){																																																																														it->insertMap(M_TENT				);	k+=3;	   }}}
										else if(text[k+1]=='h'||text[k+1]=='H'){																																																																																																				it->insertMap(M_TANH				);	++k;	     }
										else if(text[k+1]=='r'||text[k+1]=='R'){		 if(text[k+2]=='g'||text[k+2]=='G'){		 if(text[k+3]=='l'||text[k+3]=='L'){																																																																														it->insertMap(M_TENT				);	k+=3;	   }}
																					else if(text[k+2]=='w'||text[k+2]=='W'){		 if(text[k+3]=='v'||text[k+3]=='V'){																																																																														it->insertMap(M_TRWV				);	k+=3;	   }}}
										else if(exprBound)					   {																																																																																																				ex->insertRVar(&text[k], 1, 't'		);				 }	continue;
						case 'w':			 if(text[k+1]=='e'||text[k+1]=='E'){		 if(text[k+2]=='b'||text[k+2]=='B'){		 if(text[k+3]=='e'||text[k+3]=='E'){		 if(text[k+4]=='r'||text[k+4]=='R'){																																																																			it->insertMap(M_NEUMANN				);	k+=4;	  }}}}
										else if(text[k+1]=='h'				  ){		 if(text[k+2]=='i'				  ){		 if(text[k+3]=='l'				  ){		 if(text[k+4]=='e'				  ){																																																																			it->insertMap(M_WHILE				);	k+=4;	  }}}}	continue;
								 case 'W':	 if((text[k+1]=='e'||text[k+1]=='E')		&&(text[k+2]=='b'||text[k+2]=='B')			&&(text[k+3]=='e'||text[k+3]=='E')			&&(text[k+4]=='r'||text[k+4]=='R')){																																																																			it->insertMap(M_NEUMANN				);	k+=4;	     }
										else if(exprBound)					   {																																																																																																				ex->insertCVar(&text[k], 1			);				 }	continue;
						case '\r':
							k+=text[k+1]=='\n';
							++lineNo;
							continue;
						default:
							continue;
						}
						if(!exprBound)//user function token variable names
						{
							if((k-1<0||text[k-1]<'0'||text[k-1]>'9'&&text[k-1]<'A'||text[k-1]>'Z'&&text[k-1]!='_'&&text[k-1]<'a'||text[k-1]>'z')&&text[k]>='A'&&(text[k]<='Z'||text[k]>='a'&&text[k]<='z'||text[k]=='_'))
							{
								for(int f=k+1;f<=kEnd;++f)
								{
									if(text[f]<'0'||text[f]>'9'&&(text[f]<'A'||text[f]>'Z'&&(text[f]!='_'&&text[f]<'a'||text[f]>'z')))//match name
									{
										bool match=false;
										int nameLen=f-k;
										for(int n=0, nEnd=ufVarNames.size();n<nEnd;++n)
										{
											auto &name=ufVarNames[n].name;
											if(name.size()==nameLen&&!name.compare(0, name.size(), text+k, nameLen))//match, add reference
											{
												it->insertMap(G2::M_N, ufVarNames[n].data_idx);
												match=true;
												break;
											}
										}
										if(!match)//add new name and repositry
										{
											ufVarNames.push_back(UFVariableName(text+k, nameLen, scopeLevel, uf->data.size()));
											uf->data.push_back(UFTerm('R'));//variables are initialized with 0, mathSet is updated by the values assigned
										}
										break;
									}
								}
							}
						}
					}
					if(exprBound)
					{
						auto &map=ex->m;
						if(map.size())
						{
							using namespace G2;
							{
								int min=0, end=0;
								for(unsigned k=0;k<map.size();++k)
								{
									if(map[k]._0==M_LPR)
										++end;
									else if(map[k]._0==M_RPR)
									{
										--end;
										if(min>end)
											min=end;
									}
								}
								if(min<0)
								{
									int inc=-min;
									map.resize(map.size()+inc);
									for(int k=map.size()-1;k>=inc;--k)
										map[k]=map[k-inc];
									for(int k=0;k<inc;++k)
										map[k]=::Map(M_LPR);
								}
								if(end-min>0)
								{
									int inc=end-min;
									map.resize(map.size()+inc);
									for(unsigned k=map.size()-inc;k<map.size();++k)
										map[k]=::Map(M_RPR);
								}
							}
						}
						if(map.size())
						{
							Compile::compile_expression_global(*ex);
							if(!ex->n.size())//no expression
								ex->rmode[0]=0;
							else
							{
								ex->resultMathSet=Compile::predictedMathSet;
								switch(ex->nISD)
								{
								case 0://numeric 0d
									ex->rmode[0]=1;
									modes::n0d.toSolve=true, modes::n0d.solver.reset();
									ex->n[0].ndr.push_back(ex->n[0].val);
									ex->setColor_random();
									break;
								case 1:
									if(ex->i.size()&&(ex->resultLogicType=Compile::expressionResultLogicType()))//transverse implicit 1d	//bool expr
									{
										ex->rmode[0]=10;
										modes::ti1d.toSolve=true, modes::ti1d.shiftOnly=0, modes::ti1d.solver.reset();
										modes::ti1d.ready=false;
										ex->setColor_random();
									}
									else
									{
										switch(Compile::predictedMathSet)
										{
										case 'R'://transverse 1d
											ex->rmode[0]=2;
											modes::t1d.toSolve=true, modes::t1d.shiftOnly=0, modes::t1d.solver.reset();
											modes::t1d.ready=false;
											ex->setColor_random();
											break;
										case 'C'://transverse 1d complex
											ex->rmode[0]=3;
											modes::t1d_c.toSolve=true, modes::t1d_c.shiftOnly=0, modes::t1d_c.solver.reset();
											modes::t1d_c.ready=false;
											ex->setColor_random();
											break;
										case 'H'://transverse 1d quaternion
											ex->rmode[0]=4;
											ex->rmode.push_back(0);
											modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0, modes::t1d_h.solver.reset();
											modes::t1d_h.ready=false;
											ex->setColor_black();
											break;
										}
									}
									break;
								case 2:
									if(ex->i.size()&&(ex->resultLogicType=Compile::expressionResultLogicType()))//transverse implicit 2d
									{
										ex->rmode[0]=11;
										modes::ti2d.toSolve=true, modes::ti2d.shiftOnly=0, modes::ti2d.solver.reset();
										modes::ti2d.ready=false;
										ex->setColor_random();
									}
									else
									{
										switch(Compile::predictedMathSet)
										{
										case 'R'://transverse 2d
											ex->rmode[0]=5;
											modes::t2d.toSolve=true, modes::t2d.shiftOnly=0, modes::t2d.solver.reset();
											modes::t2d.ready=false;
											ex->setColor_random();
											break;
										case 'C':
											if(ex->nZ==1)//longitudinal 2d
											{
												ex->rmode[0]=7;
												modes::l2d.toSolve=true, modes::l2d.shiftOnly=0, modes::l2d.solver.reset();
												modes::l2d.ready=false;
												ex->setColor_random();
											}
											else//color 2d
											{
												ex->rmode[0]=6;
												ex->rmode.push_back(0);
												modes::c2d.toSolve=true, modes::c2d.shiftOnly=0, modes::c2d.solver.reset();
												modes::c2d.ready=false;
												ex->setColor_black();
											}
											break;
										case 'H'://transverse 2d quaternion
											ex->rmode[0]=8;
											ex->rmode.push_back(0);
											modes::t2d_h.toSolve=true, modes::t2d_h.shiftOnly=0, modes::t2d_h.solver.reset();
											modes::t2d_h.ready=false;
											ex->setColor_black();
											break;
										}
									}
									break;
								case 3://color 3d
	#if 0
									if(ex->i.size()&&(ex->resultLogicType=Compile::expressionResultLogicType()))
									{
										ex->rmode[0]=9;
										ex->rmode.push_back(0);
										modes::c3d.toSolve=true, modes::c3d.shiftOnly=0, modes::c3d.solver.reset();
										modes::c3d.ready=false;
										ex->setColor_black();
									}
									else
									{
	#endif
										ex->rmode[0]=9;
										ex->rmode.push_back(0);
										modes::c3d.toSolve=true, modes::c3d.shiftOnly=0, modes::c3d.solver.reset();
										modes::c3d.ready=false;
										ex->setColor_black();
	#if 0
									}
	#endif
									break;
								}
							}
						}
						++e;
					}
					else
					{
						Compile::compile_function(*ex);
						++function;
					}
				}
#endif
				itb.text=(char*)realloc(itb.text, (itb.textlen+1)*sizeof(char));
				lineChangeStart=lineRemoveEnd=lineInsertEnd=0;
				boundChangeStart=boundRemoveEnd=boundInsertEnd=0;
				exprChangeStart=exprRemoveEnd=exprInsertEnd=0;
				functionChangeStart=functionRemoveEnd=functionInsertEnd=0;
			}
			if(action)
				render();
		}
		if(message==WM_SYSKEYDOWN)
			break;
		return 0;
	case WM_KEYUP:
	case WM_SYSKEYUP:
		if(modes::active)
			modes::mode->inputKeyUp(wParam);
		kb[wParam]=0;
		return 0;
	case WM_CLOSE:PostQuitMessage(0);
		return 0;
	}
	return DefWindowProcA(hWnd, message, wParam, lParam);
}
int			__stdcall WinMain(HINSTANCE hInstance, HINSTANCE, char*, int nCmdShow)
{
	tagWNDCLASSEXA wndClassEx={sizeof(tagWNDCLASSEXA), CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, WndProc, 0, 0, hInstance, LoadIconA(0, (char*)0x00007F00), LoadCursorA(0, (char*)0x00007F00), (HBRUSH__*)(COLOR_WINDOW+1), 0, "New format", 0};
	RegisterClassExA(&wndClassEx);
	ghWnd=CreateWindowExA(0, wndClassEx.lpszClassName, "", WS_CAPTION|WS_SYSMENU|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX|WS_CLIPCHILDREN, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, 0, 0, hInstance, 0);
	{
		int width, height;
		bool set_width=false, set_height=false;
		char *cmd=GetCommandLineA();
		auto readint=[](char *a, int &k, int &value)
		{
			for(int k2=k;;++k2)
			{
				if(a[k2]<'0'||a[k2]>'9')
				{
					if(k2>k)
					{
						value=0;
						for(int k3=k2-1, p=1;k3>=k;--k3, p*=10)
							value+=p*(a[k3]-'0');
						k=k2-1;
						return true;
					}
					break;
				}
			}
			return false;
		};
		for(int k=0;cmd[k];++k)
		{
			if(cmd[k]=='.'&&cmd[k+1]=='e'&&cmd[k+2]=='x'&&cmd[k+3]=='e')
			{
				for(k+=4;cmd[k];++k)
				{
					if(cmd[k]=='-')
					{
						if(cmd[k+1]=='b'&&cmd[k+2]=='e'&&cmd[k+3]=='n'&&cmd[k+4]=='c'&&cmd[k+5]=='h'&&cmd[k+6]=='m'&&cmd[k+7]=='a'&&cmd[k+8]=='r'&&cmd[k+9]=='k')
							showBenchmark=true, k+=9;
						else if(cmd[k+1]=='h')
						{
							for(k+=2;cmd[k];++k)
							{
								if(cmd[k]!=' ')
								{
									set_height=readint(cmd, k, height);
									break;
								}
							}
						}
						else if(cmd[k+1]=='w')
						{
							for(k+=2;cmd[k];++k)
							{
								if(cmd[k]!=' ')
								{
									set_width=readint(cmd, k, width);
									break;
								}
							}
						}
					}
				}
				break;
			}
		}
		if(set_width||set_height)
		{
			RECT window, client, area;
			GetWindowRect(ghWnd, &window);
			GetClientRect(ghWnd, &client);
			SystemParametersInfoA(SPI_GETWORKAREA, 0, &area, 0);
			int wleft, wwidth, wtop, wheight;
			int w0width=window.right-window.left;
			int w0height=window.bottom-window.top;
			if(set_width)
			{
				wwidth=width+w0width-(client.right-client.left);
				if(wwidth>area.right)
					wleft=0, wwidth=area.right;
				else if(wwidth<w0width)
					wleft=window.right-wwidth;
				else
					wleft=window.left;
			}
			else
				wleft=window.left, wwidth=w0width;
			if(set_height)
			{
				wheight=height+w0height-(client.bottom-client.top);
				if(wheight>area.bottom)
					wtop=0, wheight=area.bottom;
				else if(wheight<w0height)
					wtop=window.bottom-wheight;
				else
					wtop=window.top;
			}
			else
				wtop=window.top, wheight=w0height;
			SetWindowPos(ghWnd, HWND_TOP, wleft, wtop, wwidth, wheight, 0);
		}
	}
	ShowWindow(ghWnd, nCmdShow);
	tagMSG msg;
	
		Performance();//

		GetClientRect(ghWnd, &R);
		h=R.bottom-R.top, w=R.right-R.left, centerP.x=w/2, centerP.y=h/2;
		ClientToScreen(ghWnd, &centerP);
		ghDC=GetDC(ghWnd), ghMemDC=CreateCompatibleDC(ghDC);
		tagBITMAPINFO bmpInfo={{sizeof(tagBITMAPINFOHEADER), w, -h, 1, 32, BI_RGB, 0, 0, 0, 0, 0}};
		ghBitmap=(HBITMAP__*)SelectObject(ghMemDC, CreateDIBSection(0, &bmpInfo, DIB_RGB_COLORS, (void**)&rgb, 0, 0));
		modeRGB=(int*)realloc(modeRGB, w*h*sizeof(int));
		font.createFonts();
		itb.setDimensions(0, 0, w, h);

	for(;GetMessageA(&msg, 0, 0, 0);)TranslateMessage(&msg), DispatchMessageA(&msg);

		DeleteObject(SelectObject(ghMemDC, ghBitmap)), DeleteDC(ghMemDC), ReleaseDC(ghWnd, ghDC);

	return msg.wParam;
}
void		render()
{
		memset(rgb, 0xFF, w*h*sizeof(int));
	
	int inputTextBkMode=OPAQUE;
	if(expr.size()||userFunctionDefinitions.size())//
//	if(expr.size())
	{
		static bool toResume=false;

		cursorB=0, cursorEx=0;
		for(int bEnd=bounds.size()-1;cursorB<bEnd&&bounds[cursorB].first<=itb.cursor;++cursorB)
			cursorEx+=bounds[cursorB].second=='e';
	//	cursorEx=0;
	//	for(int bEnd=bounds.size()-1;cursorEx<bEnd&&bounds[cursorEx].first<=itb.cursor;++cursorEx);

		if(bounds[cursorB].second&1)//expression or clear
		{
			switch(expr[cursorEx].rmode[0])//current mode
			{
			case 0://no expression
				modes::ready=false;
				if(showLastModeOnIdle)
				{
					if(modes::mode&&!modes::mode->paused)
						modes::mode->pause();
				/*	if(modes::mode&&modes::mode->toSolve)
					{
						modes::old_mode->pause();
						toResume=true;
					}//*/
				}
				else
					modes::mode=nullptr, modes::paint=modes::paint_0;
				std::fill(modes::nExpr.begin(), modes::nExpr.end(), 0);//crappy code
				for(auto &ex:expr)
					++modes::nExpr[ex.rmode[0]];
				break;
			case 1://numeric 0d
				modes::ready=true;
				modes::mode=&modes::n0d, modes::paint=modes::paint_n0d;
				modes::n0d.toPrint=true;
				break;
			case 2://transverse 1d
				modes::ready=true;
				modes::mode=&modes::t1d, modes::paint=modes::paint_t1d;
				break;
			case 3://transverse 1d complex
				modes::ready=true;
				modes::mode=&modes::t1d_c, modes::paint=modes::paint_t1d_c;
				if(modes::mode!=modes::old_mode)
					modes::t1d.ready=false;
				break;
			case 4://transverse 1d quaternion
				modes::ready=true;
				modes::mode=&modes::t1d_h, modes::paint=modes::paint_t1d_h;
				if(cursorEx!=prevCursorEx||!expr[cursorEx].n[0].ndr.size())
			//	if(!expr[cursorEx].n[0].ndr.size())
			//	if(cursorEx!=prevCursorEx)
					modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
				break;
			case 5://transverse 2d
				modes::ready=true;
				modes::mode=&modes::t2d, modes::paint=modes::paint_t2d;
				break;
			case 6://color 2d
				modes::ready=true;
				modes::mode=&modes::c2d, modes::paint=modes::paint_c2d;
				if(cursorEx!=prevCursorEx||!expr[cursorEx].n[0].ndr.size())
					modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
			/*	if(!expr[cursorEx].n[0].ndr.size())
			//	if(cursorEx!=prevCursorEx)
					modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
				else if(cursorEx!=prevCursorEx&&!modes::c2d.time_variance)//zoom glitch
					modes::c2d.solver.updateRGB(expr[cursorEx].n[0].ndr);//*/
				break;
			case 7://longitudinal 2d
				modes::ready=true;
				modes::mode=&modes::l2d, modes::paint=modes::paint_l2d;
				break;
			case 8://transverse 2d quaternion
				modes::ready=true;
				modes::mode=&modes::t2d_h, modes::paint=modes::paint_t2d_h;
				if(cursorEx!=prevCursorEx||!expr[cursorEx].n[0].ndr.size())
			//	if(!expr[cursorEx].n[0].ndr.size())
			//	if(cursorEx!=prevCursorEx)
					modes::t2d_h.toSolve=true, modes::t2d_h.shiftOnly=0;
				break;
			case 9://color 3d
				modes::ready=true;
				modes::mode=&modes::c3d, modes::paint=modes::paint_c3d;
				if(cursorEx!=prevCursorEx||!expr[cursorEx].n[0].ndr.size())
			//	if(!expr[cursorEx].n[0].ndr.size())
			//	if(cursorEx!=prevCursorEx)
					modes::c3d.toSolve=true, modes::c3d.shiftOnly=0;
				break;
			case 10://transverse implicit 1d
				modes::ready=true;
				modes::mode=&modes::ti1d, modes::paint=modes::paint_ti1d;
				break;
			case 11://transverse implicit 2d
				modes::ready=true;
				modes::mode=&modes::ti2d, modes::paint=modes::paint_ti2d;
				break;
			}
		}
		else//cursor in user function
		{
			modes::ready=false;
			if(showLastModeOnIdle)
			{
				if(modes::mode&&!modes::mode->paused)
					modes::mode->pause();
			/*	if(modes::mode&&modes::mode->toSolve)
				{
					modes::old_mode->pause();
					toResume=true;
				}//*/
			}
			else
				modes::mode=nullptr, modes::paint=modes::paint_0;
			std::fill(modes::nExpr.begin(), modes::nExpr.end(), 0);//crappy code
			for(auto &ex:expr)
				++modes::nExpr[ex.rmode[0]];
		}
		if(modes::mode!=modes::old_mode)
		{
			if(modes::old_mode)
			{
				if(modes::mode->bw!=modes::old_mode->bw||modes::mode->bh!=modes::old_mode->bh)//up, esc, resize, esc, down CRASH
					modes::mode->setDimentions(0, 0, w, h);//
				modes::old_mode->pause();
			}
			if(modes::mode)
				modes::mode->resume();
			modes::old_mode=modes::mode;//
		}
	//	modes::old_mode=modes::mode;
		if(modes::ready)
		{
			if(modes::mode->paused)
				modes::mode->resume();
			if(!modes::mode->ready)
			{
			//	modes::mode->resume();
			/*	if(modes::mode->time_variance&&toResume&&modes::mode->paused)
				{
					modes::mode->resume();
					toResume=false;
				}//*/
				//	modes::mode->paused=false;
				modes::mode->setDimentions(0, 0, w, h);
			}
			modes::mode->i_draw();
		}
		else if(showLastModeOnIdle&&modes::mode!=nullptr)//
		{
		//	auto tv=modes::mode->time_variance;
		//	modes::mode->time_variance=0;
			modes::mode->i_draw();//
		//	modes::mode->time_variance=tv;
		}
		prevCursorEx=cursorEx;
	}
	if(!modes::ready)
	{
		font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
		{
			int bkMode=GetBkMode(ghMemDC);
			SetBkMode(ghMemDC, inputTextBkMode);//TRANSPARENT
			itb.draw();
			SetBkMode(ghMemDC, bkMode);
		}
		font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
}
